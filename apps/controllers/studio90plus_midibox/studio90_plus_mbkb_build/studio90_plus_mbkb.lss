
studio90_plus_mbkb_build/studio90_plus_mbkb.elf:     file format elf32-littlearm

Sections:
Idx Name            Size      VMA       LMA       File off  Algn  Flags
  0 .mios32_bsl     00004000  08000000  08000000  00001000  2**0  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector     00000188  08004000  08004000  00005000  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .flashtext      00000000  08010000  08010000  000200d0  2**0  CONTENTS
  3 .text           0001363a  08010000  08010000  00006000  2**4  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .eh_frame       00000028  0802363c  0802363c  0001963c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .ARM.exidx      00000008  08023664  08023664  00019664  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .rodata         00005d7c  0802366c  0802366c  0001966c  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .data           000000d0  20000000  080293e8  00020000  2**3  CONTENTS, ALLOC, LOAD, DATA
  8 .bss            000075d0  200000d0  080294b8  000200d0  2**3  ALLOC
  9 ._usrstack      00000100  200076a0  080294b8  000206a0  2**0  ALLOC
 10 .data_ccm       00000000  10000000  10000000  000200d0  2**3  CONTENTS
 11 .bss_cmm        00000000  10000000  10000000  000200d0  2**0  CONTENTS
 12 .comment        00000036  00000000  00000000  000200d0  2**0  CONTENTS, READONLY
 13 .ARM.attributes 0000002c  00000000  00000000  00020106  2**0  CONTENTS, READONLY
 14 .debug_aranges  00003260  00000000  00000000  00020138  2**3  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_info     00056aca  00000000  00000000  00023398  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_abbrev   0000f5ed  00000000  00000000  00079e62  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line     0002fafc  00000000  00000000  0008944f  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_frame    00007c20  00000000  00000000  000b8f4c  2**2  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str      00011057  00000000  00000000  000c0b6c  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_loclists 000193dc  00000000  00000000  000d1bc3  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_rnglists 00003654  00000000  00000000  000eaf9f  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 000001b8  00000000  00000000  000ee5f3  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08010000 <NOTIFY_MIDI_TimeOut>:

  // print message on screen
  //SCS_Msg(SCS_MSG_L, 2000, "MIDI Protocol", "TIMEOUT !!!");

  return 0;
}
 8010000:	2000      	movs	r0, #0
 8010002:	4770      	bx	lr

08010004 <TASK_Period_1mS>:
static void TASK_Period_1mS(void* pvParameters) {
 8010004:	b513      	push	{r0, r1, r4, lr}
  xLastExecutionTime = xTaskGetTickCount();
 8010006:	f003 fa43 	bl	8013490 <xTaskGetTickCount>
 801000a:	9001      	str	r0, [sp, #4]
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 801000c:	2101      	movs	r1, #1
 801000e:	a801      	add	r0, sp, #4
 8010010:	f003 fb44 	bl	801369c <vTaskDelayUntil>
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8010014:	f003 fa3c 	bl	8013490 <xTaskGetTickCount>
    if (xLastExecutionTime < (xCurrentTickCount - 5))
 8010018:	9b01      	ldr	r3, [sp, #4]
 801001a:	1f42      	subs	r2, r0, #5
 801001c:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 801001e:	bf88      	it	hi
 8010020:	9001      	strhi	r0, [sp, #4]
    KEYBOARD_Periodic_1mS();
 8010022:	f001 f81b 	bl	801105c <KEYBOARD_Periodic_1mS>
    MIDI_PORT_Period1mS();
 8010026:	f00e fd43 	bl	801eab0 <MIDI_PORT_Period1mS>
      for (pin = 0; pin < 8; ++pin) {
 801002a:	2400      	movs	r4, #0
        KEYBOARD_AIN_NotifyChange(pin, MIOS32_AIN_PinGet(pin));
 801002c:	4620      	mov	r0, r4
 801002e:	f007 f9d5 	bl	80173dc <MIOS32_AIN_PinGet>
 8010032:	4601      	mov	r1, r0
 8010034:	4620      	mov	r0, r4
      for (pin = 0; pin < 8; ++pin) {
 8010036:	3401      	adds	r4, #1
        KEYBOARD_AIN_NotifyChange(pin, MIOS32_AIN_PinGet(pin));
 8010038:	f001 faca 	bl	80115d0 <KEYBOARD_AIN_NotifyChange>
      for (pin = 0; pin < 8; ++pin) {
 801003c:	2c08      	cmp	r4, #8
 801003e:	d1f5      	bne.n	801002c <TASK_Period_1mS+0x28>
 8010040:	e7e4      	b.n	801000c <TASK_Period_1mS+0x8>

08010042 <APP_AINSER_NotifyChange>:
static void APP_AINSER_NotifyChange(u32 module, u32 pin, u32 pin_value) {
 8010042:	4608      	mov	r0, r1
  KEYBOARD_AIN_NotifyChange(pin, pin_value);
 8010044:	3080      	adds	r0, #128	@ 0x80
 8010046:	4611      	mov	r1, r2
 8010048:	f001 bac2 	b.w	80115d0 <KEYBOARD_AIN_NotifyChange>

0801004c <NOTIFY_MIDI_Tx>:
  return MIDI_PORT_NotifyMIDITx(port, package);
 801004c:	f00e bd56 	b.w	801eafc <MIDI_PORT_NotifyMIDITx>

08010050 <NOTIFY_MIDI_Rx>:
static s32 NOTIFY_MIDI_Rx(mios32_midi_port_t port, u8 midi_byte) {
 8010050:	b508      	push	{r3, lr}
  if (MIDI_ROUTER_MIDIClockInGet(port) == 1) {
 8010052:	f00e f94d 	bl	801e2f0 <MIDI_ROUTER_MIDIClockInGet>
}
 8010056:	2000      	movs	r0, #0
 8010058:	bd08      	pop	{r3, pc}

0801005a <APP_SYSEX_Parser>:
s32 APP_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in) {
 801005a:	b508      	push	{r3, lr}
  MIDI_ROUTER_ReceiveSysEx(port, midi_in);
 801005c:	f00e f8b8 	bl	801e1d0 <MIDI_ROUTER_ReceiveSysEx>
}
 8010060:	2000      	movs	r0, #0
 8010062:	bd08      	pop	{r3, pc}

08010064 <APP_SRIO_ServiceFinish>:
void APP_SRIO_ServiceFinish(void) {
 8010064:	b508      	push	{r3, lr}
  KEYBOARD_SRIO_ServiceFinish();
 8010066:	f000 ff2f 	bl	8010ec8 <KEYBOARD_SRIO_ServiceFinish>
  KEYBOARD_SRIO_ServicePrepare();
 801006a:	f000 feb5 	bl	8010dd8 <KEYBOARD_SRIO_ServicePrepare>
}
 801006e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  MIOS32_SRIO_ScanStart(APP_SRIO_ServiceFinish);
 8010072:	4801      	ldr	r0, [pc, #4]	@ (8010078 <APP_SRIO_ServiceFinish+0x14>)
 8010074:	f004 b9a4 	b.w	80143c0 <MIOS32_SRIO_ScanStart>
 8010078:	08010065 	.word	0x08010065

0801007c <APP_Init>:
void APP_Init(void) {
 801007c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  xMIDIINSemaphore = xSemaphoreCreateRecursiveMutex();
 801007e:	2004      	movs	r0, #4
 8010080:	f003 fe43 	bl	8013d0a <xQueueCreateMutex>
 8010084:	4b30      	ldr	r3, [pc, #192]	@ (8010148 <APP_Init+0xcc>)
  MIOS32_MIDI_SendDebugMessage("\n");
 8010086:	4c31      	ldr	r4, [pc, #196]	@ (801014c <APP_Init+0xd0>)
  xMIDIINSemaphore = xSemaphoreCreateRecursiveMutex();
 8010088:	6018      	str	r0, [r3, #0]
  xMIDIOUTSemaphore = xSemaphoreCreateRecursiveMutex();
 801008a:	2004      	movs	r0, #4
 801008c:	f003 fe3d 	bl	8013d0a <xQueueCreateMutex>
 8010090:	4b2f      	ldr	r3, [pc, #188]	@ (8010150 <APP_Init+0xd4>)
  MIOS32_MIDI_SendDebugMessage("=================\n");
 8010092:	4d30      	ldr	r5, [pc, #192]	@ (8010154 <APP_Init+0xd8>)
  xMIDIOUTSemaphore = xSemaphoreCreateRecursiveMutex();
 8010094:	6018      	str	r0, [r3, #0]
  MIOS32_MIDI_SysExCallback_Init(APP_SYSEX_Parser);
 8010096:	4830      	ldr	r0, [pc, #192]	@ (8010158 <APP_Init+0xdc>)
 8010098:	f005 f9c2 	bl	8015420 <MIOS32_MIDI_SysExCallback_Init>
  MIOS32_MIDI_DirectRxCallback_Init(&NOTIFY_MIDI_Rx);
 801009c:	482f      	ldr	r0, [pc, #188]	@ (801015c <APP_Init+0xe0>)
 801009e:	f004 fe61 	bl	8014d64 <MIOS32_MIDI_DirectRxCallback_Init>
  MIOS32_MIDI_DirectTxCallback_Init(&NOTIFY_MIDI_Tx);
 80100a2:	482f      	ldr	r0, [pc, #188]	@ (8010160 <APP_Init+0xe4>)
 80100a4:	f004 fe58 	bl	8014d58 <MIOS32_MIDI_DirectTxCallback_Init>
  MIOS32_MIDI_TimeOutCallback_Init(&NOTIFY_MIDI_TimeOut);
 80100a8:	482e      	ldr	r0, [pc, #184]	@ (8010164 <APP_Init+0xe8>)
 80100aa:	f005 f9c5 	bl	8015438 <MIOS32_MIDI_TimeOutCallback_Init>
  MIOS32_SRIO_ScanNumSet(2);
 80100ae:	2002      	movs	r0, #2
 80100b0:	f004 f972 	bl	8014398 <MIOS32_SRIO_ScanNumSet>
  KEYBOARD_Init(0);
 80100b4:	2000      	movs	r0, #0
 80100b6:	f000 fe05 	bl	8010cc4 <KEYBOARD_Init>
  PRESETS_Init(0);
 80100ba:	2000      	movs	r0, #0
 80100bc:	f000 fa1c 	bl	80104f8 <PRESETS_Init>
  MIDI_PORT_Init(0);
 80100c0:	2000      	movs	r0, #0
 80100c2:	f00e fc35 	bl	801e930 <MIDI_PORT_Init>
  MIDI_ROUTER_Init(0);
 80100c6:	2000      	movs	r0, #0
 80100c8:	f00d ffde 	bl	801e088 <MIDI_ROUTER_Init>
  AINSER_Init(0);
 80100cc:	2000      	movs	r0, #0
 80100ce:	f00d fe75 	bl	801ddbc <AINSER_Init>
  AINSER_NumModulesSet(0); // 1 module
 80100d2:	2000      	movs	r0, #0
 80100d4:	f00d feac 	bl	801de30 <AINSER_NumModulesSet>
  AINSER_MuxedSet(0, 0);   // disable muxing
 80100d8:	2100      	movs	r1, #0
 80100da:	4608      	mov	r0, r1
 80100dc:	f00d feb2 	bl	801de44 <AINSER_MuxedSet>
  AINSER_NumPinsSet(0, 8); // 8 pins
 80100e0:	2108      	movs	r1, #8
 80100e2:	2000      	movs	r0, #0
 80100e4:	f00d fec0 	bl	801de68 <AINSER_NumPinsSet>
  TERMINAL_Init(0);
 80100e8:	2000      	movs	r0, #0
 80100ea:	f000 fbb3 	bl	8010854 <TERMINAL_Init>
  MIDIMON_Init(0);
 80100ee:	2000      	movs	r0, #0
 80100f0:	f00e fd7e 	bl	801ebf0 <MIDIMON_Init>
  UIP_TASK_Init(0);
 80100f4:	2000      	movs	r0, #0
 80100f6:	f010 fb25 	bl	8020744 <UIP_TASK_Init>
  MIOS32_MIDI_SendDebugMessage("\n");
 80100fa:	4620      	mov	r0, r4
 80100fc:	f004 fd74 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("=================\n");
 8010100:	4628      	mov	r0, r5
 8010102:	f004 fd71 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("%s\n", MIOS32_LCD_BOOT_MSG_LINE1);
 8010106:	4918      	ldr	r1, [pc, #96]	@ (8010168 <APP_Init+0xec>)
 8010108:	4818      	ldr	r0, [pc, #96]	@ (801016c <APP_Init+0xf0>)
 801010a:	f004 fd6d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("=================\n");
 801010e:	4628      	mov	r0, r5
 8010110:	f004 fd6a 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("\n");
 8010114:	4620      	mov	r0, r4
 8010116:	f004 fd67 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 801011a:	2206      	movs	r2, #6
 801011c:	2103      	movs	r1, #3
 801011e:	2001      	movs	r0, #1
 8010120:	f006 fcb2 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
  KEYBOARD_SRIO_ServicePrepare();
 8010124:	f000 fe58 	bl	8010dd8 <KEYBOARD_SRIO_ServicePrepare>
  MIOS32_SRIO_ScanStart(APP_SRIO_ServiceFinish);
 8010128:	4811      	ldr	r0, [pc, #68]	@ (8010170 <APP_Init+0xf4>)
 801012a:	f004 f949 	bl	80143c0 <MIOS32_SRIO_ScanStart>
  xTaskCreate(TASK_Period_1mS, "1mS", configMINIMAL_STACK_SIZE, NULL, PRIORITY_TASK_PERIOD_1mS, NULL);
 801012e:	2300      	movs	r3, #0
 8010130:	2203      	movs	r2, #3
 8010132:	e9cd 2300 	strd	r2, r3, [sp]
 8010136:	490f      	ldr	r1, [pc, #60]	@ (8010174 <APP_Init+0xf8>)
 8010138:	480f      	ldr	r0, [pc, #60]	@ (8010178 <APP_Init+0xfc>)
 801013a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801013e:	f003 f897 	bl	8013270 <xTaskCreate>
}
 8010142:	b003      	add	sp, #12
 8010144:	bd30      	pop	{r4, r5, pc}
 8010146:	bf00      	nop
 8010148:	200000d4 	.word	0x200000d4
 801014c:	08023ddd 	.word	0x08023ddd
 8010150:	200000d0 	.word	0x200000d0
 8010154:	08026a84 	.word	0x08026a84
 8010158:	0801005b 	.word	0x0801005b
 801015c:	08010051 	.word	0x08010051
 8010160:	0801004d 	.word	0x0801004d
 8010164:	08010001 	.word	0x08010001
 8010168:	080239e2 	.word	0x080239e2
 801016c:	0802793d 	.word	0x0802793d
 8010170:	08010065 	.word	0x08010065
 8010174:	0802366c 	.word	0x0802366c
 8010178:	08010005 	.word	0x08010005

0801017c <APP_Background>:
}
 801017c:	4770      	bx	lr
	...

08010180 <APP_Tick>:
void APP_Tick(void) {
 8010180:	b508      	push	{r3, lr}
  u32 timestamp = MIOS32_TIMESTAMP_Get();
 8010182:	f006 f955 	bl	8016430 <MIOS32_TIMESTAMP_Get>
  MIOS32_BOARD_LED_Set(1, (timestamp % 20) <= ((timestamp / 100) % 10));
 8010186:	2314      	movs	r3, #20
 8010188:	fbb0 f1f3 	udiv	r1, r0, r3
 801018c:	fb03 0111 	mls	r1, r3, r1, r0
 8010190:	2364      	movs	r3, #100	@ 0x64
 8010192:	fbb0 f0f3 	udiv	r0, r0, r3
 8010196:	230a      	movs	r3, #10
 8010198:	fbb0 f2f3 	udiv	r2, r0, r3
 801019c:	fb03 0012 	mls	r0, r3, r2, r0
 80101a0:	4281      	cmp	r1, r0
 80101a2:	bf8c      	ite	hi
 80101a4:	2100      	movhi	r1, #0
 80101a6:	2101      	movls	r1, #1
 80101a8:	2001      	movs	r0, #1
 80101aa:	f006 ff01 	bl	8016fb0 <MIOS32_BOARD_LED_Set>
}
 80101ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  AINSER_Handler(APP_AINSER_NotifyChange);
 80101b2:	4801      	ldr	r0, [pc, #4]	@ (80101b8 <APP_Tick+0x38>)
 80101b4:	f00d be66 	b.w	801de84 <AINSER_Handler>
 80101b8:	08010043 	.word	0x08010043

080101bc <APP_MIDI_Tick>:
void APP_MIDI_Tick(void) {
 80101bc:	4770      	bx	lr

080101be <APP_MIDI_NotifyPackage>:
void APP_MIDI_NotifyPackage(mios32_midi_port_t port, mios32_midi_package_t midi_package) {
 80101be:	b538      	push	{r3, r4, r5, lr}
 80101c0:	4604      	mov	r4, r0
 80101c2:	460d      	mov	r5, r1
  MIDI_ROUTER_Receive(port, midi_package);
 80101c4:	f00d ff7c 	bl	801e0c0 <MIDI_ROUTER_Receive>
  MIDI_PORT_NotifyMIDIRx(port, midi_package);
 80101c8:	4629      	mov	r1, r5
 80101ca:	4620      	mov	r0, r4
 80101cc:	f00e fccc 	bl	801eb68 <MIDI_PORT_NotifyMIDIRx>
  u8 filter_sysex_message = (port == USB0) || (port == UART0);
 80101d0:	2c10      	cmp	r4, #16
 80101d2:	d009      	beq.n	80101e8 <APP_MIDI_NotifyPackage+0x2a>
 80101d4:	f1a4 0320 	sub.w	r3, r4, #32
 80101d8:	425a      	negs	r2, r3
 80101da:	415a      	adcs	r2, r3
  MIDIMON_Receive(port, midi_package, filter_sysex_message);
 80101dc:	4629      	mov	r1, r5
 80101de:	4620      	mov	r0, r4
}
 80101e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  MIDIMON_Receive(port, midi_package, filter_sysex_message);
 80101e4:	f00f b81e 	b.w	801f224 <MIDIMON_Receive>
  u8 filter_sysex_message = (port == USB0) || (port == UART0);
 80101e8:	2201      	movs	r2, #1
 80101ea:	e7f7      	b.n	80101dc <APP_MIDI_NotifyPackage+0x1e>

080101ec <APP_DIN_NotifyToggle>:
}
 80101ec:	4770      	bx	lr

080101ee <APP_ENC_NotifyChange>:
}
 80101ee:	4770      	bx	lr

080101f0 <APP_AIN_NotifyChange>:
  KEYBOARD_AIN_NotifyChange(pin, pin_value);
 80101f0:	f001 b9ee 	b.w	80115d0 <KEYBOARD_AIN_NotifyChange>

080101f4 <PRESETS_Read32>:
/////////////////////////////////////////////////////////////////////////////
u16 PRESETS_Read16(u16 addr) {
  return EEPROM_Read(addr);
}

u32 PRESETS_Read32(u16 addr) {
 80101f4:	b538      	push	{r3, r4, r5, lr}
 80101f6:	4604      	mov	r4, r0
  return ((u32)EEPROM_Read(addr) << 16) | EEPROM_Read(addr + 1);
 80101f8:	f012 f934 	bl	8022464 <EEPROM_Read>
 80101fc:	3401      	adds	r4, #1
 80101fe:	4605      	mov	r5, r0
 8010200:	b2a0      	uxth	r0, r4
 8010202:	f012 f92f 	bl	8022464 <EEPROM_Read>
}
 8010206:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 801020a:	bd38      	pop	{r3, r4, r5, pc}

0801020c <PRESETS_Write32>:
/////////////////////////////////////////////////////////////////////////////
s32 PRESETS_Write16(u16 addr, u16 value) {
  return EEPROM_Write(addr, value);
}

s32 PRESETS_Write32(u16 addr, u32 value) {
 801020c:	b570      	push	{r4, r5, r6, lr}
 801020e:	460d      	mov	r5, r1
  return EEPROM_Write(addr, (value >> 16) & 0xffff) | EEPROM_Write(addr + 1, (value >> 0) & 0xffff);
 8010210:	0c09      	lsrs	r1, r1, #16
s32 PRESETS_Write32(u16 addr, u32 value) {
 8010212:	4604      	mov	r4, r0
  return EEPROM_Write(addr, (value >> 16) & 0xffff) | EEPROM_Write(addr + 1, (value >> 0) & 0xffff);
 8010214:	f012 f9fc 	bl	8022610 <EEPROM_Write>
 8010218:	3401      	adds	r4, #1
 801021a:	4606      	mov	r6, r0
 801021c:	b2a9      	uxth	r1, r5
 801021e:	b2a0      	uxth	r0, r4
 8010220:	f012 f9f6 	bl	8022610 <EEPROM_Write>
}
 8010224:	4330      	orrs	r0, r6
 8010226:	bd70      	pop	{r4, r5, r6, pc}

08010228 <PRESETS_StoreAll>:
/////////////////////////////////////////////////////////////////////////////
// Stores all presets
// (the EEPROM emulation ensures that a value won't be written if it is already
// equal)
/////////////////////////////////////////////////////////////////////////////
s32 PRESETS_StoreAll(void) {
 8010228:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  s32 status = 0;

  // magic numbers
  status |= PRESETS_Write32(PRESETS_ADDR_MAGIC01, EEPROM_MAGIC_NUMBER);
 801022c:	49ad      	ldr	r1, [pc, #692]	@ (80104e4 <PRESETS_StoreAll+0x2bc>)
 801022e:	2001      	movs	r0, #1
 8010230:	f7ff ffec 	bl	801020c <PRESETS_Write32>
 8010234:	4604      	mov	r4, r0

  // write MIDImon data
  status |= PRESETS_Write16(PRESETS_ADDR_MIDIMON,
    (MIDIMON_ActiveGet() ? 1 : 0) |
 8010236:	f00e fd11 	bl	801ec5c <MIDIMON_ActiveGet>
 801023a:	4606      	mov	r6, r0
    (MIDIMON_FilterActiveGet() ? 2 : 0) |
 801023c:	f00e fd14 	bl	801ec68 <MIDIMON_FilterActiveGet>
 8010240:	4605      	mov	r5, r0
    (MIDIMON_TempoActiveGet() ? 4 : 0));
 8010242:	f00e fd17 	bl	801ec74 <MIDIMON_TempoActiveGet>
    (MIDIMON_FilterActiveGet() ? 2 : 0) |
 8010246:	3800      	subs	r0, #0
 8010248:	bf18      	it	ne
 801024a:	2001      	movne	r0, #1
    (MIDIMON_ActiveGet() ? 1 : 0) |
 801024c:	1e29      	subs	r1, r5, #0
 801024e:	bf18      	it	ne
 8010250:	2101      	movne	r1, #1
 8010252:	0049      	lsls	r1, r1, #1
    (MIDIMON_FilterActiveGet() ? 2 : 0) |
 8010254:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
  return EEPROM_Write(addr, value);
 8010258:	2e00      	cmp	r6, #0
 801025a:	bf18      	it	ne
 801025c:	f041 0101 	orrne.w	r1, r1, #1
 8010260:	2004      	movs	r0, #4
 8010262:	f012 f9d5 	bl	8022610 <EEPROM_Write>
  status |= PRESETS_Write16(PRESETS_ADDR_MIDIMON,
 8010266:	4304      	orrs	r4, r0

  // write number of SRIOs
  status |= PRESETS_Write16(PRESETS_ADDR_NUM_SRIO,
    MIOS32_SRIO_ScanNumGet());
 8010268:	f004 f890 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 801026c:	4601      	mov	r1, r0
  return EEPROM_Write(addr, value);
 801026e:	2005      	movs	r0, #5
 8010270:	f012 f9ce 	bl	8022610 <EEPROM_Write>
  status |= PRESETS_Write16(PRESETS_ADDR_NUM_SRIO,
 8010274:	ea44 0600 	orr.w	r6, r4, r0

  // write uIP data
  status |= PRESETS_Write16(PRESETS_ADDR_UIP_USE_DHCP, UIP_TASK_DHCP_EnableGet());
 8010278:	f010 fbac 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
  return EEPROM_Write(addr, value);
 801027c:	b281      	uxth	r1, r0
 801027e:	2008      	movs	r0, #8
 8010280:	f012 f9c6 	bl	8022610 <EEPROM_Write>
  status |= PRESETS_Write16(PRESETS_ADDR_UIP_USE_DHCP, UIP_TASK_DHCP_EnableGet());
 8010284:	4306      	orrs	r6, r0
  status |= PRESETS_Write32(PRESETS_ADDR_UIP_IP01, UIP_TASK_IP_AddressGet());
 8010286:	f010 fbc3 	bl	8020a10 <UIP_TASK_IP_AddressGet>
 801028a:	4601      	mov	r1, r0
 801028c:	2012      	movs	r0, #18
 801028e:	f7ff ffbd 	bl	801020c <PRESETS_Write32>
 8010292:	4306      	orrs	r6, r0
  status |= PRESETS_Write32(PRESETS_ADDR_UIP_NETMASK01, UIP_TASK_NetmaskGet());
 8010294:	f010 fbda 	bl	8020a4c <UIP_TASK_NetmaskGet>
 8010298:	4601      	mov	r1, r0
 801029a:	2014      	movs	r0, #20
 801029c:	f7ff ffb6 	bl	801020c <PRESETS_Write32>
 80102a0:	4306      	orrs	r6, r0
  status |= PRESETS_Write32(PRESETS_ADDR_UIP_GATEWAY01, UIP_TASK_GatewayGet());
 80102a2:	f010 fbf1 	bl	8020a88 <UIP_TASK_GatewayGet>
 80102a6:	4601      	mov	r1, r0
 80102a8:	2016      	movs	r0, #22
 80102aa:	f7ff ffaf 	bl	801020c <PRESETS_Write32>
 80102ae:	2420      	movs	r4, #32
 80102b0:	4306      	orrs	r6, r0
 80102b2:	2700      	movs	r7, #0
 80102b4:	fa5f f887 	uxtb.w	r8, r7

  // write OSC data
  u8 con = 0;
  for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
    int offset = con * PRESETS_OFFSET_BETWEEN_OSC_RECORDS;
    status |= PRESETS_Write32(PRESETS_ADDR_OSC0_REMOTE01 + offset, OSC_SERVER_RemoteIP_Get(con));
 80102b8:	4640      	mov	r0, r8
 80102ba:	f011 f91b 	bl	80214f4 <OSC_SERVER_RemoteIP_Get>
 80102be:	4601      	mov	r1, r0
 80102c0:	4620      	mov	r0, r4
 80102c2:	f7ff ffa3 	bl	801020c <PRESETS_Write32>
 80102c6:	4605      	mov	r5, r0
    status |= PRESETS_Write16(PRESETS_ADDR_OSC0_REMOTE_PORT + offset, OSC_SERVER_RemotePortGet(con));
 80102c8:	4640      	mov	r0, r8
 80102ca:	f011 f925 	bl	8021518 <OSC_SERVER_RemotePortGet>
 80102ce:	4601      	mov	r1, r0
 80102d0:	1ca0      	adds	r0, r4, #2
  return EEPROM_Write(addr, value);
 80102d2:	b280      	uxth	r0, r0
 80102d4:	f012 f99c 	bl	8022610 <EEPROM_Write>
 80102d8:	4305      	orrs	r5, r0
    status |= PRESETS_Write16(PRESETS_ADDR_OSC0_LOCAL_PORT + offset, OSC_SERVER_LocalPortGet(con));
 80102da:	4640      	mov	r0, r8
 80102dc:	f011 f92e 	bl	802153c <OSC_SERVER_LocalPortGet>
 80102e0:	4601      	mov	r1, r0
 80102e2:	1ce0      	adds	r0, r4, #3
  return EEPROM_Write(addr, value);
 80102e4:	b280      	uxth	r0, r0
 80102e6:	f012 f993 	bl	8022610 <EEPROM_Write>
  for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
 80102ea:	3701      	adds	r7, #1
    status |= PRESETS_Write16(PRESETS_ADDR_OSC0_LOCAL_PORT + offset, OSC_SERVER_LocalPortGet(con));
 80102ec:	4305      	orrs	r5, r0
  for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
 80102ee:	3408      	adds	r4, #8
 80102f0:	2f04      	cmp	r7, #4
    status |= PRESETS_Write16(PRESETS_ADDR_OSC0_LOCAL_PORT + offset, OSC_SERVER_LocalPortGet(con));
 80102f2:	ea46 0605 	orr.w	r6, r6, r5
  for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
 80102f6:	b2a4      	uxth	r4, r4
 80102f8:	d1dc      	bne.n	80102b4 <PRESETS_StoreAll+0x8c>
  {
    int kb;
    keyboard_config_t* kc = (keyboard_config_t*)&keyboard_config[0];
    for (kb = 0; kb < KEYBOARD_NUM; ++kb, ++kc) {
      int offset = kb * PRESETS_OFFSET_BETWEEN_KB_RECORDS;
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_MIDI_PORTS + offset, kc->midi_ports);
 80102fa:	4d7b      	ldr	r5, [pc, #492]	@ (80104e8 <PRESETS_StoreAll+0x2c0>)
  return EEPROM_Write(addr, value);
 80102fc:	20c0      	movs	r0, #192	@ 0xc0
 80102fe:	8829      	ldrh	r1, [r5, #0]
 8010300:	f012 f986 	bl	8022610 <EEPROM_Write>
 8010304:	78a9      	ldrb	r1, [r5, #2]
 8010306:	4604      	mov	r4, r0
 8010308:	20c1      	movs	r0, #193	@ 0xc1
 801030a:	f012 f981 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_MIDI_CHN + offset, kc->midi_chn);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_NOTE_OFFSET + offset, kc->note_offset | ((u16)kc->din_key_offset << 8));
 801030e:	78eb      	ldrb	r3, [r5, #3]
 8010310:	7b29      	ldrb	r1, [r5, #12]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_MIDI_CHN + offset, kc->midi_chn);
 8010312:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010314:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8010318:	20c2      	movs	r0, #194	@ 0xc2
 801031a:	f012 f979 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_MIDI_CHN + offset, kc->midi_chn);
 801031e:	4334      	orrs	r4, r6
  return EEPROM_Write(addr, value);
 8010320:	7929      	ldrb	r1, [r5, #4]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_NOTE_OFFSET + offset, kc->note_offset | ((u16)kc->din_key_offset << 8));
 8010322:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010324:	20c3      	movs	r0, #195	@ 0xc3
 8010326:	f012 f973 	bl	8022610 <EEPROM_Write>
 801032a:	7a29      	ldrb	r1, [r5, #8]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_ROWS + offset, kc->num_rows);
 801032c:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 801032e:	20c4      	movs	r0, #196	@ 0xc4
 8010330:	f012 f96e 	bl	8022610 <EEPROM_Write>
 8010334:	7a69      	ldrb	r1, [r5, #9]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DOUT_SR1 + offset, kc->dout_sr1);
 8010336:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010338:	20c5      	movs	r0, #197	@ 0xc5
 801033a:	f012 f969 	bl	8022610 <EEPROM_Write>
 801033e:	7aa9      	ldrb	r1, [r5, #10]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DOUT_SR2 + offset, kc->dout_sr2);
 8010340:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010342:	20c6      	movs	r0, #198	@ 0xc6
 8010344:	f012 f964 	bl	8022610 <EEPROM_Write>
 8010348:	7ae9      	ldrb	r1, [r5, #11]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DIN_SR1 + offset, kc->din_sr1);
 801034a:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 801034c:	20c7      	movs	r0, #199	@ 0xc7
 801034e:	f012 f95f 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DIN_SR2 + offset, kc->din_sr2);

      u16 misc =
        (kc->din_inverted << 0) |
        (kc->break_inverted << 1) |
 8010352:	7b69      	ldrb	r1, [r5, #13]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DIN_SR2 + offset, kc->din_sr2);
 8010354:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010356:	f001 013f 	and.w	r1, r1, #63	@ 0x3f
 801035a:	20c8      	movs	r0, #200	@ 0xc8
 801035c:	f012 f958 	bl	8022610 <EEPROM_Write>
 8010360:	89e9      	ldrh	r1, [r5, #14]
        (kc->scan_velocity << 2) |
        (kc->scan_optimized << 3) |
        (kc->scan_release_velocity << 4) |
        (kc->make_debounced << 5);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_MISC + offset, misc);
 8010362:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010364:	20c9      	movs	r0, #201	@ 0xc9
 8010366:	f012 f953 	bl	8022610 <EEPROM_Write>
 801036a:	8ae9      	ldrh	r1, [r5, #22]

      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_FASTEST + offset, kc->delay_fastest);
 801036c:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 801036e:	20ca      	movs	r0, #202	@ 0xca
 8010370:	f012 f94e 	bl	8022610 <EEPROM_Write>
 8010374:	8a29      	ldrh	r1, [r5, #16]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_SLOWEST + offset, kc->delay_slowest);
 8010376:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010378:	20d4      	movs	r0, #212	@ 0xd4
 801037a:	f012 f949 	bl	8022610 <EEPROM_Write>
 801037e:	8a69      	ldrh	r1, [r5, #18]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_FASTEST_BLACK_KEYS + offset, kc->delay_fastest_black_keys);
 8010380:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010382:	20d5      	movs	r0, #213	@ 0xd5
 8010384:	f012 f944 	bl	8022610 <EEPROM_Write>
 8010388:	8aa9      	ldrh	r1, [r5, #20]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_FASTEST_RELEASE + offset, kc->delay_fastest_release);
 801038a:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 801038c:	20d6      	movs	r0, #214	@ 0xd6
 801038e:	f012 f93f 	bl	8022610 <EEPROM_Write>
 8010392:	8b29      	ldrh	r1, [r5, #24]
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_FASTEST_RELEASE_BLACK_KEYS + offset, kc->delay_fastest_release_black_keys);
 8010394:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 8010396:	20d7      	movs	r0, #215	@ 0xd7
 8010398:	f012 f93a 	bl	8022610 <EEPROM_Write>
 801039c:	f895 1146 	ldrb.w	r1, [r5, #326]	@ 0x146
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_DELAY_SLOWEST_RELEASE + offset, kc->delay_slowest_release);
 80103a0:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103a2:	20d8      	movs	r0, #216	@ 0xd8
 80103a4:	f012 f934 	bl	8022610 <EEPROM_Write>
 80103a8:	f895 1147 	ldrb.w	r1, [r5, #327]	@ 0x147

      // Scott Rush - added split points
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_SPLIT_MODE + offset, kc->split_mode);
 80103ac:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103ae:	20d9      	movs	r0, #217	@ 0xd9
 80103b0:	f012 f92e 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_TWO_SPLIT_NN + offset, kc->two_split_middle_note_number);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_TWO_SPLIT_RIGHT_SHIFT + offset, kc->two_split_right_shift);
 80103b4:	f995 1148 	ldrsb.w	r1, [r5, #328]	@ 0x148
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_TWO_SPLIT_NN + offset, kc->two_split_middle_note_number);
 80103b8:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103ba:	b289      	uxth	r1, r1
 80103bc:	20da      	movs	r0, #218	@ 0xda
 80103be:	f012 f927 	bl	8022610 <EEPROM_Write>
 80103c2:	f895 1149 	ldrb.w	r1, [r5, #329]	@ 0x149
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_TWO_SPLIT_RIGHT_SHIFT + offset, kc->two_split_right_shift);
 80103c6:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103c8:	20db      	movs	r0, #219	@ 0xdb
 80103ca:	f012 f921 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_LEFT_NN + offset, kc->three_split_left_note_number);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_LEFT_SHIFT + offset, kc->three_split_left_shift);
 80103ce:	f995 114a 	ldrsb.w	r1, [r5, #330]	@ 0x14a
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_LEFT_NN + offset, kc->three_split_left_note_number);
 80103d2:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103d4:	b289      	uxth	r1, r1
 80103d6:	20dc      	movs	r0, #220	@ 0xdc
 80103d8:	f012 f91a 	bl	8022610 <EEPROM_Write>
 80103dc:	f895 114b 	ldrb.w	r1, [r5, #331]	@ 0x14b
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_LEFT_SHIFT + offset, kc->three_split_left_shift);
 80103e0:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103e2:	20dd      	movs	r0, #221	@ 0xdd
 80103e4:	f012 f914 	bl	8022610 <EEPROM_Write>
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_NN + offset, kc->three_split_right_note_number);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_SHIFT + offset, kc->three_split_right_shift);
 80103e8:	f995 114c 	ldrsb.w	r1, [r5, #332]	@ 0x14c
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_NN + offset, kc->three_split_right_note_number);
 80103ec:	4304      	orrs	r4, r0
  return EEPROM_Write(addr, value);
 80103ee:	b289      	uxth	r1, r1
 80103f0:	20de      	movs	r0, #222	@ 0xde
 80103f2:	f012 f90d 	bl	8022610 <EEPROM_Write>
 80103f6:	f205 172b 	addw	r7, r5, #299	@ 0x12b
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_SHIFT + offset, kc->three_split_right_shift);
 80103fa:	4304      	orrs	r4, r0
 80103fc:	26cb      	movs	r6, #203	@ 0xcb

      int i;
      for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
        u16 ain_cfg1 =
          (kc->ain_pin[i] << 0) |
 80103fe:	787b      	ldrb	r3, [r7, #1]
          (kc->ain_ctrl[i] << 8);
 8010400:	7979      	ldrb	r1, [r7, #5]
  return EEPROM_Write(addr, value);
 8010402:	4630      	mov	r0, r6
 8010404:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8010408:	f012 f902 	bl	8022610 <EEPROM_Write>
        status |= PRESETS_Write16(PRESETS_ADDR_KB1_AIN_CFG1_1 + i * 2 + offset, ain_cfg1);

        u16 ain_cfg2 =
          (kc->ain_min[i] << 0) |
          (kc->ain_max[i] << 8);
 801040c:	7b79      	ldrb	r1, [r7, #13]
          (kc->ain_min[i] << 0) |
 801040e:	7a7b      	ldrb	r3, [r7, #9]
  return EEPROM_Write(addr, value);
 8010410:	4680      	mov	r8, r0
        status |= PRESETS_Write16(PRESETS_ADDR_KB1_AIN_CFG1_2 + i * 2 + offset, ain_cfg2);
 8010412:	1c70      	adds	r0, r6, #1
  return EEPROM_Write(addr, value);
 8010414:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8010418:	b280      	uxth	r0, r0
 801041a:	f012 f8f9 	bl	8022610 <EEPROM_Write>
      for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 801041e:	3602      	adds	r6, #2
 8010420:	b2b6      	uxth	r6, r6
        status |= PRESETS_Write16(PRESETS_ADDR_KB1_AIN_CFG1_2 + i * 2 + offset, ain_cfg2);
 8010422:	ea40 0008 	orr.w	r0, r0, r8
      for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 8010426:	2ed3      	cmp	r6, #211	@ 0xd3
          (kc->ain_pin[i] << 0) |
 8010428:	f107 0701 	add.w	r7, r7, #1
        status |= PRESETS_Write16(PRESETS_ADDR_KB1_AIN_CFG1_2 + i * 2 + offset, ain_cfg2);
 801042c:	ea44 0400 	orr.w	r4, r4, r0
      for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 8010430:	d1e5      	bne.n	80103fe <PRESETS_StoreAll+0x1d6>
#if KEYBOARD_AIN_NUM != 4
# error "please adapt the code below"
#endif
      u16 ain_cfg5 =
        (kc->ain_bandwidth_ms << 0) |
        (kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? 0x0100 : 0) |
 8010432:	f895 3141 	ldrb.w	r3, [r5, #321]	@ 0x141
        (kc->ain_bandwidth_ms << 0) |
 8010436:	f895 2140 	ldrb.w	r2, [r5, #320]	@ 0x140
        (kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] ? 0x0200 : 0) |
        (kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] ? 0x0400 : 0) |
        (kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] ? 0x0800 : 0) |
 801043a:	f895 1144 	ldrb.w	r1, [r5, #324]	@ 0x144
        (kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? 0x0100 : 0) |
 801043e:	3b00      	subs	r3, #0
 8010440:	bf18      	it	ne
 8010442:	2301      	movne	r3, #1
        (kc->ain_bandwidth_ms << 0) |
 8010444:	3a00      	subs	r2, #0
 8010446:	bf18      	it	ne
 8010448:	2201      	movne	r2, #1
 801044a:	0212      	lsls	r2, r2, #8
        (kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? 0x0100 : 0) |
 801044c:	ea42 2243 	orr.w	r2, r2, r3, lsl #9
        (kc->ain_bandwidth_ms << 0) |
 8010450:	f895 3145 	ldrb.w	r3, [r5, #325]	@ 0x145
        (kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? 0x0100 : 0) |
 8010454:	4313      	orrs	r3, r2
        (kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] ? 0x0200 : 0) |
 8010456:	f895 2142 	ldrb.w	r2, [r5, #322]	@ 0x142
 801045a:	3a00      	subs	r2, #0
 801045c:	bf18      	it	ne
 801045e:	2201      	movne	r2, #1
 8010460:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
        (kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] ? 0x0400 : 0) |
 8010464:	f895 2143 	ldrb.w	r2, [r5, #323]	@ 0x143
 8010468:	3a00      	subs	r2, #0
 801046a:	bf18      	it	ne
 801046c:	2201      	movne	r2, #1
        (kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] ? 0x0800 : 0) |
 801046e:	3900      	subs	r1, #0
        (kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] ? 0x0400 : 0) |
 8010470:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
        (kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] ? 0x0800 : 0) |
 8010474:	bf18      	it	ne
 8010476:	2101      	movne	r1, #1
  return EEPROM_Write(addr, value);
 8010478:	4630      	mov	r0, r6
 801047a:	ea43 31c1 	orr.w	r1, r3, r1, lsl #15
 801047e:	f012 f8c7 	bl	8022610 <EEPROM_Write>
 8010482:	4e1a      	ldr	r6, [pc, #104]	@ (80104ec <PRESETS_StoreAll+0x2c4>)
        (kc->ain_sustain_switch ? 0x8000 : 0);
      status |= PRESETS_Write16(PRESETS_ADDR_KB1_AIN_CFG5 + offset, ain_cfg5);
 8010484:	4304      	orrs	r4, r0
 8010486:	f44f 7500 	mov.w	r5, #512	@ 0x200
  return EEPROM_Write(addr, value);
 801048a:	4628      	mov	r0, r5
 801048c:	f836 1f02 	ldrh.w	r1, [r6, #2]!
 8010490:	f012 f8be 	bl	8022610 <EEPROM_Write>

      // store calibration data
      {
        u16 calidata_base = (kb >= 1) ? PRESETS_ADDR_KB2_CALIDATA_BEGIN : PRESETS_ADDR_KB1_CALIDATA_BEGIN;
        for (i = 0; i < 128 && i < KEYBOARD_MAX_KEYS; ++i) { // note: actually KEYBOARD_MAX_KEYS is 128, we just want to avoid memory overwrites for the case that somebody defines a lower number
 8010494:	3501      	adds	r5, #1
 8010496:	b2ad      	uxth	r5, r5
 8010498:	f5b5 7f20 	cmp.w	r5, #640	@ 0x280
          status |= PRESETS_Write16(calidata_base + i, kc->delay_key[i]);
 801049c:	ea44 0400 	orr.w	r4, r4, r0
        for (i = 0; i < 128 && i < KEYBOARD_MAX_KEYS; ++i) { // note: actually KEYBOARD_MAX_KEYS is 128, we just want to avoid memory overwrites for the case that somebody defines a lower number
 80104a0:	d1f3      	bne.n	801048a <PRESETS_StoreAll+0x262>
  {
#if MIDI_ROUTER_NUM_NODES != 16
# error "EEPROM format only prepared for 16 nodes"
#endif
    u8 node;
    midi_router_node_entry_t* n = &midi_router_node[0];
 80104a2:	4f13      	ldr	r7, [pc, #76]	@ (80104f0 <PRESETS_StoreAll+0x2c8>)
 80104a4:	f44f 7580 	mov.w	r5, #256	@ 0x100
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
      u16 cfg1 = n->src_port | ((u16)n->src_chn << 8);
      u16 cfg2 = n->dst_port | ((u16)n->dst_chn << 8);
 80104a8:	f8b7 8002 	ldrh.w	r8, [r7, #2]
  return EEPROM_Write(addr, value);
 80104ac:	f837 1b04 	ldrh.w	r1, [r7], #4
 80104b0:	4628      	mov	r0, r5
 80104b2:	f012 f8ad 	bl	8022610 <EEPROM_Write>
 80104b6:	4606      	mov	r6, r0

      status |= PRESETS_Write16(PRESETS_ADDR_ROUTER_BEGIN + node * 2 + 0, cfg1);
      status |= PRESETS_Write16(PRESETS_ADDR_ROUTER_BEGIN + node * 2 + 1, cfg2);
 80104b8:	1c68      	adds	r0, r5, #1
  return EEPROM_Write(addr, value);
 80104ba:	4641      	mov	r1, r8
 80104bc:	b280      	uxth	r0, r0
 80104be:	f012 f8a7 	bl	8022610 <EEPROM_Write>
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 80104c2:	3502      	adds	r5, #2
 80104c4:	b2ad      	uxth	r5, r5
      status |= PRESETS_Write16(PRESETS_ADDR_ROUTER_BEGIN + node * 2 + 1, cfg2);
 80104c6:	4330      	orrs	r0, r6
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 80104c8:	f5b5 7f90 	cmp.w	r5, #288	@ 0x120
      status |= PRESETS_Write16(PRESETS_ADDR_ROUTER_BEGIN + node * 2 + 1, cfg2);
 80104cc:	ea44 0400 	orr.w	r4, r4, r0
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 80104d0:	d1ea      	bne.n	80104a8 <PRESETS_StoreAll+0x280>
    }
  }

#if DEBUG_VERBOSE_LEVEL >= 1
  if (status < 0) {
 80104d2:	2c00      	cmp	r4, #0
 80104d4:	da02      	bge.n	80104dc <PRESETS_StoreAll+0x2b4>
    DEBUG_MSG("[PRESETS] ERROR while writing into EEPROM!");
 80104d6:	4807      	ldr	r0, [pc, #28]	@ (80104f4 <PRESETS_StoreAll+0x2cc>)
 80104d8:	f004 fb86 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  }
#endif

  return 0; // no error
}
 80104dc:	2000      	movs	r0, #0
 80104de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80104e2:	bf00      	nop
 80104e4:	47114228 	.word	0x47114228
 80104e8:	20000370 	.word	0x20000370
 80104ec:	20000388 	.word	0x20000388
 80104f0:	2000005e 	.word	0x2000005e
 80104f4:	08023670 	.word	0x08023670

080104f8 <PRESETS_Init>:
s32 PRESETS_Init(u32 mode) {
 80104f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if ((status = EEPROM_Init(0)) < 0) {
 80104fc:	2000      	movs	r0, #0
 80104fe:	f011 ffd9 	bl	80224b4 <EEPROM_Init>
 8010502:	1e04      	subs	r4, r0, #0
 8010504:	da03      	bge.n	801050e <PRESETS_Init+0x16>
    DEBUG_MSG("[PRESETS] EEPROM initialisation failed with status %d!\n", status);
 8010506:	48c6      	ldr	r0, [pc, #792]	@ (8010820 <PRESETS_Init+0x328>)
 8010508:	4621      	mov	r1, r4
 801050a:	f004 fb6d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  u32 magic = PRESETS_Read32(PRESETS_ADDR_MAGIC01);
 801050e:	2001      	movs	r0, #1
 8010510:	f7ff fe70 	bl	80101f4 <PRESETS_Read32>
  if (status < 0 ||
 8010514:	2c00      	cmp	r4, #0
  u32 magic = PRESETS_Read32(PRESETS_ADDR_MAGIC01);
 8010516:	4605      	mov	r5, r0
  if (status < 0 ||
 8010518:	db03      	blt.n	8010522 <PRESETS_Init+0x2a>
 801051a:	4bc2      	ldr	r3, [pc, #776]	@ (8010824 <PRESETS_Init+0x32c>)
 801051c:	4403      	add	r3, r0
 801051e:	2b04      	cmp	r3, #4
 8010520:	d91d      	bls.n	801055e <PRESETS_Init+0x66>
    DEBUG_MSG("[PRESETS] magic number not found (was 0x%08x) - initialize EEPROM!\n", magic);
 8010522:	4629      	mov	r1, r5
 8010524:	48c0      	ldr	r0, [pc, #768]	@ (8010828 <PRESETS_Init+0x330>)
 8010526:	f004 fb5f 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
    if ((status = EEPROM_Init(1)) < 0) {
 801052a:	2001      	movs	r0, #1
 801052c:	f011 ffc2 	bl	80224b4 <EEPROM_Init>
 8010530:	1e04      	subs	r4, r0, #0
 8010532:	da06      	bge.n	8010542 <PRESETS_Init+0x4a>
      DEBUG_MSG("[PRESETS] EEPROM clear failed with status %d!\n", status);
 8010534:	48bd      	ldr	r0, [pc, #756]	@ (801082c <PRESETS_Init+0x334>)
 8010536:	4621      	mov	r1, r4
 8010538:	f004 fb56 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
}
 801053c:	4620      	mov	r0, r4
 801053e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    for (addr = 0; addr < PRESETS_EEPROM_SIZE; ++addr)
 8010542:	2600      	movs	r6, #0
  return EEPROM_Write(addr, value);
 8010544:	b2b0      	uxth	r0, r6
 8010546:	2100      	movs	r1, #0
 8010548:	f012 f862 	bl	8022610 <EEPROM_Write>
    for (addr = 0; addr < PRESETS_EEPROM_SIZE; ++addr)
 801054c:	3601      	adds	r6, #1
 801054e:	f5b6 6f00 	cmp.w	r6, #2048	@ 0x800
      status |= PRESETS_Write16(addr, 0x00);
 8010552:	ea44 0400 	orr.w	r4, r4, r0
    for (addr = 0; addr < PRESETS_EEPROM_SIZE; ++addr)
 8010556:	d1f5      	bne.n	8010544 <PRESETS_Init+0x4c>
    status |= PRESETS_StoreAll();
 8010558:	f7ff fe66 	bl	8010228 <PRESETS_StoreAll>
 801055c:	4304      	orrs	r4, r0
    magic == EEPROM_MAGIC_NUMBER_OLDFORMAT3 ||
 801055e:	4eb1      	ldr	r6, [pc, #708]	@ (8010824 <PRESETS_Init+0x32c>)
 8010560:	442e      	add	r6, r5
  if (magic == EEPROM_MAGIC_NUMBER_OLDFORMAT1 ||
 8010562:	2e03      	cmp	r6, #3
 8010564:	d80e      	bhi.n	8010584 <PRESETS_Init+0x8c>
    DEBUG_MSG("[PRESETS] new format detected: clearing upper part of EEPROM...\n");
 8010566:	48b2      	ldr	r0, [pc, #712]	@ (8010830 <PRESETS_Init+0x338>)
 8010568:	f004 fb3e 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
    for (addr = 0x100; addr < PRESETS_EEPROM_SIZE; ++addr)
 801056c:	f44f 7780 	mov.w	r7, #256	@ 0x100
  return EEPROM_Write(addr, value);
 8010570:	b2b8      	uxth	r0, r7
 8010572:	2100      	movs	r1, #0
 8010574:	f012 f84c 	bl	8022610 <EEPROM_Write>
    for (addr = 0x100; addr < PRESETS_EEPROM_SIZE; ++addr)
 8010578:	3701      	adds	r7, #1
 801057a:	f5b7 6f00 	cmp.w	r7, #2048	@ 0x800
      status |= PRESETS_Write16(addr, 0x00);
 801057e:	ea44 0400 	orr.w	r4, r4, r0
    for (addr = 0x100; addr < PRESETS_EEPROM_SIZE; ++addr)
 8010582:	d1f5      	bne.n	8010570 <PRESETS_Init+0x78>
  if (status >= 0) {
 8010584:	2c00      	cmp	r4, #0
 8010586:	f2c0 80ca 	blt.w	801071e <PRESETS_Init+0x226>
    DEBUG_MSG("[PRESETS] reading configuration data from EEPROM!\n");
 801058a:	48aa      	ldr	r0, [pc, #680]	@ (8010834 <PRESETS_Init+0x33c>)
 801058c:	f004 fb2c 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  return EEPROM_Read(addr);
 8010590:	2004      	movs	r0, #4
 8010592:	f011 ff67 	bl	8022464 <EEPROM_Read>
    status |= MIDIMON_InitFromPresets((midimon_setup >> 0) & 1, (midimon_setup >> 1) & 1, (midimon_setup >> 2) & 1);
 8010596:	f3c0 0280 	ubfx	r2, r0, #2, #1
 801059a:	f3c0 0140 	ubfx	r1, r0, #1, #1
 801059e:	f000 0001 	and.w	r0, r0, #1
 80105a2:	f00e fb4d 	bl	801ec40 <MIDIMON_InitFromPresets>
  return EEPROM_Read(addr);
 80105a6:	2005      	movs	r0, #5
 80105a8:	f011 ff5c 	bl	8022464 <EEPROM_Read>
    if (num_srio)
 80105ac:	f010 00ff 	ands.w	r0, r0, #255	@ 0xff
 80105b0:	d001      	beq.n	80105b6 <PRESETS_Init+0xbe>
      MIOS32_SRIO_ScanNumSet(num_srio);
 80105b2:	f003 fef1 	bl	8014398 <MIOS32_SRIO_ScanNumSet>
  return EEPROM_Read(addr);
 80105b6:	2008      	movs	r0, #8
 80105b8:	f011 ff54 	bl	8022464 <EEPROM_Read>
 80105bc:	4604      	mov	r4, r0
    status |= UIP_TASK_InitFromPresets(PRESETS_Read16(PRESETS_ADDR_UIP_USE_DHCP),
 80105be:	2012      	movs	r0, #18
 80105c0:	f7ff fe18 	bl	80101f4 <PRESETS_Read32>
 80105c4:	4607      	mov	r7, r0
 80105c6:	2014      	movs	r0, #20
 80105c8:	f7ff fe14 	bl	80101f4 <PRESETS_Read32>
 80105cc:	4680      	mov	r8, r0
 80105ce:	2016      	movs	r0, #22
 80105d0:	f7ff fe10 	bl	80101f4 <PRESETS_Read32>
 80105d4:	4642      	mov	r2, r8
 80105d6:	4603      	mov	r3, r0
 80105d8:	4639      	mov	r1, r7
 80105da:	b2e0      	uxtb	r0, r4
 80105dc:	f010 f8da 	bl	8020794 <UIP_TASK_InitFromPresets>
 80105e0:	2420      	movs	r4, #32
 80105e2:	f04f 0900 	mov.w	r9, #0
      status |= OSC_SERVER_InitFromPresets(con,
 80105e6:	4620      	mov	r0, r4
 80105e8:	f7ff fe04 	bl	80101f4 <PRESETS_Read32>
 80105ec:	4607      	mov	r7, r0
 80105ee:	1ca0      	adds	r0, r4, #2
  return EEPROM_Read(addr);
 80105f0:	b280      	uxth	r0, r0
 80105f2:	f011 ff37 	bl	8022464 <EEPROM_Read>
 80105f6:	4680      	mov	r8, r0
      status |= OSC_SERVER_InitFromPresets(con,
 80105f8:	1ce0      	adds	r0, r4, #3
  return EEPROM_Read(addr);
 80105fa:	b280      	uxth	r0, r0
 80105fc:	f011 ff32 	bl	8022464 <EEPROM_Read>
      status |= OSC_SERVER_InitFromPresets(con,
 8010600:	fa1f f288 	uxth.w	r2, r8
 8010604:	b283      	uxth	r3, r0
 8010606:	4639      	mov	r1, r7
 8010608:	fa5f f089 	uxtb.w	r0, r9
    for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
 801060c:	f109 0901 	add.w	r9, r9, #1
      status |= OSC_SERVER_InitFromPresets(con,
 8010610:	f010 ff4c 	bl	80214ac <OSC_SERVER_InitFromPresets>
    for (con = 0; con < PRESETS_NUM_OSC_RECORDS; ++con) {
 8010614:	3408      	adds	r4, #8
 8010616:	f1b9 0f04 	cmp.w	r9, #4
 801061a:	b2a4      	uxth	r4, r4
 801061c:	d1e3      	bne.n	80105e6 <PRESETS_Init+0xee>
  return EEPROM_Read(addr);
 801061e:	20c0      	movs	r0, #192	@ 0xc0
 8010620:	f011 ff20 	bl	8022464 <EEPROM_Read>
      kc->midi_ports = PRESETS_Read16(PRESETS_ADDR_KB1_MIDI_PORTS + offset);
 8010624:	4c84      	ldr	r4, [pc, #528]	@ (8010838 <PRESETS_Init+0x340>)
  return EEPROM_Read(addr);
 8010626:	8020      	strh	r0, [r4, #0]
 8010628:	20c1      	movs	r0, #193	@ 0xc1
 801062a:	f011 ff1b 	bl	8022464 <EEPROM_Read>
      kc->midi_chn = PRESETS_Read16(PRESETS_ADDR_KB1_MIDI_CHN + offset);
 801062e:	70a0      	strb	r0, [r4, #2]
  return EEPROM_Read(addr);
 8010630:	20c2      	movs	r0, #194	@ 0xc2
 8010632:	f011 ff17 	bl	8022464 <EEPROM_Read>
      kc->note_offset = (note_offsets >> 0) & 0xff;
 8010636:	70e0      	strb	r0, [r4, #3]
      kc->din_key_offset = (note_offsets >> 8) & 0xff;
 8010638:	f3c0 2007 	ubfx	r0, r0, #8, #8
 801063c:	7320      	strb	r0, [r4, #12]
  return EEPROM_Read(addr);
 801063e:	20c3      	movs	r0, #195	@ 0xc3
 8010640:	f011 ff10 	bl	8022464 <EEPROM_Read>
      kc->num_rows = PRESETS_Read16(PRESETS_ADDR_KB1_ROWS + offset);
 8010644:	7120      	strb	r0, [r4, #4]
  return EEPROM_Read(addr);
 8010646:	20c4      	movs	r0, #196	@ 0xc4
 8010648:	f011 ff0c 	bl	8022464 <EEPROM_Read>
      kc->dout_sr1 = PRESETS_Read16(PRESETS_ADDR_KB1_DOUT_SR1 + offset);
 801064c:	7220      	strb	r0, [r4, #8]
  return EEPROM_Read(addr);
 801064e:	20c5      	movs	r0, #197	@ 0xc5
 8010650:	f011 ff08 	bl	8022464 <EEPROM_Read>
      kc->dout_sr2 = PRESETS_Read16(PRESETS_ADDR_KB1_DOUT_SR2 + offset);
 8010654:	7260      	strb	r0, [r4, #9]
  return EEPROM_Read(addr);
 8010656:	20c6      	movs	r0, #198	@ 0xc6
 8010658:	f011 ff04 	bl	8022464 <EEPROM_Read>
      kc->din_sr1 = PRESETS_Read16(PRESETS_ADDR_KB1_DIN_SR1 + offset);
 801065c:	72a0      	strb	r0, [r4, #10]
  return EEPROM_Read(addr);
 801065e:	20c7      	movs	r0, #199	@ 0xc7
 8010660:	f011 ff00 	bl	8022464 <EEPROM_Read>
      kc->din_sr2 = PRESETS_Read16(PRESETS_ADDR_KB1_DIN_SR2 + offset);
 8010664:	72e0      	strb	r0, [r4, #11]
  return EEPROM_Read(addr);
 8010666:	20c8      	movs	r0, #200	@ 0xc8
 8010668:	f011 fefc 	bl	8022464 <EEPROM_Read>
      kc->din_inverted = (misc & (1 << 0)) ? 1 : 0;
 801066c:	7b63      	ldrb	r3, [r4, #13]
 801066e:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
 8010672:	f023 033f 	bic.w	r3, r3, #63	@ 0x3f
 8010676:	4318      	orrs	r0, r3
 8010678:	7360      	strb	r0, [r4, #13]
  return EEPROM_Read(addr);
 801067a:	20c9      	movs	r0, #201	@ 0xc9
 801067c:	f011 fef2 	bl	8022464 <EEPROM_Read>
 8010680:	81e0      	strh	r0, [r4, #14]
 8010682:	20ca      	movs	r0, #202	@ 0xca
 8010684:	f011 feee 	bl	8022464 <EEPROM_Read>
      if (magic != EEPROM_MAGIC_NUMBER_OLDFORMAT1 && magic != EEPROM_MAGIC_NUMBER_OLDFORMAT2) {
 8010688:	2e01      	cmp	r6, #1
  return EEPROM_Read(addr);
 801068a:	82e0      	strh	r0, [r4, #22]
      if (magic != EEPROM_MAGIC_NUMBER_OLDFORMAT1 && magic != EEPROM_MAGIC_NUMBER_OLDFORMAT2) {
 801068c:	d90f      	bls.n	80106ae <PRESETS_Init+0x1b6>
  return EEPROM_Read(addr);
 801068e:	20d4      	movs	r0, #212	@ 0xd4
 8010690:	f011 fee8 	bl	8022464 <EEPROM_Read>
 8010694:	8220      	strh	r0, [r4, #16]
 8010696:	20d5      	movs	r0, #213	@ 0xd5
 8010698:	f011 fee4 	bl	8022464 <EEPROM_Read>
 801069c:	8260      	strh	r0, [r4, #18]
 801069e:	20d6      	movs	r0, #214	@ 0xd6
 80106a0:	f011 fee0 	bl	8022464 <EEPROM_Read>
 80106a4:	82a0      	strh	r0, [r4, #20]
 80106a6:	20d7      	movs	r0, #215	@ 0xd7
 80106a8:	f011 fedc 	bl	8022464 <EEPROM_Read>
 80106ac:	8320      	strh	r0, [r4, #24]
 80106ae:	20d8      	movs	r0, #216	@ 0xd8
 80106b0:	f011 fed8 	bl	8022464 <EEPROM_Read>
      kc->split_mode= PRESETS_Read16(PRESETS_ADDR_KB1_SPLIT_MODE + offset);
 80106b4:	f884 0146 	strb.w	r0, [r4, #326]	@ 0x146
  return EEPROM_Read(addr);
 80106b8:	20d9      	movs	r0, #217	@ 0xd9
 80106ba:	f011 fed3 	bl	8022464 <EEPROM_Read>
      kc->two_split_middle_note_number = PRESETS_Read16(PRESETS_ADDR_KB1_TWO_SPLIT_NN + offset);
 80106be:	f884 0147 	strb.w	r0, [r4, #327]	@ 0x147
  return EEPROM_Read(addr);
 80106c2:	20da      	movs	r0, #218	@ 0xda
 80106c4:	f011 fece 	bl	8022464 <EEPROM_Read>
      kc->two_split_right_shift = PRESETS_Read16(PRESETS_ADDR_KB2_TWO_SPLIT_RIGHT_SHIFT + offset);
 80106c8:	f884 0148 	strb.w	r0, [r4, #328]	@ 0x148
  return EEPROM_Read(addr);
 80106cc:	20dd      	movs	r0, #221	@ 0xdd
 80106ce:	f011 fec9 	bl	8022464 <EEPROM_Read>
      kc->three_split_right_note_number = PRESETS_Read16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_NN + offset);
 80106d2:	f884 014b 	strb.w	r0, [r4, #331]	@ 0x14b
  return EEPROM_Read(addr);
 80106d6:	20db      	movs	r0, #219	@ 0xdb
 80106d8:	f011 fec4 	bl	8022464 <EEPROM_Read>
      kc->three_split_left_note_number = PRESETS_Read16(PRESETS_ADDR_KB1_THREE_SPLIT_LEFT_NN + offset);
 80106dc:	f884 0149 	strb.w	r0, [r4, #329]	@ 0x149
  return EEPROM_Read(addr);
 80106e0:	20dc      	movs	r0, #220	@ 0xdc
 80106e2:	f011 febf 	bl	8022464 <EEPROM_Read>
      kc->three_split_left_shift = PRESETS_Read16(PRESETS_ADDR_KB2_THREE_SPLIT_LEFT_SHIFT + offset);
 80106e6:	f884 014a 	strb.w	r0, [r4, #330]	@ 0x14a
  return EEPROM_Read(addr);
 80106ea:	20dd      	movs	r0, #221	@ 0xdd
 80106ec:	f011 feba 	bl	8022464 <EEPROM_Read>
      kc->three_split_right_note_number = PRESETS_Read16(PRESETS_ADDR_KB1_THREE_SPLIT_RIGHT_NN + offset);
 80106f0:	f884 014b 	strb.w	r0, [r4, #331]	@ 0x14b
  return EEPROM_Read(addr);
 80106f4:	20de      	movs	r0, #222	@ 0xde
 80106f6:	f011 feb5 	bl	8022464 <EEPROM_Read>
      if (magic == EEPROM_MAGIC_NUMBER_OLDFORMAT1) {
 80106fa:	4b50      	ldr	r3, [pc, #320]	@ (801083c <PRESETS_Init+0x344>)
      kc->three_split_right_shift = PRESETS_Read16(PRESETS_ADDR_KB2_THREE_SPLIT_RIGHT_SHIFT + offset);
 80106fc:	f884 014c 	strb.w	r0, [r4, #332]	@ 0x14c
      if (magic == EEPROM_MAGIC_NUMBER_OLDFORMAT1) {
 8010700:	429d      	cmp	r5, r3
 8010702:	d131      	bne.n	8010768 <PRESETS_Init+0x270>
  return EEPROM_Read(addr);
 8010704:	20cb      	movs	r0, #203	@ 0xcb
 8010706:	f011 fead 	bl	8022464 <EEPROM_Read>
        kc->ain_pin[KEYBOARD_AIN_PITCHWHEEL] = (ain_assign >> 0) & 0xff;
 801070a:	f8a4 012c 	strh.w	r0, [r4, #300]	@ 0x12c
  return EEPROM_Read(addr);
 801070e:	20cc      	movs	r0, #204	@ 0xcc
 8010710:	f011 fea8 	bl	8022464 <EEPROM_Read>
        kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL] = (ctrl_assign >> 0) & 0xff;
 8010714:	f8a4 0130 	strh.w	r0, [r4, #304]	@ 0x130
    KEYBOARD_Init(1); // without overwriting default configuration
 8010718:	2001      	movs	r0, #1
 801071a:	f000 fad3 	bl	8010cc4 <KEYBOARD_Init>
      if (magic > EEPROM_MAGIC_NUMBER_OLDFORMAT4) {
 801071e:	4e48      	ldr	r6, [pc, #288]	@ (8010840 <PRESETS_Init+0x348>)
 8010720:	f44f 7480 	mov.w	r4, #256	@ 0x100
  return EEPROM_Read(addr);
 8010724:	4620      	mov	r0, r4
 8010726:	f011 fe9d 	bl	8022464 <EEPROM_Read>
 801072a:	4605      	mov	r5, r0
 801072c:	b287      	uxth	r7, r0
      u16 cfg2 = PRESETS_Read16(PRESETS_ADDR_ROUTER_BEGIN + node * 2 + 1);
 801072e:	1c60      	adds	r0, r4, #1
  return EEPROM_Read(addr);
 8010730:	b280      	uxth	r0, r0
 8010732:	f011 fe97 	bl	8022464 <EEPROM_Read>
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 8010736:	3402      	adds	r4, #2
  return EEPROM_Read(addr);
 8010738:	b282      	uxth	r2, r0
      if (!cfg1 && !cfg2) {
 801073a:	ea52 0107 	orrs.w	r1, r2, r7
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801073e:	b2a4      	uxth	r4, r4
        n->src_port = (cfg1 >> 0) & 0xff;
 8010740:	bf1f      	itttt	ne
 8010742:	b2ed      	uxtbne	r5, r5
        n->src_chn = (cfg1 >> 8) & 0xff;
 8010744:	0a39      	lsrne	r1, r7, #8
        n->dst_port = (cfg2 >> 0) & 0xff;
 8010746:	b2c3      	uxtbne	r3, r0
        n->dst_chn = (cfg2 >> 8) & 0xff;
 8010748:	0a12      	lsrne	r2, r2, #8
 801074a:	bf02      	ittt	eq
 801074c:	2510      	moveq	r5, #16
 801074e:	2320      	moveq	r3, #32
 8010750:	2211      	moveq	r2, #17
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 8010752:	f5b4 7f90 	cmp.w	r4, #288	@ 0x120
        n->src_port = USB0;
 8010756:	7035      	strb	r5, [r6, #0]
        n->src_chn = 0;
 8010758:	7071      	strb	r1, [r6, #1]
        n->dst_port = UART0;
 801075a:	70b3      	strb	r3, [r6, #2]
        n->dst_chn = 17; // All
 801075c:	70f2      	strb	r2, [r6, #3]
    for (node = 0; node < MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801075e:	f106 0604 	add.w	r6, r6, #4
 8010762:	d1df      	bne.n	8010724 <PRESETS_Init+0x22c>
  return 0; // no error
 8010764:	2400      	movs	r4, #0
 8010766:	e6e9      	b.n	801053c <PRESETS_Init+0x44>
      else if (magic == EEPROM_MAGIC_NUMBER_OLDFORMAT2 || magic == EEPROM_MAGIC_NUMBER_OLDFORMAT3) {
 8010768:	4b36      	ldr	r3, [pc, #216]	@ (8010844 <PRESETS_Init+0x34c>)
 801076a:	442b      	add	r3, r5
 801076c:	2b01      	cmp	r3, #1
 801076e:	d816      	bhi.n	801079e <PRESETS_Init+0x2a6>
 8010770:	4d35      	ldr	r5, [pc, #212]	@ (8010848 <PRESETS_Init+0x350>)
 8010772:	24cb      	movs	r4, #203	@ 0xcb
  return EEPROM_Read(addr);
 8010774:	4620      	mov	r0, r4
 8010776:	f011 fe75 	bl	8022464 <EEPROM_Read>
          kc->ain_pin[i] = (ain_cfg1 >> 0) & 0xff;
 801077a:	f805 0f01 	strb.w	r0, [r5, #1]!
          kc->ain_ctrl[i] = (ain_cfg1 >> 8) & 0xff;
 801077e:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8010782:	7128      	strb	r0, [r5, #4]
          u16 ain_cfg2 = PRESETS_Read16(PRESETS_ADDR_KB1_AIN_CFG1_2 + i * 2 + offset);
 8010784:	1c60      	adds	r0, r4, #1
  return EEPROM_Read(addr);
 8010786:	b280      	uxth	r0, r0
 8010788:	f011 fe6c 	bl	8022464 <EEPROM_Read>
        for (i = 0; i < 3; ++i) {
 801078c:	3402      	adds	r4, #2
 801078e:	b2a4      	uxth	r4, r4
          kc->ain_min[i] = (ain_cfg2 >> 0) & 0xff;
 8010790:	7228      	strb	r0, [r5, #8]
        for (i = 0; i < 3; ++i) {
 8010792:	2cd1      	cmp	r4, #209	@ 0xd1
          kc->ain_max[i] = (ain_cfg2 >> 8) & 0xff;
 8010794:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8010798:	7328      	strb	r0, [r5, #12]
        for (i = 0; i < 3; ++i) {
 801079a:	d1eb      	bne.n	8010774 <PRESETS_Init+0x27c>
 801079c:	e7bc      	b.n	8010718 <PRESETS_Init+0x220>
 801079e:	4f2a      	ldr	r7, [pc, #168]	@ (8010848 <PRESETS_Init+0x350>)
      else if (magic == EEPROM_MAGIC_NUMBER_OLDFORMAT2 || magic == EEPROM_MAGIC_NUMBER_OLDFORMAT3) {
 80107a0:	26cb      	movs	r6, #203	@ 0xcb
  return EEPROM_Read(addr);
 80107a2:	4630      	mov	r0, r6
 80107a4:	f011 fe5e 	bl	8022464 <EEPROM_Read>
          kc->ain_pin[i] = (ain_cfg1 >> 0) & 0xff;
 80107a8:	f807 0f01 	strb.w	r0, [r7, #1]!
          kc->ain_ctrl[i] = (ain_cfg1 >> 8) & 0xff;
 80107ac:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80107b0:	7138      	strb	r0, [r7, #4]
          u16 ain_cfg2 = PRESETS_Read16(PRESETS_ADDR_KB1_AIN_CFG1_2 + i * 2 + offset);
 80107b2:	1c70      	adds	r0, r6, #1
  return EEPROM_Read(addr);
 80107b4:	b280      	uxth	r0, r0
 80107b6:	f011 fe55 	bl	8022464 <EEPROM_Read>
        for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 80107ba:	3602      	adds	r6, #2
 80107bc:	b2b6      	uxth	r6, r6
          kc->ain_min[i] = (ain_cfg2 >> 0) & 0xff;
 80107be:	7238      	strb	r0, [r7, #8]
        for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 80107c0:	2ed3      	cmp	r6, #211	@ 0xd3
          kc->ain_max[i] = (ain_cfg2 >> 8) & 0xff;
 80107c2:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80107c6:	7338      	strb	r0, [r7, #12]
        for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 80107c8:	d1eb      	bne.n	80107a2 <PRESETS_Init+0x2aa>
  return EEPROM_Read(addr);
 80107ca:	4630      	mov	r0, r6
 80107cc:	f011 fe4a 	bl	8022464 <EEPROM_Read>
        kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] = (ain_cfg5 >> 8) & 1;
 80107d0:	f3c0 2300 	ubfx	r3, r0, #8, #1
 80107d4:	f884 3140 	strb.w	r3, [r4, #320]	@ 0x140
        kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] = (ain_cfg5 >> 9) & 1;
 80107d8:	f3c0 2340 	ubfx	r3, r0, #9, #1
 80107dc:	f884 3141 	strb.w	r3, [r4, #321]	@ 0x141
        kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] = (ain_cfg5 >> 10) & 1;
 80107e0:	f3c0 2380 	ubfx	r3, r0, #10, #1
 80107e4:	f884 3142 	strb.w	r3, [r4, #322]	@ 0x142
        kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] = (ain_cfg5 >> 11) & 1;
 80107e8:	f3c0 23c0 	ubfx	r3, r0, #11, #1
 80107ec:	f884 3143 	strb.w	r3, [r4, #323]	@ 0x143
        kc->ain_sustain_switch = (ain_cfg5 >> 15) & 1;
 80107f0:	f3c0 33c0 	ubfx	r3, r0, #15, #1
 80107f4:	f884 3144 	strb.w	r3, [r4, #324]	@ 0x144
      if (magic > EEPROM_MAGIC_NUMBER_OLDFORMAT4) {
 80107f8:	4b14      	ldr	r3, [pc, #80]	@ (801084c <PRESETS_Init+0x354>)
        kc->ain_bandwidth_ms = (ain_cfg5 >> 0) & 0xff;
 80107fa:	f884 0145 	strb.w	r0, [r4, #325]	@ 0x145
      if (magic > EEPROM_MAGIC_NUMBER_OLDFORMAT4) {
 80107fe:	429d      	cmp	r5, r3
 8010800:	d98a      	bls.n	8010718 <PRESETS_Init+0x220>
 8010802:	4d13      	ldr	r5, [pc, #76]	@ (8010850 <PRESETS_Init+0x358>)
 8010804:	f44f 7400 	mov.w	r4, #512	@ 0x200
  return EEPROM_Read(addr);
 8010808:	4620      	mov	r0, r4
 801080a:	f011 fe2b 	bl	8022464 <EEPROM_Read>
        for (i = 0; i < 128 && i < KEYBOARD_MAX_KEYS; ++i) { // note: actually KEYBOARD_MAX_KEYS is 128, we just want to avoid memory overwrites for the case that somebody defines a lower number
 801080e:	3401      	adds	r4, #1
 8010810:	b2a4      	uxth	r4, r4
 8010812:	f5b4 7f20 	cmp.w	r4, #640	@ 0x280
  return EEPROM_Read(addr);
 8010816:	f825 0f02 	strh.w	r0, [r5, #2]!
        for (i = 0; i < 128 && i < KEYBOARD_MAX_KEYS; ++i) { // note: actually KEYBOARD_MAX_KEYS is 128, we just want to avoid memory overwrites for the case that somebody defines a lower number
 801081a:	d1f5      	bne.n	8010808 <PRESETS_Init+0x310>
 801081c:	e77c      	b.n	8010718 <PRESETS_Init+0x220>
 801081e:	bf00      	nop
 8010820:	0802369b 	.word	0x0802369b
 8010824:	b8eebddc 	.word	0xb8eebddc
 8010828:	080236d3 	.word	0x080236d3
 801082c:	08023717 	.word	0x08023717
 8010830:	08023746 	.word	0x08023746
 8010834:	08023787 	.word	0x08023787
 8010838:	20000370 	.word	0x20000370
 801083c:	47114224 	.word	0x47114224
 8010840:	2000005e 	.word	0x2000005e
 8010844:	b8eebddb 	.word	0xb8eebddb
 8010848:	2000049b 	.word	0x2000049b
 801084c:	47114227 	.word	0x47114227
 8010850:	20000388 	.word	0x20000388

08010854 <TERMINAL_Init>:

/////////////////////////////////////////////////////////////////////////////
// Initialisation
/////////////////////////////////////////////////////////////////////////////
s32 TERMINAL_Init(u32 mode)
{
 8010854:	b508      	push	{r3, lr}
  // install the callback function which is called on incoming characters
  // from MIOS Terminal
  MIOS32_MIDI_DebugCommandCallback_Init(TERMINAL_Parse);
 8010856:	4804      	ldr	r0, [pc, #16]	@ (8010868 <TERMINAL_Init+0x14>)
 8010858:	f004 fde8 	bl	801542c <MIOS32_MIDI_DebugCommandCallback_Init>

  // clear line buffer
  line_buffer[0] = 0;
 801085c:	4b03      	ldr	r3, [pc, #12]	@ (801086c <TERMINAL_Init+0x18>)
 801085e:	2000      	movs	r0, #0
 8010860:	7018      	strb	r0, [r3, #0]
  line_ix = 0;
 8010862:	4b03      	ldr	r3, [pc, #12]	@ (8010870 <TERMINAL_Init+0x1c>)
 8010864:	8018      	strh	r0, [r3, #0]

  return 0; // no error
}
 8010866:	bd08      	pop	{r3, pc}
 8010868:	08010a3d 	.word	0x08010a3d
 801086c:	200000da 	.word	0x200000da
 8010870:	200000d8 	.word	0x200000d8

08010874 <TERMINAL_ParseLine>:

/////////////////////////////////////////////////////////////////////////////
// Parser for a complete line - also used by shell.c for telnet
/////////////////////////////////////////////////////////////////////////////
s32 TERMINAL_ParseLine(char *input, void *_output_function)
{
 8010874:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8010876:	4605      	mov	r5, r0
 8010878:	460c      	mov	r4, r1
  void (*out)(char *format, ...) = _output_function;
  char *separators = " \t";
  char *brkt;
  char *parameter;

  if( UIP_TERMINAL_ParseLine(input, _output_function) > 0 )
 801087a:	f011 faf1 	bl	8021e60 <UIP_TERMINAL_ParseLine>
 801087e:	2800      	cmp	r0, #0
 8010880:	dc49      	bgt.n	8010916 <TERMINAL_ParseLine+0xa2>
    return 0; // command parsed by UIP Terminal

  if( KEYBOARD_TerminalParseLine(input, _output_function) > 0 )
 8010882:	4621      	mov	r1, r4
 8010884:	4628      	mov	r0, r5
 8010886:	f001 fa97 	bl	8011db8 <KEYBOARD_TerminalParseLine>
 801088a:	2800      	cmp	r0, #0
 801088c:	dc43      	bgt.n	8010916 <TERMINAL_ParseLine+0xa2>
    return 0; // command parsed by Keyboard Terminal

  if( MIDIMON_TerminalParseLine(input, _output_function) > 0 )
 801088e:	4621      	mov	r1, r4
 8010890:	4628      	mov	r0, r5
 8010892:	f00e fced 	bl	801f270 <MIDIMON_TerminalParseLine>
 8010896:	2800      	cmp	r0, #0
 8010898:	dc3d      	bgt.n	8010916 <TERMINAL_ParseLine+0xa2>
    return 0; // command parsed

  if( MIDI_ROUTER_TerminalParseLine(input, _output_function) > 0 )
 801089a:	4621      	mov	r1, r4
 801089c:	4628      	mov	r0, r5
 801089e:	f00d fe35 	bl	801e50c <MIDI_ROUTER_TerminalParseLine>
 80108a2:	2800      	cmp	r0, #0
 80108a4:	dc37      	bgt.n	8010916 <TERMINAL_ParseLine+0xa2>
    return 0; // command parsed

  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 80108a6:	4628      	mov	r0, r5
 80108a8:	4948      	ldr	r1, [pc, #288]	@ (80109cc <TERMINAL_ParseLine+0x158>)
 80108aa:	466a      	mov	r2, sp
 80108ac:	f012 feaa 	bl	8023604 <strtok_r>
 80108b0:	4605      	mov	r5, r0
 80108b2:	2800      	cmp	r0, #0
 80108b4:	d02f      	beq.n	8010916 <TERMINAL_ParseLine+0xa2>
    if( strcmp(parameter, "help") == 0 ) {
 80108b6:	4946      	ldr	r1, [pc, #280]	@ (80109d0 <TERMINAL_ParseLine+0x15c>)
 80108b8:	f012 fea7 	bl	802360a <strcmp>
 80108bc:	bb08      	cbnz	r0, 8010902 <TERMINAL_ParseLine+0x8e>
      out("Welcome to " MIOS32_LCD_BOOT_MSG_LINE1 "!");
 80108be:	4845      	ldr	r0, [pc, #276]	@ (80109d4 <TERMINAL_ParseLine+0x160>)
 80108c0:	47a0      	blx	r4
      out("Following commands are available:");
 80108c2:	4845      	ldr	r0, [pc, #276]	@ (80109d8 <TERMINAL_ParseLine+0x164>)
 80108c4:	47a0      	blx	r4
      out("  system:                           print system info");
 80108c6:	4845      	ldr	r0, [pc, #276]	@ (80109dc <TERMINAL_ParseLine+0x168>)
 80108c8:	47a0      	blx	r4
      KEYBOARD_TerminalHelp(_output_function);
 80108ca:	4620      	mov	r0, r4
 80108cc:	f000 ff84 	bl	80117d8 <KEYBOARD_TerminalHelp>
      out("  set srio_num <1..16>:             max. number of scanned DIN/DOUT registers (currently: %d)", MIOS32_SRIO_ScanNumGet());
 80108d0:	f003 fd5c 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80108d4:	4601      	mov	r1, r0
 80108d6:	4842      	ldr	r0, [pc, #264]	@ (80109e0 <TERMINAL_ParseLine+0x16c>)
 80108d8:	47a0      	blx	r4
      UIP_TERMINAL_Help(_output_function);
 80108da:	4620      	mov	r0, r4
 80108dc:	f011 f9f6 	bl	8021ccc <UIP_TERMINAL_Help>
      MIDIMON_TerminalHelp(_output_function);
 80108e0:	4620      	mov	r0, r4
 80108e2:	f00e fcb5 	bl	801f250 <MIDIMON_TerminalHelp>
      MIDI_ROUTER_TerminalHelp(_output_function);
 80108e6:	4620      	mov	r0, r4
 80108e8:	f00d fd52 	bl	801e390 <MIDI_ROUTER_TerminalHelp>
      out("  store:                            stores current config as preset");
 80108ec:	483d      	ldr	r0, [pc, #244]	@ (80109e4 <TERMINAL_ParseLine+0x170>)
 80108ee:	47a0      	blx	r4
      out("  restore:                          restores config from preset");
 80108f0:	483d      	ldr	r0, [pc, #244]	@ (80109e8 <TERMINAL_ParseLine+0x174>)
 80108f2:	47a0      	blx	r4
      out("  reset:                            resets the MIDIbox (!)\n");
 80108f4:	483d      	ldr	r0, [pc, #244]	@ (80109ec <TERMINAL_ParseLine+0x178>)
 80108f6:	47a0      	blx	r4
      out("  help:                             this page");
 80108f8:	483d      	ldr	r0, [pc, #244]	@ (80109f0 <TERMINAL_ParseLine+0x17c>)
 80108fa:	47a0      	blx	r4
      out("  exit:                             (telnet only) exits the terminal");
 80108fc:	483d      	ldr	r0, [pc, #244]	@ (80109f4 <TERMINAL_ParseLine+0x180>)
        }
      } else {
	out("Missing parameter after 'set'!");
      }
    } else {
      out("Unknown command - type 'help' to list available commands!");
 80108fe:	47a0      	blx	r4
 8010900:	e009      	b.n	8010916 <TERMINAL_ParseLine+0xa2>
    } else if( strcmp(parameter, "system") == 0 ) {
 8010902:	493d      	ldr	r1, [pc, #244]	@ (80109f8 <TERMINAL_ParseLine+0x184>)
 8010904:	4628      	mov	r0, r5
 8010906:	f012 fe80 	bl	802360a <strcmp>
 801090a:	b938      	cbnz	r0, 801091c <TERMINAL_ParseLine+0xa8>
/////////////////////////////////////////////////////////////////////////////
static s32 TERMINAL_PrintSystem(void *_output_function)
{
  void (*out)(char *format, ...) = _output_function;

  out("Application: " MIOS32_LCD_BOOT_MSG_LINE1);
 801090c:	483b      	ldr	r0, [pc, #236]	@ (80109fc <TERMINAL_ParseLine+0x188>)
 801090e:	47a0      	blx	r4

  MIDIMON_TerminalPrintConfig(out);
 8010910:	4620      	mov	r0, r4
 8010912:	f00e fd43 	bl	801f39c <MIDIMON_TerminalPrintConfig>
}
 8010916:	2000      	movs	r0, #0
 8010918:	b002      	add	sp, #8
 801091a:	bd70      	pop	{r4, r5, r6, pc}
    } else if( strcmp(parameter, "store") == 0 ) {
 801091c:	4938      	ldr	r1, [pc, #224]	@ (8010a00 <TERMINAL_ParseLine+0x18c>)
 801091e:	4628      	mov	r0, r5
 8010920:	f012 fe73 	bl	802360a <strcmp>
 8010924:	b940      	cbnz	r0, 8010938 <TERMINAL_ParseLine+0xc4>
      s32 status = PRESETS_StoreAll();
 8010926:	f7ff fc7f 	bl	8010228 <PRESETS_StoreAll>
      if( status >= 0 ) {
 801092a:	1e01      	subs	r1, r0, #0
 801092c:	db01      	blt.n	8010932 <TERMINAL_ParseLine+0xbe>
	out("Presets stored in internal EEPROM!");
 801092e:	4835      	ldr	r0, [pc, #212]	@ (8010a04 <TERMINAL_ParseLine+0x190>)
 8010930:	e7e5      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
	out("ERROR: failed to store presets in internal EEPROM (status %d)!", status);
 8010932:	4835      	ldr	r0, [pc, #212]	@ (8010a08 <TERMINAL_ParseLine+0x194>)
	      out("%d DINs and DOUTs will be scanned!", MIOS32_SRIO_ScanNumGet());
 8010934:	47a0      	blx	r4
 8010936:	e7ee      	b.n	8010916 <TERMINAL_ParseLine+0xa2>
    } else if( strcmp(parameter, "restore") == 0 ) {
 8010938:	4934      	ldr	r1, [pc, #208]	@ (8010a0c <TERMINAL_ParseLine+0x198>)
 801093a:	4628      	mov	r0, r5
 801093c:	f012 fe65 	bl	802360a <strcmp>
 8010940:	b938      	cbnz	r0, 8010952 <TERMINAL_ParseLine+0xde>
      s32 status = PRESETS_Init(0);
 8010942:	f7ff fdd9 	bl	80104f8 <PRESETS_Init>
      if( status >= 0 ) {
 8010946:	1e01      	subs	r1, r0, #0
 8010948:	db01      	blt.n	801094e <TERMINAL_ParseLine+0xda>
	out("Presets restored from internal EEPROM!");
 801094a:	4831      	ldr	r0, [pc, #196]	@ (8010a10 <TERMINAL_ParseLine+0x19c>)
 801094c:	e7d7      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
	out("ERROR: failed to restore presets from internal EEPROM (status %d)!", status);
 801094e:	4831      	ldr	r0, [pc, #196]	@ (8010a14 <TERMINAL_ParseLine+0x1a0>)
 8010950:	e7f0      	b.n	8010934 <TERMINAL_ParseLine+0xc0>
    } else if( strcmp(parameter, "reset") == 0 ) {
 8010952:	4931      	ldr	r1, [pc, #196]	@ (8010a18 <TERMINAL_ParseLine+0x1a4>)
 8010954:	4628      	mov	r0, r5
 8010956:	f012 fe58 	bl	802360a <strcmp>
 801095a:	b910      	cbnz	r0, 8010962 <TERMINAL_ParseLine+0xee>
      MIOS32_SYS_Reset();
 801095c:	f005 fd6e 	bl	801643c <MIOS32_SYS_Reset>
 8010960:	e7d9      	b.n	8010916 <TERMINAL_ParseLine+0xa2>
    } else if( strcmp(parameter, "set") == 0 ) {
 8010962:	492e      	ldr	r1, [pc, #184]	@ (8010a1c <TERMINAL_ParseLine+0x1a8>)
 8010964:	4628      	mov	r0, r5
 8010966:	f012 fe50 	bl	802360a <strcmp>
 801096a:	bb68      	cbnz	r0, 80109c8 <TERMINAL_ParseLine+0x154>
      if( (parameter = strtok_r(NULL, separators, &brkt)) ) {
 801096c:	4917      	ldr	r1, [pc, #92]	@ (80109cc <TERMINAL_ParseLine+0x158>)
 801096e:	466a      	mov	r2, sp
 8010970:	f012 fe48 	bl	8023604 <strtok_r>
 8010974:	4605      	mov	r5, r0
 8010976:	b328      	cbz	r0, 80109c4 <TERMINAL_ParseLine+0x150>
	if( strcmp(parameter, "srio_num") == 0 ) {
 8010978:	4929      	ldr	r1, [pc, #164]	@ (8010a20 <TERMINAL_ParseLine+0x1ac>)
 801097a:	f012 fe46 	bl	802360a <strcmp>
 801097e:	4606      	mov	r6, r0
 8010980:	b9e8      	cbnz	r0, 80109be <TERMINAL_ParseLine+0x14a>
	  if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 8010982:	4912      	ldr	r1, [pc, #72]	@ (80109cc <TERMINAL_ParseLine+0x158>)
 8010984:	466a      	mov	r2, sp
 8010986:	f012 fe3d 	bl	8023604 <strtok_r>
 801098a:	4605      	mov	r5, r0
 801098c:	b908      	cbnz	r0, 8010992 <TERMINAL_ParseLine+0x11e>
	    out("Please specify the number of DIN/DOUTs which should be scanned (1..16)!");
 801098e:	4825      	ldr	r0, [pc, #148]	@ (8010a24 <TERMINAL_ParseLine+0x1b0>)
 8010990:	e7b5      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
  long l = strtol(word, &next, 0);
 8010992:	4632      	mov	r2, r6
 8010994:	a901      	add	r1, sp, #4
 8010996:	f002 fc0b 	bl	80131b0 <strtol>
    return -1;
 801099a:	9b01      	ldr	r3, [sp, #4]
 801099c:	429d      	cmp	r5, r3
 801099e:	bf08      	it	eq
 80109a0:	f04f 30ff 	moveq.w	r0, #4294967295	@ 0xffffffff
	    if( srs < 1 || srs > 16 ) {
 80109a4:	1e43      	subs	r3, r0, #1
 80109a6:	2b0f      	cmp	r3, #15
 80109a8:	d901      	bls.n	80109ae <TERMINAL_ParseLine+0x13a>
	      out("Number of DIN/DOUTs should be in the range between 1..16!");
 80109aa:	481f      	ldr	r0, [pc, #124]	@ (8010a28 <TERMINAL_ParseLine+0x1b4>)
 80109ac:	e7a7      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
	      MIOS32_SRIO_ScanNumSet(srs);
 80109ae:	b2c0      	uxtb	r0, r0
 80109b0:	f003 fcf2 	bl	8014398 <MIOS32_SRIO_ScanNumSet>
	      out("%d DINs and DOUTs will be scanned!", MIOS32_SRIO_ScanNumGet());
 80109b4:	f003 fcea 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80109b8:	4601      	mov	r1, r0
 80109ba:	481c      	ldr	r0, [pc, #112]	@ (8010a2c <TERMINAL_ParseLine+0x1b8>)
 80109bc:	e7ba      	b.n	8010934 <TERMINAL_ParseLine+0xc0>
          out("Unknown set parameter: '%s'!", parameter);
 80109be:	481c      	ldr	r0, [pc, #112]	@ (8010a30 <TERMINAL_ParseLine+0x1bc>)
 80109c0:	4629      	mov	r1, r5
 80109c2:	e7b7      	b.n	8010934 <TERMINAL_ParseLine+0xc0>
	out("Missing parameter after 'set'!");
 80109c4:	481b      	ldr	r0, [pc, #108]	@ (8010a34 <TERMINAL_ParseLine+0x1c0>)
 80109c6:	e79a      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
      out("Unknown command - type 'help' to list available commands!");
 80109c8:	481b      	ldr	r0, [pc, #108]	@ (8010a38 <TERMINAL_ParseLine+0x1c4>)
 80109ca:	e798      	b.n	80108fe <TERMINAL_ParseLine+0x8a>
 80109cc:	080237ba 	.word	0x080237ba
 80109d0:	080237bd 	.word	0x080237bd
 80109d4:	080237c2 	.word	0x080237c2
 80109d8:	080237e5 	.word	0x080237e5
 80109dc:	08023807 	.word	0x08023807
 80109e0:	0802383d 	.word	0x0802383d
 80109e4:	0802389b 	.word	0x0802389b
 80109e8:	080238df 	.word	0x080238df
 80109ec:	0802391f 	.word	0x0802391f
 80109f0:	0802395b 	.word	0x0802395b
 80109f4:	08023989 	.word	0x08023989
 80109f8:	080239ce 	.word	0x080239ce
 80109fc:	080239d5 	.word	0x080239d5
 8010a00:	08023a5d 	.word	0x08023a5d
 8010a04:	080239f9 	.word	0x080239f9
 8010a08:	08023a1c 	.word	0x08023a1c
 8010a0c:	08023a5b 	.word	0x08023a5b
 8010a10:	08023a63 	.word	0x08023a63
 8010a14:	08023a8a 	.word	0x08023a8a
 8010a18:	08023919 	.word	0x08023919
 8010a1c:	0802391b 	.word	0x0802391b
 8010a20:	08023acd 	.word	0x08023acd
 8010a24:	08023ad6 	.word	0x08023ad6
 8010a28:	08023b1e 	.word	0x08023b1e
 8010a2c:	08023b58 	.word	0x08023b58
 8010a30:	08023b7b 	.word	0x08023b7b
 8010a34:	08023b98 	.word	0x08023b98
 8010a38:	08023bb7 	.word	0x08023bb7

08010a3c <TERMINAL_Parse>:
{
 8010a3c:	b570      	push	{r4, r5, r6, lr}
 8010a3e:	460c      	mov	r4, r1
 8010a40:	4606      	mov	r6, r0
  mios32_midi_port_t prev_debug_port = MIOS32_MIDI_DebugPortGet();
 8010a42:	f004 fce7 	bl	8015414 <MIOS32_MIDI_DebugPortGet>
 8010a46:	4605      	mov	r5, r0
  MIOS32_MIDI_DebugPortSet(port);
 8010a48:	4630      	mov	r0, r6
 8010a4a:	f004 f9c7 	bl	8014ddc <MIOS32_MIDI_DebugPortSet>
  if( byte == '\r' ) {
 8010a4e:	2c0d      	cmp	r4, #13
 8010a50:	d017      	beq.n	8010a82 <TERMINAL_Parse+0x46>
  } else if( byte == '\n' ) {
 8010a52:	2c0a      	cmp	r4, #10
 8010a54:	d11a      	bne.n	8010a8c <TERMINAL_Parse+0x50>
    MUTEX_MIDIOUT_TAKE;
 8010a56:	4c13      	ldr	r4, [pc, #76]	@ (8010aa4 <TERMINAL_Parse+0x68>)
 8010a58:	6823      	ldr	r3, [r4, #0]
 8010a5a:	b12b      	cbz	r3, 8010a68 <TERMINAL_Parse+0x2c>
 8010a5c:	6820      	ldr	r0, [r4, #0]
 8010a5e:	2101      	movs	r1, #1
 8010a60:	f003 fa16 	bl	8013e90 <xQueueTakeMutexRecursive>
 8010a64:	2801      	cmp	r0, #1
 8010a66:	d1f9      	bne.n	8010a5c <TERMINAL_Parse+0x20>
    TERMINAL_ParseLine(line_buffer, MIOS32_MIDI_SendDebugMessage);
 8010a68:	490f      	ldr	r1, [pc, #60]	@ (8010aa8 <TERMINAL_Parse+0x6c>)
 8010a6a:	4810      	ldr	r0, [pc, #64]	@ (8010aac <TERMINAL_Parse+0x70>)
 8010a6c:	f7ff ff02 	bl	8010874 <TERMINAL_ParseLine>
    MUTEX_MIDIOUT_GIVE;
 8010a70:	6820      	ldr	r0, [r4, #0]
 8010a72:	b108      	cbz	r0, 8010a78 <TERMINAL_Parse+0x3c>
 8010a74:	f003 f95b 	bl	8013d2e <xQueueGiveMutexRecursive>
    line_ix = 0;
 8010a78:	4a0d      	ldr	r2, [pc, #52]	@ (8010ab0 <TERMINAL_Parse+0x74>)
 8010a7a:	2300      	movs	r3, #0
 8010a7c:	8013      	strh	r3, [r2, #0]
    line_buffer[line_ix] = 0;
 8010a7e:	4a0b      	ldr	r2, [pc, #44]	@ (8010aac <TERMINAL_Parse+0x70>)
 8010a80:	7013      	strb	r3, [r2, #0]
  MIOS32_MIDI_DebugPortSet(prev_debug_port);
 8010a82:	4628      	mov	r0, r5
 8010a84:	f004 f9aa 	bl	8014ddc <MIOS32_MIDI_DebugPortSet>
}
 8010a88:	2000      	movs	r0, #0
 8010a8a:	bd70      	pop	{r4, r5, r6, pc}
  } else if( line_ix < (STRING_MAX-1) ) {
 8010a8c:	4908      	ldr	r1, [pc, #32]	@ (8010ab0 <TERMINAL_Parse+0x74>)
 8010a8e:	880a      	ldrh	r2, [r1, #0]
 8010a90:	2a4e      	cmp	r2, #78	@ 0x4e
 8010a92:	d8f6      	bhi.n	8010a82 <TERMINAL_Parse+0x46>
    line_buffer[line_ix++] = byte;
 8010a94:	1c53      	adds	r3, r2, #1
 8010a96:	b29b      	uxth	r3, r3
 8010a98:	800b      	strh	r3, [r1, #0]
 8010a9a:	4904      	ldr	r1, [pc, #16]	@ (8010aac <TERMINAL_Parse+0x70>)
 8010a9c:	548c      	strb	r4, [r1, r2]
    line_buffer[line_ix] = 0;
 8010a9e:	2200      	movs	r2, #0
 8010aa0:	54ca      	strb	r2, [r1, r3]
 8010aa2:	e7ee      	b.n	8010a82 <TERMINAL_Parse+0x46>
 8010aa4:	200000d0 	.word	0x200000d0
 8010aa8:	08014be9 	.word	0x08014be9
 8010aac:	200000da 	.word	0x200000da
 8010ab0:	200000d8 	.word	0x200000d8

08010ab4 <KEYBOARD_GetNoteName>:


/////////////////////////////////////////////////////////////////////////////
//! Help function to put the note name into a string (buffer has 3 chars + terminator)
/////////////////////////////////////////////////////////////////////////////
static char* KEYBOARD_GetNoteName(u8 note, char str[4]) {
 8010ab4:	b5f0      	push	{r4, r5, r6, r7, lr}
	const char note_tab[12][3] = { "c-", "c#", "d-", "d#", "e-", "f-", "f#", "g-", "g#", "a-", "a#", "b-" };
 8010ab6:	4b1e      	ldr	r3, [pc, #120]	@ (8010b30 <KEYBOARD_GetNoteName+0x7c>)
static char* KEYBOARD_GetNoteName(u8 note, char str[4]) {
 8010ab8:	b08b      	sub	sp, #44	@ 0x2c
 8010aba:	4605      	mov	r5, r0
 8010abc:	460c      	mov	r4, r1
	const char note_tab[12][3] = { "c-", "c#", "d-", "d#", "e-", "f-", "f#", "g-", "g#", "a-", "a#", "b-" };
 8010abe:	aa01      	add	r2, sp, #4
 8010ac0:	f103 0720 	add.w	r7, r3, #32
 8010ac4:	6818      	ldr	r0, [r3, #0]
 8010ac6:	6859      	ldr	r1, [r3, #4]
 8010ac8:	4616      	mov	r6, r2
 8010aca:	c603      	stmia	r6!, {r0, r1}
 8010acc:	3308      	adds	r3, #8
 8010ace:	42bb      	cmp	r3, r7
 8010ad0:	4632      	mov	r2, r6
 8010ad2:	d1f7      	bne.n	8010ac4 <KEYBOARD_GetNoteName+0x10>

	// determine octave, note contains semitone number thereafter
	int octave = note / 12;
 8010ad4:	210c      	movs	r1, #12
	const char note_tab[12][3] = { "c-", "c#", "d-", "d#", "e-", "f-", "f#", "g-", "g#", "a-", "a#", "b-" };
 8010ad6:	6818      	ldr	r0, [r3, #0]
	int octave = note / 12;
 8010ad8:	fbb5 f3f1 	udiv	r3, r5, r1
 8010adc:	b2da      	uxtb	r2, r3
	note %= 12;
 8010ade:	fb01 5313 	mls	r3, r1, r3, r5

	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010ae2:	b2db      	uxtb	r3, r3
 8010ae4:	0059      	lsls	r1, r3, #1
	const char note_tab[12][3] = { "c-", "c#", "d-", "d#", "e-", "f-", "f#", "g-", "g#", "a-", "a#", "b-" };
 8010ae6:	6030      	str	r0, [r6, #0]
	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010ae8:	18c8      	adds	r0, r1, r3
 8010aea:	3028      	adds	r0, #40	@ 0x28
 8010aec:	4468      	add	r0, sp
	str[1] = note_tab[note][1];
 8010aee:	4419      	add	r1, r3
	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010af0:	f810 0c24 	ldrb.w	r0, [r0, #-36]
 8010af4:	2d17      	cmp	r5, #23
	str[1] = note_tab[note][1];
 8010af6:	f101 0328 	add.w	r3, r1, #40	@ 0x28
	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010afa:	bf88      	it	hi
 8010afc:	3820      	subhi	r0, #32
	str[1] = note_tab[note][1];
 8010afe:	eb0d 0103 	add.w	r1, sp, r3
	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010b02:	bf88      	it	hi
 8010b04:	b2c0      	uxtbhi	r0, r0

	switch (octave) {
 8010b06:	2d0b      	cmp	r5, #11
	str[1] = note_tab[note][1];
 8010b08:	f811 1c23 	ldrb.w	r1, [r1, #-35]
	str[0] = octave >= 2 ? (note_tab[note][0] + 'A' - 'a') : note_tab[note][0];
 8010b0c:	7020      	strb	r0, [r4, #0]
	switch (octave) {
 8010b0e:	d90b      	bls.n	8010b28 <KEYBOARD_GetNoteName+0x74>
 8010b10:	2a01      	cmp	r2, #1
 8010b12:	d00b      	beq.n	8010b2c <KEYBOARD_GetNoteName+0x78>
		case 0:  str[2] = '2'; break; // -2
		case 1:  str[2] = '1'; break; // -1
		default: str[2] = '0' + (octave - 2); // 0..7
 8010b14:	f102 032e 	add.w	r3, r2, #46	@ 0x2e
 8010b18:	b2db      	uxtb	r3, r3
		case 0:  str[2] = '2'; break; // -2
 8010b1a:	70a3      	strb	r3, [r4, #2]
		}

	str[3] = 0;

	return str;
	}
 8010b1c:	4620      	mov	r0, r4
	str[3] = 0;
 8010b1e:	2300      	movs	r3, #0
	str[1] = note_tab[note][1];
 8010b20:	7061      	strb	r1, [r4, #1]
	str[3] = 0;
 8010b22:	70e3      	strb	r3, [r4, #3]
	}
 8010b24:	b00b      	add	sp, #44	@ 0x2c
 8010b26:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (octave) {
 8010b28:	2332      	movs	r3, #50	@ 0x32
 8010b2a:	e7f6      	b.n	8010b1a <KEYBOARD_GetNoteName+0x66>
 8010b2c:	2331      	movs	r3, #49	@ 0x31
 8010b2e:	e7f4      	b.n	8010b1a <KEYBOARD_GetNoteName+0x66>
 8010b30:	080269b7 	.word	0x080269b7

08010b34 <get_dec>:
/////////////////////////////////////////////////////////////////////////////
//! help function which parses a decimal or hex value
//! \retval >= 0 if value is valid
//! \retval -1 if value is invalid
/////////////////////////////////////////////////////////////////////////////
static s32 get_dec(char* word) {
 8010b34:	b513      	push	{r0, r1, r4, lr}
	if (word == NULL)
 8010b36:	4604      	mov	r4, r0
 8010b38:	b918      	cbnz	r0, 8010b42 <get_dec+0xe>
		return -1;
 8010b3a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff

	if (word == next)
		return -1;

	return l; // value is valid
	}
 8010b3e:	b002      	add	sp, #8
 8010b40:	bd10      	pop	{r4, pc}
	long l = strtol(word, &next, 0);
 8010b42:	2200      	movs	r2, #0
 8010b44:	a901      	add	r1, sp, #4
 8010b46:	f002 fb33 	bl	80131b0 <strtol>
	if (word == next)
 8010b4a:	9b01      	ldr	r3, [sp, #4]
 8010b4c:	42a3      	cmp	r3, r4
 8010b4e:	d1f6      	bne.n	8010b3e <get_dec+0xa>
 8010b50:	e7f3      	b.n	8010b3a <get_dec+0x6>
	...

08010b54 <get_on_off>:
//! help function which parses for on or off
//! \retval 0 if 'off'
//! \retval 1 if 'on'
//! \retval -1 if invalid
/////////////////////////////////////////////////////////////////////////////
static s32 get_on_off(char* word) {
 8010b54:	b510      	push	{r4, lr}
	if (strcmp(word, "on") == 0 || strcmp(word, "1") == 0)
 8010b56:	490d      	ldr	r1, [pc, #52]	@ (8010b8c <get_on_off+0x38>)
static s32 get_on_off(char* word) {
 8010b58:	4604      	mov	r4, r0
	if (strcmp(word, "on") == 0 || strcmp(word, "1") == 0)
 8010b5a:	f012 fd56 	bl	802360a <strcmp>
 8010b5e:	b190      	cbz	r0, 8010b86 <get_on_off+0x32>
 8010b60:	490b      	ldr	r1, [pc, #44]	@ (8010b90 <get_on_off+0x3c>)
 8010b62:	4620      	mov	r0, r4
 8010b64:	f012 fd51 	bl	802360a <strcmp>
 8010b68:	b168      	cbz	r0, 8010b86 <get_on_off+0x32>
		return 1;

	if (strcmp(word, "off") == 0 || strcmp(word, "0") == 0)
 8010b6a:	490a      	ldr	r1, [pc, #40]	@ (8010b94 <get_on_off+0x40>)
 8010b6c:	4620      	mov	r0, r4
 8010b6e:	f012 fd4c 	bl	802360a <strcmp>
 8010b72:	b138      	cbz	r0, 8010b84 <get_on_off+0x30>
 8010b74:	4908      	ldr	r1, [pc, #32]	@ (8010b98 <get_on_off+0x44>)
 8010b76:	4620      	mov	r0, r4
 8010b78:	f012 fd47 	bl	802360a <strcmp>
 8010b7c:	3800      	subs	r0, #0
 8010b7e:	bf18      	it	ne
 8010b80:	2001      	movne	r0, #1
 8010b82:	4240      	negs	r0, r0
		return 0;

	return -1;
	}
 8010b84:	bd10      	pop	{r4, pc}
		return 1;
 8010b86:	2001      	movs	r0, #1
 8010b88:	e7fc      	b.n	8010b84 <get_on_off+0x30>
 8010b8a:	bf00      	nop
 8010b8c:	08024c4d 	.word	0x08024c4d
 8010b90:	080283d9 	.word	0x080283d9
 8010b94:	0802531e 	.word	0x0802531e
 8010b98:	080283d6 	.word	0x080283d6

08010b9c <KEYBOARD_TerminalCaliMode.isra.0>:
/////////////////////////////////////////////////////////////////////////////
#if !KEYBOARD_DONT_USE_AIN
static s32 KEYBOARD_TerminalCaliMode(void* _output_function) {
	void (*out)(char* format, ...) = _output_function;

	switch (ain_cali_mode_pin) {
 8010b9c:	4a0e      	ldr	r2, [pc, #56]	@ (8010bd8 <KEYBOARD_TerminalCaliMode.isra.0+0x3c>)
 8010b9e:	7812      	ldrb	r2, [r2, #0]
 8010ba0:	3a01      	subs	r2, #1
static s32 KEYBOARD_TerminalCaliMode(void* _output_function) {
 8010ba2:	4603      	mov	r3, r0
	switch (ain_cali_mode_pin) {
 8010ba4:	2a07      	cmp	r2, #7
 8010ba6:	d815      	bhi.n	8010bd4 <KEYBOARD_TerminalCaliMode.isra.0+0x38>
 8010ba8:	e8df f002 	tbb	[pc, r2]
 8010bac:	0a080604 	.word	0x0a080604
 8010bb0:	12100e0c 	.word	0x12100e0c
		case 1: out("AIN Calibration Mode enabled for kb 1 pitchwheel"); break;
 8010bb4:	4809      	ldr	r0, [pc, #36]	@ (8010bdc <KEYBOARD_TerminalCaliMode.isra.0+0x40>)
		case 5: out("AIN Calibration Mode enabled for kb 2 pitchwheel"); break;
		case 6: out("AIN Calibration Mode enabled for kb 2 modwheel"); break;
		case 7: out("AIN Calibration Mode enabled for kb 2 sustain"); break;
		case 8: out("AIN Calibration Mode enabled for kb 2 expression"); break;
		default:
			out("AIN Calibration Mode disabled.");
 8010bb6:	4718      	bx	r3
		case 2: out("AIN Calibration Mode enabled for kb 1 modwheel"); break;
 8010bb8:	4809      	ldr	r0, [pc, #36]	@ (8010be0 <KEYBOARD_TerminalCaliMode.isra.0+0x44>)
 8010bba:	e7fc      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 3: out("AIN Calibration Mode enabled for kb 1 sustain"); break;
 8010bbc:	4809      	ldr	r0, [pc, #36]	@ (8010be4 <KEYBOARD_TerminalCaliMode.isra.0+0x48>)
 8010bbe:	e7fa      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 4: out("AIN Calibration Mode enabled for kb 1 expression"); break;
 8010bc0:	4809      	ldr	r0, [pc, #36]	@ (8010be8 <KEYBOARD_TerminalCaliMode.isra.0+0x4c>)
 8010bc2:	e7f8      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 5: out("AIN Calibration Mode enabled for kb 2 pitchwheel"); break;
 8010bc4:	4809      	ldr	r0, [pc, #36]	@ (8010bec <KEYBOARD_TerminalCaliMode.isra.0+0x50>)
 8010bc6:	e7f6      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 6: out("AIN Calibration Mode enabled for kb 2 modwheel"); break;
 8010bc8:	4809      	ldr	r0, [pc, #36]	@ (8010bf0 <KEYBOARD_TerminalCaliMode.isra.0+0x54>)
 8010bca:	e7f4      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 7: out("AIN Calibration Mode enabled for kb 2 sustain"); break;
 8010bcc:	4809      	ldr	r0, [pc, #36]	@ (8010bf4 <KEYBOARD_TerminalCaliMode.isra.0+0x58>)
 8010bce:	e7f2      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
		case 8: out("AIN Calibration Mode enabled for kb 2 expression"); break;
 8010bd0:	4809      	ldr	r0, [pc, #36]	@ (8010bf8 <KEYBOARD_TerminalCaliMode.isra.0+0x5c>)
 8010bd2:	e7f0      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
			out("AIN Calibration Mode disabled.");
 8010bd4:	4809      	ldr	r0, [pc, #36]	@ (8010bfc <KEYBOARD_TerminalCaliMode.isra.0+0x60>)
 8010bd6:	e7ee      	b.n	8010bb6 <KEYBOARD_TerminalCaliMode.isra.0+0x1a>
 8010bd8:	2000012a 	.word	0x2000012a
 8010bdc:	08023bf1 	.word	0x08023bf1
 8010be0:	08023c22 	.word	0x08023c22
 8010be4:	08023c51 	.word	0x08023c51
 8010be8:	08023c7f 	.word	0x08023c7f
 8010bec:	08023cb0 	.word	0x08023cb0
 8010bf0:	08023ce1 	.word	0x08023ce1
 8010bf4:	08023d10 	.word	0x08023d10
 8010bf8:	08023d3e 	.word	0x08023d3e
 8010bfc:	08023d6f 	.word	0x08023d6f

08010c00 <KEYBOARD_MIDI_SendNote.isra.0>:
static s32 KEYBOARD_MIDI_SendNote(u8 kb, u8 note_number, u8 velocity, u8 depressed) {
 8010c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010c04:	4617      	mov	r7, r2
	if (kc->midi_chn) {
 8010c06:	4a2e      	ldr	r2, [pc, #184]	@ (8010cc0 <KEYBOARD_MIDI_SendNote.isra.0+0xc0>)
static s32 KEYBOARD_MIDI_SendNote(u8 kb, u8 note_number, u8 velocity, u8 depressed) {
 8010c08:	460d      	mov	r5, r1
	if (kc->midi_chn) {
 8010c0a:	f44f 71a8 	mov.w	r1, #336	@ 0x150
 8010c0e:	fb01 2100 	mla	r1, r1, r0, r2
static s32 KEYBOARD_MIDI_SendNote(u8 kb, u8 note_number, u8 velocity, u8 depressed) {
 8010c12:	4698      	mov	r8, r3
	if (kc->midi_chn) {
 8010c14:	788c      	ldrb	r4, [r1, #2]
 8010c16:	2c00      	cmp	r4, #0
 8010c18:	d047      	beq.n	8010caa <KEYBOARD_MIDI_SendNote.isra.0+0xaa>
		if (kc->split_mode == KEYBOARD_SPLIT_MODE_TWO){
 8010c1a:	f891 3146 	ldrb.w	r3, [r1, #326]	@ 0x146
 8010c1e:	2b01      	cmp	r3, #1
 8010c20:	d10a      	bne.n	8010c38 <KEYBOARD_MIDI_SendNote.isra.0+0x38>
			if (note_number >= kc->two_split_middle_note_number){
 8010c22:	f891 3147 	ldrb.w	r3, [r1, #327]	@ 0x147
 8010c26:	42ab      	cmp	r3, r5
 8010c28:	d817      	bhi.n	8010c5a <KEYBOARD_MIDI_SendNote.isra.0+0x5a>
				midi_chn += 1;
 8010c2a:	3401      	adds	r4, #1
				sent_note += kc->two_split_right_shift;
 8010c2c:	f891 3148 	ldrb.w	r3, [r1, #328]	@ 0x148
				midi_chn += 1;
 8010c30:	b2e4      	uxtb	r4, r4
				sent_note += kc->three_split_left_shift;
 8010c32:	442b      	add	r3, r5
 8010c34:	b2dd      	uxtb	r5, r3
 8010c36:	e010      	b.n	8010c5a <KEYBOARD_MIDI_SendNote.isra.0+0x5a>
		else if (kc->split_mode == KEYBOARD_SPLIT_MODE_THREE){
 8010c38:	2b02      	cmp	r3, #2
 8010c3a:	d10e      	bne.n	8010c5a <KEYBOARD_MIDI_SendNote.isra.0+0x5a>
			if (note_number >= kc->three_split_right_note_number){
 8010c3c:	f891 314b 	ldrb.w	r3, [r1, #331]	@ 0x14b
 8010c40:	42ab      	cmp	r3, r5
 8010c42:	d804      	bhi.n	8010c4e <KEYBOARD_MIDI_SendNote.isra.0+0x4e>
				midi_chn += 2;
 8010c44:	3402      	adds	r4, #2
				sent_note += kc->three_split_right_shift;
 8010c46:	f891 314c 	ldrb.w	r3, [r1, #332]	@ 0x14c
				midi_chn += 2;
 8010c4a:	b2e4      	uxtb	r4, r4
				sent_note += kc->three_split_right_shift;
 8010c4c:	e7f1      	b.n	8010c32 <KEYBOARD_MIDI_SendNote.isra.0+0x32>
			else if (note_number >= kc->three_split_left_note_number) {
 8010c4e:	f891 3149 	ldrb.w	r3, [r1, #329]	@ 0x149
 8010c52:	42ab      	cmp	r3, r5
 8010c54:	d82b      	bhi.n	8010cae <KEYBOARD_MIDI_SendNote.isra.0+0xae>
				midi_chn += 1;
 8010c56:	3401      	adds	r4, #1
 8010c58:	b2e4      	uxtb	r4, r4
			if (kc->midi_ports & mask) {
 8010c5a:	f44f 73a8 	mov.w	r3, #336	@ 0x150
		for (i = 0; i < 16; ++i, mask <<= 1) {
 8010c5e:	f04f 0a00 	mov.w	sl, #0
		u16 mask = 1;
 8010c62:	2601      	movs	r6, #1
			if (kc->midi_ports & mask) {
 8010c64:	fb03 2900 	mla	r9, r3, r0, r2
					MIOS32_MIDI_SendNoteOff(port, midi_chn - 1, sent_note, velocity);
 8010c68:	3c01      	subs	r4, #1
			if (kc->midi_ports & mask) {
 8010c6a:	f8b9 3000 	ldrh.w	r3, [r9]
 8010c6e:	421e      	tst	r6, r3
 8010c70:	d014      	beq.n	8010c9c <KEYBOARD_MIDI_SendNote.isra.0+0x9c>
				mios32_midi_port_t port = 0x10 + ((i & 0xc) << 2) + (i & 3);
 8010c72:	fa5f f38a 	uxtb.w	r3, sl
 8010c76:	0098      	lsls	r0, r3, #2
 8010c78:	f000 0030 	and.w	r0, r0, #48	@ 0x30
 8010c7c:	f003 0303 	and.w	r3, r3, #3
 8010c80:	4318      	orrs	r0, r3
 8010c82:	3010      	adds	r0, #16
					MIOS32_MIDI_SendNoteOff(port, midi_chn - 1, sent_note, velocity);
 8010c84:	b2e1      	uxtb	r1, r4
				if (depressed && kc->scan_release_velocity)
 8010c86:	f1b8 0f00 	cmp.w	r8, #0
 8010c8a:	d013      	beq.n	8010cb4 <KEYBOARD_MIDI_SendNote.isra.0+0xb4>
 8010c8c:	f899 300d 	ldrb.w	r3, [r9, #13]
 8010c90:	06db      	lsls	r3, r3, #27
 8010c92:	d50f      	bpl.n	8010cb4 <KEYBOARD_MIDI_SendNote.isra.0+0xb4>
					MIOS32_MIDI_SendNoteOff(port, midi_chn - 1, sent_note, velocity);
 8010c94:	463b      	mov	r3, r7
 8010c96:	462a      	mov	r2, r5
 8010c98:	f003 fe83 	bl	80149a2 <MIOS32_MIDI_SendNoteOff>
		for (i = 0; i < 16; ++i, mask <<= 1) {
 8010c9c:	f10a 0a01 	add.w	sl, sl, #1
 8010ca0:	0076      	lsls	r6, r6, #1
 8010ca2:	f1ba 0f10 	cmp.w	sl, #16
 8010ca6:	b2b6      	uxth	r6, r6
 8010ca8:	d1df      	bne.n	8010c6a <KEYBOARD_MIDI_SendNote.isra.0+0x6a>
	}
 8010caa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				sent_note += kc->three_split_left_shift;
 8010cae:	f891 314a 	ldrb.w	r3, [r1, #330]	@ 0x14a
 8010cb2:	e7be      	b.n	8010c32 <KEYBOARD_MIDI_SendNote.isra.0+0x32>
					MIOS32_MIDI_SendNoteOn(port, midi_chn - 1, sent_note, velocity);
 8010cb4:	463b      	mov	r3, r7
 8010cb6:	462a      	mov	r2, r5
 8010cb8:	f003 fe77 	bl	80149aa <MIOS32_MIDI_SendNoteOn>
 8010cbc:	e7ee      	b.n	8010c9c <KEYBOARD_MIDI_SendNote.isra.0+0x9c>
 8010cbe:	bf00      	nop
 8010cc0:	20000370 	.word	0x20000370

08010cc4 <KEYBOARD_Init>:
s32 KEYBOARD_Init(u32 mode) {
 8010cc4:	b570      	push	{r4, r5, r6, lr}
	ain_cali_mode_pin = 0;
 8010cc6:	4a37      	ldr	r2, [pc, #220]	@ (8010da4 <KEYBOARD_Init+0xe0>)
	connected_keyboards_num = 0;
 8010cc8:	4e37      	ldr	r6, [pc, #220]	@ (8010da8 <KEYBOARD_Init+0xe4>)
 8010cca:	4c38      	ldr	r4, [pc, #224]	@ (8010dac <KEYBOARD_Init+0xe8>)
 8010ccc:	2300      	movs	r3, #0
 8010cce:	7033      	strb	r3, [r6, #0]
	ain_cali_mode_pin = 0;
 8010cd0:	7013      	strb	r3, [r2, #0]
		if (init_configuration) {
 8010cd2:	4605      	mov	r5, r0
 8010cd4:	2800      	cmp	r0, #0
 8010cd6:	d138      	bne.n	8010d4a <KEYBOARD_Init+0x86>
				kc->delay_key[i] = 0;
 8010cd8:	f104 031a 	add.w	r3, r4, #26
 8010cdc:	4601      	mov	r1, r0
 8010cde:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8010ce2:	4618      	mov	r0, r3
 8010ce4:	f012 fc35 	bl	8023552 <memset>
				kc->num_rows = 12;
 8010ce8:	230c      	movs	r3, #12
 8010cea:	7123      	strb	r3, [r4, #4]
			kc->verbose_level = 1;
 8010cec:	2301      	movs	r3, #1
 8010cee:	71e3      	strb	r3, [r4, #7]
				kc->dout_sr1 = 1;
 8010cf0:	4b2f      	ldr	r3, [pc, #188]	@ (8010db0 <KEYBOARD_Init+0xec>)
 8010cf2:	60a3      	str	r3, [r4, #8]
				kc->din_key_offset = 40;	// 32 for 61 keys and 76 keys; 40 for 88 keys
 8010cf4:	68e3      	ldr	r3, [r4, #12]
			kc->midi_ports = 0x1011; // OSC1, OUT1 and USB1
 8010cf6:	4a2f      	ldr	r2, [pc, #188]	@ (8010db4 <KEYBOARD_Init+0xf0>)
 8010cf8:	f840 2c1a 	str.w	r2, [r0, #-26]
				kc->din_key_offset = 40;	// 32 for 61 keys and 76 keys; 40 for 88 keys
 8010cfc:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8010d00:	f443 03c8 	orr.w	r3, r3, #6553600	@ 0x640000
 8010d04:	f443 6385 	orr.w	r3, r3, #1064	@ 0x428
			kc->delay_fastest_release_black_keys = 160; // if 0, we take delay_fastest_release, otherwise we take this value for releasing black keys
 8010d08:	4a2b      	ldr	r2, [pc, #172]	@ (8010db8 <KEYBOARD_Init+0xf4>)
				kc->din_key_offset = 40;	// 32 for 61 keys and 76 keys; 40 for 88 keys
 8010d0a:	60e3      	str	r3, [r4, #12]
			kc->delay_fastest_release_black_keys = 160; // if 0, we take delay_fastest_release, otherwise we take this value for releasing black keys
 8010d0c:	4b2b      	ldr	r3, [pc, #172]	@ (8010dbc <KEYBOARD_Init+0xf8>)
				kc->ain_pin[i] = 0;
 8010d0e:	f8c4 512c 	str.w	r5, [r4, #300]	@ 0x12c
			kc->delay_fastest_release_black_keys = 160; // if 0, we take delay_fastest_release, otherwise we take this value for releasing black keys
 8010d12:	e9c4 2304 	strd	r2, r3, [r4, #16]
			kc->delay_slowest_release = 1500;
 8010d16:	f240 53dc 	movw	r3, #1500	@ 0x5dc
 8010d1a:	8323      	strh	r3, [r4, #24]
				kc->ain_min[i] = 1;
 8010d1c:	f04f 31fe 	mov.w	r1, #4278124286	@ 0xfefefefe
 8010d20:	f04f 3301 	mov.w	r3, #16843009	@ 0x1010101
 8010d24:	e9c4 314d 	strd	r3, r1, [r4, #308]	@ 0x134
				kc->ain_timestamp[i] = 0;
 8010d28:	2210      	movs	r2, #16
				kc->ain_last_value7[i] = 0xff; // will force to send the value
 8010d2a:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
				kc->ain_timestamp[i] = 0;
 8010d2e:	4629      	mov	r1, r5
 8010d30:	f504 708e 	add.w	r0, r4, #284	@ 0x11c
				kc->ain_last_value7[i] = 0xff; // will force to send the value
 8010d34:	f8c4 313c 	str.w	r3, [r4, #316]	@ 0x13c
				kc->ain_inverted[i] = 0;
 8010d38:	f8c4 5140 	str.w	r5, [r4, #320]	@ 0x140
				kc->ain_timestamp[i] = 0;
 8010d3c:	f012 fc09 	bl	8023552 <memset>
			for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 8010d40:	4b1f      	ldr	r3, [pc, #124]	@ (8010dc0 <KEYBOARD_Init+0xfc>)
 8010d42:	f8c4 3130 	str.w	r3, [r4, #304]	@ 0x130
			kc->ain_sustain_switch = 0;
 8010d46:	f8a4 5144 	strh.w	r5, [r4, #324]	@ 0x144
		kc->selected_row = 0;
 8010d4a:	2300      	movs	r3, #0
 8010d4c:	7163      	strb	r3, [r4, #5]
		kc->prev_row = 0xff;
 8010d4e:	23ff      	movs	r3, #255	@ 0xff
 8010d50:	71a3      	strb	r3, [r4, #6]
		if (kc->num_rows)
 8010d52:	7923      	ldrb	r3, [r4, #4]
 8010d54:	b10b      	cbz	r3, 8010d5a <KEYBOARD_Init+0x96>
			connected_keyboards_num = kb + 1;
 8010d56:	2301      	movs	r3, #1
 8010d58:	7033      	strb	r3, [r6, #0]
		u16 inversion = kc->din_inverted ? 0xffff : 0x0000;
 8010d5a:	7b63      	ldrb	r3, [r4, #13]
 8010d5c:	4919      	ldr	r1, [pc, #100]	@ (8010dc4 <KEYBOARD_Init+0x100>)
 8010d5e:	f003 0301 	and.w	r3, r3, #1
		for (row = 0; row < MATRIX_NUM_ROWS; ++row) {
 8010d62:	2200      	movs	r2, #0
			din_value[kb][row] = 0xffff ^ inversion; // default state: buttons depressed
 8010d64:	3b01      	subs	r3, #1
		for (row = 0; row < MATRIX_NUM_ROWS; ++row) {
 8010d66:	3201      	adds	r2, #1
 8010d68:	2a10      	cmp	r2, #16
			din_value[kb][row] = 0xffff ^ inversion; // default state: buttons depressed
 8010d6a:	f821 3b02 	strh.w	r3, [r1], #2
		for (row = 0; row < MATRIX_NUM_ROWS; ++row) {
 8010d6e:	d1fa      	bne.n	8010d66 <KEYBOARD_Init+0xa2>
			din_value_changed[kb][row] = 0x0000;
 8010d70:	2220      	movs	r2, #32
 8010d72:	2100      	movs	r1, #0
 8010d74:	4814      	ldr	r0, [pc, #80]	@ (8010dc8 <KEYBOARD_Init+0x104>)
 8010d76:	f012 fbec 	bl	8023552 <memset>
		timestamp = 0;
 8010d7a:	2500      	movs	r5, #0
 8010d7c:	4b13      	ldr	r3, [pc, #76]	@ (8010dcc <KEYBOARD_Init+0x108>)
			din_activated_timestamp[kb][i] = 0;
 8010d7e:	4814      	ldr	r0, [pc, #80]	@ (8010dd0 <KEYBOARD_Init+0x10c>)
		timestamp = 0;
 8010d80:	801d      	strh	r5, [r3, #0]
			din_activated_timestamp[kb][i] = 0;
 8010d82:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8010d86:	4629      	mov	r1, r5
 8010d88:	f012 fbe3 	bl	8023552 <memset>
		kc->split_mode = KEYBOARD_SPLIT_MODE_OFF;
 8010d8c:	f44f 5370 	mov.w	r3, #15360	@ 0x3c00
 8010d90:	f8a4 3296 	strh.w	r3, [r4, #662]	@ 0x296
		kc->two_split_right_shift = -36;
 8010d94:	4b0f      	ldr	r3, [pc, #60]	@ (8010dd4 <KEYBOARD_Init+0x110>)
 8010d96:	f8c4 3298 	str.w	r3, [r4, #664]	@ 0x298
		kc->three_split_right_shift = -12;
 8010d9a:	23f4      	movs	r3, #244	@ 0xf4
 8010d9c:	f884 329c 	strb.w	r3, [r4, #668]	@ 0x29c
	}
 8010da0:	4628      	mov	r0, r5
 8010da2:	bd70      	pop	{r4, r5, r6, pc}
 8010da4:	2000012a 	.word	0x2000012a
 8010da8:	2000036e 	.word	0x2000036e
 8010dac:	20000370 	.word	0x20000370
 8010db0:	02010201 	.word	0x02010201
 8010db4:	15011011 	.word	0x15011011
 8010db8:	00fa0078 	.word	0x00fa0078
 8010dbc:	01f400a0 	.word	0x01f400a0
 8010dc0:	0b400180 	.word	0x0b400180
 8010dc4:	2000034e 	.word	0x2000034e
 8010dc8:	2000032e 	.word	0x2000032e
 8010dcc:	2000032c 	.word	0x2000032c
 8010dd0:	2000012c 	.word	0x2000012c
 8010dd4:	55182adc 	.word	0x55182adc

08010dd8 <KEYBOARD_SRIO_ServicePrepare>:
		++timestamp;
 8010dd8:	4a37      	ldr	r2, [pc, #220]	@ (8010eb8 <KEYBOARD_SRIO_ServicePrepare+0xe0>)
	if (!(++timestamp))
 8010dda:	8813      	ldrh	r3, [r2, #0]
 8010ddc:	3301      	adds	r3, #1
		++timestamp;
 8010dde:	b29b      	uxth	r3, r3
 8010de0:	2b01      	cmp	r3, #1
void KEYBOARD_SRIO_ServicePrepare(void) {
 8010de2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		++timestamp;
 8010de6:	bf38      	it	cc
 8010de8:	2301      	movcc	r3, #1
 8010dea:	4e34      	ldr	r6, [pc, #208]	@ (8010ebc <KEYBOARD_SRIO_ServicePrepare+0xe4>)
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 8010dec:	4c34      	ldr	r4, [pc, #208]	@ (8010ec0 <KEYBOARD_SRIO_ServicePrepare+0xe8>)
		++timestamp;
 8010dee:	8013      	strh	r3, [r2, #0]
 8010df0:	2700      	movs	r7, #0
		u16 selection_mask = ~(1 << (u16)kc->selected_row);
 8010df2:	2501      	movs	r5, #1
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 8010df4:	7823      	ldrb	r3, [r4, #0]
 8010df6:	42bb      	cmp	r3, r7
 8010df8:	dc01      	bgt.n	8010dfe <KEYBOARD_SRIO_ServicePrepare+0x26>
	}
 8010dfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (kc->scan_velocity && !kc->break_inverted && kc->scan_optimized) {
 8010dfe:	7b71      	ldrb	r1, [r6, #13]
			if ((kc->selected_row & 1)) { // break
 8010e00:	7973      	ldrb	r3, [r6, #5]
					((!kc->din_inverted && din_value[kb][kc->prev_row] == 0xffff) ||
 8010e02:	f001 0201 	and.w	r2, r1, #1
		if (kc->scan_velocity && !kc->break_inverted && kc->scan_optimized) {
 8010e06:	f001 010e 	and.w	r1, r1, #14
 8010e0a:	290c      	cmp	r1, #12
 8010e0c:	d14c      	bne.n	8010ea8 <KEYBOARD_SRIO_ServicePrepare+0xd0>
			if (kc->prev_row & 1) { // last scan was break contact
 8010e0e:	79b0      	ldrb	r0, [r6, #6]
 8010e10:	f010 0101 	ands.w	r1, r0, #1
 8010e14:	d00f      	beq.n	8010e36 <KEYBOARD_SRIO_ServicePrepare+0x5e>
				if (kc->prev_row != 0xff && // if 0xff, no row has been scanned yet
 8010e16:	28ff      	cmp	r0, #255	@ 0xff
 8010e18:	d01c      	beq.n	8010e54 <KEYBOARD_SRIO_ServicePrepare+0x7c>
					((!kc->din_inverted && din_value[kb][kc->prev_row] == 0xffff) ||
 8010e1a:	492a      	ldr	r1, [pc, #168]	@ (8010ec4 <KEYBOARD_SRIO_ServicePrepare+0xec>)
 8010e1c:	eb00 1007 	add.w	r0, r0, r7, lsl #4
 8010e20:	f831 1010 	ldrh.w	r1, [r1, r0, lsl #1]
				if (kc->prev_row != 0xff && // if 0xff, no row has been scanned yet
 8010e24:	b992      	cbnz	r2, 8010e4c <KEYBOARD_SRIO_ServicePrepare+0x74>
					((!kc->din_inverted && din_value[kb][kc->prev_row] == 0xffff) ||
 8010e26:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8010e2a:	eba1 0c00 	sub.w	ip, r1, r0
 8010e2e:	f1dc 0100 	rsbs	r1, ip, #0
 8010e32:	eb41 010c 	adc.w	r1, r1, ip
			if ((kc->selected_row & 1)) { // break
 8010e36:	07d8      	lsls	r0, r3, #31
 8010e38:	d534      	bpl.n	8010ea4 <KEYBOARD_SRIO_ServicePrepare+0xcc>
				if (skip_make) {
 8010e3a:	b169      	cbz	r1, 8010e58 <KEYBOARD_SRIO_ServicePrepare+0x80>
					if ((kc->selected_row += 2) >= kc->num_rows) // switch to next break
 8010e3c:	3302      	adds	r3, #2
				if ((kc->selected_row += 3) >= kc->num_rows) {
 8010e3e:	7931      	ldrb	r1, [r6, #4]
 8010e40:	b2db      	uxtb	r3, r3
 8010e42:	4299      	cmp	r1, r3
 8010e44:	7173      	strb	r3, [r6, #5]
 8010e46:	d809      	bhi.n	8010e5c <KEYBOARD_SRIO_ServicePrepare+0x84>
					kc->selected_row = 1; // restart at first break
 8010e48:	2301      	movs	r3, #1
 8010e4a:	e006      	b.n	8010e5a <KEYBOARD_SRIO_ServicePrepare+0x82>
						(kc->din_inverted && din_value[kb][kc->prev_row] == 0x0000))) {
 8010e4c:	fab1 f181 	clz	r1, r1
 8010e50:	0949      	lsrs	r1, r1, #5
 8010e52:	e7f0      	b.n	8010e36 <KEYBOARD_SRIO_ServicePrepare+0x5e>
			u8 skip_make = 0;
 8010e54:	2100      	movs	r1, #0
 8010e56:	e7ee      	b.n	8010e36 <KEYBOARD_SRIO_ServicePrepare+0x5e>
					kc->selected_row -= 1; // switch to make
 8010e58:	3b01      	subs	r3, #1
				kc->selected_row = 0;
 8010e5a:	7173      	strb	r3, [r6, #5]
		u16 selection_mask = ~(1 << (u16)kc->selected_row);
 8010e5c:	f896 8005 	ldrb.w	r8, [r6, #5]
 8010e60:	fa05 f808 	lsl.w	r8, r5, r8
 8010e64:	fa1f f888 	uxth.w	r8, r8
		if (kc->din_inverted)
 8010e68:	b91a      	cbnz	r2, 8010e72 <KEYBOARD_SRIO_ServicePrepare+0x9a>
		u16 selection_mask = ~(1 << (u16)kc->selected_row);
 8010e6a:	ea6f 0808 	mvn.w	r8, r8
 8010e6e:	fa1f f888 	uxth.w	r8, r8
		if (kc->dout_sr1)
 8010e72:	7a30      	ldrb	r0, [r6, #8]
 8010e74:	b120      	cbz	r0, 8010e80 <KEYBOARD_SRIO_ServicePrepare+0xa8>
			MIOS32_DOUT_SRSet(kc->dout_sr1 - 1, selection_mask >> 0);
 8010e76:	fa5f f188 	uxtb.w	r1, r8
 8010e7a:	3801      	subs	r0, #1
 8010e7c:	f003 fb56 	bl	801452c <MIOS32_DOUT_SRSet>
		if (kc->dout_sr2)
 8010e80:	7a70      	ldrb	r0, [r6, #9]
 8010e82:	b158      	cbz	r0, 8010e9c <KEYBOARD_SRIO_ServicePrepare+0xc4>
			MIOS32_DOUT_SRSet(kc->dout_sr2 - 1, selection_mask >> ((kc->num_rows <= 8) ? 0 : 8));
 8010e84:	7933      	ldrb	r3, [r6, #4]
 8010e86:	2b08      	cmp	r3, #8
 8010e88:	bf94      	ite	ls
 8010e8a:	2300      	movls	r3, #0
 8010e8c:	2301      	movhi	r3, #1
 8010e8e:	00db      	lsls	r3, r3, #3
 8010e90:	fa48 f103 	asr.w	r1, r8, r3
 8010e94:	b2c9      	uxtb	r1, r1
 8010e96:	3801      	subs	r0, #1
 8010e98:	f003 fb48 	bl	801452c <MIOS32_DOUT_SRSet>
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 8010e9c:	3701      	adds	r7, #1
 8010e9e:	f506 76a8 	add.w	r6, r6, #336	@ 0x150
 8010ea2:	e7a7      	b.n	8010df4 <KEYBOARD_SRIO_ServicePrepare+0x1c>
				if ((kc->selected_row += 3) >= kc->num_rows) {
 8010ea4:	3303      	adds	r3, #3
 8010ea6:	e7ca      	b.n	8010e3e <KEYBOARD_SRIO_ServicePrepare+0x66>
			if (++kc->selected_row >= kc->num_rows) {
 8010ea8:	7931      	ldrb	r1, [r6, #4]
 8010eaa:	3301      	adds	r3, #1
 8010eac:	b2db      	uxtb	r3, r3
 8010eae:	4299      	cmp	r1, r3
 8010eb0:	7173      	strb	r3, [r6, #5]
 8010eb2:	d8d3      	bhi.n	8010e5c <KEYBOARD_SRIO_ServicePrepare+0x84>
				kc->selected_row = 0;
 8010eb4:	2300      	movs	r3, #0
 8010eb6:	e7d0      	b.n	8010e5a <KEYBOARD_SRIO_ServicePrepare+0x82>
 8010eb8:	2000032c 	.word	0x2000032c
 8010ebc:	20000370 	.word	0x20000370
 8010ec0:	2000036e 	.word	0x2000036e
 8010ec4:	2000034e 	.word	0x2000034e

08010ec8 <KEYBOARD_SRIO_ServiceFinish>:
void KEYBOARD_SRIO_ServiceFinish(void) {
 8010ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	keyboard_config_t* kc = (keyboard_config_t*)&keyboard_config[0];
 8010ecc:	4c5a      	ldr	r4, [pc, #360]	@ (8011038 <KEYBOARD_SRIO_ServiceFinish+0x170>)
void KEYBOARD_SRIO_ServiceFinish(void) {
 8010ece:	b085      	sub	sp, #20
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 8010ed0:	2700      	movs	r7, #0
 8010ed2:	4b5a      	ldr	r3, [pc, #360]	@ (801103c <KEYBOARD_SRIO_ServiceFinish+0x174>)
 8010ed4:	781b      	ldrb	r3, [r3, #0]
 8010ed6:	42bb      	cmp	r3, r7
 8010ed8:	dc02      	bgt.n	8010ee0 <KEYBOARD_SRIO_ServiceFinish+0x18>
}
 8010eda:	b005      	add	sp, #20
 8010edc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int prev_row = kc->prev_row;
 8010ee0:	f894 a006 	ldrb.w	sl, [r4, #6]
		kc->prev_row = kc->selected_row;
 8010ee4:	7963      	ldrb	r3, [r4, #5]
 8010ee6:	71a3      	strb	r3, [r4, #6]
		if (0xff == prev_row) // not scanned yet
 8010ee8:	f1ba 0fff 	cmp.w	sl, #255	@ 0xff
 8010eec:	d103      	bne.n	8010ef6 <KEYBOARD_SRIO_ServiceFinish+0x2e>
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 8010eee:	3701      	adds	r7, #1
 8010ef0:	f504 74a8 	add.w	r4, r4, #336	@ 0x150
 8010ef4:	e7ed      	b.n	8010ed2 <KEYBOARD_SRIO_ServiceFinish+0xa>
		if (kc->din_sr1) {
 8010ef6:	7aa0      	ldrb	r0, [r4, #10]
 8010ef8:	2800      	cmp	r0, #0
 8010efa:	d058      	beq.n	8010fae <KEYBOARD_SRIO_ServiceFinish+0xe6>
			MIOS32_DIN_SRChangedGetAndClear(kc->din_sr1 - 1, 0xff); // ensure that change won't be propagated to normal DIN handler
 8010efc:	21ff      	movs	r1, #255	@ 0xff
 8010efe:	3801      	subs	r0, #1
 8010f00:	f003 fabc 	bl	801447c <MIOS32_DIN_SRChangedGetAndClear>
			sr_value |= MIOS32_DIN_SRGet(kc->din_sr1 - 1);
 8010f04:	7aa0      	ldrb	r0, [r4, #10]
 8010f06:	3801      	subs	r0, #1
 8010f08:	f003 faaa 	bl	8014460 <MIOS32_DIN_SRGet>
 8010f0c:	b285      	uxth	r5, r0
		if (kc->din_sr2) {
 8010f0e:	7ae0      	ldrb	r0, [r4, #11]
 8010f10:	2800      	cmp	r0, #0
 8010f12:	d04e      	beq.n	8010fb2 <KEYBOARD_SRIO_ServiceFinish+0xea>
			MIOS32_DIN_SRChangedGetAndClear(kc->din_sr2 - 1, 0xff); // ensure that change won't be propagated to normal DIN handler
 8010f14:	21ff      	movs	r1, #255	@ 0xff
 8010f16:	3801      	subs	r0, #1
 8010f18:	f003 fab0 	bl	801447c <MIOS32_DIN_SRChangedGetAndClear>
			sr_value |= (u16)MIOS32_DIN_SRGet(kc->din_sr2 - 1) << 8;
 8010f1c:	7ae0      	ldrb	r0, [r4, #11]
 8010f1e:	3801      	subs	r0, #1
 8010f20:	f003 fa9e 	bl	8014460 <MIOS32_DIN_SRGet>
 8010f24:	4b46      	ldr	r3, [pc, #280]	@ (8011040 <KEYBOARD_SRIO_ServiceFinish+0x178>)
 8010f26:	ea03 2300 	and.w	r3, r3, r0, lsl #8
 8010f2a:	432b      	orrs	r3, r5
 8010f2c:	b29b      	uxth	r3, r3
		if (kc->din_inverted)
 8010f2e:	f894 e00d 	ldrb.w	lr, [r4, #13]
		u16 changed = sr_value ^ din_value[kb][prev_row];
 8010f32:	4944      	ldr	r1, [pc, #272]	@ (8011044 <KEYBOARD_SRIO_ServiceFinish+0x17c>)
 8010f34:	eb0a 1507 	add.w	r5, sl, r7, lsl #4
		if (kc->din_inverted)
 8010f38:	f01e 0f01 	tst.w	lr, #1
			sr_value ^= 0xffff;
 8010f3c:	bf18      	it	ne
 8010f3e:	43db      	mvnne	r3, r3
		u16 changed = sr_value ^ din_value[kb][prev_row];
 8010f40:	f831 8015 	ldrh.w	r8, [r1, r5, lsl #1]
			sr_value ^= 0xffff;
 8010f44:	bf18      	it	ne
 8010f46:	b29b      	uxthne	r3, r3
		if (changed) {
 8010f48:	4598      	cmp	r8, r3
		u16 changed = sr_value ^ din_value[kb][prev_row];
 8010f4a:	ea4f 1607 	mov.w	r6, r7, lsl #4
		if (changed) {
 8010f4e:	d0ce      	beq.n	8010eee <KEYBOARD_SRIO_ServiceFinish+0x26>
			din_value_changed[kb][prev_row] |= changed;
 8010f50:	483d      	ldr	r0, [pc, #244]	@ (8011048 <KEYBOARD_SRIO_ServiceFinish+0x180>)
			din_value[kb][prev_row] = sr_value;
 8010f52:	f821 3015 	strh.w	r3, [r1, r5, lsl #1]
			din_value_changed[kb][prev_row] |= changed;
 8010f56:	f830 c015 	ldrh.w	ip, [r0, r5, lsl #1]
		u16 changed = sr_value ^ din_value[kb][prev_row];
 8010f5a:	ea88 0803 	eor.w	r8, r8, r3
			din_value_changed[kb][prev_row] |= changed;
 8010f5e:	ea48 0c0c 	orr.w	ip, r8, ip
 8010f62:	f820 c015 	strh.w	ip, [r0, r5, lsl #1]
			int pins_per_row = kc->din_sr2 ? 16 : 8;
 8010f66:	7ae5      	ldrb	r5, [r4, #11]
      		u16 *ts_ptr = (u16 *)&din_activated_timestamp[kb][prev_row * MATRIX_NUM_ROWS];
 8010f68:	ea4f 1c0a 	mov.w	ip, sl, lsl #4
			int pins_per_row = kc->din_sr2 ? 16 : 8;
 8010f6c:	2d00      	cmp	r5, #0
      		u16 *ts_ptr = (u16 *)&din_activated_timestamp[kb][prev_row * MATRIX_NUM_ROWS];
 8010f6e:	4d37      	ldr	r5, [pc, #220]	@ (801104c <KEYBOARD_SRIO_ServiceFinish+0x184>)
			int pins_per_row = kc->din_sr2 ? 16 : 8;
 8010f70:	bf0c      	ite	eq
 8010f72:	f04f 0908 	moveq.w	r9, #8
 8010f76:	f04f 0910 	movne.w	r9, #16
      		u16 *ts_ptr = (u16 *)&din_activated_timestamp[kb][prev_row * MATRIX_NUM_ROWS];
 8010f7a:	eb0c 2c07 	add.w	ip, ip, r7, lsl #8
			if ( !kc->scan_release_velocity ) {
 8010f7e:	f01e 0f10 	tst.w	lr, #16
      		u16 *ts_ptr = (u16 *)&din_activated_timestamp[kb][prev_row * MATRIX_NUM_ROWS];
 8010f82:	eb05 054c 	add.w	r5, r5, ip, lsl #1
			if ( !kc->scan_release_velocity ) {
 8010f86:	d117      	bne.n	8010fb8 <KEYBOARD_SRIO_ServiceFinish+0xf0>
	    				*ts_ptr = timestamp;
 8010f88:	4a31      	ldr	r2, [pc, #196]	@ (8011050 <KEYBOARD_SRIO_ServiceFinish+0x188>)
 8010f8a:	eb05 0949 	add.w	r9, r5, r9, lsl #1
 8010f8e:	8811      	ldrh	r1, [r2, #0]
			u16 mask = 0x0001;
 8010f90:	2201      	movs	r2, #1
	  				if( (changed & mask) && !(sr_value & mask) && !(*ts_ptr)) {
 8010f92:	ea18 0f02 	tst.w	r8, r2
 8010f96:	d004      	beq.n	8010fa2 <KEYBOARD_SRIO_ServiceFinish+0xda>
 8010f98:	4213      	tst	r3, r2
 8010f9a:	d102      	bne.n	8010fa2 <KEYBOARD_SRIO_ServiceFinish+0xda>
 8010f9c:	8828      	ldrh	r0, [r5, #0]
 8010f9e:	b900      	cbnz	r0, 8010fa2 <KEYBOARD_SRIO_ServiceFinish+0xda>
	    				*ts_ptr = timestamp;
 8010fa0:	8029      	strh	r1, [r5, #0]
    			for(sr_pin=0; sr_pin<pins_per_row; ++sr_pin, mask <<= 1, ++ts_ptr) {
 8010fa2:	3502      	adds	r5, #2
 8010fa4:	0052      	lsls	r2, r2, #1
 8010fa6:	454d      	cmp	r5, r9
 8010fa8:	b292      	uxth	r2, r2
 8010faa:	d1f2      	bne.n	8010f92 <KEYBOARD_SRIO_ServiceFinish+0xca>
 8010fac:	e79f      	b.n	8010eee <KEYBOARD_SRIO_ServiceFinish+0x26>
			sr_value |= 0x00ff;
 8010fae:	25ff      	movs	r5, #255	@ 0xff
 8010fb0:	e7ad      	b.n	8010f0e <KEYBOARD_SRIO_ServiceFinish+0x46>
			sr_value |= 0xff00;
 8010fb2:	f445 437f 	orr.w	r3, r5, #65280	@ 0xff00
 8010fb6:	e7ba      	b.n	8010f2e <KEYBOARD_SRIO_ServiceFinish+0x66>
				u8 rel_row = prev_row + ((prev_row & 1) ? (-1) : 1);
 8010fb8:	f01a 0301 	ands.w	r3, sl, #1
 8010fbc:	9302      	str	r3, [sp, #8]
 8010fbe:	bf14      	ite	ne
 8010fc0:	23ff      	movne	r3, #255	@ 0xff
 8010fc2:	2301      	moveq	r3, #1
 8010fc4:	4453      	add	r3, sl
				u16 rel_changed = din_value_changed[kb][rel_row];
 8010fc6:	fa56 f383 	uxtab	r3, r6, r3
				u16 rel_sr_value = din_value[kb][rel_row];
 8010fca:	f04f 0b00 	mov.w	fp, #0
				u16 rel_changed = din_value_changed[kb][rel_row];
 8010fce:	f830 2013 	ldrh.w	r2, [r0, r3, lsl #1]
				u16 rel_sr_value = din_value[kb][rel_row];
 8010fd2:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
				u16 rel_changed = din_value_changed[kb][rel_row];
 8010fd6:	9203      	str	r2, [sp, #12]
				u16 rel_sr_value = din_value[kb][rel_row];
 8010fd8:	9301      	str	r3, [sp, #4]
			u16 mask = 0x0001;
 8010fda:	2601      	movs	r6, #1
					if (changed & mask) {
 8010fdc:	ea18 0f06 	tst.w	r8, r6
 8010fe0:	d013      	beq.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
							if (!(rel_changed & mask) && (rel_sr_value & mask)){
 8010fe2:	9b03      	ldr	r3, [sp, #12]
						if (prev_row & 1){
 8010fe4:	9a02      	ldr	r2, [sp, #8]
							if (!(rel_changed & mask) && (rel_sr_value & mask)){
 8010fe6:	4033      	ands	r3, r6
						if (prev_row & 1){
 8010fe8:	b1b2      	cbz	r2, 8011018 <KEYBOARD_SRIO_ServiceFinish+0x150>
							if (!(rel_changed & mask) && (rel_sr_value & mask)){
 8010fea:	b973      	cbnz	r3, 801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
 8010fec:	9b01      	ldr	r3, [sp, #4]
 8010fee:	4233      	tst	r3, r6
 8010ff0:	d00b      	beq.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
								*ts_ptr = timestamp;
 8010ff2:	4b17      	ldr	r3, [pc, #92]	@ (8011050 <KEYBOARD_SRIO_ServiceFinish+0x188>)
					           	if (kc->verbose_level >= 2)
 8010ff4:	79e0      	ldrb	r0, [r4, #7]
								*ts_ptr = timestamp;
 8010ff6:	881b      	ldrh	r3, [r3, #0]
 8010ff8:	f825 301b 	strh.w	r3, [r5, fp, lsl #1]
					           	if (kc->verbose_level >= 2)
 8010ffc:	2801      	cmp	r0, #1
 8010ffe:	d904      	bls.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
			    					DEBUG_MSG("Scanned Break TS: pin %d & row %d = %d \n", sr_pin, prev_row, *ts_ptr);
 8011000:	4814      	ldr	r0, [pc, #80]	@ (8011054 <KEYBOARD_SRIO_ServiceFinish+0x18c>)
 8011002:	4652      	mov	r2, sl
 8011004:	4659      	mov	r1, fp
			    					DEBUG_MSG("Scanned Make TS: pin %d & row %d = %d \n", sr_pin, prev_row, *ts_ptr);
 8011006:	f003 fdef 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
				for (sr_pin = 0; sr_pin < pins_per_row; ++sr_pin, mask <<= 1, ++ts_ptr) {
 801100a:	f10b 0b01 	add.w	fp, fp, #1
 801100e:	0076      	lsls	r6, r6, #1
 8011010:	45d9      	cmp	r9, fp
 8011012:	b2b6      	uxth	r6, r6
 8011014:	d1e2      	bne.n	8010fdc <KEYBOARD_SRIO_ServiceFinish+0x114>
 8011016:	e76a      	b.n	8010eee <KEYBOARD_SRIO_ServiceFinish+0x26>
							if (!(rel_changed & mask) && (rel_sr_value & mask)){
 8011018:	2b00      	cmp	r3, #0
 801101a:	d1f6      	bne.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
 801101c:	9b01      	ldr	r3, [sp, #4]
 801101e:	4233      	tst	r3, r6
 8011020:	d0f3      	beq.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
								*ts_ptr = timestamp;
 8011022:	4b0b      	ldr	r3, [pc, #44]	@ (8011050 <KEYBOARD_SRIO_ServiceFinish+0x188>)
					           	if (kc->verbose_level >= 2)
 8011024:	79e0      	ldrb	r0, [r4, #7]
								*ts_ptr = timestamp;
 8011026:	881b      	ldrh	r3, [r3, #0]
 8011028:	f825 301b 	strh.w	r3, [r5, fp, lsl #1]
					           	if (kc->verbose_level >= 2)
 801102c:	2801      	cmp	r0, #1
 801102e:	d9ec      	bls.n	801100a <KEYBOARD_SRIO_ServiceFinish+0x142>
			    					DEBUG_MSG("Scanned Make TS: pin %d & row %d = %d \n", sr_pin, prev_row, *ts_ptr);
 8011030:	4809      	ldr	r0, [pc, #36]	@ (8011058 <KEYBOARD_SRIO_ServiceFinish+0x190>)
 8011032:	4652      	mov	r2, sl
 8011034:	4659      	mov	r1, fp
 8011036:	e7e6      	b.n	8011006 <KEYBOARD_SRIO_ServiceFinish+0x13e>
 8011038:	20000370 	.word	0x20000370
 801103c:	2000036e 	.word	0x2000036e
 8011040:	00ffff00 	.word	0x00ffff00
 8011044:	2000034e 	.word	0x2000034e
 8011048:	2000032e 	.word	0x2000032e
 801104c:	2000012c 	.word	0x2000012c
 8011050:	2000032c 	.word	0x2000032c
 8011054:	08023d8e 	.word	0x08023d8e
 8011058:	08023db7 	.word	0x08023db7

0801105c <KEYBOARD_Periodic_1mS>:
void KEYBOARD_Periodic_1mS(void) {
 801105c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011060:	b0a5      	sub	sp, #148	@ 0x94
 8011062:	4b83      	ldr	r3, [pc, #524]	@ (8011270 <KEYBOARD_Periodic_1mS+0x214>)
 8011064:	9317      	str	r3, [sp, #92]	@ 0x5c
	keyboard_config_t* kc = (keyboard_config_t*)&keyboard_config[0];
 8011066:	f8df b20c 	ldr.w	fp, [pc, #524]	@ 8011274 <KEYBOARD_Periodic_1mS+0x218>
 801106a:	4b83      	ldr	r3, [pc, #524]	@ (8011278 <KEYBOARD_Periodic_1mS+0x21c>)
 801106c:	9315      	str	r3, [sp, #84]	@ 0x54
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 801106e:	f04f 0a00 	mov.w	sl, #0
 8011072:	4b82      	ldr	r3, [pc, #520]	@ (801127c <KEYBOARD_Periodic_1mS+0x220>)
 8011074:	781b      	ldrb	r3, [r3, #0]
 8011076:	4553      	cmp	r3, sl
 8011078:	dc02      	bgt.n	8011080 <KEYBOARD_Periodic_1mS+0x24>
	}
 801107a:	b025      	add	sp, #148	@ 0x94
 801107c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		int pins_per_row = kc->din_sr2 ? 16 : 8;
 8011080:	f89b 300b 	ldrb.w	r3, [fp, #11]
 8011084:	2b00      	cmp	r3, #0
 8011086:	bf0c      	ite	eq
 8011088:	2308      	moveq	r3, #8
 801108a:	2310      	movne	r3, #16
 801108c:	931b      	str	r3, [sp, #108]	@ 0x6c
		for (row = 0; row < kc->num_rows; ++row) {
 801108e:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8011090:	9318      	str	r3, [sp, #96]	@ 0x60
 8011092:	2300      	movs	r3, #0
 8011094:	9311      	str	r3, [sp, #68]	@ 0x44
 8011096:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 8011098:	f89b 3004 	ldrb.w	r3, [fp, #4]
 801109c:	4293      	cmp	r3, r2
 801109e:	dc0a      	bgt.n	80110b6 <KEYBOARD_Periodic_1mS+0x5a>
	for (kb = 0; kb < connected_keyboards_num; ++kb, ++kc) {
 80110a0:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 80110a2:	3320      	adds	r3, #32
 80110a4:	9317      	str	r3, [sp, #92]	@ 0x5c
 80110a6:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 80110a8:	3320      	adds	r3, #32
 80110aa:	f10a 0a01 	add.w	sl, sl, #1
 80110ae:	f50b 7ba8 	add.w	fp, fp, #336	@ 0x150
 80110b2:	9315      	str	r3, [sp, #84]	@ 0x54
 80110b4:	e7dd      	b.n	8011072 <KEYBOARD_Periodic_1mS+0x16>
			MIOS32_IRQ_Disable();
 80110b6:	f005 fb19 	bl	80166ec <MIOS32_IRQ_Disable>
			u16 changed = din_value_changed[kb][row];
 80110ba:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 80110bc:	881b      	ldrh	r3, [r3, #0]
 80110be:	9319      	str	r3, [sp, #100]	@ 0x64
			din_value_changed[kb][row] = 0;
 80110c0:	9b18      	ldr	r3, [sp, #96]	@ 0x60
 80110c2:	f04f 0800 	mov.w	r8, #0
 80110c6:	f823 8b02 	strh.w	r8, [r3], #2
 80110ca:	9318      	str	r3, [sp, #96]	@ 0x60
			MIOS32_IRQ_Enable();
 80110cc:	f005 fb22 	bl	8016714 <MIOS32_IRQ_Enable>
			if (!changed)
 80110d0:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 80110d2:	b913      	cbnz	r3, 80110da <KEYBOARD_Periodic_1mS+0x7e>
		for (row = 0; row < kc->num_rows; ++row) {
 80110d4:	9b11      	ldr	r3, [sp, #68]	@ 0x44
 80110d6:	3301      	adds	r3, #1
 80110d8:	e7dc      	b.n	8011094 <KEYBOARD_Periodic_1mS+0x38>
 80110da:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80110dc:	f89d 3044 	ldrb.w	r3, [sp, #68]	@ 0x44
 80110e0:	0112      	lsls	r2, r2, #4
 80110e2:	921f      	str	r2, [sp, #124]	@ 0x7c
		pin_make = (row_make)*MATRIX_NUM_ROWS + column;
 80110e4:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 80110e6:	f012 0201 	ands.w	r2, r2, #1
 80110ea:	9216      	str	r2, [sp, #88]	@ 0x58
 80110ec:	eba3 0202 	sub.w	r2, r3, r2
 80110f0:	b2d2      	uxtb	r2, r2
 80110f2:	ea4f 1202 	mov.w	r2, r2, lsl #4
 80110f6:	921a      	str	r2, [sp, #104]	@ 0x68
	u8 row_break = (row & 1) ? row : row + 1;
 80110f8:	f103 0201 	add.w	r2, r3, #1
		pin_break = (row_break)*MATRIX_NUM_ROWS + column;
 80110fc:	bf18      	it	ne
 80110fe:	461a      	movne	r2, r3
 8011100:	b2d2      	uxtb	r2, r2
 8011102:	0112      	lsls	r2, r2, #4
 8011104:	921c      	str	r2, [sp, #112]	@ 0x70
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 8011106:	085b      	lsrs	r3, r3, #1
 8011108:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 801110a:	00db      	lsls	r3, r3, #3
 801110c:	00d2      	lsls	r2, r2, #3
 801110e:	931d      	str	r3, [sp, #116]	@ 0x74
			u16 mask = 0x01;
 8011110:	2301      	movs	r3, #1
 8011112:	921e      	str	r2, [sp, #120]	@ 0x78
 8011114:	9313      	str	r3, [sp, #76]	@ 0x4c
				if (changed & mask)
 8011116:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8011118:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 801111a:	4213      	tst	r3, r2
 801111c:	f000 8115 	beq.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
					KEYBOARD_NotifyToggle(kb, row, sr_pin, (din_value[kb][row] & mask) ? 1 : 0);
 8011120:	fa5f f38a 	uxtb.w	r3, sl
 8011124:	9314      	str	r3, [sp, #80]	@ 0x50
 8011126:	fa5f f388 	uxtb.w	r3, r8
 801112a:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 801112c:	9320      	str	r3, [sp, #128]	@ 0x80
 801112e:	9b15      	ldr	r3, [sp, #84]	@ 0x54
 8011130:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8011134:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 8011136:	4013      	ands	r3, r2
 8011138:	9312      	str	r3, [sp, #72]	@ 0x48
	if (kc->verbose_level >= 2) {
 801113a:	f89b 3007 	ldrb.w	r3, [fp, #7]
					KEYBOARD_NotifyToggle(kb, row, sr_pin, (din_value[kb][row] & mask) ? 1 : 0);
 801113e:	bf14      	ite	ne
 8011140:	2401      	movne	r4, #1
 8011142:	2400      	moveq	r4, #0
	if (kc->verbose_level >= 2) {
 8011144:	2b01      	cmp	r3, #1
 8011146:	d81a      	bhi.n	801117e <KEYBOARD_Periodic_1mS+0x122>
	if (kc->scan_velocity) {
 8011148:	4a4a      	ldr	r2, [pc, #296]	@ (8011274 <KEYBOARD_Periodic_1mS+0x218>)
 801114a:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 801114e:	fb03 230a 	mla	r3, r3, sl, r2
 8011152:	7b5a      	ldrb	r2, [r3, #13]
 8011154:	f012 0904 	ands.w	r9, r2, #4
 8011158:	f040 8096 	bne.w	8011288 <KEYBOARD_Periodic_1mS+0x22c>
		pin_make = (row)*MATRIX_NUM_ROWS + column;
 801115c:	9b1f      	ldr	r3, [sp, #124]	@ 0x7c
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 801115e:	f1b8 0f07 	cmp.w	r8, #7
		pin_make = (row)*MATRIX_NUM_ROWS + column;
 8011162:	eb08 0503 	add.w	r5, r8, r3
 8011166:	462e      	mov	r6, r5
		break_contact = 0;
 8011168:	4649      	mov	r1, r9
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 801116a:	f340 80f9 	ble.w	8011360 <KEYBOARD_Periodic_1mS+0x304>
 801116e:	f89b 000c 	ldrb.w	r0, [fp, #12]
 8011172:	f1b9 0f00 	cmp.w	r9, #0
 8011176:	f040 8093 	bne.w	80112a0 <KEYBOARD_Periodic_1mS+0x244>
 801117a:	9b1e      	ldr	r3, [sp, #120]	@ 0x78
 801117c:	e091      	b.n	80112a2 <KEYBOARD_Periodic_1mS+0x246>
		DEBUG_MSG("---\n");
 801117e:	4840      	ldr	r0, [pc, #256]	@ (8011280 <KEYBOARD_Periodic_1mS+0x224>)
 8011180:	f003 fd32 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
		for (i = 0; i < kc->num_rows; ++i) {
 8011184:	f8dd 9054 	ldr.w	r9, [sp, #84]	@ 0x54
 8011188:	2500      	movs	r5, #0
 801118a:	f89b 3004 	ldrb.w	r3, [fp, #4]
 801118e:	429d      	cmp	r5, r3
 8011190:	dada      	bge.n	8011148 <KEYBOARD_Periodic_1mS+0xec>
			int v = ~din_value[kb][i];
 8011192:	f839 3b02 	ldrh.w	r3, [r9], #2
 8011196:	43db      	mvns	r3, r3
				(v & 0x0001) ? '1' : '0',
 8011198:	f003 0201 	and.w	r2, r3, #1
			DEBUG_MSG("DOUT SR%d.%d:  %c%c%c%c%c%c%c%c  %c%c%c%c%c%c%c%c\n",
 801119c:	f013 0f02 	tst.w	r3, #2
				(v & 0x0001) ? '1' : '0',
 80111a0:	9221      	str	r2, [sp, #132]	@ 0x84
			DEBUG_MSG("DOUT SR%d.%d:  %c%c%c%c%c%c%c%c  %c%c%c%c%c%c%c%c\n",
 80111a2:	bf14      	ite	ne
 80111a4:	2231      	movne	r2, #49	@ 0x31
 80111a6:	2230      	moveq	r2, #48	@ 0x30
 80111a8:	f013 0f04 	tst.w	r3, #4
 80111ac:	9200      	str	r2, [sp, #0]
 80111ae:	bf14      	ite	ne
 80111b0:	2231      	movne	r2, #49	@ 0x31
 80111b2:	2230      	moveq	r2, #48	@ 0x30
 80111b4:	f013 0f08 	tst.w	r3, #8
 80111b8:	9201      	str	r2, [sp, #4]
 80111ba:	bf14      	ite	ne
 80111bc:	2231      	movne	r2, #49	@ 0x31
 80111be:	2230      	moveq	r2, #48	@ 0x30
 80111c0:	f013 0f10 	tst.w	r3, #16
 80111c4:	9202      	str	r2, [sp, #8]
 80111c6:	bf14      	ite	ne
 80111c8:	2231      	movne	r2, #49	@ 0x31
 80111ca:	2230      	moveq	r2, #48	@ 0x30
 80111cc:	f013 0f20 	tst.w	r3, #32
 80111d0:	bf14      	ite	ne
 80111d2:	2131      	movne	r1, #49	@ 0x31
 80111d4:	2130      	moveq	r1, #48	@ 0x30
 80111d6:	f013 0f40 	tst.w	r3, #64	@ 0x40
 80111da:	bf14      	ite	ne
 80111dc:	2031      	movne	r0, #49	@ 0x31
 80111de:	2030      	moveq	r0, #48	@ 0x30
 80111e0:	f013 0f80 	tst.w	r3, #128	@ 0x80
 80111e4:	bf14      	ite	ne
 80111e6:	2631      	movne	r6, #49	@ 0x31
 80111e8:	2630      	moveq	r6, #48	@ 0x30
 80111ea:	f413 7f80 	tst.w	r3, #256	@ 0x100
 80111ee:	bf14      	ite	ne
 80111f0:	2731      	movne	r7, #49	@ 0x31
 80111f2:	2730      	moveq	r7, #48	@ 0x30
 80111f4:	f413 7f00 	tst.w	r3, #512	@ 0x200
 80111f8:	9203      	str	r2, [sp, #12]
 80111fa:	bf14      	ite	ne
 80111fc:	2231      	movne	r2, #49	@ 0x31
 80111fe:	2230      	moveq	r2, #48	@ 0x30
 8011200:	f413 6f80 	tst.w	r3, #1024	@ 0x400
 8011204:	9208      	str	r2, [sp, #32]
 8011206:	bf14      	ite	ne
 8011208:	2231      	movne	r2, #49	@ 0x31
 801120a:	2230      	moveq	r2, #48	@ 0x30
 801120c:	f413 6f00 	tst.w	r3, #2048	@ 0x800
 8011210:	9209      	str	r2, [sp, #36]	@ 0x24
 8011212:	bf14      	ite	ne
 8011214:	2231      	movne	r2, #49	@ 0x31
 8011216:	2230      	moveq	r2, #48	@ 0x30
 8011218:	f413 5f80 	tst.w	r3, #4096	@ 0x1000
 801121c:	920a      	str	r2, [sp, #40]	@ 0x28
 801121e:	bf14      	ite	ne
 8011220:	2231      	movne	r2, #49	@ 0x31
 8011222:	2230      	moveq	r2, #48	@ 0x30
 8011224:	f413 5f00 	tst.w	r3, #8192	@ 0x2000
 8011228:	920b      	str	r2, [sp, #44]	@ 0x2c
 801122a:	bf14      	ite	ne
 801122c:	2231      	movne	r2, #49	@ 0x31
 801122e:	2230      	moveq	r2, #48	@ 0x30
 8011230:	f413 4f80 	tst.w	r3, #16384	@ 0x4000
 8011234:	920c      	str	r2, [sp, #48]	@ 0x30
 8011236:	bf14      	ite	ne
 8011238:	2231      	movne	r2, #49	@ 0x31
 801123a:	2230      	moveq	r2, #48	@ 0x30
 801123c:	f413 4f00 	tst.w	r3, #32768	@ 0x8000
 8011240:	bf0c      	ite	eq
 8011242:	2330      	moveq	r3, #48	@ 0x30
 8011244:	2331      	movne	r3, #49	@ 0x31
 8011246:	930e      	str	r3, [sp, #56]	@ 0x38
 8011248:	9b21      	ldr	r3, [sp, #132]	@ 0x84
 801124a:	920d      	str	r2, [sp, #52]	@ 0x34
				(i / 8) + 1,
 801124c:	ea4f 0ce5 	mov.w	ip, r5, asr #3
 8011250:	ea6f 0e05 	mvn.w	lr, r5
			DEBUG_MSG("DOUT SR%d.%d:  %c%c%c%c%c%c%c%c  %c%c%c%c%c%c%c%c\n",
 8011254:	e9cd 1004 	strd	r1, r0, [sp, #16]
 8011258:	e9cd 6706 	strd	r6, r7, [sp, #24]
 801125c:	4809      	ldr	r0, [pc, #36]	@ (8011284 <KEYBOARD_Periodic_1mS+0x228>)
 801125e:	3330      	adds	r3, #48	@ 0x30
 8011260:	f00e 0207 	and.w	r2, lr, #7
 8011264:	f10c 0101 	add.w	r1, ip, #1
 8011268:	f003 fcbe 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
		for (i = 0; i < kc->num_rows; ++i) {
 801126c:	3501      	adds	r5, #1
 801126e:	e78c      	b.n	801118a <KEYBOARD_Periodic_1mS+0x12e>
 8011270:	2000032e 	.word	0x2000032e
 8011274:	20000370 	.word	0x20000370
 8011278:	2000034e 	.word	0x2000034e
 801127c:	2000036e 	.word	0x2000036e
 8011280:	08023e2f 	.word	0x08023e2f
 8011284:	08023e34 	.word	0x08023e34
		pin_make = (row_make)*MATRIX_NUM_ROWS + column;
 8011288:	9b1a      	ldr	r3, [sp, #104]	@ 0x68
	u8 break_contact = (row & 1); // odd numbers
 801128a:	9916      	ldr	r1, [sp, #88]	@ 0x58
		pin_make = (row_make)*MATRIX_NUM_ROWS + column;
 801128c:	eb03 0608 	add.w	r6, r3, r8
		pin_break = (row_break)*MATRIX_NUM_ROWS + column;
 8011290:	9b1c      	ldr	r3, [sp, #112]	@ 0x70
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 8011292:	f1b8 0f07 	cmp.w	r8, #7
		pin_break = (row_break)*MATRIX_NUM_ROWS + column;
 8011296:	eb03 0508 	add.w	r5, r3, r8
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 801129a:	f73f af68 	bgt.w	801116e <KEYBOARD_Periodic_1mS+0x112>
 801129e:	2000      	movs	r0, #0
 80112a0:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 80112a2:	4403      	add	r3, r0
 80112a4:	9820      	ldr	r0, [sp, #128]	@ 0x80
 80112a6:	f000 0007 	and.w	r0, r0, #7
 80112aa:	4418      	add	r0, r3
	int note_number = key + kc->note_offset;
 80112ac:	f89b 3003 	ldrb.w	r3, [fp, #3]
 80112b0:	287f      	cmp	r0, #127	@ 0x7f
 80112b2:	bfd4      	ite	le
 80112b4:	181b      	addle	r3, r3, r0
 80112b6:	337f      	addgt	r3, #127	@ 0x7f
	if (break_contact && kc->scan_velocity && kc->break_inverted)
 80112b8:	b139      	cbz	r1, 80112ca <KEYBOARD_Periodic_1mS+0x26e>
 80112ba:	f002 0006 	and.w	r0, r2, #6
 80112be:	2806      	cmp	r0, #6
		depressed = depressed ? 0 : 1;
 80112c0:	bf02      	ittt	eq
 80112c2:	9812      	ldreq	r0, [sp, #72]	@ 0x48
 80112c4:	fab0 f480 	clzeq	r4, r0
 80112c8:	0964      	lsreq	r4, r4, #5
	if (note_number > 127)
 80112ca:	2b7f      	cmp	r3, #127	@ 0x7f
 80112cc:	461f      	mov	r7, r3
 80112ce:	bfa8      	it	ge
 80112d0:	277f      	movge	r7, #127	@ 0x7f
	if( kc->scan_velocity || kc->scan_release_velocity ) {
 80112d2:	f012 0014 	ands.w	r0, r2, #20
 80112d6:	9012      	str	r0, [sp, #72]	@ 0x48
 80112d8:	d00e      	beq.n	80112f8 <KEYBOARD_Periodic_1mS+0x29c>
    	u8 normalized_key = (key + kc->note_offset) % 12;
 80112da:	200c      	movs	r0, #12
 80112dc:	fbb3 fcf0 	udiv	ip, r3, r0
 80112e0:	fb00 331c 	mls	r3, r0, ip, r3
    	black_key = ( 1 == normalized_key || 3 == normalized_key || 6 == normalized_key || 8 == normalized_key || 10 == normalized_key);
 80112e4:	2b01      	cmp	r3, #1
 80112e6:	bf1e      	ittt	ne
 80112e8:	f44f 60a9 	movne.w	r0, #1352	@ 0x548
 80112ec:	fa20 f303 	lsrne.w	r3, r0, r3
 80112f0:	f003 0301 	andne.w	r3, r3, #1
 80112f4:	b2db      	uxtb	r3, r3
 80112f6:	9312      	str	r3, [sp, #72]	@ 0x48
  	if( kc->scan_velocity ) {
 80112f8:	f1b9 0f00 	cmp.w	r9, #0
 80112fc:	f000 80ba 	beq.w	8011474 <KEYBOARD_Periodic_1mS+0x418>
    	if ( !kc->scan_release_velocity ) {
 8011300:	f012 0910 	ands.w	r9, r2, #16
 8011304:	d12e      	bne.n	8011364 <KEYBOARD_Periodic_1mS+0x308>
      		if( break_contact ) {
 8011306:	2900      	cmp	r1, #0
 8011308:	d05b      	beq.n	80113c2 <KEYBOARD_Periodic_1mS+0x366>
				if( depressed ) {
 801130a:	b1f4      	cbz	r4, 801134a <KEYBOARD_Periodic_1mS+0x2ee>
	  				if( kc->make_debounced ) {
 801130c:	0690      	lsls	r0, r2, #26
 801130e:	d50e      	bpl.n	801132e <KEYBOARD_Periodic_1mS+0x2d2>
	    				MIOS32_IRQ_Disable();
 8011310:	f005 f9ec 	bl	80166ec <MIOS32_IRQ_Disable>
	    				*ts_break_ptr = 0;
 8011314:	4a9f      	ldr	r2, [pc, #636]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 8011316:	eb05 230a 	add.w	r3, r5, sl, lsl #8
 801131a:	f822 9013 	strh.w	r9, [r2, r3, lsl #1]
	    				MIOS32_IRQ_Enable();
 801131e:	f005 f9f9 	bl	8016714 <MIOS32_IRQ_Enable>
				    	KEYBOARD_MIDI_SendNote(kb, note_number, 0x00, 1);
 8011322:	9814      	ldr	r0, [sp, #80]	@ 0x50
 8011324:	2301      	movs	r3, #1
 8011326:	464a      	mov	r2, r9
 8011328:	b2f9      	uxtb	r1, r7
 801132a:	f7ff fc69 	bl	8010c00 <KEYBOARD_MIDI_SendNote.isra.0>
					MIOS32_IRQ_Disable();
 801132e:	f005 f9dd 	bl	80166ec <MIOS32_IRQ_Disable>
					*ts_make_ptr = 0;
 8011332:	eb06 260a 	add.w	r6, r6, sl, lsl #8
 8011336:	4b97      	ldr	r3, [pc, #604]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
					*ts_break_ptr = 0;
 8011338:	eb05 250a 	add.w	r5, r5, sl, lsl #8
					*ts_make_ptr = 0;
 801133c:	2200      	movs	r2, #0
 801133e:	f823 2016 	strh.w	r2, [r3, r6, lsl #1]
					*ts_break_ptr = 0;
 8011342:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
          			MIOS32_IRQ_Enable();
 8011346:	f005 f9e5 	bl	8016714 <MIOS32_IRQ_Enable>
			for (sr_pin = 0; sr_pin < pins_per_row; ++sr_pin, mask <<= 1)
 801134a:	9b13      	ldr	r3, [sp, #76]	@ 0x4c
 801134c:	005b      	lsls	r3, r3, #1
 801134e:	b29b      	uxth	r3, r3
 8011350:	9313      	str	r3, [sp, #76]	@ 0x4c
 8011352:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 8011354:	f108 0801 	add.w	r8, r8, #1
 8011358:	4543      	cmp	r3, r8
 801135a:	f47f aedc 	bne.w	8011116 <KEYBOARD_Periodic_1mS+0xba>
 801135e:	e6b9      	b.n	80110d4 <KEYBOARD_Periodic_1mS+0x78>
	int key = ((column >= 8) ? kc->din_key_offset : 0) + 8 * ((kc->scan_velocity) ? row / 2 : row) + (column % 8);
 8011360:	4648      	mov	r0, r9
 8011362:	e70a      	b.n	801117a <KEYBOARD_Periodic_1mS+0x11e>
			if (break_contact){
 8011364:	4a8b      	ldr	r2, [pc, #556]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 8011366:	ea4f 230a 	mov.w	r3, sl, lsl #8
 801136a:	b329      	cbz	r1, 80113b8 <KEYBOARD_Periodic_1mS+0x35c>
				if (!(*ts_make_ptr)){
 801136c:	4433      	add	r3, r6
 801136e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8011372:	2b00      	cmp	r3, #0
 8011374:	f040 8109 	bne.w	801158a <KEYBOARD_Periodic_1mS+0x52e>
	           if (kc->verbose_level >= 2)
 8011378:	f89b 3007 	ldrb.w	r3, [fp, #7]
 801137c:	2b01      	cmp	r3, #1
 801137e:	d9e4      	bls.n	801134a <KEYBOARD_Periodic_1mS+0x2ee>
                    DEBUG_MSG("Skipped: %s contact %s %s (currrent ts=%d; ts_br=%d, ts_mk=%d)\n",
 8011380:	2900      	cmp	r1, #0
 8011382:	f040 80fa 	bne.w	801157a <KEYBOARD_Periodic_1mS+0x51e>
 8011386:	4b84      	ldr	r3, [pc, #528]	@ (8011598 <KEYBOARD_Periodic_1mS+0x53c>)
 8011388:	4a84      	ldr	r2, [pc, #528]	@ (801159c <KEYBOARD_Periodic_1mS+0x540>)
 801138a:	4985      	ldr	r1, [pc, #532]	@ (80115a0 <KEYBOARD_Periodic_1mS+0x544>)
 801138c:	2c00      	cmp	r4, #0
 801138e:	bf08      	it	eq
 8011390:	461a      	moveq	r2, r3
 8011392:	4b84      	ldr	r3, [pc, #528]	@ (80115a4 <KEYBOARD_Periodic_1mS+0x548>)
                        timestamp, *ts_break_ptr, *ts_make_ptr);
 8011394:	487f      	ldr	r0, [pc, #508]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 8011396:	eb06 260a 	add.w	r6, r6, sl, lsl #8
 801139a:	eb05 250a 	add.w	r5, r5, sl, lsl #8
                    DEBUG_MSG("Skipped: %s contact %s %s (currrent ts=%d; ts_br=%d, ts_mk=%d)\n",
 801139e:	f830 4016 	ldrh.w	r4, [r0, r6, lsl #1]
 80113a2:	9402      	str	r4, [sp, #8]
 80113a4:	f830 0015 	ldrh.w	r0, [r0, r5, lsl #1]
 80113a8:	9001      	str	r0, [sp, #4]
 80113aa:	487f      	ldr	r0, [pc, #508]	@ (80115a8 <KEYBOARD_Periodic_1mS+0x54c>)
 80113ac:	8800      	ldrh	r0, [r0, #0]
 80113ae:	9000      	str	r0, [sp, #0]
 80113b0:	487e      	ldr	r0, [pc, #504]	@ (80115ac <KEYBOARD_Periodic_1mS+0x550>)
 80113b2:	f003 fc19 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
 80113b6:	e7c8      	b.n	801134a <KEYBOARD_Periodic_1mS+0x2ee>
				if (!(*ts_break_ptr)){
 80113b8:	442b      	add	r3, r5
 80113ba:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80113be:	2b00      	cmp	r3, #0
 80113c0:	d0da      	beq.n	8011378 <KEYBOARD_Periodic_1mS+0x31c>
       	if (!depressed && !kc->scan_velocity){
 80113c2:	2c00      	cmp	r4, #0
 80113c4:	d1c1      	bne.n	801134a <KEYBOARD_Periodic_1mS+0x2ee>
		else if (!depressed && *ts_make_ptr){
 80113c6:	4b73      	ldr	r3, [pc, #460]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 80113c8:	eb06 220a 	add.w	r2, r6, sl, lsl #8
 80113cc:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 80113d0:	2b00      	cmp	r3, #0
 80113d2:	d0ba      	beq.n	801134a <KEYBOARD_Periodic_1mS+0x2ee>
           	MIOS32_IRQ_Disable();
 80113d4:	f005 f98a 	bl	80166ec <MIOS32_IRQ_Disable>
            u16 delay = *ts_make_ptr - *ts_break_ptr;
 80113d8:	eb06 260a 	add.w	r6, r6, sl, lsl #8
 80113dc:	4b6d      	ldr	r3, [pc, #436]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 80113de:	eb05 250a 	add.w	r5, r5, sl, lsl #8
            *ts_break_ptr = 0;
 80113e2:	2200      	movs	r2, #0
            u16 delay = *ts_make_ptr - *ts_break_ptr;
 80113e4:	f833 4016 	ldrh.w	r4, [r3, r6, lsl #1]
 80113e8:	f833 9015 	ldrh.w	r9, [r3, r5, lsl #1]
            *ts_break_ptr = 0;
 80113ec:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
            *ts_make_ptr = 0;
 80113f0:	f823 2016 	strh.w	r2, [r3, r6, lsl #1]
            MIOS32_IRQ_Enable();
 80113f4:	f005 f98e 	bl	8016714 <MIOS32_IRQ_Enable>
		 	if (kc->scan_velocity) {
 80113f8:	4b6d      	ldr	r3, [pc, #436]	@ (80115b0 <KEYBOARD_Periodic_1mS+0x554>)
 80113fa:	f44f 72a8 	mov.w	r2, #336	@ 0x150
 80113fe:	fb02 330a 	mla	r3, r2, sl, r3
 8011402:	7b5b      	ldrb	r3, [r3, #13]
 8011404:	075b      	lsls	r3, r3, #29
 8011406:	f140 80a5 	bpl.w	8011554 <KEYBOARD_Periodic_1mS+0x4f8>
            	u16 delay_fastest = (black_key && kc->delay_fastest_black_keys) ? kc->delay_fastest_black_keys : kc->delay_fastest;
 801140a:	9b12      	ldr	r3, [sp, #72]	@ 0x48
 801140c:	b113      	cbz	r3, 8011414 <KEYBOARD_Periodic_1mS+0x3b8>
 801140e:	f8bb 3010 	ldrh.w	r3, [fp, #16]
 8011412:	b90b      	cbnz	r3, 8011418 <KEYBOARD_Periodic_1mS+0x3bc>
 8011414:	f8bb 300e 	ldrh.w	r3, [fp, #14]
            	u16 delay_slowest = kc->delay_slowest;				
 8011418:	f8bb 2016 	ldrh.w	r2, [fp, #22]
            u16 delay = *ts_make_ptr - *ts_break_ptr;
 801141c:	eba4 0509 	sub.w	r5, r4, r9
 8011420:	b2ad      	uxth	r5, r5
	if (delay > delay_fastest) {
 8011422:	429d      	cmp	r5, r3
 8011424:	f240 8094 	bls.w	8011550 <KEYBOARD_Periodic_1mS+0x4f4>
		velocity = 127 - (((delay - delay_fastest) * 127) / (delay_slowest - delay_fastest));
 8011428:	1aec      	subs	r4, r5, r3
 801142a:	ebc4 14c4 	rsb	r4, r4, r4, lsl #7
 801142e:	1ad3      	subs	r3, r2, r3
 8011430:	fb94 f4f3 	sdiv	r4, r4, r3
 8011434:	f1c4 047f 	rsb	r4, r4, #127	@ 0x7f
		if (velocity > 127)
 8011438:	2c7f      	cmp	r4, #127	@ 0x7f
 801143a:	bfa8      	it	ge
 801143c:	247f      	movge	r4, #127	@ 0x7f
 801143e:	2c01      	cmp	r4, #1
 8011440:	bfb8      	it	lt
 8011442:	2401      	movlt	r4, #1
           		if (kc->verbose_level >= 2)
 8011444:	f89b 3007 	ldrb.w	r3, [fp, #7]
 8011448:	2b01      	cmp	r3, #1
 801144a:	d910      	bls.n	801146e <KEYBOARD_Periodic_1mS+0x412>
                	DEBUG_MSG("PRESSED note=%s, delay=%d, velocity=%d (played from a %s key)\n",
 801144c:	a923      	add	r1, sp, #140	@ 0x8c
 801144e:	b2f8      	uxtb	r0, r7
 8011450:	f7ff fb30 	bl	8010ab4 <KEYBOARD_GetNoteName>
 8011454:	4a57      	ldr	r2, [pc, #348]	@ (80115b4 <KEYBOARD_Periodic_1mS+0x558>)
 8011456:	4b58      	ldr	r3, [pc, #352]	@ (80115b8 <KEYBOARD_Periodic_1mS+0x55c>)
 8011458:	4601      	mov	r1, r0
 801145a:	9812      	ldr	r0, [sp, #72]	@ 0x48
 801145c:	2800      	cmp	r0, #0
 801145e:	bf18      	it	ne
 8011460:	4613      	movne	r3, r2
 8011462:	9300      	str	r3, [sp, #0]
 8011464:	4855      	ldr	r0, [pc, #340]	@ (80115bc <KEYBOARD_Periodic_1mS+0x560>)
 8011466:	4623      	mov	r3, r4
 8011468:	462a      	mov	r2, r5
 801146a:	f003 fbbd 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
            KEYBOARD_MIDI_SendNote(kb, note_number, velocity, 0);
 801146e:	2300      	movs	r3, #0
 8011470:	b2e2      	uxtb	r2, r4
 8011472:	e06b      	b.n	801154c <KEYBOARD_Periodic_1mS+0x4f0>
   	if (break_contact) {
 8011474:	2900      	cmp	r1, #0
 8011476:	d07c      	beq.n	8011572 <KEYBOARD_Periodic_1mS+0x516>
        if (kc->scan_release_velocity) {
 8011478:	06d1      	lsls	r1, r2, #27
 801147a:	d559      	bpl.n	8011530 <KEYBOARD_Periodic_1mS+0x4d4>
			if (!depressed && *ts_make_ptr){
 801147c:	2c00      	cmp	r4, #0
 801147e:	f47f af64 	bne.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
 8011482:	4b44      	ldr	r3, [pc, #272]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 8011484:	eb06 220a 	add.w	r2, r6, sl, lsl #8
 8011488:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 801148c:	2b00      	cmp	r3, #0
 801148e:	f43f af5c 	beq.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
				MIOS32_IRQ_Disable();
 8011492:	f005 f92b 	bl	80166ec <MIOS32_IRQ_Disable>
                u16 delay = *ts_break_ptr - *ts_make_ptr;
 8011496:	eb05 250a 	add.w	r5, r5, sl, lsl #8
 801149a:	4b3e      	ldr	r3, [pc, #248]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 801149c:	eb06 260a 	add.w	r6, r6, sl, lsl #8
 80114a0:	f833 9015 	ldrh.w	r9, [r3, r5, lsl #1]
 80114a4:	f833 2016 	ldrh.w	r2, [r3, r6, lsl #1]
 80114a8:	eba9 0902 	sub.w	r9, r9, r2
                *ts_make_ptr = 0;
 80114ac:	2200      	movs	r2, #0
 80114ae:	f823 2016 	strh.w	r2, [r3, r6, lsl #1]
                *ts_break_ptr = 0;
 80114b2:	f823 2015 	strh.w	r2, [r3, r5, lsl #1]
                MIOS32_IRQ_Enable();
 80114b6:	f005 f92d 	bl	8016714 <MIOS32_IRQ_Enable>
				u16 delay_fastest = (black_key && kc->delay_fastest_release_black_keys) ? kc->delay_fastest_release_black_keys
 80114ba:	9b12      	ldr	r3, [sp, #72]	@ 0x48
                u16 delay = *ts_break_ptr - *ts_make_ptr;
 80114bc:	fa1f f989 	uxth.w	r9, r9
				u16 delay_fastest = (black_key && kc->delay_fastest_release_black_keys) ? kc->delay_fastest_release_black_keys
 80114c0:	b113      	cbz	r3, 80114c8 <KEYBOARD_Periodic_1mS+0x46c>
 80114c2:	f8bb 3014 	ldrh.w	r3, [fp, #20]
 80114c6:	b90b      	cbnz	r3, 80114cc <KEYBOARD_Periodic_1mS+0x470>
 80114c8:	f8bb 3012 	ldrh.w	r3, [fp, #18]
                u16 delay_slowest = kc->delay_slowest_release;
 80114cc:	f8bb 2018 	ldrh.w	r2, [fp, #24]
	if (delay > delay_fastest) {
 80114d0:	4599      	cmp	r9, r3
 80114d2:	d92b      	bls.n	801152c <KEYBOARD_Periodic_1mS+0x4d0>
		velocity = 127 - (((delay - delay_fastest) * 127) / (delay_slowest - delay_fastest));
 80114d4:	eba9 0403 	sub.w	r4, r9, r3
 80114d8:	ebc4 14c4 	rsb	r4, r4, r4, lsl #7
 80114dc:	1ad3      	subs	r3, r2, r3
 80114de:	fb94 f4f3 	sdiv	r4, r4, r3
 80114e2:	f1c4 047f 	rsb	r4, r4, #127	@ 0x7f
		if (velocity > 127)
 80114e6:	2c7f      	cmp	r4, #127	@ 0x7f
 80114e8:	bfa8      	it	ge
 80114ea:	247f      	movge	r4, #127	@ 0x7f
 80114ec:	2c01      	cmp	r4, #1
 80114ee:	bfb8      	it	lt
 80114f0:	2401      	movlt	r4, #1
          		if (kc->verbose_level >= 2)
 80114f2:	f89b 3007 	ldrb.w	r3, [fp, #7]
 80114f6:	2b01      	cmp	r3, #1
				    	KEYBOARD_MIDI_SendNote(kb, note_number, 0x00, 1);
 80114f8:	b2ff      	uxtb	r7, r7
          		if (kc->verbose_level >= 2)
 80114fa:	d910      	bls.n	801151e <KEYBOARD_Periodic_1mS+0x4c2>
                	DEBUG_MSG("Released note=%s, delay=%d, velocity=%d (played from a %s key)\n",
 80114fc:	a923      	add	r1, sp, #140	@ 0x8c
 80114fe:	4638      	mov	r0, r7
 8011500:	f7ff fad8 	bl	8010ab4 <KEYBOARD_GetNoteName>
 8011504:	4a2b      	ldr	r2, [pc, #172]	@ (80115b4 <KEYBOARD_Periodic_1mS+0x558>)
 8011506:	4b2c      	ldr	r3, [pc, #176]	@ (80115b8 <KEYBOARD_Periodic_1mS+0x55c>)
 8011508:	4601      	mov	r1, r0
 801150a:	9812      	ldr	r0, [sp, #72]	@ 0x48
 801150c:	2800      	cmp	r0, #0
 801150e:	bf18      	it	ne
 8011510:	4613      	movne	r3, r2
 8011512:	9300      	str	r3, [sp, #0]
 8011514:	482a      	ldr	r0, [pc, #168]	@ (80115c0 <KEYBOARD_Periodic_1mS+0x564>)
 8011516:	4623      	mov	r3, r4
 8011518:	464a      	mov	r2, r9
 801151a:	f003 fb65 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
                KEYBOARD_MIDI_SendNote(kb, note_number, velocity, 1);
 801151e:	2301      	movs	r3, #1
 8011520:	b2e2      	uxtb	r2, r4
 8011522:	4639      	mov	r1, r7
            KEYBOARD_MIDI_SendNote(kb, note_number, velocity, 0);
 8011524:	9814      	ldr	r0, [sp, #80]	@ 0x50
 8011526:	f7ff fb6b 	bl	8010c00 <KEYBOARD_MIDI_SendNote.isra.0>
 801152a:	e70e      	b.n	801134a <KEYBOARD_Periodic_1mS+0x2ee>
	int velocity = 127;
 801152c:	247f      	movs	r4, #127	@ 0x7f
 801152e:	e7e0      	b.n	80114f2 <KEYBOARD_Periodic_1mS+0x496>
			    if (!kc->make_debounced) {
 8011530:	0692      	lsls	r2, r2, #26
 8011532:	f53f af0a 	bmi.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
                   	MIOS32_IRQ_Disable();
 8011536:	f005 f8d9 	bl	80166ec <MIOS32_IRQ_Disable>
                    *ts_break_ptr = 0;
 801153a:	eb05 250a 	add.w	r5, r5, sl, lsl #8
 801153e:	4b15      	ldr	r3, [pc, #84]	@ (8011594 <KEYBOARD_Periodic_1mS+0x538>)
 8011540:	f823 9015 	strh.w	r9, [r3, r5, lsl #1]
                    MIOS32_IRQ_Enable();
 8011544:	f005 f8e6 	bl	8016714 <MIOS32_IRQ_Enable>
                    KEYBOARD_MIDI_SendNote(kb, note_number, 0, 1);
 8011548:	2301      	movs	r3, #1
 801154a:	464a      	mov	r2, r9
            KEYBOARD_MIDI_SendNote(kb, note_number, velocity, 0);
 801154c:	b2f9      	uxtb	r1, r7
 801154e:	e7e9      	b.n	8011524 <KEYBOARD_Periodic_1mS+0x4c8>
	int velocity = 127;
 8011550:	247f      	movs	r4, #127	@ 0x7f
 8011552:	e777      	b.n	8011444 <KEYBOARD_Periodic_1mS+0x3e8>
			    if (kc->verbose_level >= 2)
 8011554:	f89b 3007 	ldrb.w	r3, [fp, #7]
 8011558:	2b01      	cmp	r3, #1
 801155a:	d908      	bls.n	801156e <KEYBOARD_Periodic_1mS+0x512>
                    DEBUG_MSG("PRESSED note=%s, velocity=%d\n", KEYBOARD_GetNoteName(note_number, note_str), velocity);
 801155c:	a923      	add	r1, sp, #140	@ 0x8c
 801155e:	b2f8      	uxtb	r0, r7
 8011560:	f7ff faa8 	bl	8010ab4 <KEYBOARD_GetNoteName>
 8011564:	227f      	movs	r2, #127	@ 0x7f
 8011566:	4601      	mov	r1, r0
 8011568:	4816      	ldr	r0, [pc, #88]	@ (80115c4 <KEYBOARD_Periodic_1mS+0x568>)
 801156a:	f003 fb3d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
   	int velocity = 127;
 801156e:	247f      	movs	r4, #127	@ 0x7f
 8011570:	e77d      	b.n	801146e <KEYBOARD_Periodic_1mS+0x412>
       	if (!depressed && !kc->scan_velocity){
 8011572:	2c00      	cmp	r4, #0
 8011574:	f47f aee9 	bne.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
 8011578:	e72c      	b.n	80113d4 <KEYBOARD_Periodic_1mS+0x378>
                    DEBUG_MSG("Skipped: %s contact %s %s (currrent ts=%d; ts_br=%d, ts_mk=%d)\n",
 801157a:	4b07      	ldr	r3, [pc, #28]	@ (8011598 <KEYBOARD_Periodic_1mS+0x53c>)
 801157c:	4a07      	ldr	r2, [pc, #28]	@ (801159c <KEYBOARD_Periodic_1mS+0x540>)
 801157e:	4912      	ldr	r1, [pc, #72]	@ (80115c8 <KEYBOARD_Periodic_1mS+0x56c>)
 8011580:	2c00      	cmp	r4, #0
 8011582:	bf08      	it	eq
 8011584:	461a      	moveq	r2, r3
 8011586:	4b11      	ldr	r3, [pc, #68]	@ (80115cc <KEYBOARD_Periodic_1mS+0x570>)
 8011588:	e704      	b.n	8011394 <KEYBOARD_Periodic_1mS+0x338>
			if (!depressed && *ts_make_ptr){
 801158a:	2c00      	cmp	r4, #0
 801158c:	f47f aedd 	bne.w	801134a <KEYBOARD_Periodic_1mS+0x2ee>
 8011590:	e77f      	b.n	8011492 <KEYBOARD_Periodic_1mS+0x436>
 8011592:	bf00      	nop
 8011594:	2000012c 	.word	0x2000012c
 8011598:	08023ddf 	.word	0x08023ddf
 801159c:	08023e12 	.word	0x08023e12
 80115a0:	08023df6 	.word	0x08023df6
 80115a4:	08023dfb 	.word	0x08023dfb
 80115a8:	2000032c 	.word	0x2000032c
 80115ac:	08023e67 	.word	0x08023e67
 80115b0:	20000370 	.word	0x20000370
 80115b4:	08023e23 	.word	0x08023e23
 80115b8:	08023e29 	.word	0x08023e29
 80115bc:	08023ee7 	.word	0x08023ee7
 80115c0:	08023ea7 	.word	0x08023ea7
 80115c4:	08023f26 	.word	0x08023f26
 80115c8:	08023e04 	.word	0x08023e04
 80115cc:	08023e0a 	.word	0x08023e0a

080115d0 <KEYBOARD_AIN_NotifyChange>:
void KEYBOARD_AIN_NotifyChange(u32 pin, u32 pin_value) {
 80115d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80115d4:	b09d      	sub	sp, #116	@ 0x74
 80115d6:	e9cd 1007 	strd	r1, r0, [sp, #28]
	u32 timestamp = MIOS32_TIMESTAMP_Get();
 80115da:	f004 ff29 	bl	8016430 <MIOS32_TIMESTAMP_Get>
				u8 value8bit = pin_value >> 4;
 80115de:	9b07      	ldr	r3, [sp, #28]
 80115e0:	4c79      	ldr	r4, [pc, #484]	@ (80117c8 <KEYBOARD_AIN_NotifyChange+0x1f8>)
	u32 timestamp = MIOS32_TIMESTAMP_Get();
 80115e2:	9006      	str	r0, [sp, #24]
				u8 value8bit = pin_value >> 4;
 80115e4:	f3c3 1307 	ubfx	r3, r3, #4, #8
 80115e8:	9303      	str	r3, [sp, #12]
 80115ea:	f504 7a8e 	add.w	sl, r4, #284	@ 0x11c
		for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 80115ee:	2700      	movs	r7, #0
			if (ain_cali_mode_pin == expected_cali_mode_pin) {
 80115f0:	4a76      	ldr	r2, [pc, #472]	@ (80117cc <KEYBOARD_AIN_NotifyChange+0x1fc>)
 80115f2:	1c7b      	adds	r3, r7, #1
 80115f4:	7812      	ldrb	r2, [r2, #0]
 80115f6:	b2db      	uxtb	r3, r3
 80115f8:	429a      	cmp	r2, r3
 80115fa:	d130      	bne.n	801165e <KEYBOARD_AIN_NotifyChange+0x8e>
				if (value8bit <= kc->ain_min[i]) {
 80115fc:	f894 3134 	ldrb.w	r3, [r4, #308]	@ 0x134
 8011600:	9a03      	ldr	r2, [sp, #12]
				if (value8bit >= kc->ain_max[i]) {
 8011602:	9903      	ldr	r1, [sp, #12]
				if (value8bit <= kc->ain_min[i]) {
 8011604:	4293      	cmp	r3, r2
					kc->ain_min[i] = value8bit;
 8011606:	bf28      	it	cs
 8011608:	4613      	movcs	r3, r2
				if (value8bit >= kc->ain_max[i]) {
 801160a:	f894 2138 	ldrb.w	r2, [r4, #312]	@ 0x138
					kc->ain_min[i] = value8bit;
 801160e:	bf2a      	itet	cs
 8011610:	f884 3134 	strbcs.w	r3, [r4, #308]	@ 0x134
				u8 notification = 0;
 8011614:	2300      	movcc	r3, #0
					notification = 1;
 8011616:	2301      	movcs	r3, #1
				if (value8bit >= kc->ain_max[i]) {
 8011618:	428a      	cmp	r2, r1
 801161a:	d814      	bhi.n	8011646 <KEYBOARD_AIN_NotifyChange+0x76>
					kc->ain_max[i] = value8bit;
 801161c:	f884 1138 	strb.w	r1, [r4, #312]	@ 0x138
					const char src_name[KEYBOARD_AIN_NUM][17] = {
 8011620:	496b      	ldr	r1, [pc, #428]	@ (80117d0 <KEYBOARD_AIN_NotifyChange+0x200>)
 8011622:	2244      	movs	r2, #68	@ 0x44
 8011624:	a80b      	add	r0, sp, #44	@ 0x2c
 8011626:	f011 fffa 	bl	802361e <memcpy>
					DEBUG_MSG("AIN Calibration of KB%d %s: min=%3d, max=%3d\n", kb + 1, src_name[i], kc->ain_min[i], kc->ain_max[i]);
 801162a:	f894 3138 	ldrb.w	r3, [r4, #312]	@ 0x138
 801162e:	9300      	str	r3, [sp, #0]
 8011630:	a90b      	add	r1, sp, #44	@ 0x2c
 8011632:	eb07 1207 	add.w	r2, r7, r7, lsl #4
 8011636:	440a      	add	r2, r1
 8011638:	f894 3134 	ldrb.w	r3, [r4, #308]	@ 0x134
 801163c:	4865      	ldr	r0, [pc, #404]	@ (80117d4 <KEYBOARD_AIN_NotifyChange+0x204>)
 801163e:	2101      	movs	r1, #1
 8011640:	f003 fad2 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
 8011644:	e001      	b.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
				if (notification) {
 8011646:	2b00      	cmp	r3, #0
 8011648:	d1ea      	bne.n	8011620 <KEYBOARD_AIN_NotifyChange+0x50>
		for (i = 0; i < KEYBOARD_AIN_NUM; ++i) {
 801164a:	3701      	adds	r7, #1
 801164c:	2f04      	cmp	r7, #4
 801164e:	f104 0401 	add.w	r4, r4, #1
 8011652:	f10a 0a04 	add.w	sl, sl, #4
 8011656:	d1cb      	bne.n	80115f0 <KEYBOARD_AIN_NotifyChange+0x20>
	}
 8011658:	b01d      	add	sp, #116	@ 0x74
 801165a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (pin == ((int)kc->ain_pin[i] - 1)) {
 801165e:	f894 312c 	ldrb.w	r3, [r4, #300]	@ 0x12c
 8011662:	9a08      	ldr	r2, [sp, #32]
 8011664:	3b01      	subs	r3, #1
 8011666:	4293      	cmp	r3, r2
 8011668:	d1ef      	bne.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
					int value16bit = (pin_value << 4) - ((int)kc->ain_min[i] << 8);
 801166a:	f894 1134 	ldrb.w	r1, [r4, #308]	@ 0x134
 801166e:	9a07      	ldr	r2, [sp, #28]
 8011670:	020b      	lsls	r3, r1, #8
 8011672:	ebc3 1302 	rsb	r3, r3, r2, lsl #4
					int range8bit = (int)kc->ain_max[i] - (int)kc->ain_min[i] + 1;
 8011676:	f894 2138 	ldrb.w	r2, [r4, #312]	@ 0x138
 801167a:	1a52      	subs	r2, r2, r1
					if (value16bit < 0)
 801167c:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
					if (value7bit != kc->ain_last_value7[i] &&
 8011680:	f894 113c 	ldrb.w	r1, [r4, #316]	@ 0x13c
					int range8bit = (int)kc->ain_max[i] - (int)kc->ain_min[i] + 1;
 8011684:	3201      	adds	r2, #1
					int value7bit = (value16bit / range8bit) >> (9 - 8);
 8011686:	fb93 f3f2 	sdiv	r3, r3, r2
 801168a:	ea4f 0c63 	mov.w	ip, r3, asr #1
					if (value7bit < 0)
 801168e:	f38c 0607 	usat	r6, #7, ip
					if (value7bit != kc->ain_last_value7[i] &&
 8011692:	42b1      	cmp	r1, r6
 8011694:	d0d9      	beq.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
						(!kc->ain_bandwidth_ms || ((timestamp - kc->ain_timestamp[i]) >= kc->ain_bandwidth_ms))) {
 8011696:	4a4c      	ldr	r2, [pc, #304]	@ (80117c8 <KEYBOARD_AIN_NotifyChange+0x1f8>)
 8011698:	f892 5145 	ldrb.w	r5, [r2, #325]	@ 0x145
					if (value7bit != kc->ain_last_value7[i] &&
 801169c:	b12d      	cbz	r5, 80116aa <KEYBOARD_AIN_NotifyChange+0xda>
						(!kc->ain_bandwidth_ms || ((timestamp - kc->ain_timestamp[i]) >= kc->ain_bandwidth_ms))) {
 801169e:	f8da 0000 	ldr.w	r0, [sl]
 80116a2:	9b06      	ldr	r3, [sp, #24]
 80116a4:	1a18      	subs	r0, r3, r0
 80116a6:	42a8      	cmp	r0, r5
 80116a8:	d3cf      	bcc.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
						kc->ain_timestamp[i] = timestamp;
 80116aa:	9b06      	ldr	r3, [sp, #24]
						kc->ain_last_value7[i] = value7bit;
 80116ac:	f884 613c 	strb.w	r6, [r4, #316]	@ 0x13c
						kc->ain_timestamp[i] = timestamp;
 80116b0:	f8ca 3000 	str.w	r3, [sl]
						int sent_value = kc->ain_inverted[i] ? (127 - value7bit) : value7bit;
 80116b4:	f894 0140 	ldrb.w	r0, [r4, #320]	@ 0x140
 80116b8:	b108      	cbz	r0, 80116be <KEYBOARD_AIN_NotifyChange+0xee>
 80116ba:	f1c6 067f 	rsb	r6, r6, #127	@ 0x7f
						if (i == KEYBOARD_AIN_SUSTAIN && kc->ain_sustain_switch) {
 80116be:	2f02      	cmp	r7, #2
 80116c0:	d10b      	bne.n	80116da <KEYBOARD_AIN_NotifyChange+0x10a>
 80116c2:	f892 0144 	ldrb.w	r0, [r2, #324]	@ 0x144
 80116c6:	b140      	cbz	r0, 80116da <KEYBOARD_AIN_NotifyChange+0x10a>
							if ((value7bit >= 0x40 && last_value7 >= 0x40) ||
 80116c8:	f1bc 0f3f 	cmp.w	ip, #63	@ 0x3f
 80116cc:	dd43      	ble.n	8011756 <KEYBOARD_AIN_NotifyChange+0x186>
 80116ce:	293f      	cmp	r1, #63	@ 0x3f
 80116d0:	d8bb      	bhi.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
								sent_value = (sent_value >= 0x40) ? 0x7f : 0x00;
 80116d2:	2e3f      	cmp	r6, #63	@ 0x3f
 80116d4:	bfcc      	ite	gt
 80116d6:	267f      	movgt	r6, #127	@ 0x7f
 80116d8:	2600      	movle	r6, #0
	if (kc->midi_chn) {
 80116da:	7893      	ldrb	r3, [r2, #2]
 80116dc:	2b00      	cmp	r3, #0
 80116de:	d0b4      	beq.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
		for (i = 0; i < 16; ++i, mask <<= 1) {
 80116e0:	2300      	movs	r3, #0
							KEYBOARD_MIDI_SendCtrl(kb, kc->ain_ctrl[i], sent_value);
 80116e2:	fa5f f986 	uxtb.w	r9, r6
		for (i = 0; i < 16; ++i, mask <<= 1) {
 80116e6:	9302      	str	r3, [sp, #8]
		u16 mask = 1;
 80116e8:	2301      	movs	r3, #1
 80116ea:	9305      	str	r3, [sp, #20]
					u16 pb_value = (value >= 0x3f && value <= 0x41) ? 0x2000 : ((value << 7) | value);
 80116ec:	f1a9 033f 	sub.w	r3, r9, #63	@ 0x3f
 80116f0:	b2db      	uxtb	r3, r3
							KEYBOARD_MIDI_SendCtrl(kb, kc->ain_ctrl[i], sent_value);
 80116f2:	f894 8130 	ldrb.w	r8, [r4, #304]	@ 0x130
			if (kc->midi_ports & mask) {
 80116f6:	f8df b0d0 	ldr.w	fp, [pc, #208]	@ 80117c8 <KEYBOARD_AIN_NotifyChange+0x1f8>
					u16 pb_value = (value >= 0x3f && value <= 0x41) ? 0x2000 : ((value << 7) | value);
 80116fa:	9309      	str	r3, [sp, #36]	@ 0x24
			if (kc->midi_ports & mask) {
 80116fc:	f8bb 3000 	ldrh.w	r3, [fp]
 8011700:	9a05      	ldr	r2, [sp, #20]
 8011702:	421a      	tst	r2, r3
 8011704:	d01c      	beq.n	8011740 <KEYBOARD_AIN_NotifyChange+0x170>
				mios32_midi_port_t port = 0x10 + ((i & 0xc) << 2) + (i & 3);
 8011706:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801170a:	009d      	lsls	r5, r3, #2
 801170c:	f005 0530 	and.w	r5, r5, #48	@ 0x30
 8011710:	f003 0303 	and.w	r3, r3, #3
 8011714:	431d      	orrs	r5, r3
				if (ctrl_number < 128){
 8011716:	f018 0f80 	tst.w	r8, #128	@ 0x80
				mios32_midi_port_t port = 0x10 + ((i & 0xc) << 2) + (i & 3);
 801171a:	f105 0510 	add.w	r5, r5, #16
				if (ctrl_number < 128){
 801171e:	d131      	bne.n	8011784 <KEYBOARD_AIN_NotifyChange+0x1b4>
					u8 midi_chn = kc->midi_chn;
 8011720:	f89b 3002 	ldrb.w	r3, [fp, #2]
 8011724:	9304      	str	r3, [sp, #16]
					MIOS32_MIDI_SendCC(port, midi_chn - 1, ctrl_number, value);
 8011726:	1e59      	subs	r1, r3, #1
 8011728:	4642      	mov	r2, r8
 801172a:	464b      	mov	r3, r9
 801172c:	b2c9      	uxtb	r1, r1
 801172e:	4628      	mov	r0, r5
 8011730:	f003 f93f 	bl	80149b2 <MIOS32_MIDI_SendCC>
					switch(kc->split_mode){
 8011734:	f89b 3146 	ldrb.w	r3, [fp, #326]	@ 0x146
 8011738:	2b01      	cmp	r3, #1
 801173a:	d010      	beq.n	801175e <KEYBOARD_AIN_NotifyChange+0x18e>
 801173c:	2b02      	cmp	r3, #2
 801173e:	d015      	beq.n	801176c <KEYBOARD_AIN_NotifyChange+0x19c>
		for (i = 0; i < 16; ++i, mask <<= 1) {
 8011740:	9b02      	ldr	r3, [sp, #8]
 8011742:	3301      	adds	r3, #1
 8011744:	9302      	str	r3, [sp, #8]
 8011746:	9b05      	ldr	r3, [sp, #20]
 8011748:	005b      	lsls	r3, r3, #1
 801174a:	b29b      	uxth	r3, r3
 801174c:	9305      	str	r3, [sp, #20]
 801174e:	9b02      	ldr	r3, [sp, #8]
 8011750:	2b10      	cmp	r3, #16
 8011752:	d1d3      	bne.n	80116fc <KEYBOARD_AIN_NotifyChange+0x12c>
 8011754:	e779      	b.n	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
								(value7bit < 0x40 && last_value7 < 0x40)) {
 8011756:	293f      	cmp	r1, #63	@ 0x3f
 8011758:	f67f af77 	bls.w	801164a <KEYBOARD_AIN_NotifyChange+0x7a>
 801175c:	e7b9      	b.n	80116d2 <KEYBOARD_AIN_NotifyChange+0x102>
						MIOS32_MIDI_SendCC(port, midi_chn, ctrl_number, value);
 801175e:	9904      	ldr	r1, [sp, #16]
 8011760:	464b      	mov	r3, r9
 8011762:	4642      	mov	r2, r8
						MIOS32_MIDI_SendCC(port, midi_chn+1, ctrl_number, value);
 8011764:	4628      	mov	r0, r5
 8011766:	f003 f924 	bl	80149b2 <MIOS32_MIDI_SendCC>
						break;
 801176a:	e7e9      	b.n	8011740 <KEYBOARD_AIN_NotifyChange+0x170>
						MIOS32_MIDI_SendCC(port, midi_chn, ctrl_number, value);
 801176c:	9904      	ldr	r1, [sp, #16]
 801176e:	464b      	mov	r3, r9
 8011770:	4642      	mov	r2, r8
 8011772:	4628      	mov	r0, r5
 8011774:	f003 f91d 	bl	80149b2 <MIOS32_MIDI_SendCC>
						MIOS32_MIDI_SendCC(port, midi_chn+1, ctrl_number, value);
 8011778:	9904      	ldr	r1, [sp, #16]
 801177a:	3101      	adds	r1, #1
 801177c:	464b      	mov	r3, r9
 801177e:	4642      	mov	r2, r8
 8011780:	b2c9      	uxtb	r1, r1
 8011782:	e7ef      	b.n	8011764 <KEYBOARD_AIN_NotifyChange+0x194>
				else if (ctrl_number == 128) {
 8011784:	f1b8 0f80 	cmp.w	r8, #128	@ 0x80
 8011788:	d111      	bne.n	80117ae <KEYBOARD_AIN_NotifyChange+0x1de>
					u16 pb_value = (value >= 0x3f && value <= 0x41) ? 0x2000 : ((value << 7) | value);
 801178a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
					MIOS32_MIDI_SendPitchBend(port, kc->midi_chn - 1, pb_value);
 801178c:	f89b 1002 	ldrb.w	r1, [fp, #2]
					u16 pb_value = (value >= 0x3f && value <= 0x41) ? 0x2000 : ((value << 7) | value);
 8011790:	2b02      	cmp	r3, #2
 8011792:	bf88      	it	hi
 8011794:	ea46 12c6 	orrhi.w	r2, r6, r6, lsl #7
					MIOS32_MIDI_SendPitchBend(port, kc->midi_chn - 1, pb_value);
 8011798:	f101 31ff 	add.w	r1, r1, #4294967295	@ 0xffffffff
					u16 pb_value = (value >= 0x3f && value <= 0x41) ? 0x2000 : ((value << 7) | value);
 801179c:	bf8c      	ite	hi
 801179e:	b292      	uxthhi	r2, r2
 80117a0:	f44f 5200 	movls.w	r2, #8192	@ 0x2000
					MIOS32_MIDI_SendPitchBend(port, kc->midi_chn - 1, pb_value);
 80117a4:	b2c9      	uxtb	r1, r1
 80117a6:	4628      	mov	r0, r5
 80117a8:	f003 f90c 	bl	80149c4 <MIOS32_MIDI_SendPitchBend>
 80117ac:	e7c8      	b.n	8011740 <KEYBOARD_AIN_NotifyChange+0x170>
				else if (ctrl_number == 129) {
 80117ae:	f1b8 0f81 	cmp.w	r8, #129	@ 0x81
 80117b2:	d1c5      	bne.n	8011740 <KEYBOARD_AIN_NotifyChange+0x170>
					MIOS32_MIDI_SendAftertouch(port, kc->midi_chn - 1, value);
 80117b4:	f89b 1002 	ldrb.w	r1, [fp, #2]
 80117b8:	3901      	subs	r1, #1
 80117ba:	464a      	mov	r2, r9
 80117bc:	b2c9      	uxtb	r1, r1
 80117be:	4628      	mov	r0, r5
 80117c0:	f003 f8fb 	bl	80149ba <MIOS32_MIDI_SendAftertouch>
 80117c4:	e7bc      	b.n	8011740 <KEYBOARD_AIN_NotifyChange+0x170>
 80117c6:	bf00      	nop
 80117c8:	20000370 	.word	0x20000370
 80117cc:	2000012a 	.word	0x2000012a
 80117d0:	080269db 	.word	0x080269db
 80117d4:	08023f44 	.word	0x08023f44

080117d8 <KEYBOARD_TerminalHelp>:


/////////////////////////////////////////////////////////////////////////////
//! Returns help page for implemented terminal commands of this module
/////////////////////////////////////////////////////////////////////////////
s32 KEYBOARD_TerminalHelp(void* _output_function) {
 80117d8:	b510      	push	{r4, lr}
 80117da:	4604      	mov	r4, r0
	void (*out)(char* format, ...) = _output_function;

	out("  keyboard <1|2> (or kb <1|2>):     print current configuration of given keyboard number");
 80117dc:	4838      	ldr	r0, [pc, #224]	@ (80118c0 <KEYBOARD_TerminalHelp+0xe8>)
 80117de:	47a0      	blx	r4
	out("  set kb <1|2> debug <on|off>:      enables/disables debug mode (not stored in EEPROM)");
 80117e0:	4838      	ldr	r0, [pc, #224]	@ (80118c4 <KEYBOARD_TerminalHelp+0xec>)
 80117e2:	47a0      	blx	r4
#if !KEYBOARD_DONT_USE_MIDI_CFG
	out("  set kb <1|2> midi_ports <ports>:  selects the MIDI ports (values: see documentation)");
 80117e4:	4838      	ldr	r0, [pc, #224]	@ (80118c8 <KEYBOARD_TerminalHelp+0xf0>)
 80117e6:	47a0      	blx	r4
	out("  set kb <1|2> midi_chn <0-16>:     selects the MIDI channel (0=off)");
 80117e8:	4838      	ldr	r0, [pc, #224]	@ (80118cc <KEYBOARD_TerminalHelp+0xf4>)
 80117ea:	47a0      	blx	r4
#endif
	out("  set kb <1|2> note_offset <0-127>: selects the note offset (transpose)");
 80117ec:	4838      	ldr	r0, [pc, #224]	@ (80118d0 <KEYBOARD_TerminalHelp+0xf8>)
 80117ee:	47a0      	blx	r4
	out("  set kb <1|2> rows <0-%d>:         how many rows should be scanned? (0=off)", MATRIX_NUM_ROWS);
 80117f0:	2110      	movs	r1, #16
 80117f2:	4838      	ldr	r0, [pc, #224]	@ (80118d4 <KEYBOARD_TerminalHelp+0xfc>)
 80117f4:	47a0      	blx	r4
	out("  set kb <1|2> velocity <on|off>:   keyboard supports break and make contacts");
 80117f6:	4838      	ldr	r0, [pc, #224]	@ (80118d8 <KEYBOARD_TerminalHelp+0x100>)
 80117f8:	47a0      	blx	r4
	out("  set kb <1|2> release_velocity <on|off>: keyboard supports NoteOff velocity");
 80117fa:	4838      	ldr	r0, [pc, #224]	@ (80118dc <KEYBOARD_TerminalHelp+0x104>)
 80117fc:	47a0      	blx	r4
	out("  set kb <1|2> optimized <on|off>:        make contacts only scanned if break contacts activated");
 80117fe:	4838      	ldr	r0, [pc, #224]	@ (80118e0 <KEYBOARD_TerminalHelp+0x108>)
 8011800:	47a0      	blx	r4
	out("  set kb <1|2> dout_sr1 <0-%d>:            selects first DOUT shift register (0=off)", MIOS32_SRIO_ScanNumGet());
 8011802:	f002 fdc3 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8011806:	4601      	mov	r1, r0
 8011808:	4836      	ldr	r0, [pc, #216]	@ (80118e4 <KEYBOARD_TerminalHelp+0x10c>)
 801180a:	47a0      	blx	r4
	out("  set kb <1|2> dout_sr2 <0-%d>:            selects second DOUT shift register (0=off)", MIOS32_SRIO_ScanNumGet());
 801180c:	f002 fdbe 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8011810:	4601      	mov	r1, r0
 8011812:	4835      	ldr	r0, [pc, #212]	@ (80118e8 <KEYBOARD_TerminalHelp+0x110>)
 8011814:	47a0      	blx	r4
	out("  set kb <1|2> din_sr1 <0-%d>:             selects first DIN shift register (0=off)", MIOS32_SRIO_ScanNumGet());
 8011816:	f002 fdb9 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 801181a:	4601      	mov	r1, r0
 801181c:	4833      	ldr	r0, [pc, #204]	@ (80118ec <KEYBOARD_TerminalHelp+0x114>)
 801181e:	47a0      	blx	r4
	out("  set kb <1|2> din_sr2 <0-%d>:             selects second DIN shift register (0=off)", MIOS32_SRIO_ScanNumGet());
 8011820:	f002 fdb4 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8011824:	4601      	mov	r1, r0
 8011826:	4832      	ldr	r0, [pc, #200]	@ (80118f0 <KEYBOARD_TerminalHelp+0x118>)
 8011828:	47a0      	blx	r4
	out("  set kb <1|2> din_key_offset <0-127>:    selects the key offset between DIN1 and DIN2");
 801182a:	4832      	ldr	r0, [pc, #200]	@ (80118f4 <KEYBOARD_TerminalHelp+0x11c>)
 801182c:	47a0      	blx	r4
	out("  set kb <1|2> din_inverted <on|off>:     DINs inverted?");
 801182e:	4832      	ldr	r0, [pc, #200]	@ (80118f8 <KEYBOARD_TerminalHelp+0x120>)
 8011830:	47a0      	blx	r4
	out("  set kb <1|2> break_inverted <on|off>:   Only break contacts inverted?");
 8011832:	4832      	ldr	r0, [pc, #200]	@ (80118fc <KEYBOARD_TerminalHelp+0x124>)
 8011834:	47a0      	blx	r4
	out("  set kb <1|2> make_debounced <on|off>:   Make contacts will be debounced");
 8011836:	4832      	ldr	r0, [pc, #200]	@ (8011900 <KEYBOARD_TerminalHelp+0x128>)
 8011838:	47a0      	blx	r4
	out("  set kb <1|2> break_is_make <on|off>:    Break contact will act like Make and trigger a note");
 801183a:	4832      	ldr	r0, [pc, #200]	@ (8011904 <KEYBOARD_TerminalHelp+0x12c>)
 801183c:	47a0      	blx	r4
	out("  set kb <1|2> delay_fastest <0-65535>:   fastest delay for velocity calculation");
 801183e:	4832      	ldr	r0, [pc, #200]	@ (8011908 <KEYBOARD_TerminalHelp+0x130>)
 8011840:	47a0      	blx	r4
	out("  set kb <1|2> delay_fastest_black_keys <0-65535>: optional fastest delay for black keys");
 8011842:	4832      	ldr	r0, [pc, #200]	@ (801190c <KEYBOARD_TerminalHelp+0x134>)
 8011844:	47a0      	blx	r4
	out("  set kb <1|2> delay_fastest_release <0-65535>: opt. fastest release delay for velocity calculation");
 8011846:	4832      	ldr	r0, [pc, #200]	@ (8011910 <KEYBOARD_TerminalHelp+0x138>)
 8011848:	47a0      	blx	r4
	out("  set kb <1|2> delay_fastest_release_black_keys <0-65535>: opt.fastest release delay for black keys");
 801184a:	4832      	ldr	r0, [pc, #200]	@ (8011914 <KEYBOARD_TerminalHelp+0x13c>)
 801184c:	47a0      	blx	r4
	out("  set kb <1|2> delay_slowest <0-65535>:   slowest delay for velocity calculation");
 801184e:	4832      	ldr	r0, [pc, #200]	@ (8011918 <KEYBOARD_TerminalHelp+0x140>)
 8011850:	47a0      	blx	r4
	out("  set kb <1|2> delay_slowest_release <0-65535>: slowest release delay for velocity calculation");
 8011852:	4832      	ldr	r0, [pc, #200]	@ (801191c <KEYBOARD_TerminalHelp+0x144>)
 8011854:	47a0      	blx	r4
	out("  set kb <1|2> split_mode: 0=Off, 1=Two split mode, 2=Three split mode");
 8011856:	4832      	ldr	r0, [pc, #200]	@ (8011920 <KEYBOARD_TerminalHelp+0x148>)
 8011858:	47a0      	blx	r4
	out("  set kb <1|2> split2_middle: MIDI note number for two-split center from 1 to 126");
 801185a:	4832      	ldr	r0, [pc, #200]	@ (8011924 <KEYBOARD_TerminalHelp+0x14c>)
 801185c:	47a0      	blx	r4
	out("  set kb <1|2> split2_right_shift: note offset +/- for split two right side");
 801185e:	4832      	ldr	r0, [pc, #200]	@ (8011928 <KEYBOARD_TerminalHelp+0x150>)
 8011860:	47a0      	blx	r4
	out("  set kb <1|2> split3_left: MIDI note number for three-split left from 1 to 126");
 8011862:	4832      	ldr	r0, [pc, #200]	@ (801192c <KEYBOARD_TerminalHelp+0x154>)
 8011864:	47a0      	blx	r4
	out("  set kb <1|2> split3_left_shift: note offset +/- for split three left side");
 8011866:	4832      	ldr	r0, [pc, #200]	@ (8011930 <KEYBOARD_TerminalHelp+0x158>)
 8011868:	47a0      	blx	r4
	out("  set kb <1|2> split3_right: MIDI note number for three-split right from 1 to 126");
 801186a:	4832      	ldr	r0, [pc, #200]	@ (8011934 <KEYBOARD_TerminalHelp+0x15c>)
 801186c:	47a0      	blx	r4
	out("  set kb <1|2> split3_right_shift: note offset +/- for split three right side");
 801186e:	4832      	ldr	r0, [pc, #200]	@ (8011938 <KEYBOARD_TerminalHelp+0x160>)
 8011870:	47a0      	blx	r4
	
#if !KEYBOARD_DONT_USE_AIN
	out("  set kb <1|2> ain_pitchwheel <0..7/128..135> or off: assigns pitchwheel to given analog pin");
 8011872:	4832      	ldr	r0, [pc, #200]	@ (801193c <KEYBOARD_TerminalHelp+0x164>)
 8011874:	47a0      	blx	r4
	out("  set kb <1|2> ctrl_pitchwheel <0-129>:               assigns CC/PB(=128)/AT(=129) to PitchWheel");
 8011876:	4832      	ldr	r0, [pc, #200]	@ (8011940 <KEYBOARD_TerminalHelp+0x168>)
 8011878:	47a0      	blx	r4
	out("  set kb <1|2> ain_pitchwheel_inverted <on|off>:      inverts the pitchwheel controller");
 801187a:	4832      	ldr	r0, [pc, #200]	@ (8011944 <KEYBOARD_TerminalHelp+0x16c>)
 801187c:	47a0      	blx	r4
	out("  set kb <1|2> ain_modwheel <0..7/128..135> or off:   assigns ModWheel to given analog pin");
 801187e:	4832      	ldr	r0, [pc, #200]	@ (8011948 <KEYBOARD_TerminalHelp+0x170>)
 8011880:	47a0      	blx	r4
	out("  set kb <1|2> ctrl_modwheel <0-129>:                 assigns CC/PB(=128)/AT(=129) to ModWheel");
 8011882:	4832      	ldr	r0, [pc, #200]	@ (801194c <KEYBOARD_TerminalHelp+0x174>)
 8011884:	47a0      	blx	r4
	out("  set kb <1|2> ain_modwheel_inverted <on|off>:        inverts the modwheel controller");
 8011886:	4832      	ldr	r0, [pc, #200]	@ (8011950 <KEYBOARD_TerminalHelp+0x178>)
 8011888:	47a0      	blx	r4
	out("  set kb <1|2> ain_expression <0..7/128..135> or off: assigns Expression Pedal to given analog pin");
 801188a:	4832      	ldr	r0, [pc, #200]	@ (8011954 <KEYBOARD_TerminalHelp+0x17c>)
 801188c:	47a0      	blx	r4
	out("  set kb <1|2> ctrl_expression <0-129>:               assigns CC/PB(=128)/AT(=129) to Expression");
 801188e:	4832      	ldr	r0, [pc, #200]	@ (8011958 <KEYBOARD_TerminalHelp+0x180>)
 8011890:	47a0      	blx	r4
	out("  set kb <1|2> ain_expression_inverted <on|off>:      inverts the expression controller");
 8011892:	4832      	ldr	r0, [pc, #200]	@ (801195c <KEYBOARD_TerminalHelp+0x184>)
 8011894:	47a0      	blx	r4
	out("  set kb <1|2> ain_sustain <0..7/128..135> or off:    assigns Sustain Pedal to given analog pin");
 8011896:	4832      	ldr	r0, [pc, #200]	@ (8011960 <KEYBOARD_TerminalHelp+0x188>)
 8011898:	47a0      	blx	r4
	out("  set kb <1|2> ctrl_sustain <0-129>:                  assigns CC/PB(=128)/AT(=129) to Sustain Pedal");
 801189a:	4832      	ldr	r0, [pc, #200]	@ (8011964 <KEYBOARD_TerminalHelp+0x18c>)
 801189c:	47a0      	blx	r4
	out("  set kb <1|2> ain_sustain_inverted <on|off>:         inverts the sustain controller");
 801189e:	4832      	ldr	r0, [pc, #200]	@ (8011968 <KEYBOARD_TerminalHelp+0x190>)
 80118a0:	47a0      	blx	r4
	out("  set kb <1|2> ain_sustain_switch <on|off>:      set to on if the pedal should behave like a switch");
 80118a2:	4832      	ldr	r0, [pc, #200]	@ (801196c <KEYBOARD_TerminalHelp+0x194>)
 80118a4:	47a0      	blx	r4
	out("  set kb <1|2> ain_bandwidth_ms <delay>:         defines the bandwidth of AIN scans in milliseconds");
 80118a6:	4832      	ldr	r0, [pc, #200]	@ (8011970 <KEYBOARD_TerminalHelp+0x198>)
 80118a8:	47a0      	blx	r4
	out("  set kb <1|2> ain_calibration <off|pitchwheel|modwheel|expression|sustain>: starts AIN calibration");
 80118aa:	4832      	ldr	r0, [pc, #200]	@ (8011974 <KEYBOARD_TerminalHelp+0x19c>)
 80118ac:	47a0      	blx	r4
#endif
#if KEYBOARD_USE_SINGLE_KEY_CALIBRATION
	out("  set kb <1|2> key_calibration <on|off>               enables/disables key calibration");
 80118ae:	4832      	ldr	r0, [pc, #200]	@ (8011978 <KEYBOARD_TerminalHelp+0x1a0>)
 80118b0:	47a0      	blx	r4
	out("  set kb <1|2> key_calibration clean                  clears calibration data");
 80118b2:	4832      	ldr	r0, [pc, #200]	@ (801197c <KEYBOARD_TerminalHelp+0x1a4>)
 80118b4:	47a0      	blx	r4
	out("  set kb <1|2> key_calibration_value <key> <delay>    directly sets delay value");
 80118b6:	4832      	ldr	r0, [pc, #200]	@ (8011980 <KEYBOARD_TerminalHelp+0x1a8>)
 80118b8:	47a0      	blx	r4
#endif

	return 0; // no error
	}
 80118ba:	2000      	movs	r0, #0
 80118bc:	bd10      	pop	{r4, pc}
 80118be:	bf00      	nop
 80118c0:	08023f72 	.word	0x08023f72
 80118c4:	08023fcb 	.word	0x08023fcb
 80118c8:	08024022 	.word	0x08024022
 80118cc:	08024079 	.word	0x08024079
 80118d0:	080240be 	.word	0x080240be
 80118d4:	08024106 	.word	0x08024106
 80118d8:	08024153 	.word	0x08024153
 80118dc:	080241a1 	.word	0x080241a1
 80118e0:	080241ee 	.word	0x080241ee
 80118e4:	0802424f 	.word	0x0802424f
 80118e8:	080242a4 	.word	0x080242a4
 80118ec:	080242fa 	.word	0x080242fa
 80118f0:	0802434e 	.word	0x0802434e
 80118f4:	080243a3 	.word	0x080243a3
 80118f8:	080243fa 	.word	0x080243fa
 80118fc:	08024433 	.word	0x08024433
 8011900:	0802447b 	.word	0x0802447b
 8011904:	080244c5 	.word	0x080244c5
 8011908:	08024523 	.word	0x08024523
 801190c:	08024574 	.word	0x08024574
 8011910:	080245cd 	.word	0x080245cd
 8011914:	08024631 	.word	0x08024631
 8011918:	08024695 	.word	0x08024695
 801191c:	080246e6 	.word	0x080246e6
 8011920:	08024745 	.word	0x08024745
 8011924:	0802478c 	.word	0x0802478c
 8011928:	080247de 	.word	0x080247de
 801192c:	0802482a 	.word	0x0802482a
 8011930:	0802487a 	.word	0x0802487a
 8011934:	080248c6 	.word	0x080248c6
 8011938:	08024918 	.word	0x08024918
 801193c:	08024966 	.word	0x08024966
 8011940:	080249c3 	.word	0x080249c3
 8011944:	08024a24 	.word	0x08024a24
 8011948:	08024a7c 	.word	0x08024a7c
 801194c:	08024ad7 	.word	0x08024ad7
 8011950:	08024b36 	.word	0x08024b36
 8011954:	08024b8c 	.word	0x08024b8c
 8011958:	08024bef 	.word	0x08024bef
 801195c:	08024c50 	.word	0x08024c50
 8011960:	08024ca8 	.word	0x08024ca8
 8011964:	08024d08 	.word	0x08024d08
 8011968:	08024d6c 	.word	0x08024d6c
 801196c:	08024dc1 	.word	0x08024dc1
 8011970:	08024e25 	.word	0x08024e25
 8011974:	08024e89 	.word	0x08024e89
 8011978:	08024eed 	.word	0x08024eed
 801197c:	08024f44 	.word	0x08024f44
 8011980:	08024f92 	.word	0x08024f92

08011984 <KEYBOARD_TerminalPrintConfig>:


/////////////////////////////////////////////////////////////////////////////
//! Keyboard Configuration (can also be called from external)
/////////////////////////////////////////////////////////////////////////////
s32 KEYBOARD_TerminalPrintConfig(int kb, void* _output_function) {
 8011984:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	void (*out)(char* format, ...) = _output_function;

	keyboard_config_t* kc = (keyboard_config_t*)&keyboard_config[kb];

	out("kb %d debug %s", kb + 1, (kc->verbose_level >= 2) ? "on" : "off");
 8011988:	4faf      	ldr	r7, [pc, #700]	@ (8011c48 <KEYBOARD_TerminalPrintConfig+0x2c4>)
 801198a:	f8df a2c0 	ldr.w	sl, [pc, #704]	@ 8011c4c <KEYBOARD_TerminalPrintConfig+0x2c8>
 801198e:	f8df 92c0 	ldr.w	r9, [pc, #704]	@ 8011c50 <KEYBOARD_TerminalPrintConfig+0x2cc>
 8011992:	f44f 7ba8 	mov.w	fp, #336	@ 0x150
 8011996:	fb0b fb00 	mul.w	fp, fp, r0
 801199a:	eb07 060b 	add.w	r6, r7, fp
 801199e:	1c45      	adds	r5, r0, #1
 80119a0:	79f2      	ldrb	r2, [r6, #7]
s32 KEYBOARD_TerminalPrintConfig(int kb, void* _output_function) {
 80119a2:	460c      	mov	r4, r1
	out("kb %d debug %s", kb + 1, (kc->verbose_level >= 2) ? "on" : "off");
 80119a4:	2a01      	cmp	r2, #1
 80119a6:	bf94      	ite	ls
 80119a8:	4652      	movls	r2, sl
 80119aa:	464a      	movhi	r2, r9
 80119ac:	4629      	mov	r1, r5
s32 KEYBOARD_TerminalPrintConfig(int kb, void* _output_function) {
 80119ae:	4680      	mov	r8, r0
	out("kb %d debug %s", kb + 1, (kc->verbose_level >= 2) ? "on" : "off");
 80119b0:	48a8      	ldr	r0, [pc, #672]	@ (8011c54 <KEYBOARD_TerminalPrintConfig+0x2d0>)
 80119b2:	47a0      	blx	r4
#if !KEYBOARD_DONT_USE_MIDI_CFG
	out("kb %d midi_ports 0x%04x", kb + 1, kc->midi_ports);
 80119b4:	f837 200b 	ldrh.w	r2, [r7, fp]
 80119b8:	48a7      	ldr	r0, [pc, #668]	@ (8011c58 <KEYBOARD_TerminalPrintConfig+0x2d4>)
 80119ba:	4629      	mov	r1, r5
 80119bc:	47a0      	blx	r4
	out("kb %d midi_chn %d", kb + 1, kc->midi_chn);
 80119be:	78b2      	ldrb	r2, [r6, #2]
 80119c0:	48a6      	ldr	r0, [pc, #664]	@ (8011c5c <KEYBOARD_TerminalPrintConfig+0x2d8>)
 80119c2:	4629      	mov	r1, r5
 80119c4:	47a0      	blx	r4
#endif
	out("kb %d note_offset %d", kb + 1, kc->note_offset);
 80119c6:	78f2      	ldrb	r2, [r6, #3]
 80119c8:	48a5      	ldr	r0, [pc, #660]	@ (8011c60 <KEYBOARD_TerminalPrintConfig+0x2dc>)
 80119ca:	4629      	mov	r1, r5
 80119cc:	47a0      	blx	r4
	out("kb %d rows %d", kb + 1, kc->num_rows);
 80119ce:	7932      	ldrb	r2, [r6, #4]
 80119d0:	48a4      	ldr	r0, [pc, #656]	@ (8011c64 <KEYBOARD_TerminalPrintConfig+0x2e0>)
 80119d2:	4629      	mov	r1, r5
 80119d4:	47a0      	blx	r4
	out("kb %d velocity %s", kb + 1, kc->scan_velocity ? "on" : "off");
 80119d6:	7b73      	ldrb	r3, [r6, #13]
 80119d8:	48a3      	ldr	r0, [pc, #652]	@ (8011c68 <KEYBOARD_TerminalPrintConfig+0x2e4>)
 80119da:	f013 0f04 	tst.w	r3, #4
 80119de:	bf0c      	ite	eq
 80119e0:	4652      	moveq	r2, sl
 80119e2:	464a      	movne	r2, r9
 80119e4:	4629      	mov	r1, r5
 80119e6:	47a0      	blx	r4
	out("kb %d release_velocity %s", kb + 1, kc->scan_release_velocity ? "on" : "off");
 80119e8:	7b73      	ldrb	r3, [r6, #13]
 80119ea:	48a0      	ldr	r0, [pc, #640]	@ (8011c6c <KEYBOARD_TerminalPrintConfig+0x2e8>)
 80119ec:	f013 0f10 	tst.w	r3, #16
 80119f0:	bf0c      	ite	eq
 80119f2:	4652      	moveq	r2, sl
 80119f4:	464a      	movne	r2, r9
 80119f6:	4629      	mov	r1, r5
 80119f8:	47a0      	blx	r4
	out("kb %d optimized %s", kb + 1, kc->scan_optimized ? "on" : "off");
 80119fa:	7b73      	ldrb	r3, [r6, #13]
 80119fc:	489c      	ldr	r0, [pc, #624]	@ (8011c70 <KEYBOARD_TerminalPrintConfig+0x2ec>)
 80119fe:	f013 0f08 	tst.w	r3, #8
 8011a02:	bf0c      	ite	eq
 8011a04:	4652      	moveq	r2, sl
 8011a06:	464a      	movne	r2, r9
 8011a08:	4629      	mov	r1, r5
 8011a0a:	47a0      	blx	r4
	out("kb %d dout_sr1 %d", kb + 1, kc->dout_sr1);
 8011a0c:	7a32      	ldrb	r2, [r6, #8]
 8011a0e:	4899      	ldr	r0, [pc, #612]	@ (8011c74 <KEYBOARD_TerminalPrintConfig+0x2f0>)
 8011a10:	4629      	mov	r1, r5
 8011a12:	47a0      	blx	r4
	out("kb %d dout_sr2 %d", kb + 1, kc->dout_sr2);
 8011a14:	7a72      	ldrb	r2, [r6, #9]
 8011a16:	4898      	ldr	r0, [pc, #608]	@ (8011c78 <KEYBOARD_TerminalPrintConfig+0x2f4>)
 8011a18:	4629      	mov	r1, r5
 8011a1a:	47a0      	blx	r4
	out("kb %d din_sr1 %d", kb + 1, kc->din_sr1);
 8011a1c:	7ab2      	ldrb	r2, [r6, #10]
 8011a1e:	4897      	ldr	r0, [pc, #604]	@ (8011c7c <KEYBOARD_TerminalPrintConfig+0x2f8>)
 8011a20:	4629      	mov	r1, r5
 8011a22:	47a0      	blx	r4
	out("kb %d din_sr2 %d", kb + 1, kc->din_sr2);
 8011a24:	7af2      	ldrb	r2, [r6, #11]
 8011a26:	4896      	ldr	r0, [pc, #600]	@ (8011c80 <KEYBOARD_TerminalPrintConfig+0x2fc>)
 8011a28:	4629      	mov	r1, r5
 8011a2a:	47a0      	blx	r4
	out("kb %d din_key_offset %d", kb + 1, kc->din_key_offset);
 8011a2c:	7b32      	ldrb	r2, [r6, #12]
 8011a2e:	4895      	ldr	r0, [pc, #596]	@ (8011c84 <KEYBOARD_TerminalPrintConfig+0x300>)
 8011a30:	4629      	mov	r1, r5
 8011a32:	47a0      	blx	r4
	out("kb %d din_inverted %s", kb + 1, kc->din_inverted ? "on" : "off");
 8011a34:	7b73      	ldrb	r3, [r6, #13]
 8011a36:	4894      	ldr	r0, [pc, #592]	@ (8011c88 <KEYBOARD_TerminalPrintConfig+0x304>)
 8011a38:	f013 0f01 	tst.w	r3, #1
 8011a3c:	bf0c      	ite	eq
 8011a3e:	4652      	moveq	r2, sl
 8011a40:	464a      	movne	r2, r9
 8011a42:	4629      	mov	r1, r5
 8011a44:	47a0      	blx	r4
	out("kb %d break_inverted %s", kb + 1, kc->break_inverted ? "on" : "off");
 8011a46:	7b73      	ldrb	r3, [r6, #13]
 8011a48:	4890      	ldr	r0, [pc, #576]	@ (8011c8c <KEYBOARD_TerminalPrintConfig+0x308>)
 8011a4a:	f013 0f02 	tst.w	r3, #2
 8011a4e:	bf0c      	ite	eq
 8011a50:	4652      	moveq	r2, sl
 8011a52:	464a      	movne	r2, r9
 8011a54:	4629      	mov	r1, r5
 8011a56:	47a0      	blx	r4
	out("kb %d make_debounced %s", kb + 1, kc->make_debounced ? "on" : "off");
 8011a58:	7b73      	ldrb	r3, [r6, #13]
 8011a5a:	488d      	ldr	r0, [pc, #564]	@ (8011c90 <KEYBOARD_TerminalPrintConfig+0x30c>)
 8011a5c:	f013 0f20 	tst.w	r3, #32
 8011a60:	bf0c      	ite	eq
 8011a62:	4652      	moveq	r2, sl
 8011a64:	464a      	movne	r2, r9
 8011a66:	4629      	mov	r1, r5
 8011a68:	47a0      	blx	r4
	out("kb %d delay_fastest %d", kb + 1, kc->delay_fastest);
 8011a6a:	89f2      	ldrh	r2, [r6, #14]
 8011a6c:	4889      	ldr	r0, [pc, #548]	@ (8011c94 <KEYBOARD_TerminalPrintConfig+0x310>)
 8011a6e:	4629      	mov	r1, r5
 8011a70:	47a0      	blx	r4
	out("kb %d delay_fastest_black_keys %d", kb + 1, kc->delay_fastest_black_keys);
 8011a72:	8a32      	ldrh	r2, [r6, #16]
 8011a74:	4888      	ldr	r0, [pc, #544]	@ (8011c98 <KEYBOARD_TerminalPrintConfig+0x314>)
 8011a76:	4629      	mov	r1, r5
 8011a78:	47a0      	blx	r4
	out("kb %d delay_fastest_release %d", kb + 1, kc->delay_fastest_release);
 8011a7a:	8a72      	ldrh	r2, [r6, #18]
 8011a7c:	4887      	ldr	r0, [pc, #540]	@ (8011c9c <KEYBOARD_TerminalPrintConfig+0x318>)
 8011a7e:	4629      	mov	r1, r5
 8011a80:	47a0      	blx	r4
	out("kb %d delay_fastest_release_black_keys %d", kb + 1, kc->delay_fastest_release_black_keys);
 8011a82:	8ab2      	ldrh	r2, [r6, #20]
 8011a84:	4886      	ldr	r0, [pc, #536]	@ (8011ca0 <KEYBOARD_TerminalPrintConfig+0x31c>)
 8011a86:	4629      	mov	r1, r5
 8011a88:	47a0      	blx	r4
	out("kb %d delay_slowest %d", kb + 1, kc->delay_slowest);
 8011a8a:	8af2      	ldrh	r2, [r6, #22]
 8011a8c:	4885      	ldr	r0, [pc, #532]	@ (8011ca4 <KEYBOARD_TerminalPrintConfig+0x320>)
 8011a8e:	4629      	mov	r1, r5
 8011a90:	47a0      	blx	r4
	out("kb %d delay_slowest_release %d", kb + 1, kc->delay_slowest_release);
 8011a92:	8b32      	ldrh	r2, [r6, #24]
 8011a94:	4884      	ldr	r0, [pc, #528]	@ (8011ca8 <KEYBOARD_TerminalPrintConfig+0x324>)
 8011a96:	4629      	mov	r1, r5
 8011a98:	47a0      	blx	r4
	out("kb %d split_mode %d", kb + 1, kc->split_mode);
 8011a9a:	f896 2146 	ldrb.w	r2, [r6, #326]	@ 0x146
 8011a9e:	4883      	ldr	r0, [pc, #524]	@ (8011cac <KEYBOARD_TerminalPrintConfig+0x328>)
 8011aa0:	4629      	mov	r1, r5
 8011aa2:	47a0      	blx	r4
	out("kb %d split2_middle %d", kb + 1, kc->two_split_middle_note_number);
 8011aa4:	f896 2147 	ldrb.w	r2, [r6, #327]	@ 0x147
 8011aa8:	4881      	ldr	r0, [pc, #516]	@ (8011cb0 <KEYBOARD_TerminalPrintConfig+0x32c>)
 8011aaa:	4629      	mov	r1, r5
 8011aac:	47a0      	blx	r4
	out("kb %d split2_right_shift %d", kb + 1, kc->two_split_right_shift);
 8011aae:	f996 2148 	ldrsb.w	r2, [r6, #328]	@ 0x148
 8011ab2:	4880      	ldr	r0, [pc, #512]	@ (8011cb4 <KEYBOARD_TerminalPrintConfig+0x330>)
 8011ab4:	4629      	mov	r1, r5
 8011ab6:	47a0      	blx	r4
	out("kb %d split3_left %d", kb + 1, kc->three_split_left_note_number);
 8011ab8:	f896 2149 	ldrb.w	r2, [r6, #329]	@ 0x149
 8011abc:	487e      	ldr	r0, [pc, #504]	@ (8011cb8 <KEYBOARD_TerminalPrintConfig+0x334>)
 8011abe:	4629      	mov	r1, r5
 8011ac0:	47a0      	blx	r4
	out("kb %d split3_left_shift %d", kb + 1, kc->three_split_left_shift);
 8011ac2:	f996 214a 	ldrsb.w	r2, [r6, #330]	@ 0x14a
 8011ac6:	487d      	ldr	r0, [pc, #500]	@ (8011cbc <KEYBOARD_TerminalPrintConfig+0x338>)
 8011ac8:	4629      	mov	r1, r5
 8011aca:	47a0      	blx	r4
	out("kb %d split3_right %d", kb + 1, kc->three_split_right_note_number);
 8011acc:	f896 214b 	ldrb.w	r2, [r6, #331]	@ 0x14b
 8011ad0:	487b      	ldr	r0, [pc, #492]	@ (8011cc0 <KEYBOARD_TerminalPrintConfig+0x33c>)
 8011ad2:	4629      	mov	r1, r5
 8011ad4:	47a0      	blx	r4
	out("kb %d split3_right_shift %d", kb + 1, kc->three_split_right_shift);
 8011ad6:	f996 214c 	ldrsb.w	r2, [r6, #332]	@ 0x14c
 8011ada:	487a      	ldr	r0, [pc, #488]	@ (8011cc4 <KEYBOARD_TerminalPrintConfig+0x340>)
 8011adc:	4629      	mov	r1, r5
 8011ade:	47a0      	blx	r4

#if !KEYBOARD_DONT_USE_AIN
	if (kc->ain_pin[KEYBOARD_AIN_PITCHWHEEL])
 8011ae0:	f896 212c 	ldrb.w	r2, [r6, #300]	@ 0x12c
 8011ae4:	2a00      	cmp	r2, #0
 8011ae6:	f000 8119 	beq.w	8011d1c <KEYBOARD_TerminalPrintConfig+0x398>
		out("kb %d ain_pitchwheel %d", kb + 1, kc->ain_pin[KEYBOARD_AIN_PITCHWHEEL] - 1);
 8011aea:	4877      	ldr	r0, [pc, #476]	@ (8011cc8 <KEYBOARD_TerminalPrintConfig+0x344>)
 8011aec:	3a01      	subs	r2, #1
 8011aee:	4629      	mov	r1, r5
 8011af0:	47a0      	blx	r4
	else
		out("kb %d ain_pitchwheel off", kb + 1);
	out("kb %d ctrl_pitchwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL],
 8011af2:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8011af6:	fb03 7308 	mla	r3, r3, r8, r7
 8011afa:	f893 2130 	ldrb.w	r2, [r3, #304]	@ 0x130
 8011afe:	f993 3130 	ldrsb.w	r3, [r3, #304]	@ 0x130
 8011b02:	2b00      	cmp	r3, #0
 8011b04:	f280 810e 	bge.w	8011d24 <KEYBOARD_TerminalPrintConfig+0x3a0>
		(kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL] < 128) ? "CC" : (kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL] == 128 ? "PitchBend" : "Aftertouch"));
 8011b08:	4b70      	ldr	r3, [pc, #448]	@ (8011ccc <KEYBOARD_TerminalPrintConfig+0x348>)
 8011b0a:	4971      	ldr	r1, [pc, #452]	@ (8011cd0 <KEYBOARD_TerminalPrintConfig+0x34c>)
 8011b0c:	2a80      	cmp	r2, #128	@ 0x80
 8011b0e:	bf18      	it	ne
 8011b10:	460b      	movne	r3, r1
	out("kb %d ain_pitchwheel_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? "on" : "off");
 8011b12:	f44f 76a8 	mov.w	r6, #336	@ 0x150
 8011b16:	fb06 7608 	mla	r6, r6, r8, r7
	out("kb %d ctrl_pitchwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL],
 8011b1a:	486e      	ldr	r0, [pc, #440]	@ (8011cd4 <KEYBOARD_TerminalPrintConfig+0x350>)
 8011b1c:	4629      	mov	r1, r5
 8011b1e:	47a0      	blx	r4
	out("kb %d ain_pitchwheel_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] ? "on" : "off");
 8011b20:	f896 1140 	ldrb.w	r1, [r6, #320]	@ 0x140
 8011b24:	4b4a      	ldr	r3, [pc, #296]	@ (8011c50 <KEYBOARD_TerminalPrintConfig+0x2cc>)
 8011b26:	4a49      	ldr	r2, [pc, #292]	@ (8011c4c <KEYBOARD_TerminalPrintConfig+0x2c8>)
 8011b28:	486b      	ldr	r0, [pc, #428]	@ (8011cd8 <KEYBOARD_TerminalPrintConfig+0x354>)
 8011b2a:	2900      	cmp	r1, #0
 8011b2c:	bf18      	it	ne
 8011b2e:	461a      	movne	r2, r3
 8011b30:	4629      	mov	r1, r5
 8011b32:	47a0      	blx	r4

	if (kc->ain_pin[KEYBOARD_AIN_MODWHEEL])
 8011b34:	f896 212d 	ldrb.w	r2, [r6, #301]	@ 0x12d
 8011b38:	2a00      	cmp	r2, #0
 8011b3a:	f000 80f5 	beq.w	8011d28 <KEYBOARD_TerminalPrintConfig+0x3a4>
		out("kb %d ain_modwheel %d", kb + 1, kc->ain_pin[KEYBOARD_AIN_MODWHEEL] - 1);
 8011b3e:	4867      	ldr	r0, [pc, #412]	@ (8011cdc <KEYBOARD_TerminalPrintConfig+0x358>)
 8011b40:	3a01      	subs	r2, #1
 8011b42:	4629      	mov	r1, r5
 8011b44:	47a0      	blx	r4
	else
		out("kb %d ain_modwheel off", kb + 1);
	out("kb %d ctrl_modwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL],
 8011b46:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8011b4a:	fb03 7308 	mla	r3, r3, r8, r7
 8011b4e:	f893 2131 	ldrb.w	r2, [r3, #305]	@ 0x131
 8011b52:	f993 3131 	ldrsb.w	r3, [r3, #305]	@ 0x131
 8011b56:	2b00      	cmp	r3, #0
 8011b58:	f280 80ea 	bge.w	8011d30 <KEYBOARD_TerminalPrintConfig+0x3ac>
		(kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL] < 128) ? "CC" : (kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL] == 128 ? "PitchBend" : "Aftertouch"));
 8011b5c:	4b5b      	ldr	r3, [pc, #364]	@ (8011ccc <KEYBOARD_TerminalPrintConfig+0x348>)
 8011b5e:	495c      	ldr	r1, [pc, #368]	@ (8011cd0 <KEYBOARD_TerminalPrintConfig+0x34c>)
 8011b60:	2a80      	cmp	r2, #128	@ 0x80
 8011b62:	bf18      	it	ne
 8011b64:	460b      	movne	r3, r1
	out("kb %d ain_modwheel_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] ? "on" : "off");
 8011b66:	f44f 76a8 	mov.w	r6, #336	@ 0x150
 8011b6a:	fb06 7608 	mla	r6, r6, r8, r7
	out("kb %d ctrl_modwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL],
 8011b6e:	485c      	ldr	r0, [pc, #368]	@ (8011ce0 <KEYBOARD_TerminalPrintConfig+0x35c>)
 8011b70:	4629      	mov	r1, r5
 8011b72:	47a0      	blx	r4
	out("kb %d ain_modwheel_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] ? "on" : "off");
 8011b74:	f896 1141 	ldrb.w	r1, [r6, #321]	@ 0x141
 8011b78:	4b35      	ldr	r3, [pc, #212]	@ (8011c50 <KEYBOARD_TerminalPrintConfig+0x2cc>)
 8011b7a:	4a34      	ldr	r2, [pc, #208]	@ (8011c4c <KEYBOARD_TerminalPrintConfig+0x2c8>)
 8011b7c:	4859      	ldr	r0, [pc, #356]	@ (8011ce4 <KEYBOARD_TerminalPrintConfig+0x360>)
 8011b7e:	2900      	cmp	r1, #0
 8011b80:	bf18      	it	ne
 8011b82:	461a      	movne	r2, r3
 8011b84:	4629      	mov	r1, r5
 8011b86:	47a0      	blx	r4

	if (kc->ain_pin[KEYBOARD_AIN_EXPRESSION])
 8011b88:	f896 212f 	ldrb.w	r2, [r6, #303]	@ 0x12f
 8011b8c:	2a00      	cmp	r2, #0
 8011b8e:	f000 80d1 	beq.w	8011d34 <KEYBOARD_TerminalPrintConfig+0x3b0>
		out("kb %d ain_expression %d", kb + 1, kc->ain_pin[KEYBOARD_AIN_EXPRESSION] - 1);
 8011b92:	4855      	ldr	r0, [pc, #340]	@ (8011ce8 <KEYBOARD_TerminalPrintConfig+0x364>)
 8011b94:	3a01      	subs	r2, #1
 8011b96:	4629      	mov	r1, r5
 8011b98:	47a0      	blx	r4
	else
		out("kb %d ain_expression off", kb + 1);
	out("kb %d ctrl_expression %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION],
 8011b9a:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8011b9e:	fb03 7308 	mla	r3, r3, r8, r7
 8011ba2:	f893 2133 	ldrb.w	r2, [r3, #307]	@ 0x133
 8011ba6:	f993 3133 	ldrsb.w	r3, [r3, #307]	@ 0x133
 8011baa:	2b00      	cmp	r3, #0
 8011bac:	f280 80c6 	bge.w	8011d3c <KEYBOARD_TerminalPrintConfig+0x3b8>
		(kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION] < 128) ? "CC" : (kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION] == 128 ? "PitchBend" : "Aftertouch"));
 8011bb0:	4b46      	ldr	r3, [pc, #280]	@ (8011ccc <KEYBOARD_TerminalPrintConfig+0x348>)
 8011bb2:	4947      	ldr	r1, [pc, #284]	@ (8011cd0 <KEYBOARD_TerminalPrintConfig+0x34c>)
 8011bb4:	2a80      	cmp	r2, #128	@ 0x80
 8011bb6:	bf18      	it	ne
 8011bb8:	460b      	movne	r3, r1
	out("kb %d ain_expression_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] ? "on" : "off");
 8011bba:	f44f 76a8 	mov.w	r6, #336	@ 0x150
 8011bbe:	fb06 7608 	mla	r6, r6, r8, r7
	out("kb %d ctrl_expression %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION],
 8011bc2:	484a      	ldr	r0, [pc, #296]	@ (8011cec <KEYBOARD_TerminalPrintConfig+0x368>)
 8011bc4:	4629      	mov	r1, r5
 8011bc6:	47a0      	blx	r4
	out("kb %d ain_expression_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] ? "on" : "off");
 8011bc8:	f896 1143 	ldrb.w	r1, [r6, #323]	@ 0x143
 8011bcc:	4b20      	ldr	r3, [pc, #128]	@ (8011c50 <KEYBOARD_TerminalPrintConfig+0x2cc>)
 8011bce:	4a1f      	ldr	r2, [pc, #124]	@ (8011c4c <KEYBOARD_TerminalPrintConfig+0x2c8>)
 8011bd0:	4847      	ldr	r0, [pc, #284]	@ (8011cf0 <KEYBOARD_TerminalPrintConfig+0x36c>)
 8011bd2:	2900      	cmp	r1, #0
 8011bd4:	bf18      	it	ne
 8011bd6:	461a      	movne	r2, r3
 8011bd8:	4629      	mov	r1, r5
 8011bda:	47a0      	blx	r4

	if (kc->ain_pin[KEYBOARD_AIN_SUSTAIN])
 8011bdc:	f896 212e 	ldrb.w	r2, [r6, #302]	@ 0x12e
 8011be0:	2a00      	cmp	r2, #0
 8011be2:	f000 80ad 	beq.w	8011d40 <KEYBOARD_TerminalPrintConfig+0x3bc>
		out("kb %d ain_sustain %d", kb + 1, kc->ain_pin[KEYBOARD_AIN_SUSTAIN] - 1);
 8011be6:	4843      	ldr	r0, [pc, #268]	@ (8011cf4 <KEYBOARD_TerminalPrintConfig+0x370>)
 8011be8:	3a01      	subs	r2, #1
 8011bea:	4629      	mov	r1, r5
 8011bec:	47a0      	blx	r4
	else
		out("kb %d ain_sustain off", kb + 1);
	out("kb %d ctrl_sustain %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN],
 8011bee:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8011bf2:	fb03 7308 	mla	r3, r3, r8, r7
 8011bf6:	f893 2132 	ldrb.w	r2, [r3, #306]	@ 0x132
 8011bfa:	f993 3132 	ldrsb.w	r3, [r3, #306]	@ 0x132
 8011bfe:	2b00      	cmp	r3, #0
 8011c00:	f280 80a2 	bge.w	8011d48 <KEYBOARD_TerminalPrintConfig+0x3c4>
		(kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN] < 128) ? "CC" : (kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN] == 128 ? "PitchBend" : "Aftertouch"));
 8011c04:	4b31      	ldr	r3, [pc, #196]	@ (8011ccc <KEYBOARD_TerminalPrintConfig+0x348>)
 8011c06:	4932      	ldr	r1, [pc, #200]	@ (8011cd0 <KEYBOARD_TerminalPrintConfig+0x34c>)
 8011c08:	2a80      	cmp	r2, #128	@ 0x80
 8011c0a:	bf18      	it	ne
 8011c0c:	460b      	movne	r3, r1
	out("kb %d ctrl_sustain %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN],
 8011c0e:	4629      	mov	r1, r5
 8011c10:	4839      	ldr	r0, [pc, #228]	@ (8011cf8 <KEYBOARD_TerminalPrintConfig+0x374>)
	out("kb %d ain_sustain_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] ? "on" : "off");
 8011c12:	4e0f      	ldr	r6, [pc, #60]	@ (8011c50 <KEYBOARD_TerminalPrintConfig+0x2cc>)
	out("kb %d ctrl_sustain %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN],
 8011c14:	47a0      	blx	r4
	out("kb %d ain_sustain_inverted %s", kb + 1, kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] ? "on" : "off");
 8011c16:	f44f 73a8 	mov.w	r3, #336	@ 0x150
 8011c1a:	fb03 7708 	mla	r7, r3, r8, r7
 8011c1e:	f8df 802c 	ldr.w	r8, [pc, #44]	@ 8011c4c <KEYBOARD_TerminalPrintConfig+0x2c8>
 8011c22:	f897 2142 	ldrb.w	r2, [r7, #322]	@ 0x142
 8011c26:	4835      	ldr	r0, [pc, #212]	@ (8011cfc <KEYBOARD_TerminalPrintConfig+0x378>)
 8011c28:	2a00      	cmp	r2, #0
 8011c2a:	bf0c      	ite	eq
 8011c2c:	4642      	moveq	r2, r8
 8011c2e:	4632      	movne	r2, r6
 8011c30:	4629      	mov	r1, r5
 8011c32:	47a0      	blx	r4

	out("kb %d ain_sustain_switch %s", kb + 1, kc->ain_sustain_switch ? "on" : "off");
 8011c34:	f897 2144 	ldrb.w	r2, [r7, #324]	@ 0x144
 8011c38:	4831      	ldr	r0, [pc, #196]	@ (8011d00 <KEYBOARD_TerminalPrintConfig+0x37c>)
 8011c3a:	2a00      	cmp	r2, #0
 8011c3c:	bf0c      	ite	eq
 8011c3e:	4642      	moveq	r2, r8
 8011c40:	4632      	movne	r2, r6
 8011c42:	4629      	mov	r1, r5
 8011c44:	e05e      	b.n	8011d04 <KEYBOARD_TerminalPrintConfig+0x380>
 8011c46:	bf00      	nop
 8011c48:	20000370 	.word	0x20000370
 8011c4c:	0802531e 	.word	0x0802531e
 8011c50:	08024c4d 	.word	0x08024c4d
 8011c54:	08024fe5 	.word	0x08024fe5
 8011c58:	08024ff4 	.word	0x08024ff4
 8011c5c:	0802500c 	.word	0x0802500c
 8011c60:	0802501e 	.word	0x0802501e
 8011c64:	08025033 	.word	0x08025033
 8011c68:	08025041 	.word	0x08025041
 8011c6c:	08025053 	.word	0x08025053
 8011c70:	0802506d 	.word	0x0802506d
 8011c74:	08025080 	.word	0x08025080
 8011c78:	08025092 	.word	0x08025092
 8011c7c:	080250a4 	.word	0x080250a4
 8011c80:	080250b5 	.word	0x080250b5
 8011c84:	080250c6 	.word	0x080250c6
 8011c88:	080250de 	.word	0x080250de
 8011c8c:	080250f4 	.word	0x080250f4
 8011c90:	0802510c 	.word	0x0802510c
 8011c94:	08025124 	.word	0x08025124
 8011c98:	0802513b 	.word	0x0802513b
 8011c9c:	0802515d 	.word	0x0802515d
 8011ca0:	0802517c 	.word	0x0802517c
 8011ca4:	080251a6 	.word	0x080251a6
 8011ca8:	080251bd 	.word	0x080251bd
 8011cac:	080251dc 	.word	0x080251dc
 8011cb0:	080251f0 	.word	0x080251f0
 8011cb4:	08025207 	.word	0x08025207
 8011cb8:	08025223 	.word	0x08025223
 8011cbc:	08025238 	.word	0x08025238
 8011cc0:	08025253 	.word	0x08025253
 8011cc4:	08025269 	.word	0x08025269
 8011cc8:	08025285 	.word	0x08025285
 8011ccc:	08026647 	.word	0x08026647
 8011cd0:	08026668 	.word	0x08026668
 8011cd4:	080252b6 	.word	0x080252b6
 8011cd8:	080252d4 	.word	0x080252d4
 8011cdc:	080252f5 	.word	0x080252f5
 8011ce0:	08025322 	.word	0x08025322
 8011ce4:	0802533e 	.word	0x0802533e
 8011ce8:	0802535d 	.word	0x0802535d
 8011cec:	0802538e 	.word	0x0802538e
 8011cf0:	080253ac 	.word	0x080253ac
 8011cf4:	080253cd 	.word	0x080253cd
 8011cf8:	080253f8 	.word	0x080253f8
 8011cfc:	08025413 	.word	0x08025413
 8011d00:	08025431 	.word	0x08025431
 8011d04:	47a0      	blx	r4
	out("kb %d ain_bandwidth_ms %d", kb + 1, kc->ain_bandwidth_ms);
 8011d06:	f897 2145 	ldrb.w	r2, [r7, #325]	@ 0x145
 8011d0a:	4810      	ldr	r0, [pc, #64]	@ (8011d4c <KEYBOARD_TerminalPrintConfig+0x3c8>)
 8011d0c:	4629      	mov	r1, r5
 8011d0e:	47a0      	blx	r4

	KEYBOARD_TerminalCaliMode(_output_function);
 8011d10:	4620      	mov	r0, r4
 8011d12:	f7fe ff43 	bl	8010b9c <KEYBOARD_TerminalCaliMode.isra.0>
#endif

	return 0; // no error
	}
 8011d16:	2000      	movs	r0, #0
 8011d18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		out("kb %d ain_pitchwheel off", kb + 1);
 8011d1c:	480c      	ldr	r0, [pc, #48]	@ (8011d50 <KEYBOARD_TerminalPrintConfig+0x3cc>)
 8011d1e:	4629      	mov	r1, r5
 8011d20:	47a0      	blx	r4
 8011d22:	e6e6      	b.n	8011af2 <KEYBOARD_TerminalPrintConfig+0x16e>
	out("kb %d ctrl_pitchwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL],
 8011d24:	4b0b      	ldr	r3, [pc, #44]	@ (8011d54 <KEYBOARD_TerminalPrintConfig+0x3d0>)
 8011d26:	e6f4      	b.n	8011b12 <KEYBOARD_TerminalPrintConfig+0x18e>
		out("kb %d ain_modwheel off", kb + 1);
 8011d28:	480b      	ldr	r0, [pc, #44]	@ (8011d58 <KEYBOARD_TerminalPrintConfig+0x3d4>)
 8011d2a:	4629      	mov	r1, r5
 8011d2c:	47a0      	blx	r4
 8011d2e:	e70a      	b.n	8011b46 <KEYBOARD_TerminalPrintConfig+0x1c2>
	out("kb %d ctrl_modwheel %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL],
 8011d30:	4b08      	ldr	r3, [pc, #32]	@ (8011d54 <KEYBOARD_TerminalPrintConfig+0x3d0>)
 8011d32:	e718      	b.n	8011b66 <KEYBOARD_TerminalPrintConfig+0x1e2>
		out("kb %d ain_expression off", kb + 1);
 8011d34:	4809      	ldr	r0, [pc, #36]	@ (8011d5c <KEYBOARD_TerminalPrintConfig+0x3d8>)
 8011d36:	4629      	mov	r1, r5
 8011d38:	47a0      	blx	r4
 8011d3a:	e72e      	b.n	8011b9a <KEYBOARD_TerminalPrintConfig+0x216>
	out("kb %d ctrl_expression %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION],
 8011d3c:	4b05      	ldr	r3, [pc, #20]	@ (8011d54 <KEYBOARD_TerminalPrintConfig+0x3d0>)
 8011d3e:	e73c      	b.n	8011bba <KEYBOARD_TerminalPrintConfig+0x236>
		out("kb %d ain_sustain off", kb + 1);
 8011d40:	4807      	ldr	r0, [pc, #28]	@ (8011d60 <KEYBOARD_TerminalPrintConfig+0x3dc>)
 8011d42:	4629      	mov	r1, r5
 8011d44:	47a0      	blx	r4
 8011d46:	e752      	b.n	8011bee <KEYBOARD_TerminalPrintConfig+0x26a>
	out("kb %d ctrl_sustain %d (%s)", kb + 1, kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN],
 8011d48:	4b02      	ldr	r3, [pc, #8]	@ (8011d54 <KEYBOARD_TerminalPrintConfig+0x3d0>)
 8011d4a:	e760      	b.n	8011c0e <KEYBOARD_TerminalPrintConfig+0x28a>
 8011d4c:	0802544d 	.word	0x0802544d
 8011d50:	0802529d 	.word	0x0802529d
 8011d54:	08024fe2 	.word	0x08024fe2
 8011d58:	0802530b 	.word	0x0802530b
 8011d5c:	08025375 	.word	0x08025375
 8011d60:	080253e2 	.word	0x080253e2

08011d64 <KEYBOARD_TerminalPrintDelays>:

/////////////////////////////////////////////////////////////////////////////
//! Keyboard Configuration (can also be called from external)
/////////////////////////////////////////////////////////////////////////////
s32 KEYBOARD_TerminalPrintDelays(int kb, void* _output_function) {
	void (*out)(char* format, ...) = _output_function;
 8011d64:	f44f 73a8 	mov.w	r3, #336	@ 0x150
s32 KEYBOARD_TerminalPrintDelays(int kb, void* _output_function) {
 8011d68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8011d6c:	4358      	muls	r0, r3
 8011d6e:	4c0f      	ldr	r4, [pc, #60]	@ (8011dac <KEYBOARD_TerminalPrintDelays+0x48>)
 8011d70:	f500 738d 	add.w	r3, r0, #282	@ 0x11a
 8011d74:	460f      	mov	r7, r1
	return -1;
#else
	keyboard_config_t* kc = (keyboard_config_t*)&keyboard_config[kb];

	int last_key;
	for (last_key = 127; last_key >= 0; --last_key) {
 8011d76:	4423      	add	r3, r4
 8011d78:	257f      	movs	r5, #127	@ 0x7f
		if (kc->delay_key[last_key] > 0)
 8011d7a:	f833 2d02 	ldrh.w	r2, [r3, #-2]!
 8011d7e:	b932      	cbnz	r2, 8011d8e <KEYBOARD_TerminalPrintDelays+0x2a>
	for (last_key = 127; last_key >= 0; --last_key) {
 8011d80:	3d01      	subs	r5, #1
 8011d82:	d2fa      	bcs.n	8011d7a <KEYBOARD_TerminalPrintDelays+0x16>
			break;
		}

	if (last_key < 0) {
		out("No delays measured yet; please enable key_calibration and press the keys");
 8011d84:	480a      	ldr	r0, [pc, #40]	@ (8011db0 <KEYBOARD_TerminalPrintDelays+0x4c>)
 8011d86:	47b8      	blx	r7
			}
		}

	return 0; // no error
#endif
	}
 8011d88:	2000      	movs	r0, #0
 8011d8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (last_key < 0) {
 8011d8e:	3018      	adds	r0, #24
			out("Key#%3d: %d\n", i, kc->delay_key[i]);
 8011d90:	f8df 8020 	ldr.w	r8, [pc, #32]	@ 8011db4 <KEYBOARD_TerminalPrintDelays+0x50>
 8011d94:	4404      	add	r4, r0
		for (i = 0; i <= last_key; ++i) {
 8011d96:	2600      	movs	r6, #0
			out("Key#%3d: %d\n", i, kc->delay_key[i]);
 8011d98:	4631      	mov	r1, r6
 8011d9a:	f834 2f02 	ldrh.w	r2, [r4, #2]!
 8011d9e:	4640      	mov	r0, r8
		for (i = 0; i <= last_key; ++i) {
 8011da0:	3601      	adds	r6, #1
			out("Key#%3d: %d\n", i, kc->delay_key[i]);
 8011da2:	47b8      	blx	r7
		for (i = 0; i <= last_key; ++i) {
 8011da4:	42ae      	cmp	r6, r5
 8011da6:	ddf7      	ble.n	8011d98 <KEYBOARD_TerminalPrintDelays+0x34>
 8011da8:	e7ee      	b.n	8011d88 <KEYBOARD_TerminalPrintDelays+0x24>
 8011daa:	bf00      	nop
 8011dac:	20000370 	.word	0x20000370
 8011db0:	08025467 	.word	0x08025467
 8011db4:	080254b0 	.word	0x080254b0

08011db8 <KEYBOARD_TerminalParseLine>:
s32 KEYBOARD_TerminalParseLine(char* input, void* _output_function) {
 8011db8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8011dbc:	b086      	sub	sp, #24
 8011dbe:	4605      	mov	r5, r0
 8011dc0:	460c      	mov	r4, r1
	int input_len = strlen(input);
 8011dc2:	f011 fba3 	bl	802350c <strlen>
	if (!(parameter = strtok_r(input, separators, &brkt))) {
 8011dc6:	4999      	ldr	r1, [pc, #612]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
	int input_len = strlen(input);
 8011dc8:	4607      	mov	r7, r0
	if (!(parameter = strtok_r(input, separators, &brkt))) {
 8011dca:	466a      	mov	r2, sp
 8011dcc:	4628      	mov	r0, r5
 8011dce:	f011 fc19 	bl	8023604 <strtok_r>
 8011dd2:	4606      	mov	r6, r0
 8011dd4:	b948      	cbnz	r0, 8011dea <KEYBOARD_TerminalParseLine+0x32>
 8011dd6:	1e6b      	subs	r3, r5, #1
				*input_ptr = ' ';
 8011dd8:	2120      	movs	r1, #32
		for (i = 0; i < input_len; ++i, ++input_ptr)
 8011dda:	f1c5 0501 	rsb	r5, r5, #1
 8011dde:	18ea      	adds	r2, r5, r3
 8011de0:	4297      	cmp	r7, r2
 8011de2:	f300 87c1 	bgt.w	8012d68 <KEYBOARD_TerminalParseLine+0xfb0>
		return 0; // command not taken
 8011de6:	2000      	movs	r0, #0
 8011de8:	e012      	b.n	8011e10 <KEYBOARD_TerminalParseLine+0x58>
		if (strcmp(parameter, "kb") == 0 || strcmp(parameter, "keyboard") == 0) {
 8011dea:	4991      	ldr	r1, [pc, #580]	@ (8012030 <KEYBOARD_TerminalParseLine+0x278>)
 8011dec:	f011 fc0d 	bl	802360a <strcmp>
 8011df0:	b120      	cbz	r0, 8011dfc <KEYBOARD_TerminalParseLine+0x44>
 8011df2:	4990      	ldr	r1, [pc, #576]	@ (8012034 <KEYBOARD_TerminalParseLine+0x27c>)
 8011df4:	4630      	mov	r0, r6
 8011df6:	f011 fc08 	bl	802360a <strcmp>
 8011dfa:	bb68      	cbnz	r0, 8011e58 <KEYBOARD_TerminalParseLine+0xa0>
			if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011dfc:	498b      	ldr	r1, [pc, #556]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011dfe:	466a      	mov	r2, sp
 8011e00:	2000      	movs	r0, #0
 8011e02:	f011 fbff 	bl	8023604 <strtok_r>
 8011e06:	b930      	cbnz	r0, 8011e16 <KEYBOARD_TerminalParseLine+0x5e>
				out("Missing keyboard number (1..%d)!", KEYBOARD_NUM);
 8011e08:	488b      	ldr	r0, [pc, #556]	@ (8012038 <KEYBOARD_TerminalParseLine+0x280>)
 8011e0a:	2101      	movs	r1, #1
 8011e0c:	47a0      	blx	r4
				return 1; // command taken
 8011e0e:	2001      	movs	r0, #1
	}
 8011e10:	b006      	add	sp, #24
 8011e12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			int kb = get_dec(parameter);
 8011e16:	f7fe fe8d 	bl	8010b34 <get_dec>
			if (kb < 1 || kb > KEYBOARD_NUM) {
 8011e1a:	2801      	cmp	r0, #1
			int kb = get_dec(parameter);
 8011e1c:	4605      	mov	r5, r0
			if (kb < 1 || kb > KEYBOARD_NUM) {
 8011e1e:	d003      	beq.n	8011e28 <KEYBOARD_TerminalParseLine+0x70>
				out("Invalid Keyboard number specified as first parameter (expecting kb 1..%d)!", KEYBOARD_NUM);
 8011e20:	4886      	ldr	r0, [pc, #536]	@ (801203c <KEYBOARD_TerminalParseLine+0x284>)
 8011e22:	2101      	movs	r1, #1
 8011e24:	47a0      	blx	r4
				return 1; // command taken
 8011e26:	e7f2      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
			if ((parameter = strtok_r(NULL, separators, &brkt))) {
 8011e28:	4980      	ldr	r1, [pc, #512]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011e2a:	466a      	mov	r2, sp
 8011e2c:	2000      	movs	r0, #0
 8011e2e:	f011 fbe9 	bl	8023604 <strtok_r>
 8011e32:	4606      	mov	r6, r0
 8011e34:	b160      	cbz	r0, 8011e50 <KEYBOARD_TerminalParseLine+0x98>
				if (strcmp(parameter, "delays") == 0) {
 8011e36:	4982      	ldr	r1, [pc, #520]	@ (8012040 <KEYBOARD_TerminalParseLine+0x288>)
 8011e38:	f011 fbe7 	bl	802360a <strcmp>
 8011e3c:	b918      	cbnz	r0, 8011e46 <KEYBOARD_TerminalParseLine+0x8e>
					KEYBOARD_TerminalPrintDelays(kb - 1, _output_function);
 8011e3e:	4621      	mov	r1, r4
 8011e40:	f7ff ff90 	bl	8011d64 <KEYBOARD_TerminalPrintDelays>
 8011e44:	e7e3      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					out("Unknown command after 'kb %d': %s!", kb, parameter);
 8011e46:	487f      	ldr	r0, [pc, #508]	@ (8012044 <KEYBOARD_TerminalParseLine+0x28c>)
 8011e48:	4632      	mov	r2, r6
 8011e4a:	4629      	mov	r1, r5
 8011e4c:	47a0      	blx	r4
 8011e4e:	e7de      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
			KEYBOARD_TerminalPrintConfig(kb - 1, _output_function);
 8011e50:	4621      	mov	r1, r4
 8011e52:	f7ff fd97 	bl	8011984 <KEYBOARD_TerminalPrintConfig>
	if (!input_line_parsed) {
 8011e56:	e7da      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
		else if (strcmp(parameter, "set") == 0) {
 8011e58:	497b      	ldr	r1, [pc, #492]	@ (8012048 <KEYBOARD_TerminalParseLine+0x290>)
 8011e5a:	4630      	mov	r0, r6
 8011e5c:	f011 fbd5 	bl	802360a <strcmp>
 8011e60:	2800      	cmp	r0, #0
 8011e62:	d1b8      	bne.n	8011dd6 <KEYBOARD_TerminalParseLine+0x1e>
			if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011e64:	4971      	ldr	r1, [pc, #452]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011e66:	466a      	mov	r2, sp
 8011e68:	f011 fbcc 	bl	8023604 <strtok_r>
 8011e6c:	4606      	mov	r6, r0
 8011e6e:	b910      	cbnz	r0, 8011e76 <KEYBOARD_TerminalParseLine+0xbe>
				out("Missing parameter after 'set'!");
 8011e70:	4876      	ldr	r0, [pc, #472]	@ (801204c <KEYBOARD_TerminalParseLine+0x294>)
 8011e72:	47a0      	blx	r4
				return 1; // command taken
 8011e74:	e7cb      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
			if (strcmp(parameter, "kb") != 0 && strcmp(parameter, "keyboard") != 0) {
 8011e76:	496e      	ldr	r1, [pc, #440]	@ (8012030 <KEYBOARD_TerminalParseLine+0x278>)
 8011e78:	f011 fbc7 	bl	802360a <strcmp>
 8011e7c:	b128      	cbz	r0, 8011e8a <KEYBOARD_TerminalParseLine+0xd2>
 8011e7e:	496d      	ldr	r1, [pc, #436]	@ (8012034 <KEYBOARD_TerminalParseLine+0x27c>)
 8011e80:	4630      	mov	r0, r6
 8011e82:	f011 fbc2 	bl	802360a <strcmp>
 8011e86:	2800      	cmp	r0, #0
 8011e88:	d1a5      	bne.n	8011dd6 <KEYBOARD_TerminalParseLine+0x1e>
				if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011e8a:	4968      	ldr	r1, [pc, #416]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011e8c:	466a      	mov	r2, sp
 8011e8e:	2000      	movs	r0, #0
 8011e90:	f011 fbb8 	bl	8023604 <strtok_r>
 8011e94:	b918      	cbnz	r0, 8011e9e <KEYBOARD_TerminalParseLine+0xe6>
					out("Missing keyboard number (1..%d)!", KEYBOARD_NUM);
 8011e96:	4868      	ldr	r0, [pc, #416]	@ (8012038 <KEYBOARD_TerminalParseLine+0x280>)
 8011e98:	2101      	movs	r1, #1
 8011e9a:	47a0      	blx	r4
					return 1; // command taken
 8011e9c:	e7b7      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				int kb = get_dec(parameter);
 8011e9e:	f7fe fe49 	bl	8010b34 <get_dec>
				if (kb < 1 || kb > KEYBOARD_NUM) {
 8011ea2:	2801      	cmp	r0, #1
				int kb = get_dec(parameter);
 8011ea4:	4606      	mov	r6, r0
				if (kb < 1 || kb > KEYBOARD_NUM) {
 8011ea6:	d003      	beq.n	8011eb0 <KEYBOARD_TerminalParseLine+0xf8>
					out("Invalid Keyboard number specified as first parameter (expecting kb 1..%d)!", KEYBOARD_NUM);
 8011ea8:	4864      	ldr	r0, [pc, #400]	@ (801203c <KEYBOARD_TerminalParseLine+0x284>)
 8011eaa:	2101      	movs	r1, #1
 8011eac:	47a0      	blx	r4
					return 1; // command taken
 8011eae:	e7ae      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011eb0:	495e      	ldr	r1, [pc, #376]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011eb2:	466a      	mov	r2, sp
 8011eb4:	2000      	movs	r0, #0
 8011eb6:	f011 fba5 	bl	8023604 <strtok_r>
 8011eba:	4605      	mov	r5, r0
 8011ebc:	b918      	cbnz	r0, 8011ec6 <KEYBOARD_TerminalParseLine+0x10e>
					out("Missing parameter name and value after 'set kb %d'!", kb + 1);
 8011ebe:	4864      	ldr	r0, [pc, #400]	@ (8012050 <KEYBOARD_TerminalParseLine+0x298>)
 8011ec0:	4631      	mov	r1, r6
 8011ec2:	47a0      	blx	r4
					return 1; // command taken
 8011ec4:	e7a3      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				if (strcmp(parameter, "note_offset") == 0) {
 8011ec6:	4963      	ldr	r1, [pc, #396]	@ (8012054 <KEYBOARD_TerminalParseLine+0x29c>)
 8011ec8:	f011 fb9f 	bl	802360a <strcmp>
 8011ecc:	b9a8      	cbnz	r0, 8011efa <KEYBOARD_TerminalParseLine+0x142>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011ece:	4957      	ldr	r1, [pc, #348]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011ed0:	466a      	mov	r2, sp
 8011ed2:	f011 fb97 	bl	8023604 <strtok_r>
 8011ed6:	b910      	cbnz	r0, 8011ede <KEYBOARD_TerminalParseLine+0x126>
						out("Please specify the Note offset!");
 8011ed8:	485f      	ldr	r0, [pc, #380]	@ (8012058 <KEYBOARD_TerminalParseLine+0x2a0>)
 8011eda:	47a0      	blx	r4
						return 1; // command taken
 8011edc:	e797      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int offset = get_dec(parameter);
 8011ede:	f7fe fe29 	bl	8010b34 <get_dec>
					if (offset < 0 || offset > 127) {
 8011ee2:	287f      	cmp	r0, #127	@ 0x7f
					int offset = get_dec(parameter);
 8011ee4:	4602      	mov	r2, r0
					if (offset < 0 || offset > 127) {
 8011ee6:	d902      	bls.n	8011eee <KEYBOARD_TerminalParseLine+0x136>
						out("Note Offset should be in the range between 0 and 127!");
 8011ee8:	485c      	ldr	r0, [pc, #368]	@ (801205c <KEYBOARD_TerminalParseLine+0x2a4>)
 8011eea:	47a0      	blx	r4
						return 1; // command taken
 8011eec:	e78f      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->note_offset = offset;
 8011eee:	4b5c      	ldr	r3, [pc, #368]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: Note Offset %d", kb + 1, kc->note_offset);
 8011ef0:	4631      	mov	r1, r6
						kc->note_offset = offset;
 8011ef2:	70d8      	strb	r0, [r3, #3]
						out("Keyboard #%d: Note Offset %d", kb + 1, kc->note_offset);
 8011ef4:	485b      	ldr	r0, [pc, #364]	@ (8012064 <KEYBOARD_TerminalParseLine+0x2ac>)
 8011ef6:	47a0      	blx	r4
	if (!input_line_parsed) {
 8011ef8:	e789      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "midi_ports") == 0) {
 8011efa:	495b      	ldr	r1, [pc, #364]	@ (8012068 <KEYBOARD_TerminalParseLine+0x2b0>)
 8011efc:	4628      	mov	r0, r5
 8011efe:	f011 fb84 	bl	802360a <strcmp>
 8011f02:	b9b0      	cbnz	r0, 8011f32 <KEYBOARD_TerminalParseLine+0x17a>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011f04:	4949      	ldr	r1, [pc, #292]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011f06:	466a      	mov	r2, sp
 8011f08:	f011 fb7c 	bl	8023604 <strtok_r>
 8011f0c:	b910      	cbnz	r0, 8011f14 <KEYBOARD_TerminalParseLine+0x15c>
						out("Please specify the MIDI port selection mask!");
 8011f0e:	4857      	ldr	r0, [pc, #348]	@ (801206c <KEYBOARD_TerminalParseLine+0x2b4>)
 8011f10:	47a0      	blx	r4
						return 1; // command taken
 8011f12:	e77c      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int mask = get_dec(parameter);
 8011f14:	f7fe fe0e 	bl	8010b34 <get_dec>
					if (mask < 0 || mask > 0xffff) {
 8011f18:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int mask = get_dec(parameter);
 8011f1c:	4602      	mov	r2, r0
					if (mask < 0 || mask > 0xffff) {
 8011f1e:	d302      	bcc.n	8011f26 <KEYBOARD_TerminalParseLine+0x16e>
						out("Mask should be in the range between 0 and 0xffff (see documenation)!");
 8011f20:	4853      	ldr	r0, [pc, #332]	@ (8012070 <KEYBOARD_TerminalParseLine+0x2b8>)
 8011f22:	47a0      	blx	r4
						return 1; // command taken
 8011f24:	e773      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->midi_ports = mask;
 8011f26:	4b4e      	ldr	r3, [pc, #312]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: MIDI ports selection 0x%04x", kb + 1, kc->midi_ports);
 8011f28:	4631      	mov	r1, r6
						kc->midi_ports = mask;
 8011f2a:	8018      	strh	r0, [r3, #0]
						out("Keyboard #%d: MIDI ports selection 0x%04x", kb + 1, kc->midi_ports);
 8011f2c:	4851      	ldr	r0, [pc, #324]	@ (8012074 <KEYBOARD_TerminalParseLine+0x2bc>)
 8011f2e:	47a0      	blx	r4
	if (!input_line_parsed) {
 8011f30:	e76d      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "midi_chn") == 0) {
 8011f32:	4951      	ldr	r1, [pc, #324]	@ (8012078 <KEYBOARD_TerminalParseLine+0x2c0>)
 8011f34:	4628      	mov	r0, r5
 8011f36:	f011 fb68 	bl	802360a <strcmp>
 8011f3a:	b9a8      	cbnz	r0, 8011f68 <KEYBOARD_TerminalParseLine+0x1b0>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011f3c:	493b      	ldr	r1, [pc, #236]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011f3e:	466a      	mov	r2, sp
 8011f40:	f011 fb60 	bl	8023604 <strtok_r>
 8011f44:	b910      	cbnz	r0, 8011f4c <KEYBOARD_TerminalParseLine+0x194>
						out("Please specify the MIDI channel!");
 8011f46:	484d      	ldr	r0, [pc, #308]	@ (801207c <KEYBOARD_TerminalParseLine+0x2c4>)
 8011f48:	47a0      	blx	r4
						return 1; // command taken
 8011f4a:	e760      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int chn = get_dec(parameter);
 8011f4c:	f7fe fdf2 	bl	8010b34 <get_dec>
					if (chn < 0 || chn > 16) {
 8011f50:	2810      	cmp	r0, #16
					int chn = get_dec(parameter);
 8011f52:	4602      	mov	r2, r0
					if (chn < 0 || chn > 16) {
 8011f54:	d902      	bls.n	8011f5c <KEYBOARD_TerminalParseLine+0x1a4>
						out("Channel should be in the range between 0 and 16 (0=off)!");
 8011f56:	484a      	ldr	r0, [pc, #296]	@ (8012080 <KEYBOARD_TerminalParseLine+0x2c8>)
 8011f58:	47a0      	blx	r4
						return 1; // command taken
 8011f5a:	e758      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->midi_chn = chn;
 8011f5c:	4b40      	ldr	r3, [pc, #256]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: MIDI channel %d", kb + 1, kc->midi_chn);
 8011f5e:	4631      	mov	r1, r6
						kc->midi_chn = chn;
 8011f60:	7098      	strb	r0, [r3, #2]
						out("Keyboard #%d: MIDI channel %d", kb + 1, kc->midi_chn);
 8011f62:	4848      	ldr	r0, [pc, #288]	@ (8012084 <KEYBOARD_TerminalParseLine+0x2cc>)
 8011f64:	47a0      	blx	r4
	if (!input_line_parsed) {
 8011f66:	e752      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "din_key_offset") == 0) {
 8011f68:	4947      	ldr	r1, [pc, #284]	@ (8012088 <KEYBOARD_TerminalParseLine+0x2d0>)
 8011f6a:	4628      	mov	r0, r5
 8011f6c:	f011 fb4d 	bl	802360a <strcmp>
 8011f70:	b9c0      	cbnz	r0, 8011fa4 <KEYBOARD_TerminalParseLine+0x1ec>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011f72:	492e      	ldr	r1, [pc, #184]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011f74:	466a      	mov	r2, sp
 8011f76:	f011 fb45 	bl	8023604 <strtok_r>
 8011f7a:	b910      	cbnz	r0, 8011f82 <KEYBOARD_TerminalParseLine+0x1ca>
						out("Please specify the key offset!");
 8011f7c:	4843      	ldr	r0, [pc, #268]	@ (801208c <KEYBOARD_TerminalParseLine+0x2d4>)
 8011f7e:	47a0      	blx	r4
						return 1; // command taken
 8011f80:	e745      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int offset = get_dec(parameter);
 8011f82:	f7fe fdd7 	bl	8010b34 <get_dec>
					if (offset < 0 || offset > 127) {
 8011f86:	287f      	cmp	r0, #127	@ 0x7f
					int offset = get_dec(parameter);
 8011f88:	4602      	mov	r2, r0
					if (offset < 0 || offset > 127) {
 8011f8a:	d902      	bls.n	8011f92 <KEYBOARD_TerminalParseLine+0x1da>
						out("Key Offset should be in the range between 0 and 127!");
 8011f8c:	4840      	ldr	r0, [pc, #256]	@ (8012090 <KEYBOARD_TerminalParseLine+0x2d8>)
 8011f8e:	47a0      	blx	r4
						return 1; // command taken
 8011f90:	e73d      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->din_key_offset = offset;
 8011f92:	4b33      	ldr	r3, [pc, #204]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: DIN Key Offset %d", kb + 1, kc->din_key_offset);
 8011f94:	4631      	mov	r1, r6
						kc->din_key_offset = offset;
 8011f96:	7318      	strb	r0, [r3, #12]
						out("Keyboard #%d: DIN Key Offset %d", kb + 1, kc->din_key_offset);
 8011f98:	483e      	ldr	r0, [pc, #248]	@ (8012094 <KEYBOARD_TerminalParseLine+0x2dc>)
 8011f9a:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8011f9c:	4630      	mov	r0, r6
 8011f9e:	f7fe fe91 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8011fa2:	e734      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "debug") == 0) {
 8011fa4:	493c      	ldr	r1, [pc, #240]	@ (8012098 <KEYBOARD_TerminalParseLine+0x2e0>)
 8011fa6:	4628      	mov	r0, r5
 8011fa8:	f011 fb2f 	bl	802360a <strcmp>
 8011fac:	b9e0      	cbnz	r0, 8011fe8 <KEYBOARD_TerminalParseLine+0x230>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011fae:	491f      	ldr	r1, [pc, #124]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011fb0:	466a      	mov	r2, sp
 8011fb2:	f011 fb27 	bl	8023604 <strtok_r>
 8011fb6:	b910      	cbnz	r0, 8011fbe <KEYBOARD_TerminalParseLine+0x206>
						out("Please specify on or off (alternatively 1 or 0)");
 8011fb8:	4838      	ldr	r0, [pc, #224]	@ (801209c <KEYBOARD_TerminalParseLine+0x2e4>)
 8011fba:	47a0      	blx	r4
						return 1; // command taken
 8011fbc:	e727      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 8011fbe:	f7fe fdc9 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 8011fc2:	2800      	cmp	r0, #0
 8011fc4:	da02      	bge.n	8011fcc <KEYBOARD_TerminalParseLine+0x214>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 8011fc6:	4836      	ldr	r0, [pc, #216]	@ (80120a0 <KEYBOARD_TerminalParseLine+0x2e8>)
 8011fc8:	47a0      	blx	r4
	if (!input_line_parsed) {
 8011fca:	e720      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->verbose_level = on_off ? 2 : 1;
 8011fcc:	4b24      	ldr	r3, [pc, #144]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: debug mode %s", kb + 1, on_off ? "enabled" : "disabled");
 8011fce:	4835      	ldr	r0, [pc, #212]	@ (80120a4 <KEYBOARD_TerminalParseLine+0x2ec>)
						kc->verbose_level = on_off ? 2 : 1;
 8011fd0:	bf14      	ite	ne
 8011fd2:	2202      	movne	r2, #2
 8011fd4:	2201      	moveq	r2, #1
 8011fd6:	71da      	strb	r2, [r3, #7]
						out("Keyboard #%d: debug mode %s", kb + 1, on_off ? "enabled" : "disabled");
 8011fd8:	4b33      	ldr	r3, [pc, #204]	@ (80120a8 <KEYBOARD_TerminalParseLine+0x2f0>)
 8011fda:	4a34      	ldr	r2, [pc, #208]	@ (80120ac <KEYBOARD_TerminalParseLine+0x2f4>)
 8011fdc:	f04f 0101 	mov.w	r1, #1
 8011fe0:	bf18      	it	ne
 8011fe2:	461a      	movne	r2, r3
 8011fe4:	47a0      	blx	r4
	if (!input_line_parsed) {
 8011fe6:	e712      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "rows") == 0) {
 8011fe8:	4931      	ldr	r1, [pc, #196]	@ (80120b0 <KEYBOARD_TerminalParseLine+0x2f8>)
 8011fea:	4628      	mov	r0, r5
 8011fec:	f011 fb0d 	bl	802360a <strcmp>
 8011ff0:	2800      	cmp	r0, #0
 8011ff2:	d165      	bne.n	80120c0 <KEYBOARD_TerminalParseLine+0x308>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8011ff4:	490d      	ldr	r1, [pc, #52]	@ (801202c <KEYBOARD_TerminalParseLine+0x274>)
 8011ff6:	466a      	mov	r2, sp
 8011ff8:	f011 fb04 	bl	8023604 <strtok_r>
 8011ffc:	b918      	cbnz	r0, 8012006 <KEYBOARD_TerminalParseLine+0x24e>
						out("Please specify the number of rows (0..%d)", MATRIX_NUM_ROWS);
 8011ffe:	482d      	ldr	r0, [pc, #180]	@ (80120b4 <KEYBOARD_TerminalParseLine+0x2fc>)
 8012000:	2110      	movs	r1, #16
 8012002:	47a0      	blx	r4
						return 1; // command taken
 8012004:	e703      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int rows = get_dec(parameter);
 8012006:	f7fe fd95 	bl	8010b34 <get_dec>
					if (rows < 0 || rows > MATRIX_NUM_ROWS) {
 801200a:	2810      	cmp	r0, #16
					int rows = get_dec(parameter);
 801200c:	4602      	mov	r2, r0
					if (rows < 0 || rows > MATRIX_NUM_ROWS) {
 801200e:	d903      	bls.n	8012018 <KEYBOARD_TerminalParseLine+0x260>
						out("Rows should be in the range between 0 (off) and %d", MATRIX_NUM_ROWS);
 8012010:	4829      	ldr	r0, [pc, #164]	@ (80120b8 <KEYBOARD_TerminalParseLine+0x300>)
 8012012:	2110      	movs	r1, #16
 8012014:	47a0      	blx	r4
						return 1; // command taken
 8012016:	e6fa      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->num_rows = rows;
 8012018:	4b11      	ldr	r3, [pc, #68]	@ (8012060 <KEYBOARD_TerminalParseLine+0x2a8>)
						out("Keyboard #%d: %d rows will be scanned!", kb + 1, kc->num_rows);
 801201a:	2101      	movs	r1, #1
						kc->num_rows = rows;
 801201c:	7118      	strb	r0, [r3, #4]
						out("Keyboard #%d: %d rows will be scanned!", kb + 1, kc->num_rows);
 801201e:	4827      	ldr	r0, [pc, #156]	@ (80120bc <KEYBOARD_TerminalParseLine+0x304>)
 8012020:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012022:	2001      	movs	r0, #1
 8012024:	f7fe fe4e 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8012028:	e6f1      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
 801202a:	bf00      	nop
 801202c:	080237ba 	.word	0x080237ba
 8012030:	080254d7 	.word	0x080254d7
 8012034:	080254da 	.word	0x080254da
 8012038:	080254e3 	.word	0x080254e3
 801203c:	08025504 	.word	0x08025504
 8012040:	0802554f 	.word	0x0802554f
 8012044:	08025556 	.word	0x08025556
 8012048:	0802391b 	.word	0x0802391b
 801204c:	08023b98 	.word	0x08023b98
 8012050:	08025579 	.word	0x08025579
 8012054:	080255ad 	.word	0x080255ad
 8012058:	080255b9 	.word	0x080255b9
 801205c:	080255d9 	.word	0x080255d9
 8012060:	20000370 	.word	0x20000370
 8012064:	0802560f 	.word	0x0802560f
 8012068:	0802562c 	.word	0x0802562c
 801206c:	08025637 	.word	0x08025637
 8012070:	08025664 	.word	0x08025664
 8012074:	080256a9 	.word	0x080256a9
 8012078:	080256d3 	.word	0x080256d3
 801207c:	080256dc 	.word	0x080256dc
 8012080:	080256fd 	.word	0x080256fd
 8012084:	08025736 	.word	0x08025736
 8012088:	08025754 	.word	0x08025754
 801208c:	08025763 	.word	0x08025763
 8012090:	08025782 	.word	0x08025782
 8012094:	080257b7 	.word	0x080257b7
 8012098:	080257d7 	.word	0x080257d7
 801209c:	080257dd 	.word	0x080257dd
 80120a0:	0802580d 	.word	0x0802580d
 80120a4:	0802583d 	.word	0x0802583d
 80120a8:	080254bd 	.word	0x080254bd
 80120ac:	080254c5 	.word	0x080254c5
 80120b0:	08025859 	.word	0x08025859
 80120b4:	0802585e 	.word	0x0802585e
 80120b8:	08025888 	.word	0x08025888
 80120bc:	080258bb 	.word	0x080258bb
				else if (strcmp(parameter, "dout_sr1") == 0) {
 80120c0:	4999      	ldr	r1, [pc, #612]	@ (8012328 <KEYBOARD_TerminalParseLine+0x570>)
 80120c2:	4628      	mov	r0, r5
 80120c4:	f011 faa1 	bl	802360a <strcmp>
 80120c8:	b9f0      	cbnz	r0, 8012108 <KEYBOARD_TerminalParseLine+0x350>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80120ca:	4998      	ldr	r1, [pc, #608]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 80120cc:	466a      	mov	r2, sp
 80120ce:	f011 fa99 	bl	8023604 <strtok_r>
 80120d2:	b928      	cbnz	r0, 80120e0 <KEYBOARD_TerminalParseLine+0x328>
						out("Please specify the DOUT number to which the first column is assigned (0..%d)", MIOS32_SRIO_ScanNumGet());
 80120d4:	f002 f95a 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80120d8:	4601      	mov	r1, r0
 80120da:	4895      	ldr	r0, [pc, #596]	@ (8012330 <KEYBOARD_TerminalParseLine+0x578>)
 80120dc:	47a0      	blx	r4
						return 1; // command taken
 80120de:	e696      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int sr = get_dec(parameter);
 80120e0:	f7fe fd28 	bl	8010b34 <get_dec>
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 80120e4:	2810      	cmp	r0, #16
					int sr = get_dec(parameter);
 80120e6:	4602      	mov	r2, r0
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 80120e8:	d905      	bls.n	80120f6 <KEYBOARD_TerminalParseLine+0x33e>
						out("Shift register should be in the range between 0 (off) and %d", MIOS32_SRIO_ScanNumGet());
 80120ea:	f002 f94f 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80120ee:	4601      	mov	r1, r0
 80120f0:	4890      	ldr	r0, [pc, #576]	@ (8012334 <KEYBOARD_TerminalParseLine+0x57c>)
 80120f2:	47a0      	blx	r4
						return 1; // command taken
 80120f4:	e68b      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->dout_sr1 = sr;
 80120f6:	4b90      	ldr	r3, [pc, #576]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
						out("Keyboard #%d: dout_sr1 assigned to %d!", kb + 1, kc->dout_sr1);
 80120f8:	2101      	movs	r1, #1
						kc->dout_sr1 = sr;
 80120fa:	7218      	strb	r0, [r3, #8]
						out("Keyboard #%d: dout_sr1 assigned to %d!", kb + 1, kc->dout_sr1);
 80120fc:	488f      	ldr	r0, [pc, #572]	@ (801233c <KEYBOARD_TerminalParseLine+0x584>)
 80120fe:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012100:	2001      	movs	r0, #1
 8012102:	f7fe fddf 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8012106:	e682      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "dout_sr2") == 0) {
 8012108:	498d      	ldr	r1, [pc, #564]	@ (8012340 <KEYBOARD_TerminalParseLine+0x588>)
 801210a:	4628      	mov	r0, r5
 801210c:	f011 fa7d 	bl	802360a <strcmp>
 8012110:	b9f0      	cbnz	r0, 8012150 <KEYBOARD_TerminalParseLine+0x398>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012112:	4986      	ldr	r1, [pc, #536]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 8012114:	466a      	mov	r2, sp
 8012116:	f011 fa75 	bl	8023604 <strtok_r>
 801211a:	b928      	cbnz	r0, 8012128 <KEYBOARD_TerminalParseLine+0x370>
						out("Please specify the DOUT number to which the first column is assigned (0..%d)", MIOS32_SRIO_ScanNumGet());
 801211c:	f002 f936 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8012120:	4601      	mov	r1, r0
 8012122:	4883      	ldr	r0, [pc, #524]	@ (8012330 <KEYBOARD_TerminalParseLine+0x578>)
 8012124:	47a0      	blx	r4
						return 1; // command taken
 8012126:	e672      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int sr = get_dec(parameter);
 8012128:	f7fe fd04 	bl	8010b34 <get_dec>
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 801212c:	2810      	cmp	r0, #16
					int sr = get_dec(parameter);
 801212e:	4602      	mov	r2, r0
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 8012130:	d905      	bls.n	801213e <KEYBOARD_TerminalParseLine+0x386>
						out("Shift register should be in the range between 0 (off) and %d", MIOS32_SRIO_ScanNumGet());
 8012132:	f002 f92b 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8012136:	4601      	mov	r1, r0
 8012138:	487e      	ldr	r0, [pc, #504]	@ (8012334 <KEYBOARD_TerminalParseLine+0x57c>)
 801213a:	47a0      	blx	r4
						return 1; // command taken
 801213c:	e667      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->dout_sr2 = sr;
 801213e:	4b7e      	ldr	r3, [pc, #504]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
						out("Keyboard #%d: dout_sr2 assigned to %d!", kb + 1, kc->dout_sr2);
 8012140:	2101      	movs	r1, #1
						kc->dout_sr2 = sr;
 8012142:	7258      	strb	r0, [r3, #9]
						out("Keyboard #%d: dout_sr2 assigned to %d!", kb + 1, kc->dout_sr2);
 8012144:	487f      	ldr	r0, [pc, #508]	@ (8012344 <KEYBOARD_TerminalParseLine+0x58c>)
 8012146:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012148:	2001      	movs	r0, #1
 801214a:	f7fe fdbb 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 801214e:	e65e      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "din_sr1") == 0) {
 8012150:	497d      	ldr	r1, [pc, #500]	@ (8012348 <KEYBOARD_TerminalParseLine+0x590>)
 8012152:	4628      	mov	r0, r5
 8012154:	f011 fa59 	bl	802360a <strcmp>
 8012158:	b9f0      	cbnz	r0, 8012198 <KEYBOARD_TerminalParseLine+0x3e0>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 801215a:	4974      	ldr	r1, [pc, #464]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 801215c:	466a      	mov	r2, sp
 801215e:	f011 fa51 	bl	8023604 <strtok_r>
 8012162:	b928      	cbnz	r0, 8012170 <KEYBOARD_TerminalParseLine+0x3b8>
						out("Please specify the DIN number to which the first column is assigned (0..%d)", MIOS32_SRIO_ScanNumGet());
 8012164:	f002 f912 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 8012168:	4601      	mov	r1, r0
 801216a:	4878      	ldr	r0, [pc, #480]	@ (801234c <KEYBOARD_TerminalParseLine+0x594>)
 801216c:	47a0      	blx	r4
						return 1; // command taken
 801216e:	e64e      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int sr = get_dec(parameter);
 8012170:	f7fe fce0 	bl	8010b34 <get_dec>
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 8012174:	2810      	cmp	r0, #16
					int sr = get_dec(parameter);
 8012176:	4602      	mov	r2, r0
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 8012178:	d905      	bls.n	8012186 <KEYBOARD_TerminalParseLine+0x3ce>
						out("Shift register should be in the range between 0 (off) and %d", MIOS32_SRIO_ScanNumGet());
 801217a:	f002 f907 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 801217e:	4601      	mov	r1, r0
 8012180:	486c      	ldr	r0, [pc, #432]	@ (8012334 <KEYBOARD_TerminalParseLine+0x57c>)
 8012182:	47a0      	blx	r4
						return 1; // command taken
 8012184:	e643      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->din_sr1 = sr;
 8012186:	4b6c      	ldr	r3, [pc, #432]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
						out("Keyboard #%d: din_sr1 assigned to %d!", kb + 1, kc->din_sr1);
 8012188:	2101      	movs	r1, #1
						kc->din_sr1 = sr;
 801218a:	7298      	strb	r0, [r3, #10]
						out("Keyboard #%d: din_sr1 assigned to %d!", kb + 1, kc->din_sr1);
 801218c:	4870      	ldr	r0, [pc, #448]	@ (8012350 <KEYBOARD_TerminalParseLine+0x598>)
 801218e:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012190:	2001      	movs	r0, #1
 8012192:	f7fe fd97 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8012196:	e63a      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "din_sr2") == 0) {
 8012198:	496e      	ldr	r1, [pc, #440]	@ (8012354 <KEYBOARD_TerminalParseLine+0x59c>)
 801219a:	4628      	mov	r0, r5
 801219c:	f011 fa35 	bl	802360a <strcmp>
 80121a0:	b9f0      	cbnz	r0, 80121e0 <KEYBOARD_TerminalParseLine+0x428>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80121a2:	4962      	ldr	r1, [pc, #392]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 80121a4:	466a      	mov	r2, sp
 80121a6:	f011 fa2d 	bl	8023604 <strtok_r>
 80121aa:	b928      	cbnz	r0, 80121b8 <KEYBOARD_TerminalParseLine+0x400>
						out("Please specify the DIN number to which the first column is assigned (0..%d)", MIOS32_SRIO_ScanNumGet());
 80121ac:	f002 f8ee 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80121b0:	4601      	mov	r1, r0
 80121b2:	4866      	ldr	r0, [pc, #408]	@ (801234c <KEYBOARD_TerminalParseLine+0x594>)
 80121b4:	47a0      	blx	r4
						return 1; // command taken
 80121b6:	e62a      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int sr = get_dec(parameter);
 80121b8:	f7fe fcbc 	bl	8010b34 <get_dec>
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 80121bc:	2810      	cmp	r0, #16
					int sr = get_dec(parameter);
 80121be:	4602      	mov	r2, r0
					if (sr < 0 || sr > MATRIX_NUM_ROWS) {
 80121c0:	d905      	bls.n	80121ce <KEYBOARD_TerminalParseLine+0x416>
						out("Shift register should be in the range between 0 (off) and %d", MIOS32_SRIO_ScanNumGet());
 80121c2:	f002 f8e3 	bl	801438c <MIOS32_SRIO_ScanNumGet>
 80121c6:	4601      	mov	r1, r0
 80121c8:	485a      	ldr	r0, [pc, #360]	@ (8012334 <KEYBOARD_TerminalParseLine+0x57c>)
 80121ca:	47a0      	blx	r4
						return 1; // command taken
 80121cc:	e61f      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->din_sr2 = sr;
 80121ce:	4b5a      	ldr	r3, [pc, #360]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
						out("Keyboard #%d: din_sr2 assigned to %d!", kb + 1, kc->din_sr2);
 80121d0:	2101      	movs	r1, #1
						kc->din_sr2 = sr;
 80121d2:	72d8      	strb	r0, [r3, #11]
						out("Keyboard #%d: din_sr2 assigned to %d!", kb + 1, kc->din_sr2);
 80121d4:	4860      	ldr	r0, [pc, #384]	@ (8012358 <KEYBOARD_TerminalParseLine+0x5a0>)
 80121d6:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 80121d8:	2001      	movs	r0, #1
 80121da:	f7fe fd73 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 80121de:	e616      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "velocity") == 0) {
 80121e0:	495e      	ldr	r1, [pc, #376]	@ (801235c <KEYBOARD_TerminalParseLine+0x5a4>)
 80121e2:	4628      	mov	r0, r5
 80121e4:	f011 fa11 	bl	802360a <strcmp>
 80121e8:	b9e8      	cbnz	r0, 8012226 <KEYBOARD_TerminalParseLine+0x46e>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80121ea:	4950      	ldr	r1, [pc, #320]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 80121ec:	466a      	mov	r2, sp
 80121ee:	f011 fa09 	bl	8023604 <strtok_r>
 80121f2:	b910      	cbnz	r0, 80121fa <KEYBOARD_TerminalParseLine+0x442>
						out("Please specify on or off (alternatively 1 or 0)");
 80121f4:	485a      	ldr	r0, [pc, #360]	@ (8012360 <KEYBOARD_TerminalParseLine+0x5a8>)
 80121f6:	47a0      	blx	r4
						return 1; // command taken
 80121f8:	e609      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 80121fa:	f7fe fcab 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 80121fe:	2800      	cmp	r0, #0
 8012200:	da02      	bge.n	8012208 <KEYBOARD_TerminalParseLine+0x450>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 8012202:	4858      	ldr	r0, [pc, #352]	@ (8012364 <KEYBOARD_TerminalParseLine+0x5ac>)
 8012204:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012206:	e602      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->scan_velocity = on_off;
 8012208:	4b4b      	ldr	r3, [pc, #300]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
 801220a:	7b5a      	ldrb	r2, [r3, #13]
 801220c:	f360 0282 	bfi	r2, r0, #2, #1
 8012210:	735a      	strb	r2, [r3, #13]
						out("Keyboard #%d: velocity mode %s", kb + 1, on_off ? "enabled" : "disabled");
 8012212:	4855      	ldr	r0, [pc, #340]	@ (8012368 <KEYBOARD_TerminalParseLine+0x5b0>)
 8012214:	bf14      	ite	ne
 8012216:	4a55      	ldrne	r2, [pc, #340]	@ (801236c <KEYBOARD_TerminalParseLine+0x5b4>)
 8012218:	4a55      	ldreq	r2, [pc, #340]	@ (8012370 <KEYBOARD_TerminalParseLine+0x5b8>)
 801221a:	2101      	movs	r1, #1
 801221c:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 801221e:	2001      	movs	r0, #1
 8012220:	f7fe fd50 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8012224:	e5f3      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "release_velocity") == 0) {
 8012226:	4953      	ldr	r1, [pc, #332]	@ (8012374 <KEYBOARD_TerminalParseLine+0x5bc>)
 8012228:	4628      	mov	r0, r5
 801222a:	f011 f9ee 	bl	802360a <strcmp>
 801222e:	b9e8      	cbnz	r0, 801226c <KEYBOARD_TerminalParseLine+0x4b4>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012230:	493e      	ldr	r1, [pc, #248]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 8012232:	466a      	mov	r2, sp
 8012234:	f011 f9e6 	bl	8023604 <strtok_r>
 8012238:	b910      	cbnz	r0, 8012240 <KEYBOARD_TerminalParseLine+0x488>
						out("Please specify on or off (alternatively 1 or 0)");
 801223a:	4849      	ldr	r0, [pc, #292]	@ (8012360 <KEYBOARD_TerminalParseLine+0x5a8>)
 801223c:	47a0      	blx	r4
						return 1; // command taken
 801223e:	e5e6      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 8012240:	f7fe fc88 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 8012244:	2800      	cmp	r0, #0
 8012246:	da02      	bge.n	801224e <KEYBOARD_TerminalParseLine+0x496>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 8012248:	4846      	ldr	r0, [pc, #280]	@ (8012364 <KEYBOARD_TerminalParseLine+0x5ac>)
 801224a:	47a0      	blx	r4
	if (!input_line_parsed) {
 801224c:	e5df      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->scan_release_velocity = on_off;
 801224e:	4b3a      	ldr	r3, [pc, #232]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
 8012250:	7b5a      	ldrb	r2, [r3, #13]
 8012252:	f360 1204 	bfi	r2, r0, #4, #1
 8012256:	735a      	strb	r2, [r3, #13]
						out("Keyboard #%d: release velocity mode %s", kb + 1, on_off ? "enabled" : "disabled");
 8012258:	4847      	ldr	r0, [pc, #284]	@ (8012378 <KEYBOARD_TerminalParseLine+0x5c0>)
 801225a:	bf14      	ite	ne
 801225c:	4a43      	ldrne	r2, [pc, #268]	@ (801236c <KEYBOARD_TerminalParseLine+0x5b4>)
 801225e:	4a44      	ldreq	r2, [pc, #272]	@ (8012370 <KEYBOARD_TerminalParseLine+0x5b8>)
 8012260:	2101      	movs	r1, #1
 8012262:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012264:	2001      	movs	r0, #1
 8012266:	f7fe fd2d 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 801226a:	e5d0      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "optimized") == 0) {
 801226c:	4943      	ldr	r1, [pc, #268]	@ (801237c <KEYBOARD_TerminalParseLine+0x5c4>)
 801226e:	4628      	mov	r0, r5
 8012270:	f011 f9cb 	bl	802360a <strcmp>
 8012274:	b9e8      	cbnz	r0, 80122b2 <KEYBOARD_TerminalParseLine+0x4fa>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012276:	492d      	ldr	r1, [pc, #180]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 8012278:	466a      	mov	r2, sp
 801227a:	f011 f9c3 	bl	8023604 <strtok_r>
 801227e:	b910      	cbnz	r0, 8012286 <KEYBOARD_TerminalParseLine+0x4ce>
						out("Please specify on or off (alternatively 1 or 0)");
 8012280:	4837      	ldr	r0, [pc, #220]	@ (8012360 <KEYBOARD_TerminalParseLine+0x5a8>)
 8012282:	47a0      	blx	r4
						return 1; // command taken
 8012284:	e5c3      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 8012286:	f7fe fc65 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 801228a:	2800      	cmp	r0, #0
 801228c:	da02      	bge.n	8012294 <KEYBOARD_TerminalParseLine+0x4dc>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 801228e:	4835      	ldr	r0, [pc, #212]	@ (8012364 <KEYBOARD_TerminalParseLine+0x5ac>)
 8012290:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012292:	e5bc      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->scan_optimized = on_off;
 8012294:	4b28      	ldr	r3, [pc, #160]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
 8012296:	7b5a      	ldrb	r2, [r3, #13]
 8012298:	f360 02c3 	bfi	r2, r0, #3, #1
 801229c:	735a      	strb	r2, [r3, #13]
						out("Keyboard #%d: optimized scan %s", kb + 1, on_off ? "enabled" : "disabled");
 801229e:	4838      	ldr	r0, [pc, #224]	@ (8012380 <KEYBOARD_TerminalParseLine+0x5c8>)
 80122a0:	bf14      	ite	ne
 80122a2:	4a32      	ldrne	r2, [pc, #200]	@ (801236c <KEYBOARD_TerminalParseLine+0x5b4>)
 80122a4:	4a32      	ldreq	r2, [pc, #200]	@ (8012370 <KEYBOARD_TerminalParseLine+0x5b8>)
 80122a6:	2101      	movs	r1, #1
 80122a8:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 80122aa:	2001      	movs	r0, #1
 80122ac:	f7fe fd0a 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 80122b0:	e5ad      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "din_inverted") == 0) {
 80122b2:	4934      	ldr	r1, [pc, #208]	@ (8012384 <KEYBOARD_TerminalParseLine+0x5cc>)
 80122b4:	4628      	mov	r0, r5
 80122b6:	f011 f9a8 	bl	802360a <strcmp>
 80122ba:	bb00      	cbnz	r0, 80122fe <KEYBOARD_TerminalParseLine+0x546>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80122bc:	491b      	ldr	r1, [pc, #108]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 80122be:	466a      	mov	r2, sp
 80122c0:	f011 f9a0 	bl	8023604 <strtok_r>
 80122c4:	b910      	cbnz	r0, 80122cc <KEYBOARD_TerminalParseLine+0x514>
						out("Please specify on or off (alternatively 1 or 0)");
 80122c6:	4826      	ldr	r0, [pc, #152]	@ (8012360 <KEYBOARD_TerminalParseLine+0x5a8>)
 80122c8:	47a0      	blx	r4
						return 1; // command taken
 80122ca:	e5a0      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 80122cc:	f7fe fc42 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 80122d0:	2800      	cmp	r0, #0
 80122d2:	da02      	bge.n	80122da <KEYBOARD_TerminalParseLine+0x522>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 80122d4:	4823      	ldr	r0, [pc, #140]	@ (8012364 <KEYBOARD_TerminalParseLine+0x5ac>)
 80122d6:	47a0      	blx	r4
	if (!input_line_parsed) {
 80122d8:	e599      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->din_inverted = on_off;
 80122da:	4a17      	ldr	r2, [pc, #92]	@ (8012338 <KEYBOARD_TerminalParseLine+0x580>)
 80122dc:	7b53      	ldrb	r3, [r2, #13]
 80122de:	f360 0300 	bfi	r3, r0, #0, #1
						out("Keyboard #%d: DIN values are %sinverted", kb + 1, kc->din_inverted ? "" : "not ");
 80122e2:	f013 0f01 	tst.w	r3, #1
						kc->din_inverted = on_off;
 80122e6:	7353      	strb	r3, [r2, #13]
						out("Keyboard #%d: DIN values are %sinverted", kb + 1, kc->din_inverted ? "" : "not ");
 80122e8:	4b27      	ldr	r3, [pc, #156]	@ (8012388 <KEYBOARD_TerminalParseLine+0x5d0>)
 80122ea:	4a28      	ldr	r2, [pc, #160]	@ (801238c <KEYBOARD_TerminalParseLine+0x5d4>)
 80122ec:	4828      	ldr	r0, [pc, #160]	@ (8012390 <KEYBOARD_TerminalParseLine+0x5d8>)
 80122ee:	bf18      	it	ne
 80122f0:	461a      	movne	r2, r3
 80122f2:	2101      	movs	r1, #1
 80122f4:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 80122f6:	2001      	movs	r0, #1
 80122f8:	f7fe fce4 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 80122fc:	e587      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "break_inverted") == 0) {
 80122fe:	4925      	ldr	r1, [pc, #148]	@ (8012394 <KEYBOARD_TerminalParseLine+0x5dc>)
 8012300:	4628      	mov	r0, r5
 8012302:	f011 f982 	bl	802360a <strcmp>
 8012306:	2800      	cmp	r0, #0
 8012308:	d158      	bne.n	80123bc <KEYBOARD_TerminalParseLine+0x604>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 801230a:	4908      	ldr	r1, [pc, #32]	@ (801232c <KEYBOARD_TerminalParseLine+0x574>)
 801230c:	466a      	mov	r2, sp
 801230e:	f011 f979 	bl	8023604 <strtok_r>
 8012312:	b910      	cbnz	r0, 801231a <KEYBOARD_TerminalParseLine+0x562>
						out("Please specify on or off (alternatively 1 or 0)");
 8012314:	4812      	ldr	r0, [pc, #72]	@ (8012360 <KEYBOARD_TerminalParseLine+0x5a8>)
 8012316:	47a0      	blx	r4
						return 1; // command taken
 8012318:	e579      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 801231a:	f7fe fc1b 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 801231e:	2800      	cmp	r0, #0
 8012320:	da3a      	bge.n	8012398 <KEYBOARD_TerminalParseLine+0x5e0>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 8012322:	4810      	ldr	r0, [pc, #64]	@ (8012364 <KEYBOARD_TerminalParseLine+0x5ac>)
 8012324:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012326:	e572      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
 8012328:	080258e2 	.word	0x080258e2
 801232c:	080237ba 	.word	0x080237ba
 8012330:	080258eb 	.word	0x080258eb
 8012334:	08025938 	.word	0x08025938
 8012338:	20000370 	.word	0x20000370
 801233c:	08025975 	.word	0x08025975
 8012340:	0802599c 	.word	0x0802599c
 8012344:	080259a5 	.word	0x080259a5
 8012348:	080259cc 	.word	0x080259cc
 801234c:	080259d4 	.word	0x080259d4
 8012350:	08025a20 	.word	0x08025a20
 8012354:	08025a46 	.word	0x08025a46
 8012358:	08025a4e 	.word	0x08025a4e
 801235c:	080241e5 	.word	0x080241e5
 8012360:	080257dd 	.word	0x080257dd
 8012364:	0802580d 	.word	0x0802580d
 8012368:	08025a74 	.word	0x08025a74
 801236c:	080254bd 	.word	0x080254bd
 8012370:	080254c5 	.word	0x080254c5
 8012374:	08025a93 	.word	0x08025a93
 8012378:	08025aa4 	.word	0x08025aa4
 801237c:	08025acb 	.word	0x08025acb
 8012380:	08025ad5 	.word	0x08025ad5
 8012384:	08025af5 	.word	0x08025af5
 8012388:	080237bc 	.word	0x080237bc
 801238c:	080254ce 	.word	0x080254ce
 8012390:	08025b02 	.word	0x08025b02
 8012394:	08025b2a 	.word	0x08025b2a
						kc->break_inverted = on_off;
 8012398:	4a92      	ldr	r2, [pc, #584]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
 801239a:	7b53      	ldrb	r3, [r2, #13]
 801239c:	f360 0341 	bfi	r3, r0, #1, #1
						out("Keyboard #%d: Break contacts are %sinverted", kb + 1, kc->break_inverted ? "" : "not ");
 80123a0:	f013 0f02 	tst.w	r3, #2
						kc->break_inverted = on_off;
 80123a4:	7353      	strb	r3, [r2, #13]
						out("Keyboard #%d: Break contacts are %sinverted", kb + 1, kc->break_inverted ? "" : "not ");
 80123a6:	4b90      	ldr	r3, [pc, #576]	@ (80125e8 <KEYBOARD_TerminalParseLine+0x830>)
 80123a8:	4a90      	ldr	r2, [pc, #576]	@ (80125ec <KEYBOARD_TerminalParseLine+0x834>)
 80123aa:	4891      	ldr	r0, [pc, #580]	@ (80125f0 <KEYBOARD_TerminalParseLine+0x838>)
 80123ac:	bf18      	it	ne
 80123ae:	461a      	movne	r2, r3
 80123b0:	2101      	movs	r1, #1
 80123b2:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 80123b4:	2001      	movs	r0, #1
 80123b6:	f7fe fc85 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 80123ba:	e528      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "make_debounced") == 0) {
 80123bc:	498d      	ldr	r1, [pc, #564]	@ (80125f4 <KEYBOARD_TerminalParseLine+0x83c>)
 80123be:	4628      	mov	r0, r5
 80123c0:	f011 f923 	bl	802360a <strcmp>
 80123c4:	bb00      	cbnz	r0, 8012408 <KEYBOARD_TerminalParseLine+0x650>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80123c6:	498c      	ldr	r1, [pc, #560]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 80123c8:	466a      	mov	r2, sp
 80123ca:	f011 f91b 	bl	8023604 <strtok_r>
 80123ce:	b910      	cbnz	r0, 80123d6 <KEYBOARD_TerminalParseLine+0x61e>
						out("Please specify on or off (alternatively 1 or 0)");
 80123d0:	488a      	ldr	r0, [pc, #552]	@ (80125fc <KEYBOARD_TerminalParseLine+0x844>)
 80123d2:	47a0      	blx	r4
						return 1; // command taken
 80123d4:	e51b      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int on_off = get_on_off(parameter);
 80123d6:	f7fe fbbd 	bl	8010b54 <get_on_off>
					if (on_off < 0) {
 80123da:	2800      	cmp	r0, #0
 80123dc:	da02      	bge.n	80123e4 <KEYBOARD_TerminalParseLine+0x62c>
						out("Expecting 'on' or 'off' (alternatively 1 or 0)!");
 80123de:	4888      	ldr	r0, [pc, #544]	@ (8012600 <KEYBOARD_TerminalParseLine+0x848>)
 80123e0:	47a0      	blx	r4
	if (!input_line_parsed) {
 80123e2:	e514      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->make_debounced = on_off;
 80123e4:	4a7f      	ldr	r2, [pc, #508]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
 80123e6:	7b53      	ldrb	r3, [r2, #13]
 80123e8:	f360 1345 	bfi	r3, r0, #5, #1
						out("Keyboard #%d: Make contact debouncing %s", kb + 1, kc->make_debounced ? "on" : "off");
 80123ec:	f013 0f20 	tst.w	r3, #32
						kc->make_debounced = on_off;
 80123f0:	7353      	strb	r3, [r2, #13]
						out("Keyboard #%d: Make contact debouncing %s", kb + 1, kc->make_debounced ? "on" : "off");
 80123f2:	4b84      	ldr	r3, [pc, #528]	@ (8012604 <KEYBOARD_TerminalParseLine+0x84c>)
 80123f4:	4a84      	ldr	r2, [pc, #528]	@ (8012608 <KEYBOARD_TerminalParseLine+0x850>)
 80123f6:	4885      	ldr	r0, [pc, #532]	@ (801260c <KEYBOARD_TerminalParseLine+0x854>)
 80123f8:	bf18      	it	ne
 80123fa:	461a      	movne	r2, r3
 80123fc:	2101      	movs	r1, #1
 80123fe:	47a0      	blx	r4
						KEYBOARD_Init(1); // re-init runtime variables, don't touch configuration
 8012400:	2001      	movs	r0, #1
 8012402:	f7fe fc5f 	bl	8010cc4 <KEYBOARD_Init>
	if (!input_line_parsed) {
 8012406:	e502      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_fastest") == 0) {
 8012408:	4981      	ldr	r1, [pc, #516]	@ (8012610 <KEYBOARD_TerminalParseLine+0x858>)
 801240a:	4628      	mov	r0, r5
 801240c:	f011 f8fd 	bl	802360a <strcmp>
 8012410:	b9b0      	cbnz	r0, 8012440 <KEYBOARD_TerminalParseLine+0x688>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012412:	4979      	ldr	r1, [pc, #484]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 8012414:	466a      	mov	r2, sp
 8012416:	f011 f8f5 	bl	8023604 <strtok_r>
 801241a:	b910      	cbnz	r0, 8012422 <KEYBOARD_TerminalParseLine+0x66a>
						out("Please specify the fastest delay for velocity calculation!");
 801241c:	487d      	ldr	r0, [pc, #500]	@ (8012614 <KEYBOARD_TerminalParseLine+0x85c>)
 801241e:	47a0      	blx	r4
						return 1; // command taken
 8012420:	e4f5      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 8012422:	f7fe fb87 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 8012426:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 801242a:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 801242c:	d302      	bcc.n	8012434 <KEYBOARD_TerminalParseLine+0x67c>
						out("Delay should be in the range between 0 and 65535");
 801242e:	487a      	ldr	r0, [pc, #488]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 8012430:	47a0      	blx	r4
						return 1; // command taken
 8012432:	e4ec      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_fastest = delay;
 8012434:	4b6b      	ldr	r3, [pc, #428]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_fastest set to %d!", kb + 1, kc->delay_fastest);
 8012436:	2101      	movs	r1, #1
						kc->delay_fastest = delay;
 8012438:	81d8      	strh	r0, [r3, #14]
						out("Keyboard #%d: delay_fastest set to %d!", kb + 1, kc->delay_fastest);
 801243a:	4878      	ldr	r0, [pc, #480]	@ (801261c <KEYBOARD_TerminalParseLine+0x864>)
 801243c:	47a0      	blx	r4
	if (!input_line_parsed) {
 801243e:	e4e6      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_fastest_black_keys") == 0) {
 8012440:	4977      	ldr	r1, [pc, #476]	@ (8012620 <KEYBOARD_TerminalParseLine+0x868>)
 8012442:	4628      	mov	r0, r5
 8012444:	f011 f8e1 	bl	802360a <strcmp>
 8012448:	b9b0      	cbnz	r0, 8012478 <KEYBOARD_TerminalParseLine+0x6c0>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 801244a:	496b      	ldr	r1, [pc, #428]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 801244c:	466a      	mov	r2, sp
 801244e:	f011 f8d9 	bl	8023604 <strtok_r>
 8012452:	b910      	cbnz	r0, 801245a <KEYBOARD_TerminalParseLine+0x6a2>
						out("Please specify the fastest delay for the black keys!");
 8012454:	4873      	ldr	r0, [pc, #460]	@ (8012624 <KEYBOARD_TerminalParseLine+0x86c>)
 8012456:	47a0      	blx	r4
						return 1; // command taken
 8012458:	e4d9      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 801245a:	f7fe fb6b 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 801245e:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 8012462:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 8012464:	d302      	bcc.n	801246c <KEYBOARD_TerminalParseLine+0x6b4>
						out("Delay should be in the range between 0 and 65535");
 8012466:	486c      	ldr	r0, [pc, #432]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 8012468:	47a0      	blx	r4
						return 1; // command taken
 801246a:	e4d0      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_fastest_black_keys = delay;
 801246c:	4b5d      	ldr	r3, [pc, #372]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_fastest_black_keys set to %d!", kb + 1, kc->delay_fastest_black_keys);
 801246e:	2101      	movs	r1, #1
						kc->delay_fastest_black_keys = delay;
 8012470:	8218      	strh	r0, [r3, #16]
						out("Keyboard #%d: delay_fastest_black_keys set to %d!", kb + 1, kc->delay_fastest_black_keys);
 8012472:	486d      	ldr	r0, [pc, #436]	@ (8012628 <KEYBOARD_TerminalParseLine+0x870>)
 8012474:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012476:	e4ca      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_fastest_release") == 0) {
 8012478:	496c      	ldr	r1, [pc, #432]	@ (801262c <KEYBOARD_TerminalParseLine+0x874>)
 801247a:	4628      	mov	r0, r5
 801247c:	f011 f8c5 	bl	802360a <strcmp>
 8012480:	b9b0      	cbnz	r0, 80124b0 <KEYBOARD_TerminalParseLine+0x6f8>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012482:	495d      	ldr	r1, [pc, #372]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 8012484:	466a      	mov	r2, sp
 8012486:	f011 f8bd 	bl	8023604 <strtok_r>
 801248a:	b910      	cbnz	r0, 8012492 <KEYBOARD_TerminalParseLine+0x6da>
						out("Please specify the fastest delay for release velocity calculation!");
 801248c:	4868      	ldr	r0, [pc, #416]	@ (8012630 <KEYBOARD_TerminalParseLine+0x878>)
 801248e:	47a0      	blx	r4
						return 1; // command taken
 8012490:	e4bd      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 8012492:	f7fe fb4f 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 8012496:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 801249a:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 801249c:	d302      	bcc.n	80124a4 <KEYBOARD_TerminalParseLine+0x6ec>
						out("Delay should be in the range between 0 and 65535");
 801249e:	485e      	ldr	r0, [pc, #376]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 80124a0:	47a0      	blx	r4
						return 1; // command taken
 80124a2:	e4b4      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_fastest_release = delay;
 80124a4:	4b4f      	ldr	r3, [pc, #316]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_fastest_release set to %d!", kb + 1, kc->delay_fastest_release);
 80124a6:	2101      	movs	r1, #1
						kc->delay_fastest_release = delay;
 80124a8:	8258      	strh	r0, [r3, #18]
						out("Keyboard #%d: delay_fastest_release set to %d!", kb + 1, kc->delay_fastest_release);
 80124aa:	4862      	ldr	r0, [pc, #392]	@ (8012634 <KEYBOARD_TerminalParseLine+0x87c>)
 80124ac:	47a0      	blx	r4
	if (!input_line_parsed) {
 80124ae:	e4ae      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_fastest_release_black_keys") == 0) {
 80124b0:	4961      	ldr	r1, [pc, #388]	@ (8012638 <KEYBOARD_TerminalParseLine+0x880>)
 80124b2:	4628      	mov	r0, r5
 80124b4:	f011 f8a9 	bl	802360a <strcmp>
 80124b8:	b9b0      	cbnz	r0, 80124e8 <KEYBOARD_TerminalParseLine+0x730>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80124ba:	494f      	ldr	r1, [pc, #316]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 80124bc:	466a      	mov	r2, sp
 80124be:	f011 f8a1 	bl	8023604 <strtok_r>
 80124c2:	b910      	cbnz	r0, 80124ca <KEYBOARD_TerminalParseLine+0x712>
						out("Please specify the fastest delay for release of black keys!");
 80124c4:	485d      	ldr	r0, [pc, #372]	@ (801263c <KEYBOARD_TerminalParseLine+0x884>)
 80124c6:	47a0      	blx	r4
						return 1; // command taken
 80124c8:	e4a1      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 80124ca:	f7fe fb33 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 80124ce:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 80124d2:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 80124d4:	d302      	bcc.n	80124dc <KEYBOARD_TerminalParseLine+0x724>
						out("Delay should be in the range between 0 and 65535");
 80124d6:	4850      	ldr	r0, [pc, #320]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 80124d8:	47a0      	blx	r4
						return 1; // command taken
 80124da:	e498      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_fastest_release_black_keys = delay;
 80124dc:	4b41      	ldr	r3, [pc, #260]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_fastest_release_black_keys set to %d!", kb + 1, kc->delay_fastest_release_black_keys);
 80124de:	2101      	movs	r1, #1
						kc->delay_fastest_release_black_keys = delay;
 80124e0:	8298      	strh	r0, [r3, #20]
						out("Keyboard #%d: delay_fastest_release_black_keys set to %d!", kb + 1, kc->delay_fastest_release_black_keys);
 80124e2:	4857      	ldr	r0, [pc, #348]	@ (8012640 <KEYBOARD_TerminalParseLine+0x888>)
 80124e4:	47a0      	blx	r4
	if (!input_line_parsed) {
 80124e6:	e492      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_slowest") == 0) {
 80124e8:	4956      	ldr	r1, [pc, #344]	@ (8012644 <KEYBOARD_TerminalParseLine+0x88c>)
 80124ea:	4628      	mov	r0, r5
 80124ec:	f011 f88d 	bl	802360a <strcmp>
 80124f0:	b9b0      	cbnz	r0, 8012520 <KEYBOARD_TerminalParseLine+0x768>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80124f2:	4941      	ldr	r1, [pc, #260]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 80124f4:	466a      	mov	r2, sp
 80124f6:	f011 f885 	bl	8023604 <strtok_r>
 80124fa:	b910      	cbnz	r0, 8012502 <KEYBOARD_TerminalParseLine+0x74a>
						out("Please specify the slowest delay for velocity calculation!");
 80124fc:	4852      	ldr	r0, [pc, #328]	@ (8012648 <KEYBOARD_TerminalParseLine+0x890>)
 80124fe:	47a0      	blx	r4
						return 1; // command taken
 8012500:	e485      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 8012502:	f7fe fb17 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 8012506:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 801250a:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 801250c:	d302      	bcc.n	8012514 <KEYBOARD_TerminalParseLine+0x75c>
						out("Delay should be in the range between 0 and 65535");
 801250e:	4842      	ldr	r0, [pc, #264]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 8012510:	47a0      	blx	r4
						return 1; // command taken
 8012512:	e47c      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_slowest = delay;
 8012514:	4b33      	ldr	r3, [pc, #204]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_slowest set to %d!", kb + 1, kc->delay_slowest);
 8012516:	2101      	movs	r1, #1
						kc->delay_slowest = delay;
 8012518:	82d8      	strh	r0, [r3, #22]
						out("Keyboard #%d: delay_slowest set to %d!", kb + 1, kc->delay_slowest);
 801251a:	484c      	ldr	r0, [pc, #304]	@ (801264c <KEYBOARD_TerminalParseLine+0x894>)
 801251c:	47a0      	blx	r4
	if (!input_line_parsed) {
 801251e:	e476      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "delay_slowest_release") == 0) {
 8012520:	494b      	ldr	r1, [pc, #300]	@ (8012650 <KEYBOARD_TerminalParseLine+0x898>)
 8012522:	4628      	mov	r0, r5
 8012524:	f011 f871 	bl	802360a <strcmp>
 8012528:	b9b0      	cbnz	r0, 8012558 <KEYBOARD_TerminalParseLine+0x7a0>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 801252a:	4933      	ldr	r1, [pc, #204]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 801252c:	466a      	mov	r2, sp
 801252e:	f011 f869 	bl	8023604 <strtok_r>
 8012532:	b910      	cbnz	r0, 801253a <KEYBOARD_TerminalParseLine+0x782>
						out("Please specify the slowest release delay for velocity calculation!");
 8012534:	4847      	ldr	r0, [pc, #284]	@ (8012654 <KEYBOARD_TerminalParseLine+0x89c>)
 8012536:	47a0      	blx	r4
						return 1; // command taken
 8012538:	e469      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int delay = get_dec(parameter);
 801253a:	f7fe fafb 	bl	8010b34 <get_dec>
					if (delay < 0 || delay > 65535) {
 801253e:	f5b0 3f80 	cmp.w	r0, #65536	@ 0x10000
					int delay = get_dec(parameter);
 8012542:	4602      	mov	r2, r0
					if (delay < 0 || delay > 65535) {
 8012544:	d302      	bcc.n	801254c <KEYBOARD_TerminalParseLine+0x794>
						out("Delay should be in the range between 0 and 65535");
 8012546:	4834      	ldr	r0, [pc, #208]	@ (8012618 <KEYBOARD_TerminalParseLine+0x860>)
 8012548:	47a0      	blx	r4
						return 1; // command taken
 801254a:	e460      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->delay_slowest_release = delay;
 801254c:	4b25      	ldr	r3, [pc, #148]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: delay_slowest_release set to %d!", kb + 1, kc->delay_slowest_release);
 801254e:	2101      	movs	r1, #1
						kc->delay_slowest_release = delay;
 8012550:	8318      	strh	r0, [r3, #24]
						out("Keyboard #%d: delay_slowest_release set to %d!", kb + 1, kc->delay_slowest_release);
 8012552:	4841      	ldr	r0, [pc, #260]	@ (8012658 <KEYBOARD_TerminalParseLine+0x8a0>)
 8012554:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012556:	e45a      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split_mode") == 0) {
 8012558:	4940      	ldr	r1, [pc, #256]	@ (801265c <KEYBOARD_TerminalParseLine+0x8a4>)
 801255a:	4628      	mov	r0, r5
 801255c:	f011 f855 	bl	802360a <strcmp>
 8012560:	b9a0      	cbnz	r0, 801258c <KEYBOARD_TerminalParseLine+0x7d4>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012562:	4925      	ldr	r1, [pc, #148]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 8012564:	466a      	mov	r2, sp
 8012566:	f011 f84d 	bl	8023604 <strtok_r>
 801256a:	b910      	cbnz	r0, 8012572 <KEYBOARD_TerminalParseLine+0x7ba>
						out("Please enter split_mode 0=OFF, 1=TWO-SPLIT, 2=THREE-SPLIT");
 801256c:	483c      	ldr	r0, [pc, #240]	@ (8012660 <KEYBOARD_TerminalParseLine+0x8a8>)
 801256e:	47a0      	blx	r4
						return 1; // command taken
 8012570:	e44d      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int split_mode = get_dec(parameter);
 8012572:	f7fe fadf 	bl	8010b34 <get_dec>
					if ((split_mode >= 0) && (split_mode <= KEYBOARD_SPLIT_MODE_THREE)){
 8012576:	2802      	cmp	r0, #2
					int split_mode = get_dec(parameter);
 8012578:	4602      	mov	r2, r0
					if ((split_mode >= 0) && (split_mode <= KEYBOARD_SPLIT_MODE_THREE)){
 801257a:	f63f ac48 	bhi.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->split_mode = split_mode;
 801257e:	4b19      	ldr	r3, [pc, #100]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: split mode set to %d!", kb + 1, kc->split_mode);
 8012580:	2101      	movs	r1, #1
						kc->split_mode = split_mode;
 8012582:	f883 0146 	strb.w	r0, [r3, #326]	@ 0x146
						out("Keyboard #%d: split mode set to %d!", kb + 1, kc->split_mode);
 8012586:	4837      	ldr	r0, [pc, #220]	@ (8012664 <KEYBOARD_TerminalParseLine+0x8ac>)
 8012588:	47a0      	blx	r4
	if (!input_line_parsed) {
 801258a:	e440      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split2_middle") == 0) {
 801258c:	4936      	ldr	r1, [pc, #216]	@ (8012668 <KEYBOARD_TerminalParseLine+0x8b0>)
 801258e:	4628      	mov	r0, r5
 8012590:	f011 f83b 	bl	802360a <strcmp>
 8012594:	b9b8      	cbnz	r0, 80125c6 <KEYBOARD_TerminalParseLine+0x80e>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012596:	4918      	ldr	r1, [pc, #96]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 8012598:	466a      	mov	r2, sp
 801259a:	f011 f833 	bl	8023604 <strtok_r>
 801259e:	b910      	cbnz	r0, 80125a6 <KEYBOARD_TerminalParseLine+0x7ee>
						out("Please specify midi note numbe for the two split point");
 80125a0:	4832      	ldr	r0, [pc, #200]	@ (801266c <KEYBOARD_TerminalParseLine+0x8b4>)
 80125a2:	47a0      	blx	r4
						return 1; // command taken
 80125a4:	e433      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int split_point = get_dec(parameter);
 80125a6:	f7fe fac5 	bl	8010b34 <get_dec>
					if (split_point <= 0 || split_point >= 126) {
 80125aa:	1e43      	subs	r3, r0, #1
 80125ac:	2b7c      	cmp	r3, #124	@ 0x7c
					int split_point = get_dec(parameter);
 80125ae:	4602      	mov	r2, r0
					if (split_point <= 0 || split_point >= 126) {
 80125b0:	d902      	bls.n	80125b8 <KEYBOARD_TerminalParseLine+0x800>
						out("Split must be valid note number from 1 to 126");
 80125b2:	482f      	ldr	r0, [pc, #188]	@ (8012670 <KEYBOARD_TerminalParseLine+0x8b8>)
 80125b4:	47a0      	blx	r4
						return 1; // command taken
 80125b6:	e42a      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->two_split_middle_note_number = split_point;
 80125b8:	4b0a      	ldr	r3, [pc, #40]	@ (80125e4 <KEYBOARD_TerminalParseLine+0x82c>)
						out("Keyboard #%d: split2_middle set to %d!", kb + 1, kc->two_split_middle_note_number);
 80125ba:	2101      	movs	r1, #1
						kc->two_split_middle_note_number = split_point;
 80125bc:	f883 0147 	strb.w	r0, [r3, #327]	@ 0x147
						out("Keyboard #%d: split2_middle set to %d!", kb + 1, kc->two_split_middle_note_number);
 80125c0:	482c      	ldr	r0, [pc, #176]	@ (8012674 <KEYBOARD_TerminalParseLine+0x8bc>)
 80125c2:	47a0      	blx	r4
	if (!input_line_parsed) {
 80125c4:	e423      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split2_right_shift") == 0) {
 80125c6:	492c      	ldr	r1, [pc, #176]	@ (8012678 <KEYBOARD_TerminalParseLine+0x8c0>)
 80125c8:	4628      	mov	r0, r5
 80125ca:	f011 f81e 	bl	802360a <strcmp>
 80125ce:	2800      	cmp	r0, #0
 80125d0:	d161      	bne.n	8012696 <KEYBOARD_TerminalParseLine+0x8de>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80125d2:	4909      	ldr	r1, [pc, #36]	@ (80125f8 <KEYBOARD_TerminalParseLine+0x840>)
 80125d4:	466a      	mov	r2, sp
 80125d6:	f011 f815 	bl	8023604 <strtok_r>
 80125da:	2800      	cmp	r0, #0
 80125dc:	d150      	bne.n	8012680 <KEYBOARD_TerminalParseLine+0x8c8>
						out("Please specify +/- shift for split two right side shift");
 80125de:	4827      	ldr	r0, [pc, #156]	@ (801267c <KEYBOARD_TerminalParseLine+0x8c4>)
 80125e0:	47a0      	blx	r4
						return 1; // command taken
 80125e2:	e414      	b.n	8011e0e <KEYBOARD_TerminalParseLine+0x56>
 80125e4:	20000370 	.word	0x20000370
 80125e8:	080237bc 	.word	0x080237bc
 80125ec:	080254ce 	.word	0x080254ce
 80125f0:	08025b39 	.word	0x08025b39
 80125f4:	08025b65 	.word	0x08025b65
 80125f8:	080237ba 	.word	0x080237ba
 80125fc:	080257dd 	.word	0x080257dd
 8012600:	0802580d 	.word	0x0802580d
 8012604:	08024c4d 	.word	0x08024c4d
 8012608:	0802531e 	.word	0x0802531e
 801260c:	08025b74 	.word	0x08025b74
 8012610:	08025b9d 	.word	0x08025b9d
 8012614:	08025bab 	.word	0x08025bab
 8012618:	08025be6 	.word	0x08025be6
 801261c:	08025c17 	.word	0x08025c17
 8012620:	08025c3e 	.word	0x08025c3e
 8012624:	08025c57 	.word	0x08025c57
 8012628:	08025c8c 	.word	0x08025c8c
 801262c:	08025cbe 	.word	0x08025cbe
 8012630:	08025cd4 	.word	0x08025cd4
 8012634:	08025d17 	.word	0x08025d17
 8012638:	08025d46 	.word	0x08025d46
 801263c:	08025d67 	.word	0x08025d67
 8012640:	08025da3 	.word	0x08025da3
 8012644:	08025ddd 	.word	0x08025ddd
 8012648:	08025deb 	.word	0x08025deb
 801264c:	08025e26 	.word	0x08025e26
 8012650:	08025e4d 	.word	0x08025e4d
 8012654:	08025e63 	.word	0x08025e63
 8012658:	08025ea6 	.word	0x08025ea6
 801265c:	08025ed5 	.word	0x08025ed5
 8012660:	08025ee0 	.word	0x08025ee0
 8012664:	08025f1a 	.word	0x08025f1a
 8012668:	08025f3e 	.word	0x08025f3e
 801266c:	08025f4c 	.word	0x08025f4c
 8012670:	08025f83 	.word	0x08025f83
 8012674:	08025fb1 	.word	0x08025fb1
 8012678:	08025fd8 	.word	0x08025fd8
 801267c:	08025feb 	.word	0x08025feb
					int shift = get_dec(parameter);
 8012680:	f7fe fa58 	bl	8010b34 <get_dec>
					kc->two_split_right_shift = shift;
 8012684:	4ba2      	ldr	r3, [pc, #648]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
 8012686:	b242      	sxtb	r2, r0
 8012688:	f883 2148 	strb.w	r2, [r3, #328]	@ 0x148
					out("Keyboard #%d: split2_right_shift set to %d!", kb + 1, kc->two_split_right_shift);
 801268c:	48a1      	ldr	r0, [pc, #644]	@ (8012914 <KEYBOARD_TerminalParseLine+0xb5c>)
 801268e:	2101      	movs	r1, #1
 8012690:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012692:	f7ff bbbc 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split3_left_shift") == 0) {
 8012696:	49a0      	ldr	r1, [pc, #640]	@ (8012918 <KEYBOARD_TerminalParseLine+0xb60>)
 8012698:	4628      	mov	r0, r5
 801269a:	f010 ffb6 	bl	802360a <strcmp>
 801269e:	b998      	cbnz	r0, 80126c8 <KEYBOARD_TerminalParseLine+0x910>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80126a0:	499e      	ldr	r1, [pc, #632]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 80126a2:	466a      	mov	r2, sp
 80126a4:	f010 ffae 	bl	8023604 <strtok_r>
 80126a8:	b918      	cbnz	r0, 80126b2 <KEYBOARD_TerminalParseLine+0x8fa>
						out("Please specify +/- shift for split three left side shift");
 80126aa:	489d      	ldr	r0, [pc, #628]	@ (8012920 <KEYBOARD_TerminalParseLine+0xb68>)
 80126ac:	47a0      	blx	r4
						return 1; // command taken
 80126ae:	f7ff bbae 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int shift = get_dec(parameter);
 80126b2:	f7fe fa3f 	bl	8010b34 <get_dec>
					kc->three_split_left_shift = shift;
 80126b6:	4b96      	ldr	r3, [pc, #600]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
 80126b8:	b242      	sxtb	r2, r0
 80126ba:	f883 214a 	strb.w	r2, [r3, #330]	@ 0x14a
					out("Keyboard #%d: split3_left_shift set to %d!", kb + 1, kc->three_split_left_shift);
 80126be:	4899      	ldr	r0, [pc, #612]	@ (8012924 <KEYBOARD_TerminalParseLine+0xb6c>)
 80126c0:	2101      	movs	r1, #1
 80126c2:	47a0      	blx	r4
	if (!input_line_parsed) {
 80126c4:	f7ff bba3 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split3_right_shift") == 0) {
 80126c8:	4997      	ldr	r1, [pc, #604]	@ (8012928 <KEYBOARD_TerminalParseLine+0xb70>)
 80126ca:	4628      	mov	r0, r5
 80126cc:	f010 ff9d 	bl	802360a <strcmp>
 80126d0:	b998      	cbnz	r0, 80126fa <KEYBOARD_TerminalParseLine+0x942>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 80126d2:	4992      	ldr	r1, [pc, #584]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 80126d4:	466a      	mov	r2, sp
 80126d6:	f010 ff95 	bl	8023604 <strtok_r>
 80126da:	b918      	cbnz	r0, 80126e4 <KEYBOARD_TerminalParseLine+0x92c>
						out("Please specify +/- shift for split three right side shift");
 80126dc:	4893      	ldr	r0, [pc, #588]	@ (801292c <KEYBOARD_TerminalParseLine+0xb74>)
 80126de:	47a0      	blx	r4
						return 1; // command taken
 80126e0:	f7ff bb95 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int shift = get_dec(parameter);
 80126e4:	f7fe fa26 	bl	8010b34 <get_dec>
					kc->three_split_right_shift = shift;
 80126e8:	4b89      	ldr	r3, [pc, #548]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
 80126ea:	b242      	sxtb	r2, r0
 80126ec:	f883 214c 	strb.w	r2, [r3, #332]	@ 0x14c
					out("Keyboard #%d: split3_right_shift set to %d!", kb + 1, kc->three_split_right_shift);
 80126f0:	488f      	ldr	r0, [pc, #572]	@ (8012930 <KEYBOARD_TerminalParseLine+0xb78>)
 80126f2:	2101      	movs	r1, #1
 80126f4:	47a0      	blx	r4
	if (!input_line_parsed) {
 80126f6:	f7ff bb8a 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split3_left") == 0) {
 80126fa:	498e      	ldr	r1, [pc, #568]	@ (8012934 <KEYBOARD_TerminalParseLine+0xb7c>)
 80126fc:	4628      	mov	r0, r5
 80126fe:	f010 ff84 	bl	802360a <strcmp>
 8012702:	b9d0      	cbnz	r0, 801273a <KEYBOARD_TerminalParseLine+0x982>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012704:	4985      	ldr	r1, [pc, #532]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 8012706:	466a      	mov	r2, sp
 8012708:	f010 ff7c 	bl	8023604 <strtok_r>
 801270c:	b918      	cbnz	r0, 8012716 <KEYBOARD_TerminalParseLine+0x95e>
						out("Please specify midi note numbe for the left three split point");
 801270e:	488a      	ldr	r0, [pc, #552]	@ (8012938 <KEYBOARD_TerminalParseLine+0xb80>)
 8012710:	47a0      	blx	r4
						return 1; // command taken
 8012712:	f7ff bb7c 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int split_point = get_dec(parameter);
 8012716:	f7fe fa0d 	bl	8010b34 <get_dec>
					if (split_point <= 0 || split_point >= 126) {
 801271a:	1e43      	subs	r3, r0, #1
 801271c:	2b7c      	cmp	r3, #124	@ 0x7c
					int split_point = get_dec(parameter);
 801271e:	4602      	mov	r2, r0
					if (split_point <= 0 || split_point >= 126) {
 8012720:	d903      	bls.n	801272a <KEYBOARD_TerminalParseLine+0x972>
						out("Split must be valid note number from 1 to 126");
 8012722:	4886      	ldr	r0, [pc, #536]	@ (801293c <KEYBOARD_TerminalParseLine+0xb84>)
 8012724:	47a0      	blx	r4
						return 1; // command taken
 8012726:	f7ff bb72 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->three_split_left_note_number = split_point;
 801272a:	4b79      	ldr	r3, [pc, #484]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
						out("Keyboard #%d: split3 left set to %d!", kb + 1, kc->three_split_left_note_number);
 801272c:	2101      	movs	r1, #1
						kc->three_split_left_note_number = split_point;
 801272e:	f883 0149 	strb.w	r0, [r3, #329]	@ 0x149
						out("Keyboard #%d: split3 left set to %d!", kb + 1, kc->three_split_left_note_number);
 8012732:	4883      	ldr	r0, [pc, #524]	@ (8012940 <KEYBOARD_TerminalParseLine+0xb88>)
 8012734:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012736:	f7ff bb6a 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "split3_right") == 0) {
 801273a:	4982      	ldr	r1, [pc, #520]	@ (8012944 <KEYBOARD_TerminalParseLine+0xb8c>)
 801273c:	4628      	mov	r0, r5
 801273e:	f010 ff64 	bl	802360a <strcmp>
 8012742:	b9d0      	cbnz	r0, 801277a <KEYBOARD_TerminalParseLine+0x9c2>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012744:	4975      	ldr	r1, [pc, #468]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 8012746:	466a      	mov	r2, sp
 8012748:	f010 ff5c 	bl	8023604 <strtok_r>
 801274c:	b918      	cbnz	r0, 8012756 <KEYBOARD_TerminalParseLine+0x99e>
						out("Please specify midi note numbe for the right three split point");
 801274e:	487e      	ldr	r0, [pc, #504]	@ (8012948 <KEYBOARD_TerminalParseLine+0xb90>)
 8012750:	47a0      	blx	r4
						return 1; // command taken
 8012752:	f7ff bb5c 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int split_point = get_dec(parameter);
 8012756:	f7fe f9ed 	bl	8010b34 <get_dec>
					if (split_point <= 0 || split_point >= 126) {
 801275a:	1e43      	subs	r3, r0, #1
 801275c:	2b7c      	cmp	r3, #124	@ 0x7c
					int split_point = get_dec(parameter);
 801275e:	4602      	mov	r2, r0
					if (split_point <= 0 || split_point >= 126) {
 8012760:	d903      	bls.n	801276a <KEYBOARD_TerminalParseLine+0x9b2>
						out("Split must be valid note number from 1 to 126");
 8012762:	4876      	ldr	r0, [pc, #472]	@ (801293c <KEYBOARD_TerminalParseLine+0xb84>)
 8012764:	47a0      	blx	r4
						return 1; // command taken
 8012766:	f7ff bb52 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->three_split_right_note_number = split_point;
 801276a:	4b69      	ldr	r3, [pc, #420]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
						out("Keyboard #%d: split3 right set to %d!", kb + 1, kc->three_split_right_note_number);
 801276c:	2101      	movs	r1, #1
						kc->three_split_right_note_number = split_point;
 801276e:	f883 014b 	strb.w	r0, [r3, #331]	@ 0x14b
						out("Keyboard #%d: split3 right set to %d!", kb + 1, kc->three_split_right_note_number);
 8012772:	4876      	ldr	r0, [pc, #472]	@ (801294c <KEYBOARD_TerminalParseLine+0xb94>)
 8012774:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012776:	f7ff bb4a 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "key_calibration_value") == 0) {
 801277a:	4975      	ldr	r1, [pc, #468]	@ (8012950 <KEYBOARD_TerminalParseLine+0xb98>)
 801277c:	4628      	mov	r0, r5
 801277e:	f010 ff44 	bl	802360a <strcmp>
 8012782:	4606      	mov	r6, r0
 8012784:	bb40      	cbnz	r0, 80127d8 <KEYBOARD_TerminalParseLine+0xa20>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 8012786:	4965      	ldr	r1, [pc, #404]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 8012788:	466a      	mov	r2, sp
 801278a:	f010 ff3b 	bl	8023604 <strtok_r>
 801278e:	b920      	cbnz	r0, 801279a <KEYBOARD_TerminalParseLine+0x9e2>
						out("Invalid <key> value, expect 0..%d!", KEYBOARD_MAX_KEYS - 1);
 8012790:	4870      	ldr	r0, [pc, #448]	@ (8012954 <KEYBOARD_TerminalParseLine+0xb9c>)
 8012792:	217f      	movs	r1, #127	@ 0x7f
 8012794:	47a0      	blx	r4
						return 1; // command taken
 8012796:	f7ff bb3a 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						((key = get_dec(parameter)) < 0 || key >= KEYBOARD_MAX_KEYS)) {
 801279a:	f7fe f9cb 	bl	8010b34 <get_dec>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 801279e:	287f      	cmp	r0, #127	@ 0x7f
						((key = get_dec(parameter)) < 0 || key >= KEYBOARD_MAX_KEYS)) {
 80127a0:	4605      	mov	r5, r0
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 80127a2:	d8f5      	bhi.n	8012790 <KEYBOARD_TerminalParseLine+0x9d8>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 80127a4:	495d      	ldr	r1, [pc, #372]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 80127a6:	466a      	mov	r2, sp
 80127a8:	4630      	mov	r0, r6
 80127aa:	f010 ff2b 	bl	8023604 <strtok_r>
 80127ae:	b918      	cbnz	r0, 80127b8 <KEYBOARD_TerminalParseLine+0xa00>
						out("Invalid <delay> value, expect 0..65535!");
 80127b0:	4869      	ldr	r0, [pc, #420]	@ (8012958 <KEYBOARD_TerminalParseLine+0xba0>)
 80127b2:	47a0      	blx	r4
						return 1; // command taken
 80127b4:	f7ff bb2b 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						((value = get_dec(parameter)) < 0 || value >= 65535)) {
 80127b8:	f7fe f9bc 	bl	8010b34 <get_dec>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 80127bc:	f64f 73fe 	movw	r3, #65534	@ 0xfffe
 80127c0:	4298      	cmp	r0, r3
						((value = get_dec(parameter)) < 0 || value >= 65535)) {
 80127c2:	4602      	mov	r2, r0
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 80127c4:	d8f4      	bhi.n	80127b0 <KEYBOARD_TerminalParseLine+0x9f8>
					kc->delay_key[key] = value;
 80127c6:	4b52      	ldr	r3, [pc, #328]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
 80127c8:	eb03 0345 	add.w	r3, r3, r5, lsl #1
					out("Delay of key #%d set to %d", key, value);
 80127cc:	4629      	mov	r1, r5
					kc->delay_key[key] = value;
 80127ce:	8358      	strh	r0, [r3, #26]
					out("Delay of key #%d set to %d", key, value);
 80127d0:	4862      	ldr	r0, [pc, #392]	@ (801295c <KEYBOARD_TerminalParseLine+0xba4>)
 80127d2:	47a0      	blx	r4
	if (!input_line_parsed) {
 80127d4:	f7ff bb1b 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "key_calibration") == 0 || strcmp(parameter, "key_calibrate") == 0) {
 80127d8:	4961      	ldr	r1, [pc, #388]	@ (8012960 <KEYBOARD_TerminalParseLine+0xba8>)
 80127da:	4628      	mov	r0, r5
 80127dc:	f010 ff15 	bl	802360a <strcmp>
 80127e0:	b128      	cbz	r0, 80127ee <KEYBOARD_TerminalParseLine+0xa36>
 80127e2:	4960      	ldr	r1, [pc, #384]	@ (8012964 <KEYBOARD_TerminalParseLine+0xbac>)
 80127e4:	4628      	mov	r0, r5
 80127e6:	f010 ff10 	bl	802360a <strcmp>
 80127ea:	2800      	cmp	r0, #0
 80127ec:	d13a      	bne.n	8012864 <KEYBOARD_TerminalParseLine+0xaac>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 80127ee:	494b      	ldr	r1, [pc, #300]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 80127f0:	466a      	mov	r2, sp
 80127f2:	2000      	movs	r0, #0
 80127f4:	f010 ff06 	bl	8023604 <strtok_r>
 80127f8:	4605      	mov	r5, r0
 80127fa:	b148      	cbz	r0, 8012810 <KEYBOARD_TerminalParseLine+0xa58>
						((value = get_on_off(parameter)) < 0 && (clean = strcmp(parameter, "clean")) != 0)) {
 80127fc:	f7fe f9aa 	bl	8010b54 <get_on_off>
					if (!(parameter = strtok_r(NULL, separators, &brkt)) ||
 8012800:	1e03      	subs	r3, r0, #0
 8012802:	da12      	bge.n	801282a <KEYBOARD_TerminalParseLine+0xa72>
						((value = get_on_off(parameter)) < 0 && (clean = strcmp(parameter, "clean")) != 0)) {
 8012804:	4958      	ldr	r1, [pc, #352]	@ (8012968 <KEYBOARD_TerminalParseLine+0xbb0>)
 8012806:	4628      	mov	r0, r5
 8012808:	f010 feff 	bl	802360a <strcmp>
 801280c:	4601      	mov	r1, r0
 801280e:	b118      	cbz	r0, 8012818 <KEYBOARD_TerminalParseLine+0xa60>
						out("Please specify on, off or clean!");
 8012810:	4856      	ldr	r0, [pc, #344]	@ (801296c <KEYBOARD_TerminalParseLine+0xbb4>)
 8012812:	47a0      	blx	r4
						return 1; // command taken
 8012814:	f7ff bafb 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
							kc->delay_key[i] = 0;
 8012818:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801281c:	4854      	ldr	r0, [pc, #336]	@ (8012970 <KEYBOARD_TerminalParseLine+0xbb8>)
 801281e:	f010 fe98 	bl	8023552 <memset>
						out("Cleaned calibration data.");
 8012822:	4854      	ldr	r0, [pc, #336]	@ (8012974 <KEYBOARD_TerminalParseLine+0xbbc>)
 8012824:	47a0      	blx	r4
 8012826:	f7ff baf2 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->key_calibration = value;
 801282a:	4939      	ldr	r1, [pc, #228]	@ (8012910 <KEYBOARD_TerminalParseLine+0xb58>)
 801282c:	7b4a      	ldrb	r2, [r1, #13]
 801282e:	f363 1286 	bfi	r2, r3, #6, #1
						if (kc->key_calibration) {
 8012832:	0653      	lsls	r3, r2, #25
						kc->key_calibration = value;
 8012834:	734a      	strb	r2, [r1, #13]
						if (kc->key_calibration) {
 8012836:	d50e      	bpl.n	8012856 <KEYBOARD_TerminalParseLine+0xa9e>
							out("Key calibration enabled.");
 8012838:	484f      	ldr	r0, [pc, #316]	@ (8012978 <KEYBOARD_TerminalParseLine+0xbc0>)
 801283a:	47a0      	blx	r4
							out("Press all keys with slowest velocity now.");
 801283c:	484f      	ldr	r0, [pc, #316]	@ (801297c <KEYBOARD_TerminalParseLine+0xbc4>)
 801283e:	47a0      	blx	r4
							out("Enter 'set kb %d key_calibration clean' to clean previous data", kb + 1);
 8012840:	484f      	ldr	r0, [pc, #316]	@ (8012980 <KEYBOARD_TerminalParseLine+0xbc8>)
 8012842:	2101      	movs	r1, #1
 8012844:	47a0      	blx	r4
							out("Enter 'set kb %d key_calibration off' to finish calibration", kb + 1);
 8012846:	484f      	ldr	r0, [pc, #316]	@ (8012984 <KEYBOARD_TerminalParseLine+0xbcc>)
 8012848:	2101      	movs	r1, #1
 801284a:	47a0      	blx	r4
							out("Enter 'kb %d delays' to display current measurement results", kb + 1);
 801284c:	484e      	ldr	r0, [pc, #312]	@ (8012988 <KEYBOARD_TerminalParseLine+0xbd0>)
 801284e:	2101      	movs	r1, #1
 8012850:	47a0      	blx	r4
 8012852:	f7ff badc 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
							out("Key calibration disabled.");
 8012856:	484d      	ldr	r0, [pc, #308]	@ (801298c <KEYBOARD_TerminalParseLine+0xbd4>)
 8012858:	47a0      	blx	r4
							out("Enter 'kb %d delays' to display measured delays.", kb + 1);
 801285a:	484d      	ldr	r0, [pc, #308]	@ (8012990 <KEYBOARD_TerminalParseLine+0xbd8>)
 801285c:	2101      	movs	r1, #1
 801285e:	47a0      	blx	r4
 8012860:	f7ff bad5 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "ain_pitchwheel") == 0 ||
 8012864:	494b      	ldr	r1, [pc, #300]	@ (8012994 <KEYBOARD_TerminalParseLine+0xbdc>)
 8012866:	4628      	mov	r0, r5
 8012868:	f010 fecf 	bl	802360a <strcmp>
					strcmp(parameter, "ain_modwheel") == 0 ||
 801286c:	494a      	ldr	r1, [pc, #296]	@ (8012998 <KEYBOARD_TerminalParseLine+0xbe0>)
				else if (strcmp(parameter, "ain_pitchwheel") == 0 ||
 801286e:	4680      	mov	r8, r0
					strcmp(parameter, "ain_modwheel") == 0 ||
 8012870:	4628      	mov	r0, r5
 8012872:	f010 feca 	bl	802360a <strcmp>
					strcmp(parameter, "ain_expression") == 0 ||
 8012876:	4949      	ldr	r1, [pc, #292]	@ (801299c <KEYBOARD_TerminalParseLine+0xbe4>)
					strcmp(parameter, "ain_modwheel") == 0 ||
 8012878:	4607      	mov	r7, r0
					strcmp(parameter, "ain_expression") == 0 ||
 801287a:	4628      	mov	r0, r5
 801287c:	f010 fec5 	bl	802360a <strcmp>
 8012880:	4606      	mov	r6, r0
				else if (strcmp(parameter, "ain_pitchwheel") == 0 ||
 8012882:	f1b8 0f00 	cmp.w	r8, #0
 8012886:	d008      	beq.n	801289a <KEYBOARD_TerminalParseLine+0xae2>
 8012888:	b13f      	cbz	r7, 801289a <KEYBOARD_TerminalParseLine+0xae2>
					strcmp(parameter, "ain_modwheel") == 0 ||
 801288a:	b130      	cbz	r0, 801289a <KEYBOARD_TerminalParseLine+0xae2>
					strcmp(parameter, "ain_sustain") == 0) {
 801288c:	4944      	ldr	r1, [pc, #272]	@ (80129a0 <KEYBOARD_TerminalParseLine+0xbe8>)
 801288e:	4628      	mov	r0, r5
 8012890:	f010 febb 	bl	802360a <strcmp>
					strcmp(parameter, "ain_expression") == 0 ||
 8012894:	2800      	cmp	r0, #0
 8012896:	f040 80ae 	bne.w	80129f6 <KEYBOARD_TerminalParseLine+0xc3e>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 801289a:	4920      	ldr	r1, [pc, #128]	@ (801291c <KEYBOARD_TerminalParseLine+0xb64>)
 801289c:	466a      	mov	r2, sp
 801289e:	2000      	movs	r0, #0
 80128a0:	f010 feb0 	bl	8023604 <strtok_r>
 80128a4:	4681      	mov	r9, r0
 80128a6:	b918      	cbnz	r0, 80128b0 <KEYBOARD_TerminalParseLine+0xaf8>
						out("Please specify J5.Ax number (0..7), AINSER number (128..135) or off!");
 80128a8:	483e      	ldr	r0, [pc, #248]	@ (80129a4 <KEYBOARD_TerminalParseLine+0xbec>)
 80128aa:	47a0      	blx	r4
						return 1; // command taken
 80128ac:	f7ff baaf 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					if (strcmp(parameter, "off") != 0) {
 80128b0:	493d      	ldr	r1, [pc, #244]	@ (80129a8 <KEYBOARD_TerminalParseLine+0xbf0>)
 80128b2:	f010 feaa 	bl	802360a <strcmp>
 80128b6:	4605      	mov	r5, r0
 80128b8:	b150      	cbz	r0, 80128d0 <KEYBOARD_TerminalParseLine+0xb18>
						ain = get_dec(parameter);
 80128ba:	4648      	mov	r0, r9
 80128bc:	f7fe f93a 	bl	8010b34 <get_dec>
						if (ain < 0 || ain > 255) {
 80128c0:	28ff      	cmp	r0, #255	@ 0xff
						ain = get_dec(parameter);
 80128c2:	4605      	mov	r5, r0
						if (ain < 0 || ain > 255) {
 80128c4:	d903      	bls.n	80128ce <KEYBOARD_TerminalParseLine+0xb16>
							out("AIN pin should be in the range of 0..255");
 80128c6:	4839      	ldr	r0, [pc, #228]	@ (80129ac <KEYBOARD_TerminalParseLine+0xbf4>)
 80128c8:	47a0      	blx	r4
							return 1; // command taken
 80128ca:	f7ff baa0 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						ain += 1;
 80128ce:	3501      	adds	r5, #1
					if (pitchwheel) {
 80128d0:	f8df 903c 	ldr.w	r9, [pc, #60]	@ 8012910 <KEYBOARD_TerminalParseLine+0xb58>
						kc->ain_pin[KEYBOARD_AIN_PITCHWHEEL] = ain;
 80128d4:	fa5f fa85 	uxtb.w	sl, r5
					if (pitchwheel) {
 80128d8:	f1b8 0f00 	cmp.w	r8, #0
 80128dc:	d16e      	bne.n	80129bc <KEYBOARD_TerminalParseLine+0xc04>
						strcpy(wheel_name, "PitchWheel");
 80128de:	4934      	ldr	r1, [pc, #208]	@ (80129b0 <KEYBOARD_TerminalParseLine+0xbf8>)
 80128e0:	a801      	add	r0, sp, #4
 80128e2:	f010 fdfb 	bl	80234dc <strcpy>
						kc->ain_pin[KEYBOARD_AIN_PITCHWHEEL] = ain;
 80128e6:	f889 a12c 	strb.w	sl, [r9, #300]	@ 0x12c
					if (ain) {
 80128ea:	2d00      	cmp	r5, #0
 80128ec:	d07d      	beq.n	80129ea <KEYBOARD_TerminalParseLine+0xc32>
						if (ain >= 128) {
 80128ee:	2d7f      	cmp	r5, #127	@ 0x7f
							out("Keyboard #%d: %s assigned to AINSER pin A%d!", kb + 1, wheel_name, ain - 1 - 128);
 80128f0:	bfc9      	itett	gt
 80128f2:	4830      	ldrgt	r0, [pc, #192]	@ (80129b4 <KEYBOARD_TerminalParseLine+0xbfc>)
							out("Keyboard #%d: %s assigned to J5.A%d!", kb + 1, wheel_name, ain - 1);
 80128f4:	4830      	ldrle	r0, [pc, #192]	@ (80129b8 <KEYBOARD_TerminalParseLine+0xc00>)
							out("Keyboard #%d: %s assigned to AINSER pin A%d!", kb + 1, wheel_name, ain - 1 - 128);
 80128f6:	f1a5 0381 	subgt.w	r3, r5, #129	@ 0x81
 80128fa:	aa01      	addgt	r2, sp, #4
 80128fc:	bfcf      	iteee	gt
 80128fe:	2101      	movgt	r1, #1
							out("Keyboard #%d: %s assigned to J5.A%d!", kb + 1, wheel_name, ain - 1);
 8012900:	f105 33ff 	addle.w	r3, r5, #4294967295	@ 0xffffffff
 8012904:	aa01      	addle	r2, sp, #4
 8012906:	2101      	movle	r1, #1
 8012908:	47a0      	blx	r4
 801290a:	f7ff ba80 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
 801290e:	bf00      	nop
 8012910:	20000370 	.word	0x20000370
 8012914:	08026023 	.word	0x08026023
 8012918:	0802604f 	.word	0x0802604f
 801291c:	080237ba 	.word	0x080237ba
 8012920:	08026061 	.word	0x08026061
 8012924:	0802609a 	.word	0x0802609a
 8012928:	080260c5 	.word	0x080260c5
 801292c:	080260d8 	.word	0x080260d8
 8012930:	08026112 	.word	0x08026112
 8012934:	0802613e 	.word	0x0802613e
 8012938:	0802614a 	.word	0x0802614a
 801293c:	08025f83 	.word	0x08025f83
 8012940:	08026188 	.word	0x08026188
 8012944:	080261ad 	.word	0x080261ad
 8012948:	080261ba 	.word	0x080261ba
 801294c:	080261f9 	.word	0x080261f9
 8012950:	0802621f 	.word	0x0802621f
 8012954:	08026235 	.word	0x08026235
 8012958:	08026258 	.word	0x08026258
 801295c:	08026280 	.word	0x08026280
 8012960:	0802629b 	.word	0x0802629b
 8012964:	080262ab 	.word	0x080262ab
 8012968:	080262b9 	.word	0x080262b9
 801296c:	080262bf 	.word	0x080262bf
 8012970:	2000038a 	.word	0x2000038a
 8012974:	080262e0 	.word	0x080262e0
 8012978:	080262fa 	.word	0x080262fa
 801297c:	08026313 	.word	0x08026313
 8012980:	0802633d 	.word	0x0802633d
 8012984:	0802637c 	.word	0x0802637c
 8012988:	080263b8 	.word	0x080263b8
 801298c:	080263f4 	.word	0x080263f4
 8012990:	0802640e 	.word	0x0802640e
 8012994:	0802643f 	.word	0x0802643f
 8012998:	0802644e 	.word	0x0802644e
 801299c:	0802645b 	.word	0x0802645b
 80129a0:	0802646a 	.word	0x0802646a
 80129a4:	08026476 	.word	0x08026476
 80129a8:	0802531e 	.word	0x0802531e
 80129ac:	080264bb 	.word	0x080264bb
 80129b0:	08024a19 	.word	0x08024a19
 80129b4:	080264e4 	.word	0x080264e4
 80129b8:	08026511 	.word	0x08026511
					else if (modwheel) {
 80129bc:	b937      	cbnz	r7, 80129cc <KEYBOARD_TerminalParseLine+0xc14>
						strcpy(wheel_name, "ModWheel");
 80129be:	49a6      	ldr	r1, [pc, #664]	@ (8012c58 <KEYBOARD_TerminalParseLine+0xea0>)
 80129c0:	a801      	add	r0, sp, #4
 80129c2:	f010 fd8b 	bl	80234dc <strcpy>
						kc->ain_pin[KEYBOARD_AIN_MODWHEEL] = ain;
 80129c6:	f889 a12d 	strb.w	sl, [r9, #301]	@ 0x12d
 80129ca:	e78e      	b.n	80128ea <KEYBOARD_TerminalParseLine+0xb32>
					else if (expression) {
 80129cc:	b936      	cbnz	r6, 80129dc <KEYBOARD_TerminalParseLine+0xc24>
						strcpy(wheel_name, "Expression");
 80129ce:	49a3      	ldr	r1, [pc, #652]	@ (8012c5c <KEYBOARD_TerminalParseLine+0xea4>)
 80129d0:	a801      	add	r0, sp, #4
 80129d2:	f010 fd83 	bl	80234dc <strcpy>
						kc->ain_pin[KEYBOARD_AIN_EXPRESSION] = ain;
 80129d6:	f889 a12f 	strb.w	sl, [r9, #303]	@ 0x12f
 80129da:	e786      	b.n	80128ea <KEYBOARD_TerminalParseLine+0xb32>
						strcpy(wheel_name, "Sustain Pedal");
 80129dc:	49a0      	ldr	r1, [pc, #640]	@ (8012c60 <KEYBOARD_TerminalParseLine+0xea8>)
 80129de:	a801      	add	r0, sp, #4
 80129e0:	f010 fd7c 	bl	80234dc <strcpy>
						kc->ain_pin[KEYBOARD_AIN_SUSTAIN] = ain;
 80129e4:	f889 a12e 	strb.w	sl, [r9, #302]	@ 0x12e
 80129e8:	e77f      	b.n	80128ea <KEYBOARD_TerminalParseLine+0xb32>
						out("Keyboard #%d: %s disabled!", kb + 1, wheel_name);
 80129ea:	489e      	ldr	r0, [pc, #632]	@ (8012c64 <KEYBOARD_TerminalParseLine+0xeac>)
 80129ec:	aa01      	add	r2, sp, #4
 80129ee:	2101      	movs	r1, #1
 80129f0:	47a0      	blx	r4
	if (!input_line_parsed) {
 80129f2:	f7ff ba0c 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "ctrl_pitchwheel") == 0 ||
 80129f6:	499c      	ldr	r1, [pc, #624]	@ (8012c68 <KEYBOARD_TerminalParseLine+0xeb0>)
 80129f8:	4628      	mov	r0, r5
 80129fa:	f010 fe06 	bl	802360a <strcmp>
					strcmp(parameter, "ctrl_modwheel") == 0 ||
 80129fe:	499b      	ldr	r1, [pc, #620]	@ (8012c6c <KEYBOARD_TerminalParseLine+0xeb4>)
				else if (strcmp(parameter, "ctrl_pitchwheel") == 0 ||
 8012a00:	4681      	mov	r9, r0
					strcmp(parameter, "ctrl_modwheel") == 0 ||
 8012a02:	4628      	mov	r0, r5
 8012a04:	f010 fe01 	bl	802360a <strcmp>
					strcmp(parameter, "ctrl_expression") == 0 ||
 8012a08:	4999      	ldr	r1, [pc, #612]	@ (8012c70 <KEYBOARD_TerminalParseLine+0xeb8>)
					strcmp(parameter, "ctrl_modwheel") == 0 ||
 8012a0a:	4680      	mov	r8, r0
					strcmp(parameter, "ctrl_expression") == 0 ||
 8012a0c:	4628      	mov	r0, r5
 8012a0e:	f010 fdfc 	bl	802360a <strcmp>
 8012a12:	4607      	mov	r7, r0
				else if (strcmp(parameter, "ctrl_pitchwheel") == 0 ||
 8012a14:	f1b9 0f00 	cmp.w	r9, #0
 8012a18:	d009      	beq.n	8012a2e <KEYBOARD_TerminalParseLine+0xc76>
 8012a1a:	f1b8 0f00 	cmp.w	r8, #0
 8012a1e:	d006      	beq.n	8012a2e <KEYBOARD_TerminalParseLine+0xc76>
					strcmp(parameter, "ctrl_modwheel") == 0 ||
 8012a20:	b128      	cbz	r0, 8012a2e <KEYBOARD_TerminalParseLine+0xc76>
					strcmp(parameter, "ctrl_sustain") == 0) {
 8012a22:	4994      	ldr	r1, [pc, #592]	@ (8012c74 <KEYBOARD_TerminalParseLine+0xebc>)
 8012a24:	4628      	mov	r0, r5
 8012a26:	f010 fdf0 	bl	802360a <strcmp>
					strcmp(parameter, "ctrl_expression") == 0 ||
 8012a2a:	2800      	cmp	r0, #0
 8012a2c:	d149      	bne.n	8012ac2 <KEYBOARD_TerminalParseLine+0xd0a>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012a2e:	4992      	ldr	r1, [pc, #584]	@ (8012c78 <KEYBOARD_TerminalParseLine+0xec0>)
 8012a30:	466a      	mov	r2, sp
 8012a32:	2000      	movs	r0, #0
 8012a34:	f010 fde6 	bl	8023604 <strtok_r>
 8012a38:	b918      	cbnz	r0, 8012a42 <KEYBOARD_TerminalParseLine+0xc8a>
						out("Please specify the CC number (or 128 for PitchBend or 129 for Aftertouch)!");
 8012a3a:	4890      	ldr	r0, [pc, #576]	@ (8012c7c <KEYBOARD_TerminalParseLine+0xec4>)
 8012a3c:	47a0      	blx	r4
						return 1; // command taken
 8012a3e:	f7ff b9e6 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					int ctrl = get_dec(parameter);
 8012a42:	f7fe f877 	bl	8010b34 <get_dec>
					if (ctrl < 0 || ctrl > 129) {
 8012a46:	2881      	cmp	r0, #129	@ 0x81
					int ctrl = get_dec(parameter);
 8012a48:	4605      	mov	r5, r0
					if (ctrl < 0 || ctrl > 129) {
 8012a4a:	d903      	bls.n	8012a54 <KEYBOARD_TerminalParseLine+0xc9c>
						out("Controller Number should be in the range between 0 and 129!");
 8012a4c:	488c      	ldr	r0, [pc, #560]	@ (8012c80 <KEYBOARD_TerminalParseLine+0xec8>)
 8012a4e:	47a0      	blx	r4
						return 1; // command taken
 8012a50:	f7ff b9dd 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						if (pitchwheel) {
 8012a54:	4e8b      	ldr	r6, [pc, #556]	@ (8012c84 <KEYBOARD_TerminalParseLine+0xecc>)
							kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL] = ctrl;
 8012a56:	fa5f fa80 	uxtb.w	sl, r0
						if (pitchwheel) {
 8012a5a:	f1b9 0f00 	cmp.w	r9, #0
 8012a5e:	d10e      	bne.n	8012a7e <KEYBOARD_TerminalParseLine+0xcc6>
							strcpy(wheel_name, "PitchWheel");
 8012a60:	4989      	ldr	r1, [pc, #548]	@ (8012c88 <KEYBOARD_TerminalParseLine+0xed0>)
 8012a62:	a801      	add	r0, sp, #4
 8012a64:	f010 fd3a 	bl	80234dc <strcpy>
							kc->ain_ctrl[KEYBOARD_AIN_PITCHWHEEL] = ctrl;
 8012a68:	f886 a130 	strb.w	sl, [r6, #304]	@ 0x130
						if (ctrl < 128)
 8012a6c:	2d7f      	cmp	r5, #127	@ 0x7f
 8012a6e:	dc1f      	bgt.n	8012ab0 <KEYBOARD_TerminalParseLine+0xcf8>
							out("Keyboard #%d: %s sends CC#%d", kb + 1, wheel_name, ctrl);
 8012a70:	4886      	ldr	r0, [pc, #536]	@ (8012c8c <KEYBOARD_TerminalParseLine+0xed4>)
 8012a72:	462b      	mov	r3, r5
 8012a74:	aa01      	add	r2, sp, #4
 8012a76:	2101      	movs	r1, #1
 8012a78:	47a0      	blx	r4
 8012a7a:	f7ff b9c8 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						else if (modwheel) {
 8012a7e:	f1b8 0f00 	cmp.w	r8, #0
 8012a82:	d106      	bne.n	8012a92 <KEYBOARD_TerminalParseLine+0xcda>
							strcpy(wheel_name, "ModWheel");
 8012a84:	4974      	ldr	r1, [pc, #464]	@ (8012c58 <KEYBOARD_TerminalParseLine+0xea0>)
 8012a86:	a801      	add	r0, sp, #4
 8012a88:	f010 fd28 	bl	80234dc <strcpy>
							kc->ain_ctrl[KEYBOARD_AIN_MODWHEEL] = ctrl;
 8012a8c:	f886 a131 	strb.w	sl, [r6, #305]	@ 0x131
 8012a90:	e7ec      	b.n	8012a6c <KEYBOARD_TerminalParseLine+0xcb4>
						else if (expression) {
 8012a92:	b937      	cbnz	r7, 8012aa2 <KEYBOARD_TerminalParseLine+0xcea>
							strcpy(wheel_name, "Expression");
 8012a94:	4971      	ldr	r1, [pc, #452]	@ (8012c5c <KEYBOARD_TerminalParseLine+0xea4>)
 8012a96:	a801      	add	r0, sp, #4
 8012a98:	f010 fd20 	bl	80234dc <strcpy>
							kc->ain_ctrl[KEYBOARD_AIN_EXPRESSION] = ctrl;
 8012a9c:	f886 a133 	strb.w	sl, [r6, #307]	@ 0x133
 8012aa0:	e7e4      	b.n	8012a6c <KEYBOARD_TerminalParseLine+0xcb4>
							strcpy(wheel_name, "Sustain Pedal");
 8012aa2:	496f      	ldr	r1, [pc, #444]	@ (8012c60 <KEYBOARD_TerminalParseLine+0xea8>)
 8012aa4:	a801      	add	r0, sp, #4
 8012aa6:	f010 fd19 	bl	80234dc <strcpy>
							kc->ain_ctrl[KEYBOARD_AIN_SUSTAIN] = ctrl;
 8012aaa:	f886 a132 	strb.w	sl, [r6, #306]	@ 0x132
 8012aae:	e7dd      	b.n	8012a6c <KEYBOARD_TerminalParseLine+0xcb4>
						else if (ctrl == 128)
 8012ab0:	2d80      	cmp	r5, #128	@ 0x80
							out("Keyboard #%d: %s sends PitchBend", kb + 1, wheel_name);
 8012ab2:	bf0c      	ite	eq
 8012ab4:	4876      	ldreq	r0, [pc, #472]	@ (8012c90 <KEYBOARD_TerminalParseLine+0xed8>)
							out("Keyboard #%d: %s sends Aftertouch", kb + 1, wheel_name);
 8012ab6:	4877      	ldrne	r0, [pc, #476]	@ (8012c94 <KEYBOARD_TerminalParseLine+0xedc>)
							out("Keyboard #%d: %s sends PitchBend", kb + 1, wheel_name);
 8012ab8:	aa01      	add	r2, sp, #4
 8012aba:	2101      	movs	r1, #1
							out("Keyboard #%d: %s sends Aftertouch", kb + 1, wheel_name);
 8012abc:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012abe:	f7ff b9a6 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "ain_pitchwheel_inverted") == 0 ||
 8012ac2:	4975      	ldr	r1, [pc, #468]	@ (8012c98 <KEYBOARD_TerminalParseLine+0xee0>)
 8012ac4:	4628      	mov	r0, r5
 8012ac6:	f010 fda0 	bl	802360a <strcmp>
					strcmp(parameter, "ain_modwheel_inverted") == 0 ||
 8012aca:	4974      	ldr	r1, [pc, #464]	@ (8012c9c <KEYBOARD_TerminalParseLine+0xee4>)
				else if (strcmp(parameter, "ain_pitchwheel_inverted") == 0 ||
 8012acc:	4682      	mov	sl, r0
					strcmp(parameter, "ain_modwheel_inverted") == 0 ||
 8012ace:	4628      	mov	r0, r5
 8012ad0:	f010 fd9b 	bl	802360a <strcmp>
					strcmp(parameter, "ain_expression_inverted") == 0 ||
 8012ad4:	4972      	ldr	r1, [pc, #456]	@ (8012ca0 <KEYBOARD_TerminalParseLine+0xee8>)
					strcmp(parameter, "ain_modwheel_inverted") == 0 ||
 8012ad6:	4681      	mov	r9, r0
					strcmp(parameter, "ain_expression_inverted") == 0 ||
 8012ad8:	4628      	mov	r0, r5
 8012ada:	f010 fd96 	bl	802360a <strcmp>
 8012ade:	4680      	mov	r8, r0
				else if (strcmp(parameter, "ain_pitchwheel_inverted") == 0 ||
 8012ae0:	f1ba 0f00 	cmp.w	sl, #0
 8012ae4:	d009      	beq.n	8012afa <KEYBOARD_TerminalParseLine+0xd42>
 8012ae6:	f1b9 0f00 	cmp.w	r9, #0
 8012aea:	d006      	beq.n	8012afa <KEYBOARD_TerminalParseLine+0xd42>
					strcmp(parameter, "ain_modwheel_inverted") == 0 ||
 8012aec:	b128      	cbz	r0, 8012afa <KEYBOARD_TerminalParseLine+0xd42>
					strcmp(parameter, "ain_sustain_inverted") == 0) {
 8012aee:	496d      	ldr	r1, [pc, #436]	@ (8012ca4 <KEYBOARD_TerminalParseLine+0xeec>)
 8012af0:	4628      	mov	r0, r5
 8012af2:	f010 fd8a 	bl	802360a <strcmp>
					strcmp(parameter, "ain_expression_inverted") == 0 ||
 8012af6:	2800      	cmp	r0, #0
 8012af8:	d142      	bne.n	8012b80 <KEYBOARD_TerminalParseLine+0xdc8>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012afa:	495f      	ldr	r1, [pc, #380]	@ (8012c78 <KEYBOARD_TerminalParseLine+0xec0>)
 8012afc:	466a      	mov	r2, sp
 8012afe:	2000      	movs	r0, #0
 8012b00:	f010 fd80 	bl	8023604 <strtok_r>
 8012b04:	b918      	cbnz	r0, 8012b0e <KEYBOARD_TerminalParseLine+0xd56>
						out("Please specify on or off!");
 8012b06:	4868      	ldr	r0, [pc, #416]	@ (8012ca8 <KEYBOARD_TerminalParseLine+0xef0>)
 8012b08:	47a0      	blx	r4
						return 1; // command taken
 8012b0a:	f7ff b980 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					if ((value = get_on_off(parameter)) < 0) {
 8012b0e:	f7fe f821 	bl	8010b54 <get_on_off>
 8012b12:	1e05      	subs	r5, r0, #0
 8012b14:	da03      	bge.n	8012b1e <KEYBOARD_TerminalParseLine+0xd66>
						out("Invalid value, please specify on or off!");
 8012b16:	4865      	ldr	r0, [pc, #404]	@ (8012cac <KEYBOARD_TerminalParseLine+0xef4>)
 8012b18:	47a0      	blx	r4
						return 1; // command taken
 8012b1a:	f7ff b978 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					if (pitchwheel) {
 8012b1e:	4e59      	ldr	r6, [pc, #356]	@ (8012c84 <KEYBOARD_TerminalParseLine+0xecc>)
						kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] = value;
 8012b20:	b2ef      	uxtb	r7, r5
					if (pitchwheel) {
 8012b22:	f1ba 0f00 	cmp.w	sl, #0
 8012b26:	d110      	bne.n	8012b4a <KEYBOARD_TerminalParseLine+0xd92>
						strcpy(wheel_name, "PitchWheel");
 8012b28:	4957      	ldr	r1, [pc, #348]	@ (8012c88 <KEYBOARD_TerminalParseLine+0xed0>)
 8012b2a:	a801      	add	r0, sp, #4
 8012b2c:	f010 fcd6 	bl	80234dc <strcpy>
						kc->ain_inverted[KEYBOARD_AIN_PITCHWHEEL] = value;
 8012b30:	f886 7140 	strb.w	r7, [r6, #320]	@ 0x140
					out("Keyboard #%d: %s controller inversion %s!", kb + 1, wheel_name, value ? "on" : "off");
 8012b34:	4a5e      	ldr	r2, [pc, #376]	@ (8012cb0 <KEYBOARD_TerminalParseLine+0xef8>)
 8012b36:	4b5f      	ldr	r3, [pc, #380]	@ (8012cb4 <KEYBOARD_TerminalParseLine+0xefc>)
 8012b38:	485f      	ldr	r0, [pc, #380]	@ (8012cb8 <KEYBOARD_TerminalParseLine+0xf00>)
 8012b3a:	2d00      	cmp	r5, #0
 8012b3c:	bf08      	it	eq
 8012b3e:	4613      	moveq	r3, r2
 8012b40:	2101      	movs	r1, #1
 8012b42:	aa01      	add	r2, sp, #4
 8012b44:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012b46:	f7ff b962 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					else if (modwheel) {
 8012b4a:	f1b9 0f00 	cmp.w	r9, #0
 8012b4e:	d106      	bne.n	8012b5e <KEYBOARD_TerminalParseLine+0xda6>
						strcpy(wheel_name, "ModWheel");
 8012b50:	4941      	ldr	r1, [pc, #260]	@ (8012c58 <KEYBOARD_TerminalParseLine+0xea0>)
 8012b52:	a801      	add	r0, sp, #4
 8012b54:	f010 fcc2 	bl	80234dc <strcpy>
						kc->ain_inverted[KEYBOARD_AIN_MODWHEEL] = value;
 8012b58:	f886 7141 	strb.w	r7, [r6, #321]	@ 0x141
 8012b5c:	e7ea      	b.n	8012b34 <KEYBOARD_TerminalParseLine+0xd7c>
					else if (expression) {
 8012b5e:	f1b8 0f00 	cmp.w	r8, #0
 8012b62:	d106      	bne.n	8012b72 <KEYBOARD_TerminalParseLine+0xdba>
						strcpy(wheel_name, "Expression");
 8012b64:	493d      	ldr	r1, [pc, #244]	@ (8012c5c <KEYBOARD_TerminalParseLine+0xea4>)
 8012b66:	a801      	add	r0, sp, #4
 8012b68:	f010 fcb8 	bl	80234dc <strcpy>
						kc->ain_inverted[KEYBOARD_AIN_EXPRESSION] = value;
 8012b6c:	f886 7143 	strb.w	r7, [r6, #323]	@ 0x143
 8012b70:	e7e0      	b.n	8012b34 <KEYBOARD_TerminalParseLine+0xd7c>
						strcpy(wheel_name, "Sustain Pedal");
 8012b72:	493b      	ldr	r1, [pc, #236]	@ (8012c60 <KEYBOARD_TerminalParseLine+0xea8>)
 8012b74:	a801      	add	r0, sp, #4
 8012b76:	f010 fcb1 	bl	80234dc <strcpy>
						kc->ain_inverted[KEYBOARD_AIN_SUSTAIN] = value;
 8012b7a:	f886 7142 	strb.w	r7, [r6, #322]	@ 0x142
 8012b7e:	e7d9      	b.n	8012b34 <KEYBOARD_TerminalParseLine+0xd7c>
				else if (strcmp(parameter, "calibration") == 0 || strcmp(parameter, "calibrate") == 0 ||
 8012b80:	494e      	ldr	r1, [pc, #312]	@ (8012cbc <KEYBOARD_TerminalParseLine+0xf04>)
 8012b82:	4628      	mov	r0, r5
 8012b84:	f010 fd41 	bl	802360a <strcmp>
 8012b88:	b178      	cbz	r0, 8012baa <KEYBOARD_TerminalParseLine+0xdf2>
 8012b8a:	494d      	ldr	r1, [pc, #308]	@ (8012cc0 <KEYBOARD_TerminalParseLine+0xf08>)
 8012b8c:	4628      	mov	r0, r5
 8012b8e:	f010 fd3c 	bl	802360a <strcmp>
 8012b92:	b150      	cbz	r0, 8012baa <KEYBOARD_TerminalParseLine+0xdf2>
					strcmp(parameter, "ain_calibration") == 0 || strcmp(parameter, "ain_calibrate") == 0) {
 8012b94:	494b      	ldr	r1, [pc, #300]	@ (8012cc4 <KEYBOARD_TerminalParseLine+0xf0c>)
 8012b96:	4628      	mov	r0, r5
 8012b98:	f010 fd37 	bl	802360a <strcmp>
				else if (strcmp(parameter, "calibration") == 0 || strcmp(parameter, "calibrate") == 0 ||
 8012b9c:	b128      	cbz	r0, 8012baa <KEYBOARD_TerminalParseLine+0xdf2>
					strcmp(parameter, "ain_calibration") == 0 || strcmp(parameter, "ain_calibrate") == 0) {
 8012b9e:	494a      	ldr	r1, [pc, #296]	@ (8012cc8 <KEYBOARD_TerminalParseLine+0xf10>)
 8012ba0:	4628      	mov	r0, r5
 8012ba2:	f010 fd32 	bl	802360a <strcmp>
 8012ba6:	2800      	cmp	r0, #0
 8012ba8:	d146      	bne.n	8012c38 <KEYBOARD_TerminalParseLine+0xe80>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012baa:	4933      	ldr	r1, [pc, #204]	@ (8012c78 <KEYBOARD_TerminalParseLine+0xec0>)
 8012bac:	466a      	mov	r2, sp
 8012bae:	2000      	movs	r0, #0
 8012bb0:	f010 fd28 	bl	8023604 <strtok_r>
 8012bb4:	4606      	mov	r6, r0
 8012bb6:	b1c0      	cbz	r0, 8012bea <KEYBOARD_TerminalParseLine+0xe32>
						if (strcmp(parameter, "off") == 0)
 8012bb8:	493d      	ldr	r1, [pc, #244]	@ (8012cb0 <KEYBOARD_TerminalParseLine+0xef8>)
 8012bba:	f010 fd26 	bl	802360a <strcmp>
 8012bbe:	b1c0      	cbz	r0, 8012bf2 <KEYBOARD_TerminalParseLine+0xe3a>
						else if (strcmp(parameter, "pitchwheel") == 0)
 8012bc0:	4942      	ldr	r1, [pc, #264]	@ (8012ccc <KEYBOARD_TerminalParseLine+0xf14>)
 8012bc2:	4630      	mov	r0, r6
 8012bc4:	f010 fd21 	bl	802360a <strcmp>
 8012bc8:	4605      	mov	r5, r0
 8012bca:	b1d0      	cbz	r0, 8012c02 <KEYBOARD_TerminalParseLine+0xe4a>
						else if (strcmp(parameter, "modwheel") == 0)
 8012bcc:	4940      	ldr	r1, [pc, #256]	@ (8012cd0 <KEYBOARD_TerminalParseLine+0xf18>)
 8012bce:	4630      	mov	r0, r6
 8012bd0:	f010 fd1b 	bl	802360a <strcmp>
 8012bd4:	b1a0      	cbz	r0, 8012c00 <KEYBOARD_TerminalParseLine+0xe48>
						else if (strcmp(parameter, "expression") == 0)
 8012bd6:	493f      	ldr	r1, [pc, #252]	@ (8012cd4 <KEYBOARD_TerminalParseLine+0xf1c>)
 8012bd8:	4630      	mov	r0, r6
 8012bda:	f010 fd16 	bl	802360a <strcmp>
 8012bde:	b338      	cbz	r0, 8012c30 <KEYBOARD_TerminalParseLine+0xe78>
						else if (strcmp(parameter, "sustain") == 0)
 8012be0:	493d      	ldr	r1, [pc, #244]	@ (8012cd8 <KEYBOARD_TerminalParseLine+0xf20>)
 8012be2:	4630      	mov	r0, r6
 8012be4:	f010 fd11 	bl	802360a <strcmp>
 8012be8:	b320      	cbz	r0, 8012c34 <KEYBOARD_TerminalParseLine+0xe7c>
						out("Please specify off, pitchwheel, modwheel, expression or sustain to disable/enable calibration mode!");
 8012bea:	483c      	ldr	r0, [pc, #240]	@ (8012cdc <KEYBOARD_TerminalParseLine+0xf24>)
 8012bec:	47a0      	blx	r4
						return 1; // command taken
 8012bee:	f7ff b90e 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						ain_cali_mode_pin = 0; // off
 8012bf2:	4b3b      	ldr	r3, [pc, #236]	@ (8012ce0 <KEYBOARD_TerminalParseLine+0xf28>)
 8012bf4:	7018      	strb	r0, [r3, #0]
						KEYBOARD_TerminalCaliMode(_output_function);
 8012bf6:	4620      	mov	r0, r4
 8012bf8:	f7fd ffd0 	bl	8010b9c <KEYBOARD_TerminalCaliMode.isra.0>
	if (!input_line_parsed) {
 8012bfc:	f7ff b907 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
							pin = KEYBOARD_AIN_MODWHEEL;
 8012c00:	2501      	movs	r5, #1
						ain_cali_mode_pin = 1 + KEYBOARD_AIN_NUM * kb + pin;
 8012c02:	4b37      	ldr	r3, [pc, #220]	@ (8012ce0 <KEYBOARD_TerminalParseLine+0xf28>)
 8012c04:	1c6a      	adds	r2, r5, #1
						KEYBOARD_TerminalCaliMode(_output_function);
 8012c06:	4620      	mov	r0, r4
						ain_cali_mode_pin = 1 + KEYBOARD_AIN_NUM * kb + pin;
 8012c08:	701a      	strb	r2, [r3, #0]
						KEYBOARD_TerminalCaliMode(_output_function);
 8012c0a:	f7fd ffc7 	bl	8010b9c <KEYBOARD_TerminalCaliMode.isra.0>
						kc->ain_min[pin] = 0xff;
 8012c0e:	4b1d      	ldr	r3, [pc, #116]	@ (8012c84 <KEYBOARD_TerminalParseLine+0xecc>)
						out("Please move the potentiomenter into both directions now!");
 8012c10:	4834      	ldr	r0, [pc, #208]	@ (8012ce4 <KEYBOARD_TerminalParseLine+0xf2c>)
						kc->ain_min[pin] = 0xff;
 8012c12:	442b      	add	r3, r5
 8012c14:	22ff      	movs	r2, #255	@ 0xff
 8012c16:	f883 2134 	strb.w	r2, [r3, #308]	@ 0x134
						kc->ain_max[pin] = 0x00;
 8012c1a:	2200      	movs	r2, #0
 8012c1c:	f883 2138 	strb.w	r2, [r3, #312]	@ 0x138
						out("Please move the potentiomenter into both directions now!");
 8012c20:	47a0      	blx	r4
						out("The calibration will be finished by selection a new source, or with 'set kb %d calibration off'", kb + 1);
 8012c22:	4831      	ldr	r0, [pc, #196]	@ (8012ce8 <KEYBOARD_TerminalParseLine+0xf30>)
 8012c24:	2101      	movs	r1, #1
 8012c26:	47a0      	blx	r4
						out("Enter 'store' to save the calibration values");
 8012c28:	4830      	ldr	r0, [pc, #192]	@ (8012cec <KEYBOARD_TerminalParseLine+0xf34>)
 8012c2a:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012c2c:	f7ff b8ef 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
							pin = KEYBOARD_AIN_EXPRESSION;
 8012c30:	2503      	movs	r5, #3
 8012c32:	e7e6      	b.n	8012c02 <KEYBOARD_TerminalParseLine+0xe4a>
							pin = KEYBOARD_AIN_SUSTAIN;
 8012c34:	2502      	movs	r5, #2
 8012c36:	e7e4      	b.n	8012c02 <KEYBOARD_TerminalParseLine+0xe4a>
				else if (strcmp(parameter, "ain_bandwidth_ms") == 0) {
 8012c38:	492d      	ldr	r1, [pc, #180]	@ (8012cf0 <KEYBOARD_TerminalParseLine+0xf38>)
 8012c3a:	4628      	mov	r0, r5
 8012c3c:	f010 fce5 	bl	802360a <strcmp>
 8012c40:	2800      	cmp	r0, #0
 8012c42:	d16a      	bne.n	8012d1a <KEYBOARD_TerminalParseLine+0xf62>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012c44:	490c      	ldr	r1, [pc, #48]	@ (8012c78 <KEYBOARD_TerminalParseLine+0xec0>)
 8012c46:	466a      	mov	r2, sp
 8012c48:	f010 fcdc 	bl	8023604 <strtok_r>
 8012c4c:	2800      	cmp	r0, #0
 8012c4e:	d153      	bne.n	8012cf8 <KEYBOARD_TerminalParseLine+0xf40>
						out("Please specify the AIN bandwidth in milliseconds!");
 8012c50:	4828      	ldr	r0, [pc, #160]	@ (8012cf4 <KEYBOARD_TerminalParseLine+0xf3c>)
 8012c52:	47a0      	blx	r4
						return 1; // command taken
 8012c54:	f7ff b8db 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
 8012c58:	08024b2d 	.word	0x08024b2d
 8012c5c:	08024c45 	.word	0x08024c45
 8012c60:	08024d5e 	.word	0x08024d5e
 8012c64:	08026536 	.word	0x08026536
 8012c68:	08026551 	.word	0x08026551
 8012c6c:	08026561 	.word	0x08026561
 8012c70:	0802656f 	.word	0x0802656f
 8012c74:	0802657f 	.word	0x0802657f
 8012c78:	080237ba 	.word	0x080237ba
 8012c7c:	0802658c 	.word	0x0802658c
 8012c80:	080265d7 	.word	0x080265d7
 8012c84:	20000370 	.word	0x20000370
 8012c88:	08024a19 	.word	0x08024a19
 8012c8c:	08026613 	.word	0x08026613
 8012c90:	08026630 	.word	0x08026630
 8012c94:	08026651 	.word	0x08026651
 8012c98:	08026673 	.word	0x08026673
 8012c9c:	0802668b 	.word	0x0802668b
 8012ca0:	080266a1 	.word	0x080266a1
 8012ca4:	080266b9 	.word	0x080266b9
 8012ca8:	080266ce 	.word	0x080266ce
 8012cac:	080266e8 	.word	0x080266e8
 8012cb0:	0802531e 	.word	0x0802531e
 8012cb4:	08024c4d 	.word	0x08024c4d
 8012cb8:	08026711 	.word	0x08026711
 8012cbc:	08024ee1 	.word	0x08024ee1
 8012cc0:	0802674f 	.word	0x0802674f
 8012cc4:	0802673b 	.word	0x0802673b
 8012cc8:	0802674b 	.word	0x0802674b
 8012ccc:	08023c17 	.word	0x08023c17
 8012cd0:	08023c48 	.word	0x08023c48
 8012cd4:	08023ca5 	.word	0x08023ca5
 8012cd8:	08023c77 	.word	0x08023c77
 8012cdc:	08026759 	.word	0x08026759
 8012ce0:	2000012a 	.word	0x2000012a
 8012ce4:	080267bd 	.word	0x080267bd
 8012ce8:	080267f6 	.word	0x080267f6
 8012cec:	08026856 	.word	0x08026856
 8012cf0:	08026883 	.word	0x08026883
 8012cf4:	08026894 	.word	0x08026894
					int bandwidth_ms = get_dec(parameter);
 8012cf8:	f7fd ff1c 	bl	8010b34 <get_dec>
					if (bandwidth_ms < 0 || bandwidth_ms > 255) {
 8012cfc:	28ff      	cmp	r0, #255	@ 0xff
					int bandwidth_ms = get_dec(parameter);
 8012cfe:	4602      	mov	r2, r0
					if (bandwidth_ms < 0 || bandwidth_ms > 255) {
 8012d00:	d903      	bls.n	8012d0a <KEYBOARD_TerminalParseLine+0xf52>
						out("Bandwidth delay should be in the range between 0..255");
 8012d02:	481d      	ldr	r0, [pc, #116]	@ (8012d78 <KEYBOARD_TerminalParseLine+0xfc0>)
 8012d04:	47a0      	blx	r4
						return 1; // command taken
 8012d06:	f7ff b882 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
						kc->ain_bandwidth_ms = bandwidth_ms;
 8012d0a:	4b1c      	ldr	r3, [pc, #112]	@ (8012d7c <KEYBOARD_TerminalParseLine+0xfc4>)
						out("Keyboard #%d: ain_bandwidth_ms set to %d!", kb + 1, kc->ain_bandwidth_ms);
 8012d0c:	2101      	movs	r1, #1
						kc->ain_bandwidth_ms = bandwidth_ms;
 8012d0e:	f883 0145 	strb.w	r0, [r3, #325]	@ 0x145
						out("Keyboard #%d: ain_bandwidth_ms set to %d!", kb + 1, kc->ain_bandwidth_ms);
 8012d12:	481b      	ldr	r0, [pc, #108]	@ (8012d80 <KEYBOARD_TerminalParseLine+0xfc8>)
 8012d14:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012d16:	f7ff b87a 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
				else if (strcmp(parameter, "ain_sustain_switch") == 0) {
 8012d1a:	491a      	ldr	r1, [pc, #104]	@ (8012d84 <KEYBOARD_TerminalParseLine+0xfcc>)
 8012d1c:	4628      	mov	r0, r5
 8012d1e:	f010 fc74 	bl	802360a <strcmp>
 8012d22:	b9e8      	cbnz	r0, 8012d60 <KEYBOARD_TerminalParseLine+0xfa8>
					if (!(parameter = strtok_r(NULL, separators, &brkt))) {
 8012d24:	4918      	ldr	r1, [pc, #96]	@ (8012d88 <KEYBOARD_TerminalParseLine+0xfd0>)
 8012d26:	466a      	mov	r2, sp
 8012d28:	f010 fc6c 	bl	8023604 <strtok_r>
 8012d2c:	b918      	cbnz	r0, 8012d36 <KEYBOARD_TerminalParseLine+0xf7e>
						out("Please specify on or off!");
 8012d2e:	4817      	ldr	r0, [pc, #92]	@ (8012d8c <KEYBOARD_TerminalParseLine+0xfd4>)
 8012d30:	47a0      	blx	r4
						return 1; // command taken
 8012d32:	f7ff b86c 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					if ((value = get_on_off(parameter)) < 0) {
 8012d36:	f7fd ff0d 	bl	8010b54 <get_on_off>
 8012d3a:	2800      	cmp	r0, #0
 8012d3c:	da03      	bge.n	8012d46 <KEYBOARD_TerminalParseLine+0xf8e>
						out("Please specify on or off!");
 8012d3e:	4813      	ldr	r0, [pc, #76]	@ (8012d8c <KEYBOARD_TerminalParseLine+0xfd4>)
 8012d40:	47a0      	blx	r4
						return 1; // command taken
 8012d42:	f7ff b864 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					kc->ain_sustain_switch = value;
 8012d46:	4b0d      	ldr	r3, [pc, #52]	@ (8012d7c <KEYBOARD_TerminalParseLine+0xfc4>)
					out("Sustain controller behaves like a %s", kc->ain_sustain_switch ? "switch" : "pot");
 8012d48:	4911      	ldr	r1, [pc, #68]	@ (8012d90 <KEYBOARD_TerminalParseLine+0xfd8>)
					kc->ain_sustain_switch = value;
 8012d4a:	b2c0      	uxtb	r0, r0
 8012d4c:	f883 0144 	strb.w	r0, [r3, #324]	@ 0x144
					out("Sustain controller behaves like a %s", kc->ain_sustain_switch ? "switch" : "pot");
 8012d50:	4b10      	ldr	r3, [pc, #64]	@ (8012d94 <KEYBOARD_TerminalParseLine+0xfdc>)
 8012d52:	2800      	cmp	r0, #0
 8012d54:	bf18      	it	ne
 8012d56:	4619      	movne	r1, r3
 8012d58:	480f      	ldr	r0, [pc, #60]	@ (8012d98 <KEYBOARD_TerminalParseLine+0xfe0>)
 8012d5a:	47a0      	blx	r4
	if (!input_line_parsed) {
 8012d5c:	f7ff b857 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
					out("Unknown parameter for keyboard configuration - type 'help' to list available parameters!");
 8012d60:	480e      	ldr	r0, [pc, #56]	@ (8012d9c <KEYBOARD_TerminalParseLine+0xfe4>)
 8012d62:	47a0      	blx	r4
					return 1; // command taken
 8012d64:	f7ff b853 	b.w	8011e0e <KEYBOARD_TerminalParseLine+0x56>
			if (!*input_ptr)
 8012d68:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8012d6c:	2a00      	cmp	r2, #0
 8012d6e:	f47f a836 	bne.w	8011dde <KEYBOARD_TerminalParseLine+0x26>
				*input_ptr = ' ';
 8012d72:	7019      	strb	r1, [r3, #0]
		for (i = 0; i < input_len; ++i, ++input_ptr)
 8012d74:	f7ff b833 	b.w	8011dde <KEYBOARD_TerminalParseLine+0x26>
 8012d78:	080268c6 	.word	0x080268c6
 8012d7c:	20000370 	.word	0x20000370
 8012d80:	080268fc 	.word	0x080268fc
 8012d84:	08026926 	.word	0x08026926
 8012d88:	080237ba 	.word	0x080237ba
 8012d8c:	080266ce 	.word	0x080266ce
 8012d90:	080254d3 	.word	0x080254d3
 8012d94:	08024e1e 	.word	0x08024e1e
 8012d98:	08026939 	.word	0x08026939
 8012d9c:	0802695e 	.word	0x0802695e

08012da0 <TASK_Hooks>:

/////////////////////////////////////////////////////////////////////////////
// Remaining application hooks
/////////////////////////////////////////////////////////////////////////////
static void TASK_Hooks(void *pvParameters)
{
 8012da0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  portTickType xLastExecutionTime;

  // Initialise the xLastExecutionTime variable on task entry
  xLastExecutionTime = xTaskGetTickCount();
 8012da2:	f000 fb75 	bl	8013490 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
      xLastExecutionTime = xCurrentTickCount;

#if !defined(MIOS32_DONT_USE_DIN) && !defined(MIOS32_DONT_USE_SRIO)
    // check for DIN pin changes, call APP_DIN_NotifyToggle on each toggled pin
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 8012da6:	4e0e      	ldr	r6, [pc, #56]	@ (8012de0 <TASK_Hooks+0x40>)

    // check for encoder changes, call APP_ENC_NotifyChanged on each change
# ifndef MIOS32_DONT_USE_ENC
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 8012da8:	4d0e      	ldr	r5, [pc, #56]	@ (8012de4 <TASK_Hooks+0x44>)
# endif
#endif

#if !defined(MIOS32_DONT_USE_AIN) && !defined(MIOS32_DONT_SERVICE_AIN)
    // check for AIN pin changes, call APP_AIN_NotifyChange on each pin change
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 8012daa:	4c0f      	ldr	r4, [pc, #60]	@ (8012de8 <TASK_Hooks+0x48>)
  xLastExecutionTime = xTaskGetTickCount();
 8012dac:	9001      	str	r0, [sp, #4]
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8012dae:	2101      	movs	r1, #1
 8012db0:	a801      	add	r0, sp, #4
 8012db2:	f000 fc73 	bl	801369c <vTaskDelayUntil>
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8012db6:	f000 fb6b 	bl	8013490 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 8012dba:	9b01      	ldr	r3, [sp, #4]
 8012dbc:	1f42      	subs	r2, r0, #5
 8012dbe:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8012dc0:	bf88      	it	hi
 8012dc2:	9001      	strhi	r0, [sp, #4]
    MIOS32_DIN_Handler(APP_DIN_NotifyToggle);
 8012dc4:	4630      	mov	r0, r6
 8012dc6:	f001 fb71 	bl	80144ac <MIOS32_DIN_Handler>
    MIOS32_ENC_Handler(APP_ENC_NotifyChange);
 8012dca:	4628      	mov	r0, r5
 8012dcc:	f001 fbea 	bl	80145a4 <MIOS32_ENC_Handler>
    MIOS32_AIN_Handler(APP_AIN_NotifyChange);
 8012dd0:	4620      	mov	r0, r4
 8012dd2:	f004 fc11 	bl	80175f8 <MIOS32_AIN_Handler>
#endif

#if !defined(MIOS32_DONT_USE_COM)
    // check for incoming COM messages
    MIOS32_COM_Receive_Handler();
 8012dd6:	f002 fd3b 	bl	8015850 <MIOS32_COM_Receive_Handler>
#endif

    // optional APP_Tick() hook
    // helps to save memory (re-use the TASK_Hooks for other purposes...)
    APP_Tick();
 8012dda:	f7fd f9d1 	bl	8010180 <APP_Tick>
  while( 1 ) {
 8012dde:	e7e6      	b.n	8012dae <TASK_Hooks+0xe>
 8012de0:	080101ed 	.word	0x080101ed
 8012de4:	080101ef 	.word	0x080101ef
 8012de8:	080101f1 	.word	0x080101f1

08012dec <TASK_MIDI_Hooks>:
{
 8012dec:	b513      	push	{r0, r1, r4, lr}
  xLastExecutionTime = xTaskGetTickCount();
 8012dee:	f000 fb4f 	bl	8013490 <xTaskGetTickCount>
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8012df2:	4c0a      	ldr	r4, [pc, #40]	@ (8012e1c <TASK_MIDI_Hooks+0x30>)
  xLastExecutionTime = xTaskGetTickCount();
 8012df4:	9001      	str	r0, [sp, #4]
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8012df6:	2101      	movs	r1, #1
 8012df8:	a801      	add	r0, sp, #4
 8012dfa:	f000 fc4f 	bl	801369c <vTaskDelayUntil>
    portTickType xCurrentTickCount = xTaskGetTickCount();
 8012dfe:	f000 fb47 	bl	8013490 <xTaskGetTickCount>
    if( xLastExecutionTime < (xCurrentTickCount-5) )
 8012e02:	9b01      	ldr	r3, [sp, #4]
 8012e04:	1f42      	subs	r2, r0, #5
 8012e06:	429a      	cmp	r2, r3
      xLastExecutionTime = xCurrentTickCount;
 8012e08:	bf88      	it	hi
 8012e0a:	9001      	strhi	r0, [sp, #4]
    MIOS32_MIDI_Periodic_mS();
 8012e0c:	f001 ff90 	bl	8014d30 <MIOS32_MIDI_Periodic_mS>
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8012e10:	4620      	mov	r0, r4
 8012e12:	f002 fa69 	bl	80152e8 <MIOS32_MIDI_Receive_Handler>
    APP_MIDI_Tick();
 8012e16:	f7fd f9d1 	bl	80101bc <APP_MIDI_Tick>
  while( 1 ) {
 8012e1a:	e7ec      	b.n	8012df6 <TASK_MIDI_Hooks+0xa>
 8012e1c:	080101bf 	.word	0x080101bf

08012e20 <main>:
{
 8012e20:	b537      	push	{r0, r1, r2, r4, r5, lr}
  MIOS32_SYS_Init(0);
 8012e22:	2000      	movs	r0, #0
 8012e24:	f003 fbcc 	bl	80165c0 <MIOS32_SYS_Init>
  MIOS32_DELAY_Init(0);
 8012e28:	2000      	movs	r0, #0
 8012e2a:	f004 faad 	bl	8017388 <MIOS32_DELAY_Init>
  MIOS32_TIMESTAMP_Init(0);
 8012e2e:	2000      	movs	r0, #0
 8012e30:	f003 faec 	bl	801640c <MIOS32_TIMESTAMP_Init>
  MIOS32_BOARD_Init(0);
 8012e34:	2000      	movs	r0, #0
 8012e36:	f004 f8ad 	bl	8016f94 <MIOS32_BOARD_Init>
  MIOS32_SPI_Init(0);
 8012e3a:	2000      	movs	r0, #0
 8012e3c:	f003 fe98 	bl	8016b70 <MIOS32_SPI_Init>
  MIOS32_SRIO_Init(0);
 8012e40:	2000      	movs	r0, #0
 8012e42:	f001 fa5d 	bl	8014300 <MIOS32_SRIO_Init>
  MIOS32_DIN_Init(0);
 8012e46:	2000      	movs	r0, #0
 8012e48:	f001 faf6 	bl	8014438 <MIOS32_DIN_Init>
  MIOS32_DOUT_Init(0);
 8012e4c:	2000      	movs	r0, #0
 8012e4e:	f001 fb5f 	bl	8014510 <MIOS32_DOUT_Init>
  MIOS32_ENC_Init(0);
 8012e52:	2000      	movs	r0, #0
 8012e54:	f001 fb82 	bl	801455c <MIOS32_ENC_Init>
  MIOS32_MF_Init(0);
 8012e58:	2000      	movs	r0, #0
 8012e5a:	f002 ff1e 	bl	8015c9a <MIOS32_MF_Init>
  MIOS32_AIN_Init(0);
 8012e5e:	2000      	movs	r0, #0
 8012e60:	f004 face 	bl	8017400 <MIOS32_AIN_Init>
  MIOS32_IIC_BS_Init(0);
 8012e64:	2000      	movs	r0, #0
 8012e66:	f002 ff15 	bl	8015c94 <MIOS32_IIC_BS_Init>
  MIOS32_MIDI_Init(0);
 8012e6a:	2000      	movs	r0, #0
 8012e6c:	f001 fcdc 	bl	8014828 <MIOS32_MIDI_Init>
  MIOS32_USB_Init(0);
 8012e70:	2000      	movs	r0, #0
 8012e72:	f004 fe35 	bl	8017ae0 <MIOS32_USB_Init>
  MIOS32_OSC_Init(0);
 8012e76:	2000      	movs	r0, #0
 8012e78:	f002 fb48 	bl	801550c <MIOS32_OSC_Init>
  MIOS32_COM_Init(0);
 8012e7c:	2000      	movs	r0, #0
 8012e7e:	f002 fcb3 	bl	80157e8 <MIOS32_COM_Init>
  MIOS32_LCD_Init(0);
 8012e82:	2000      	movs	r0, #0
 8012e84:	f001 fc36 	bl	80146f4 <MIOS32_LCD_Init>
  MIOS32_LCD_DeviceSet(1);
 8012e88:	2001      	movs	r0, #1
 8012e8a:	f001 fbdf 	bl	801464c <MIOS32_LCD_DeviceSet>
  APP_LCD_Init(0);
 8012e8e:	2000      	movs	r0, #0
 8012e90:	f00a fb86 	bl	801d5a0 <APP_LCD_Init>
  MIOS32_LCD_DeviceSet(0);
 8012e94:	2000      	movs	r0, #0
 8012e96:	f001 fbd9 	bl	801464c <MIOS32_LCD_DeviceSet>
  __libc_init_array();
 8012e9a:	f010 fb67 	bl	802356c <__libc_init_array>
  APP_Init();
 8012e9e:	f7fd f8ed 	bl	801007c <APP_Init>
  MIOS32_LCD_PrintBootMessage();
 8012ea2:	f001 fc9f 	bl	80147e4 <MIOS32_LCD_PrintBootMessage>
 8012ea6:	f44f 64fa 	mov.w	r4, #2000	@ 0x7d0
    MIOS32_DELAY_Wait_uS(1000);
 8012eaa:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8012eae:	f004 fa89 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
  for(delay=0; delay<MIOS32_LCD_BOOT_MSG_DELAY; ++delay)
 8012eb2:	3c01      	subs	r4, #1
 8012eb4:	d1f9      	bne.n	8012eaa <main+0x8a>
  xTaskCreate(TASK_Hooks, "Hooks", (MIOS32_TASK_HOOKS_STACK_SIZE)/4, NULL, PRIORITY_TASK_HOOKS, NULL);
 8012eb6:	2503      	movs	r5, #3
 8012eb8:	4623      	mov	r3, r4
 8012eba:	490b      	ldr	r1, [pc, #44]	@ (8012ee8 <main+0xc8>)
 8012ebc:	9401      	str	r4, [sp, #4]
 8012ebe:	9500      	str	r5, [sp, #0]
 8012ec0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8012ec4:	4809      	ldr	r0, [pc, #36]	@ (8012eec <main+0xcc>)
 8012ec6:	f000 f9d3 	bl	8013270 <xTaskCreate>
  xTaskCreate(TASK_MIDI_Hooks, "MIDI_Hooks", (MIOS32_TASK_MIDI_HOOKS_STACK_SIZE)/4, NULL, PRIORITY_TASK_HOOKS, NULL);
 8012eca:	4909      	ldr	r1, [pc, #36]	@ (8012ef0 <main+0xd0>)
 8012ecc:	4809      	ldr	r0, [pc, #36]	@ (8012ef4 <main+0xd4>)
 8012ece:	4623      	mov	r3, r4
 8012ed0:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8012ed4:	e9cd 5400 	strd	r5, r4, [sp]
 8012ed8:	f000 f9ca 	bl	8013270 <xTaskCreate>
  vTaskStartScheduler();
 8012edc:	f000 fa9e 	bl	801341c <vTaskStartScheduler>
}
 8012ee0:	4620      	mov	r0, r4
 8012ee2:	b003      	add	sp, #12
 8012ee4:	bd30      	pop	{r4, r5, pc}
 8012ee6:	bf00      	nop
 8012ee8:	08026a24 	.word	0x08026a24
 8012eec:	08012da1 	.word	0x08012da1
 8012ef0:	08026a1f 	.word	0x08026a1f
 8012ef4:	08012ded 	.word	0x08012ded

08012ef8 <vApplicationTickHook>:
  MIOS32_TIMESTAMP_Inc();
 8012ef8:	f003 ba92 	b.w	8016420 <MIOS32_TIMESTAMP_Inc>

08012efc <vApplicationIdleHook>:
  APP_Background();
 8012efc:	f7fd b93e 	b.w	801017c <APP_Background>

08012f00 <_abort>:
// This function aborts any operations, but keeps MIDI alive (for uploading
// a new firmware)
// If MIDI isn't enabled, the status LED will be flashed
/////////////////////////////////////////////////////////////////////////////
void _abort(void)
{
 8012f00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
      // handle timeout/expire counters and USB packages
      MIOS32_MIDI_Periodic_mS();
    }

    // check for incoming MIDI packages and call hook
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8012f02:	4f0e      	ldr	r7, [pc, #56]	@ (8012f3c <_abort+0x3c>)
  u32 delay_ctr = 0;
 8012f04:	2400      	movs	r4, #0
    ++delay_ctr;
 8012f06:	2564      	movs	r5, #100	@ 0x64
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8012f08:	f242 7610 	movw	r6, #10000	@ 0x2710
    ++delay_ctr;
 8012f0c:	3401      	adds	r4, #1
 8012f0e:	fbb4 f3f5 	udiv	r3, r4, r5
 8012f12:	fb05 4313 	mls	r3, r5, r3, r4
    if( (delay_ctr % 100) == 0 ) {
 8012f16:	b90b      	cbnz	r3, 8012f1c <_abort+0x1c>
      MIOS32_MIDI_Periodic_mS();
 8012f18:	f001 ff0a 	bl	8014d30 <MIOS32_MIDI_Periodic_mS>
    MIOS32_MIDI_Receive_Handler(APP_MIDI_NotifyPackage);
 8012f1c:	4638      	mov	r0, r7
 8012f1e:	f002 f9e3 	bl	80152e8 <MIOS32_MIDI_Receive_Handler>
 8012f22:	fbb4 f3f6 	udiv	r3, r4, r6
 8012f26:	fb06 4313 	mls	r3, r6, r3, r4
#if !defined(MIOS32_DONT_USE_BOARD_LED)
    if( (delay_ctr % 10000) == 0 ) {
 8012f2a:	2b00      	cmp	r3, #0
 8012f2c:	d1ee      	bne.n	8012f0c <_abort+0xc>
      // toggle board LED
      MIOS32_BOARD_LED_Set(1, ~MIOS32_BOARD_LED_Get());
 8012f2e:	f004 f86f 	bl	8017010 <MIOS32_BOARD_LED_Get>
 8012f32:	43c1      	mvns	r1, r0
 8012f34:	2001      	movs	r0, #1
 8012f36:	f004 f83b 	bl	8016fb0 <MIOS32_BOARD_LED_Set>
 8012f3a:	e7e7      	b.n	8012f0c <_abort+0xc>
 8012f3c:	080101bf 	.word	0x080101bf

08012f40 <vApplicationMallocFailedHook>:

/////////////////////////////////////////////////////////////////////////////
// enabled in FreeRTOSConfig.h
/////////////////////////////////////////////////////////////////////////////
void vApplicationMallocFailedHook(void)
{
 8012f40:	b508      	push	{r3, lr}
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 8012f42:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 8012f46:	f001 fc6b 	bl	8014820 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 8012f4a:	2000      	movs	r0, #0
 8012f4c:	f001 fc6a 	bl	8014824 <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 8012f50:	2000      	movs	r0, #0
 8012f52:	f001 fb7b 	bl	801464c <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8012f56:	f001 fbcb 	bl	80146f0 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8012f5a:	2100      	movs	r1, #0
 8012f5c:	4608      	mov	r0, r1
 8012f5e:	f001 fb7b 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("FATAL: FreeRTOS "); // 16 chars
 8012f62:	4807      	ldr	r0, [pc, #28]	@ (8012f80 <vApplicationMallocFailedHook+0x40>)
 8012f64:	f001 fc20 	bl	80147a8 <MIOS32_LCD_PrintString>
  MIOS32_LCD_CursorSet(0, 1);
 8012f68:	2101      	movs	r1, #1
 8012f6a:	2000      	movs	r0, #0
 8012f6c:	f001 fb74 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Malloc Error!!! "); // 16 chars
 8012f70:	4804      	ldr	r0, [pc, #16]	@ (8012f84 <vApplicationMallocFailedHook+0x44>)
 8012f72:	f001 fc19 	bl	80147a8 <MIOS32_LCD_PrintString>
#endif

#ifndef MIOS32_DONT_USE_MIDI
  // Note: message won't be sent if MIDI task cannot be created!
  MIOS32_MIDI_SendDebugMessage("FATAL: FreeRTOS Malloc Error!!!\n");
 8012f76:	4804      	ldr	r0, [pc, #16]	@ (8012f88 <vApplicationMallocFailedHook+0x48>)
 8012f78:	f001 fe36 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
#endif

  _abort();
 8012f7c:	f7ff ffc0 	bl	8012f00 <_abort>
 8012f80:	08026a2a 	.word	0x08026a2a
 8012f84:	08026a3b 	.word	0x08026a3b
 8012f88:	08026a4c 	.word	0x08026a4c

08012f8c <HardFault_Handler_c>:

/////////////////////////////////////////////////////////////////////////////
// Customized HardFault Handler which prints out debugging informations
/////////////////////////////////////////////////////////////////////////////
void HardFault_Handler_c(unsigned int * hardfault_args)
{
 8012f8c:	b500      	push	{lr}
 8012f8e:	b089      	sub	sp, #36	@ 0x24
  volatile unsigned int stacked_r12;
  volatile unsigned int stacked_lr;
  volatile unsigned int stacked_pc;
  volatile unsigned int stacked_psr;

  stacked_r0 = ((unsigned long) hardfault_args[0]);
 8012f90:	6803      	ldr	r3, [r0, #0]
 8012f92:	9300      	str	r3, [sp, #0]
  stacked_r1 = ((unsigned long) hardfault_args[1]);
 8012f94:	6843      	ldr	r3, [r0, #4]
 8012f96:	9301      	str	r3, [sp, #4]
  stacked_r2 = ((unsigned long) hardfault_args[2]);
 8012f98:	6883      	ldr	r3, [r0, #8]
 8012f9a:	9302      	str	r3, [sp, #8]
  stacked_r3 = ((unsigned long) hardfault_args[3]);
 8012f9c:	68c3      	ldr	r3, [r0, #12]
 8012f9e:	9303      	str	r3, [sp, #12]

  stacked_r12 = ((unsigned long) hardfault_args[4]);
 8012fa0:	6903      	ldr	r3, [r0, #16]
 8012fa2:	9304      	str	r3, [sp, #16]
  stacked_lr = ((unsigned long) hardfault_args[5]);
 8012fa4:	6943      	ldr	r3, [r0, #20]
 8012fa6:	9305      	str	r3, [sp, #20]
  stacked_pc = ((unsigned long) hardfault_args[6]);
 8012fa8:	6983      	ldr	r3, [r0, #24]
 8012faa:	9306      	str	r3, [sp, #24]
  stacked_psr = ((unsigned long) hardfault_args[7]);
 8012fac:	69c3      	ldr	r3, [r0, #28]
 8012fae:	9307      	str	r3, [sp, #28]
  
  MIOS32_MIDI_SendDebugMessage("Hard Fault PC = %08x\n", stacked_pc); // ensure that at least the PC will be sent
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8012fb0:	4c32      	ldr	r4, [pc, #200]	@ (801307c <HardFault_Handler_c+0xf0>)
  MIOS32_MIDI_SendDebugMessage("Hard Fault PC = %08x\n", stacked_pc); // ensure that at least the PC will be sent
 8012fb2:	9906      	ldr	r1, [sp, #24]
 8012fb4:	4832      	ldr	r0, [pc, #200]	@ (8013080 <HardFault_Handler_c+0xf4>)
 8012fb6:	f001 fe17 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8012fba:	4620      	mov	r0, r4
 8012fbc:	f001 fe14 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("!!! HARD FAULT !!!\n");
 8012fc0:	4830      	ldr	r0, [pc, #192]	@ (8013084 <HardFault_Handler_c+0xf8>)
 8012fc2:	f001 fe11 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("==================\n");
 8012fc6:	4620      	mov	r0, r4
 8012fc8:	f001 fe0e 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R0 = %08x\n", stacked_r0);
 8012fcc:	9900      	ldr	r1, [sp, #0]
 8012fce:	482e      	ldr	r0, [pc, #184]	@ (8013088 <HardFault_Handler_c+0xfc>)
 8012fd0:	f001 fe0a 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R1 = %08x\n", stacked_r1);
 8012fd4:	9901      	ldr	r1, [sp, #4]
 8012fd6:	482d      	ldr	r0, [pc, #180]	@ (801308c <HardFault_Handler_c+0x100>)
 8012fd8:	f001 fe06 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R2 = %08x\n", stacked_r2);
 8012fdc:	9902      	ldr	r1, [sp, #8]
 8012fde:	482c      	ldr	r0, [pc, #176]	@ (8013090 <HardFault_Handler_c+0x104>)
 8012fe0:	f001 fe02 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R3 = %08x\n", stacked_r3);
 8012fe4:	9903      	ldr	r1, [sp, #12]
 8012fe6:	482b      	ldr	r0, [pc, #172]	@ (8013094 <HardFault_Handler_c+0x108>)
 8012fe8:	f001 fdfe 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("R12 = %08x\n", stacked_r12);
 8012fec:	9904      	ldr	r1, [sp, #16]
 8012fee:	482a      	ldr	r0, [pc, #168]	@ (8013098 <HardFault_Handler_c+0x10c>)
 8012ff0:	f001 fdfa 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 8012ff4:	9905      	ldr	r1, [sp, #20]
 8012ff6:	4829      	ldr	r0, [pc, #164]	@ (801309c <HardFault_Handler_c+0x110>)
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 8012ff8:	f04f 24e0 	mov.w	r4, #3758153728	@ 0xe000e000
  MIOS32_MIDI_SendDebugMessage("LR = %08x\n", stacked_lr);
 8012ffc:	f001 fdf4 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PC = %08x\n", stacked_pc);
 8013000:	9906      	ldr	r1, [sp, #24]
 8013002:	4827      	ldr	r0, [pc, #156]	@ (80130a0 <HardFault_Handler_c+0x114>)
 8013004:	f001 fdf0 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("PSR = %08x\n", stacked_psr);
 8013008:	9907      	ldr	r1, [sp, #28]
 801300a:	4826      	ldr	r0, [pc, #152]	@ (80130a4 <HardFault_Handler_c+0x118>)
 801300c:	f001 fdec 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("BFAR = %08x\n", (*((volatile unsigned long *)(0xE000ED38))));
 8013010:	f8d4 1d38 	ldr.w	r1, [r4, #3384]	@ 0xd38
 8013014:	4824      	ldr	r0, [pc, #144]	@ (80130a8 <HardFault_Handler_c+0x11c>)
 8013016:	f001 fde7 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("CFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED28))));
 801301a:	f8d4 1d28 	ldr.w	r1, [r4, #3368]	@ 0xd28
 801301e:	4823      	ldr	r0, [pc, #140]	@ (80130ac <HardFault_Handler_c+0x120>)
 8013020:	f001 fde2 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("HFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED2C))));
 8013024:	f8d4 1d2c 	ldr.w	r1, [r4, #3372]	@ 0xd2c
 8013028:	4821      	ldr	r0, [pc, #132]	@ (80130b0 <HardFault_Handler_c+0x124>)
 801302a:	f001 fddd 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("DFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED30))));
 801302e:	f8d4 1d30 	ldr.w	r1, [r4, #3376]	@ 0xd30
 8013032:	4820      	ldr	r0, [pc, #128]	@ (80130b4 <HardFault_Handler_c+0x128>)
 8013034:	f001 fdd8 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  MIOS32_MIDI_SendDebugMessage("AFSR = %08x\n", (*((volatile unsigned long *)(0xE000ED3C))));
 8013038:	f8d4 1d3c 	ldr.w	r1, [r4, #3388]	@ 0xd3c
 801303c:	481e      	ldr	r0, [pc, #120]	@ (80130b8 <HardFault_Handler_c+0x12c>)
 801303e:	f001 fdd3 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>

#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 8013042:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 8013046:	f001 fbeb 	bl	8014820 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 801304a:	2000      	movs	r0, #0
 801304c:	f001 fbea 	bl	8014824 <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 8013050:	2000      	movs	r0, #0
 8013052:	f001 fafb 	bl	801464c <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8013056:	f001 fb4b 	bl	80146f0 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 801305a:	2100      	movs	r1, #0
 801305c:	4608      	mov	r0, r1
 801305e:	f001 fafb 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("!! HARD FAULT !!");
 8013062:	4816      	ldr	r0, [pc, #88]	@ (80130bc <HardFault_Handler_c+0x130>)
 8013064:	f001 fba0 	bl	80147a8 <MIOS32_LCD_PrintString>
  MIOS32_LCD_CursorSet(0, 1);
 8013068:	2101      	movs	r1, #1
 801306a:	2000      	movs	r0, #0
 801306c:	f001 faf4 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintFormattedString("at PC=0x%08x", stacked_pc);
 8013070:	9906      	ldr	r1, [sp, #24]
 8013072:	4813      	ldr	r0, [pc, #76]	@ (80130c0 <HardFault_Handler_c+0x134>)
 8013074:	f001 fba4 	bl	80147c0 <MIOS32_LCD_PrintFormattedString>
#endif

  _abort();
 8013078:	f7ff ff42 	bl	8012f00 <_abort>
 801307c:	08026a83 	.word	0x08026a83
 8013080:	08026a6d 	.word	0x08026a6d
 8013084:	08026a97 	.word	0x08026a97
 8013088:	08026aab 	.word	0x08026aab
 801308c:	08026ab6 	.word	0x08026ab6
 8013090:	08026ac1 	.word	0x08026ac1
 8013094:	08026acc 	.word	0x08026acc
 8013098:	08026ad7 	.word	0x08026ad7
 801309c:	08026ae3 	.word	0x08026ae3
 80130a0:	08026a78 	.word	0x08026a78
 80130a4:	08026aee 	.word	0x08026aee
 80130a8:	08026afa 	.word	0x08026afa
 80130ac:	08026b07 	.word	0x08026b07
 80130b0:	08026b14 	.word	0x08026b14
 80130b4:	08026b21 	.word	0x08026b21
 80130b8:	08026b2e 	.word	0x08026b2e
 80130bc:	08026b3b 	.word	0x08026b3b
 80130c0:	08026b4c 	.word	0x08026b4c

080130c4 <HardFault_Handler>:
}


void HardFault_Handler(void)
{
  __asm("TST LR, #4");
 80130c4:	f01e 0f04 	tst.w	lr, #4
  __asm("ITE EQ");
 80130c8:	bf0c      	ite	eq
  __asm("MRSEQ R0, MSP");
 80130ca:	f3ef 8008 	mrseq	r0, MSP
  __asm("MRSNE R0, PSP");
 80130ce:	f3ef 8009 	mrsne	r0, PSP
  __asm("B HardFault_Handler_c");
 80130d2:	f7ff bf5b 	b.w	8012f8c <HardFault_Handler_c>
}
 80130d6:	4770      	bx	lr

080130d8 <_strtol_r>:
_DEFUN (_strtol_r, (rptr, nptr, endptr, base),
	struct _reent *rptr _AND
	_CONST char *nptr _AND
	char **endptr _AND
	int base)
{
 80130d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace(c));
 80130dc:	f8df 80cc 	ldr.w	r8, [pc, #204]	@ 80131ac <_strtol_r+0xd4>
	register const unsigned char *s = (const unsigned char *)nptr;
 80130e0:	460c      	mov	r4, r1
		c = *s++;
 80130e2:	4620      	mov	r0, r4
 80130e4:	f814 5b01 	ldrb.w	r5, [r4], #1
	} while (isspace(c));
 80130e8:	f818 6005 	ldrb.w	r6, [r8, r5]
 80130ec:	f016 0608 	ands.w	r6, r6, #8
 80130f0:	d1f7      	bne.n	80130e2 <_strtol_r+0xa>
	if (c == '-') {
 80130f2:	2d2d      	cmp	r5, #45	@ 0x2d
 80130f4:	d12f      	bne.n	8013156 <_strtol_r+0x7e>
		neg = 1;
		c = *s++;
 80130f6:	7825      	ldrb	r5, [r4, #0]
		neg = 1;
 80130f8:	2601      	movs	r6, #1
		c = *s++;
 80130fa:	1c84      	adds	r4, r0, #2
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
 80130fc:	f033 0010 	bics.w	r0, r3, #16
 8013100:	d109      	bne.n	8013116 <_strtol_r+0x3e>
 8013102:	2d30      	cmp	r5, #48	@ 0x30
 8013104:	d12c      	bne.n	8013160 <_strtol_r+0x88>
	    c == '0' && (*s == 'x' || *s == 'X')) {
 8013106:	7820      	ldrb	r0, [r4, #0]
 8013108:	f000 00df 	and.w	r0, r0, #223	@ 0xdf
 801310c:	2858      	cmp	r0, #88	@ 0x58
 801310e:	d127      	bne.n	8013160 <_strtol_r+0x88>
		c = s[1];
 8013110:	7865      	ldrb	r5, [r4, #1]
		s += 2;
		base = 16;
 8013112:	2310      	movs	r3, #16
		s += 2;
 8013114:	3402      	adds	r4, #2
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -(unsigned long)LONG_MIN : LONG_MAX;
 8013116:	f106 4c00 	add.w	ip, r6, #2147483648	@ 0x80000000
 801311a:	f10c 3cff 	add.w	ip, ip, #4294967295	@ 0xffffffff
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
 801311e:	2700      	movs	r7, #0
	cutlim = cutoff % (unsigned long)base;
 8013120:	fbbc f9f3 	udiv	r9, ip, r3
	for (acc = 0, any = 0;; c = *s++) {
 8013124:	4638      	mov	r0, r7
	cutlim = cutoff % (unsigned long)base;
 8013126:	fb03 ca19 	mls	sl, r3, r9, ip
		if (isdigit(c))
 801312a:	f818 e005 	ldrb.w	lr, [r8, r5]
 801312e:	f01e 0f04 	tst.w	lr, #4
 8013132:	d01c      	beq.n	801316e <_strtol_r+0x96>
			c -= '0';
 8013134:	3d30      	subs	r5, #48	@ 0x30
		else if (isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
 8013136:	42ab      	cmp	r3, r5
 8013138:	dd29      	ble.n	801318e <_strtol_r+0xb6>
			break;
               if (any < 0 || acc > cutoff || (acc == cutoff && c > cutlim))
 801313a:	f1b7 3fff 	cmp.w	r7, #4294967295	@ 0xffffffff
 801313e:	d007      	beq.n	8013150 <_strtol_r+0x78>
 8013140:	4548      	cmp	r0, r9
 8013142:	d821      	bhi.n	8013188 <_strtol_r+0xb0>
 8013144:	d101      	bne.n	801314a <_strtol_r+0x72>
 8013146:	4555      	cmp	r5, sl
 8013148:	dc1e      	bgt.n	8013188 <_strtol_r+0xb0>
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
 801314a:	fb00 5003 	mla	r0, r0, r3, r5
			any = 1;
 801314e:	2701      	movs	r7, #1
	for (acc = 0, any = 0;; c = *s++) {
 8013150:	f814 5b01 	ldrb.w	r5, [r4], #1
		if (isdigit(c))
 8013154:	e7e9      	b.n	801312a <_strtol_r+0x52>
	} else if (c == '+')
 8013156:	2d2b      	cmp	r5, #43	@ 0x2b
		c = *s++;
 8013158:	bf04      	itt	eq
 801315a:	7825      	ldrbeq	r5, [r4, #0]
 801315c:	1c84      	addeq	r4, r0, #2
 801315e:	e7cd      	b.n	80130fc <_strtol_r+0x24>
	if (base == 0)
 8013160:	2b00      	cmp	r3, #0
 8013162:	d1d8      	bne.n	8013116 <_strtol_r+0x3e>
		base = c == '0' ? 8 : 10;
 8013164:	2d30      	cmp	r5, #48	@ 0x30
 8013166:	bf0c      	ite	eq
 8013168:	2308      	moveq	r3, #8
 801316a:	230a      	movne	r3, #10
 801316c:	e7d3      	b.n	8013116 <_strtol_r+0x3e>
		else if (isalpha(c))
 801316e:	f01e 0e03 	ands.w	lr, lr, #3
 8013172:	d00c      	beq.n	801318e <_strtol_r+0xb6>
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
 8013174:	f1be 0f01 	cmp.w	lr, #1
 8013178:	bf14      	ite	ne
 801317a:	f04f 0e57 	movne.w	lr, #87	@ 0x57
 801317e:	f04f 0e37 	moveq.w	lr, #55	@ 0x37
 8013182:	eba5 050e 	sub.w	r5, r5, lr
 8013186:	e7d6      	b.n	8013136 <_strtol_r+0x5e>
			any = -1;
 8013188:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
 801318c:	e7e0      	b.n	8013150 <_strtol_r+0x78>
		}
	}
	if (any < 0) {
 801318e:	1c7b      	adds	r3, r7, #1
 8013190:	d007      	beq.n	80131a2 <_strtol_r+0xca>
		acc = neg ? LONG_MIN : LONG_MAX;
#if NO_ERRNO == 0
		rptr->_errno = ERANGE;
#endif
	} else if (neg)
 8013192:	b106      	cbz	r6, 8013196 <_strtol_r+0xbe>
		acc = -acc;
 8013194:	4240      	negs	r0, r0
	if (endptr != 0)
 8013196:	b112      	cbz	r2, 801319e <_strtol_r+0xc6>
		*endptr = (char *) (any ? (char *)s - 1 : nptr);
 8013198:	b107      	cbz	r7, 801319c <_strtol_r+0xc4>
 801319a:	1e61      	subs	r1, r4, #1
 801319c:	6011      	str	r1, [r2, #0]
	return (acc);
}
 801319e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		acc = neg ? LONG_MIN : LONG_MAX;
 80131a2:	4660      	mov	r0, ip
	if (endptr != 0)
 80131a4:	2a00      	cmp	r2, #0
 80131a6:	d1f8      	bne.n	801319a <_strtol_r+0xc2>
 80131a8:	e7f9      	b.n	801319e <_strtol_r+0xc6>
 80131aa:	bf00      	nop
 80131ac:	080292e5 	.word	0x080292e5

080131b0 <strtol>:
long
_DEFUN (strtol, (s, ptr, base),
	_CONST char *s _AND
	char **ptr _AND
	int base)
{
 80131b0:	4613      	mov	r3, r2
#if NO_ERRNO == 0
	return _strtol_r (_REENT, s, ptr, base);
#else
	return _strtol_r (NULL, s, ptr, base);
 80131b2:	460a      	mov	r2, r1
 80131b4:	4601      	mov	r1, r0
 80131b6:	2000      	movs	r0, #0
 80131b8:	f7ff bf8e 	b.w	80130d8 <_strtol_r>

080131bc <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80131bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80131be:	4b1c      	ldr	r3, [pc, #112]	@ (8013230 <prvAddCurrentTaskToDelayedList+0x74>)
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 80131c0:	4d1c      	ldr	r5, [pc, #112]	@ (8013234 <prvAddCurrentTaskToDelayedList+0x78>)
const TickType_t xConstTickCount = xTickCount;
 80131c2:	681c      	ldr	r4, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 80131c4:	682b      	ldr	r3, [r5, #0]
{
 80131c6:	4606      	mov	r6, r0
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80131c8:	6828      	ldr	r0, [r5, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 80131ca:	2200      	movs	r2, #0
 80131cc:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80131d0:	3004      	adds	r0, #4
{
 80131d2:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80131d4:	f000 fc42 	bl	8013a5c <uxListRemove>
 80131d8:	b940      	cbnz	r0, 80131ec <prvAddCurrentTaskToDelayedList+0x30>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 80131da:	682a      	ldr	r2, [r5, #0]
 80131dc:	4916      	ldr	r1, [pc, #88]	@ (8013238 <prvAddCurrentTaskToDelayedList+0x7c>)
 80131de:	6ad0      	ldr	r0, [r2, #44]	@ 0x2c
 80131e0:	680b      	ldr	r3, [r1, #0]
 80131e2:	2201      	movs	r2, #1
 80131e4:	4082      	lsls	r2, r0
 80131e6:	ea23 0302 	bic.w	r3, r3, r2
 80131ea:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80131ec:	1c73      	adds	r3, r6, #1
 80131ee:	d107      	bne.n	8013200 <prvAddCurrentTaskToDelayedList+0x44>
 80131f0:	b137      	cbz	r7, 8013200 <prvAddCurrentTaskToDelayedList+0x44>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80131f2:	6829      	ldr	r1, [r5, #0]
 80131f4:	4811      	ldr	r0, [pc, #68]	@ (801323c <prvAddCurrentTaskToDelayedList+0x80>)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80131f6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80131fa:	3104      	adds	r1, #4
 80131fc:	f000 bc0c 	b.w	8013a18 <vListInsertEnd>
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8013200:	682b      	ldr	r3, [r5, #0]
 8013202:	19a4      	adds	r4, r4, r6
 8013204:	605c      	str	r4, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 8013206:	d307      	bcc.n	8013218 <prvAddCurrentTaskToDelayedList+0x5c>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013208:	4b0d      	ldr	r3, [pc, #52]	@ (8013240 <prvAddCurrentTaskToDelayedList+0x84>)
 801320a:	6818      	ldr	r0, [r3, #0]
 801320c:	6829      	ldr	r1, [r5, #0]
}
 801320e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013212:	3104      	adds	r1, #4
 8013214:	f000 bc0b 	b.w	8013a2e <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8013218:	4b0a      	ldr	r3, [pc, #40]	@ (8013244 <prvAddCurrentTaskToDelayedList+0x88>)
 801321a:	6818      	ldr	r0, [r3, #0]
 801321c:	6829      	ldr	r1, [r5, #0]
 801321e:	3104      	adds	r1, #4
 8013220:	f000 fc05 	bl	8013a2e <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8013224:	4b08      	ldr	r3, [pc, #32]	@ (8013248 <prvAddCurrentTaskToDelayedList+0x8c>)
 8013226:	681a      	ldr	r2, [r3, #0]
 8013228:	42a2      	cmp	r2, r4
					xNextTaskUnblockTime = xTimeToWake;
 801322a:	bf88      	it	hi
 801322c:	601c      	strhi	r4, [r3, #0]
}
 801322e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8013230:	20002ce4 	.word	0x20002ce4
 8013234:	20002dc0 	.word	0x20002dc0
 8013238:	20002ce0 	.word	0x20002ce0
 801323c:	20002cec 	.word	0x20002cec
 8013240:	20002d2c 	.word	0x20002d2c
 8013244:	20002d30 	.word	0x20002d30
 8013248:	20002cc8 	.word	0x20002cc8

0801324c <prvResetNextTaskUnblockTime>:
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 801324c:	4a06      	ldr	r2, [pc, #24]	@ (8013268 <prvResetNextTaskUnblockTime+0x1c>)
 801324e:	6813      	ldr	r3, [r2, #0]
 8013250:	6819      	ldr	r1, [r3, #0]
 8013252:	4b06      	ldr	r3, [pc, #24]	@ (801326c <prvResetNextTaskUnblockTime+0x20>)
 8013254:	b919      	cbnz	r1, 801325e <prvResetNextTaskUnblockTime+0x12>
		xNextTaskUnblockTime = portMAX_DELAY;
 8013256:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 801325a:	601a      	str	r2, [r3, #0]
}
 801325c:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 801325e:	6812      	ldr	r2, [r2, #0]
 8013260:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8013262:	68d2      	ldr	r2, [r2, #12]
 8013264:	6852      	ldr	r2, [r2, #4]
 8013266:	e7f8      	b.n	801325a <prvResetNextTaskUnblockTime+0xe>
 8013268:	20002d30 	.word	0x20002d30
 801326c:	20002cc8 	.word	0x20002cc8

08013270 <xTaskCreate>:
	{
 8013270:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013274:	0095      	lsls	r5, r2, #2
	{
 8013276:	4606      	mov	r6, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013278:	4628      	mov	r0, r5
	{
 801327a:	f8dd 802c 	ldr.w	r8, [sp, #44]	@ 0x2c
 801327e:	468a      	mov	sl, r1
 8013280:	461f      	mov	r7, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013282:	f000 feff 	bl	8014084 <pvPortMalloc>
			if( pxStack != NULL )
 8013286:	4681      	mov	r9, r0
 8013288:	b918      	cbnz	r0, 8013292 <xTaskCreate+0x22>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 801328a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
	}
 801328e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8013292:	2050      	movs	r0, #80	@ 0x50
 8013294:	f000 fef6 	bl	8014084 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8013298:	4604      	mov	r4, r0
 801329a:	2800      	cmp	r0, #0
 801329c:	f000 80a0 	beq.w	80133e0 <xTaskCreate+0x170>
					pxNewTCB->pxStack = pxStack;
 80132a0:	f8c0 9030 	str.w	r9, [r0, #48]	@ 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80132a4:	462a      	mov	r2, r5
 80132a6:	4648      	mov	r0, r9
 80132a8:	21a5      	movs	r1, #165	@ 0xa5
 80132aa:	f010 f952 	bl	8023552 <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 80132ae:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80132b0:	3d04      	subs	r5, #4
 80132b2:	442b      	add	r3, r5
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 80132b4:	f023 0907 	bic.w	r9, r3, #7
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80132b8:	f104 0233 	add.w	r2, r4, #51	@ 0x33
 80132bc:	f10a 33ff 	add.w	r3, sl, #4294967295	@ 0xffffffff
 80132c0:	f10a 0a0f 	add.w	sl, sl, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80132c4:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80132c8:	f802 1f01 	strb.w	r1, [r2, #1]!
		if( pcName[ x ] == 0x00 )
 80132cc:	b109      	cbz	r1, 80132d2 <xTaskCreate+0x62>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80132ce:	4553      	cmp	r3, sl
 80132d0:	d1f8      	bne.n	80132c4 <xTaskCreate+0x54>
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 80132d2:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 80132d4:	2d04      	cmp	r5, #4
 80132d6:	bf28      	it	cs
 80132d8:	2504      	movcs	r5, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80132da:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80132de:	f104 0a04 	add.w	sl, r4, #4
		pxNewTCB->uxMutexesHeld = 0;
 80132e2:	e9c4 5b11 	strd	r5, fp, [r4, #68]	@ 0x44
	pxNewTCB->uxPriority = uxPriority;
 80132e6:	62e5      	str	r5, [r4, #44]	@ 0x2c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80132e8:	4650      	mov	r0, sl
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 80132ea:	f884 b043 	strb.w	fp, [r4, #67]	@ 0x43
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 80132ee:	f000 fb90 	bl	8013a12 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80132f2:	f1c5 0505 	rsb	r5, r5, #5
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 80132f6:	f104 0018 	add.w	r0, r4, #24
 80132fa:	f000 fb8a 	bl	8013a12 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 80132fe:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013300:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8013302:	6264      	str	r4, [r4, #36]	@ 0x24
		pxNewTCB->ucDelayAborted = pdFALSE;
 8013304:	f884 b04c 	strb.w	fp, [r4, #76]	@ 0x4c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8013308:	463a      	mov	r2, r7
 801330a:	4631      	mov	r1, r6
 801330c:	4648      	mov	r0, r9
 801330e:	f000 fdf1 	bl	8013ef4 <pxPortInitialiseStack>
 8013312:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8013314:	f1b8 0f00 	cmp.w	r8, #0
 8013318:	d001      	beq.n	801331e <xTaskCreate+0xae>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 801331a:	f8c8 4000 	str.w	r4, [r8]
	taskENTER_CRITICAL();
 801331e:	f000 fe11 	bl	8013f44 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8013322:	4b31      	ldr	r3, [pc, #196]	@ (80133e8 <xTaskCreate+0x178>)
		if( pxCurrentTCB == NULL )
 8013324:	4f31      	ldr	r7, [pc, #196]	@ (80133ec <xTaskCreate+0x17c>)
		uxCurrentNumberOfTasks++;
 8013326:	681a      	ldr	r2, [r3, #0]
 8013328:	4e31      	ldr	r6, [pc, #196]	@ (80133f0 <xTaskCreate+0x180>)
 801332a:	3201      	adds	r2, #1
 801332c:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 801332e:	683d      	ldr	r5, [r7, #0]
 8013330:	2d00      	cmp	r5, #0
 8013332:	d14a      	bne.n	80133ca <xTaskCreate+0x15a>
			pxCurrentTCB = pxNewTCB;
 8013334:	603c      	str	r4, [r7, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8013336:	681b      	ldr	r3, [r3, #0]
 8013338:	2b01      	cmp	r3, #1
 801333a:	d11f      	bne.n	801337c <xTaskCreate+0x10c>
 801333c:	46b0      	mov	r8, r6
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 801333e:	4640      	mov	r0, r8
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8013340:	3501      	adds	r5, #1
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8013342:	f000 fb5b 	bl	80139fc <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8013346:	2d05      	cmp	r5, #5
 8013348:	f108 0814 	add.w	r8, r8, #20
 801334c:	d1f7      	bne.n	801333e <xTaskCreate+0xce>
	vListInitialise( &xDelayedTaskList1 );
 801334e:	f8df 80a4 	ldr.w	r8, [pc, #164]	@ 80133f4 <xTaskCreate+0x184>
	vListInitialise( &xDelayedTaskList2 );
 8013352:	4d29      	ldr	r5, [pc, #164]	@ (80133f8 <xTaskCreate+0x188>)
	vListInitialise( &xDelayedTaskList1 );
 8013354:	4640      	mov	r0, r8
 8013356:	f000 fb51 	bl	80139fc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 801335a:	4628      	mov	r0, r5
 801335c:	f000 fb4e 	bl	80139fc <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8013360:	4826      	ldr	r0, [pc, #152]	@ (80133fc <xTaskCreate+0x18c>)
 8013362:	f000 fb4b 	bl	80139fc <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8013366:	4826      	ldr	r0, [pc, #152]	@ (8013400 <xTaskCreate+0x190>)
 8013368:	f000 fb48 	bl	80139fc <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 801336c:	4825      	ldr	r0, [pc, #148]	@ (8013404 <xTaskCreate+0x194>)
 801336e:	f000 fb45 	bl	80139fc <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8013372:	4b25      	ldr	r3, [pc, #148]	@ (8013408 <xTaskCreate+0x198>)
 8013374:	f8c3 8000 	str.w	r8, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8013378:	4b24      	ldr	r3, [pc, #144]	@ (801340c <xTaskCreate+0x19c>)
 801337a:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 801337c:	4a24      	ldr	r2, [pc, #144]	@ (8013410 <xTaskCreate+0x1a0>)
		prvAddTaskToReadyList( pxNewTCB );
 801337e:	4925      	ldr	r1, [pc, #148]	@ (8013414 <xTaskCreate+0x1a4>)
		uxTaskNumber++;
 8013380:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8013382:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8013384:	3301      	adds	r3, #1
 8013386:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8013388:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801338a:	2301      	movs	r3, #1
 801338c:	4093      	lsls	r3, r2
 801338e:	4303      	orrs	r3, r0
 8013390:	2014      	movs	r0, #20
 8013392:	600b      	str	r3, [r1, #0]
 8013394:	fb00 6002 	mla	r0, r0, r2, r6
 8013398:	4651      	mov	r1, sl
 801339a:	f000 fb3d 	bl	8013a18 <vListInsertEnd>
	taskEXIT_CRITICAL();
 801339e:	f000 fde1 	bl	8013f64 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 80133a2:	4b1d      	ldr	r3, [pc, #116]	@ (8013418 <xTaskCreate+0x1a8>)
 80133a4:	681b      	ldr	r3, [r3, #0]
 80133a6:	b173      	cbz	r3, 80133c6 <xTaskCreate+0x156>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80133a8:	683b      	ldr	r3, [r7, #0]
 80133aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80133ac:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
 80133ae:	429a      	cmp	r2, r3
 80133b0:	d209      	bcs.n	80133c6 <xTaskCreate+0x156>
			taskYIELD_IF_USING_PREEMPTION();
 80133b2:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80133b6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80133ba:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80133be:	f3bf 8f4f 	dsb	sy
 80133c2:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
 80133c6:	2001      	movs	r0, #1
		return xReturn;
 80133c8:	e761      	b.n	801328e <xTaskCreate+0x1e>
			if( xSchedulerRunning == pdFALSE )
 80133ca:	4b13      	ldr	r3, [pc, #76]	@ (8013418 <xTaskCreate+0x1a8>)
 80133cc:	681a      	ldr	r2, [r3, #0]
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80133ce:	6ae3      	ldr	r3, [r4, #44]	@ 0x2c
			if( xSchedulerRunning == pdFALSE )
 80133d0:	2a00      	cmp	r2, #0
 80133d2:	d1d3      	bne.n	801337c <xTaskCreate+0x10c>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80133d4:	683a      	ldr	r2, [r7, #0]
 80133d6:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80133d8:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 80133da:	bf98      	it	ls
 80133dc:	603c      	strls	r4, [r7, #0]
 80133de:	e7cd      	b.n	801337c <xTaskCreate+0x10c>
					vPortFree( pxStack );
 80133e0:	4648      	mov	r0, r9
 80133e2:	f000 fecd 	bl	8014180 <vPortFree>
		if( pxNewTCB != NULL )
 80133e6:	e750      	b.n	801328a <xTaskCreate+0x1a>
 80133e8:	20002ce8 	.word	0x20002ce8
 80133ec:	20002dc0 	.word	0x20002dc0
 80133f0:	20002d5c 	.word	0x20002d5c
 80133f4:	20002d48 	.word	0x20002d48
 80133f8:	20002d34 	.word	0x20002d34
 80133fc:	20002d18 	.word	0x20002d18
 8013400:	20002d04 	.word	0x20002d04
 8013404:	20002cec 	.word	0x20002cec
 8013408:	20002d30 	.word	0x20002d30
 801340c:	20002d2c 	.word	0x20002d2c
 8013410:	20002ccc 	.word	0x20002ccc
 8013414:	20002ce0 	.word	0x20002ce0
 8013418:	20002cdc 	.word	0x20002cdc

0801341c <vTaskStartScheduler>:
{
 801341c:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 801341e:	4b12      	ldr	r3, [pc, #72]	@ (8013468 <vTaskStartScheduler+0x4c>)
 8013420:	9301      	str	r3, [sp, #4]
 8013422:	2400      	movs	r4, #0
 8013424:	4911      	ldr	r1, [pc, #68]	@ (801346c <vTaskStartScheduler+0x50>)
 8013426:	4812      	ldr	r0, [pc, #72]	@ (8013470 <vTaskStartScheduler+0x54>)
 8013428:	9400      	str	r4, [sp, #0]
 801342a:	4623      	mov	r3, r4
 801342c:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8013430:	f7ff ff1e 	bl	8013270 <xTaskCreate>
	if( xReturn == pdPASS )
 8013434:	2801      	cmp	r0, #1
 8013436:	d114      	bne.n	8013462 <vTaskStartScheduler+0x46>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8013438:	f04f 03bf 	mov.w	r3, #191	@ 0xbf
 801343c:	f383 8811 	msr	BASEPRI, r3
 8013440:	f3bf 8f6f 	isb	sy
 8013444:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8013448:	4b0a      	ldr	r3, [pc, #40]	@ (8013474 <vTaskStartScheduler+0x58>)
 801344a:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801344e:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8013450:	4b09      	ldr	r3, [pc, #36]	@ (8013478 <vTaskStartScheduler+0x5c>)
 8013452:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8013454:	4b09      	ldr	r3, [pc, #36]	@ (801347c <vTaskStartScheduler+0x60>)
 8013456:	601c      	str	r4, [r3, #0]
}
 8013458:	b002      	add	sp, #8
 801345a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 801345e:	f000 bdd1 	b.w	8014004 <xPortStartScheduler>
}
 8013462:	b002      	add	sp, #8
 8013464:	bd10      	pop	{r4, pc}
 8013466:	bf00      	nop
 8013468:	20002cc4 	.word	0x20002cc4
 801346c:	08026b59 	.word	0x08026b59
 8013470:	080136ed 	.word	0x080136ed
 8013474:	20002cc8 	.word	0x20002cc8
 8013478:	20002cdc 	.word	0x20002cdc
 801347c:	20002ce4 	.word	0x20002ce4

08013480 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8013480:	4a02      	ldr	r2, [pc, #8]	@ (801348c <vTaskSuspendAll+0xc>)
 8013482:	6813      	ldr	r3, [r2, #0]
 8013484:	3301      	adds	r3, #1
 8013486:	6013      	str	r3, [r2, #0]
}
 8013488:	4770      	bx	lr
 801348a:	bf00      	nop
 801348c:	20002cc0 	.word	0x20002cc0

08013490 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8013490:	4b01      	ldr	r3, [pc, #4]	@ (8013498 <xTaskGetTickCount+0x8>)
 8013492:	6818      	ldr	r0, [r3, #0]
}
 8013494:	4770      	bx	lr
 8013496:	bf00      	nop
 8013498:	20002ce4 	.word	0x20002ce4

0801349c <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 801349c:	4b3e      	ldr	r3, [pc, #248]	@ (8013598 <xTaskIncrementTick+0xfc>)
 801349e:	681b      	ldr	r3, [r3, #0]
{
 80134a0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80134a4:	2b00      	cmp	r3, #0
 80134a6:	d16e      	bne.n	8013586 <xTaskIncrementTick+0xea>
		const TickType_t xConstTickCount = xTickCount + 1;
 80134a8:	4b3c      	ldr	r3, [pc, #240]	@ (801359c <xTaskIncrementTick+0x100>)
 80134aa:	681c      	ldr	r4, [r3, #0]
 80134ac:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 80134ae:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 80134b0:	b95c      	cbnz	r4, 80134ca <xTaskIncrementTick+0x2e>
			taskSWITCH_DELAYED_LISTS();
 80134b2:	4a3b      	ldr	r2, [pc, #236]	@ (80135a0 <xTaskIncrementTick+0x104>)
 80134b4:	4b3b      	ldr	r3, [pc, #236]	@ (80135a4 <xTaskIncrementTick+0x108>)
 80134b6:	6811      	ldr	r1, [r2, #0]
 80134b8:	6818      	ldr	r0, [r3, #0]
 80134ba:	6010      	str	r0, [r2, #0]
 80134bc:	4a3a      	ldr	r2, [pc, #232]	@ (80135a8 <xTaskIncrementTick+0x10c>)
 80134be:	6019      	str	r1, [r3, #0]
 80134c0:	6813      	ldr	r3, [r2, #0]
 80134c2:	3301      	adds	r3, #1
 80134c4:	6013      	str	r3, [r2, #0]
 80134c6:	f7ff fec1 	bl	801324c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80134ca:	4d38      	ldr	r5, [pc, #224]	@ (80135ac <xTaskIncrementTick+0x110>)
 80134cc:	4e38      	ldr	r6, [pc, #224]	@ (80135b0 <xTaskIncrementTick+0x114>)
 80134ce:	682b      	ldr	r3, [r5, #0]
 80134d0:	4f38      	ldr	r7, [pc, #224]	@ (80135b4 <xTaskIncrementTick+0x118>)
 80134d2:	42a3      	cmp	r3, r4
BaseType_t xSwitchRequired = pdFALSE;
 80134d4:	f04f 0b00 	mov.w	fp, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 80134d8:	d916      	bls.n	8013508 <xTaskIncrementTick+0x6c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80134da:	683a      	ldr	r2, [r7, #0]
 80134dc:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80134de:	2114      	movs	r1, #20
 80134e0:	434a      	muls	r2, r1
 80134e2:	58b2      	ldr	r2, [r6, r2]
				xSwitchRequired = pdTRUE;
 80134e4:	2a02      	cmp	r2, #2
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 80134e6:	4a34      	ldr	r2, [pc, #208]	@ (80135b8 <xTaskIncrementTick+0x11c>)
 80134e8:	6812      	ldr	r2, [r2, #0]
				xSwitchRequired = pdTRUE;
 80134ea:	bf28      	it	cs
 80134ec:	f04f 0b01 	movcs.w	fp, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 80134f0:	b90a      	cbnz	r2, 80134f6 <xTaskIncrementTick+0x5a>
				vApplicationTickHook();
 80134f2:	f7ff fd01 	bl	8012ef8 <vApplicationTickHook>
		if( xYieldPending != pdFALSE )
 80134f6:	4a31      	ldr	r2, [pc, #196]	@ (80135bc <xTaskIncrementTick+0x120>)
 80134f8:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 80134fa:	2a00      	cmp	r2, #0
}
 80134fc:	bf0c      	ite	eq
 80134fe:	4658      	moveq	r0, fp
 8013500:	2001      	movne	r0, #1
 8013502:	b003      	add	sp, #12
 8013504:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8013508:	f8df a094 	ldr.w	sl, [pc, #148]	@ 80135a0 <xTaskIncrementTick+0x104>
					prvAddTaskToReadyList( pxTCB );
 801350c:	f8df 90b0 	ldr.w	r9, [pc, #176]	@ 80135c0 <xTaskIncrementTick+0x124>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8013510:	f8da 2000 	ldr.w	r2, [sl]
 8013514:	6812      	ldr	r2, [r2, #0]
 8013516:	b91a      	cbnz	r2, 8013520 <xTaskIncrementTick+0x84>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013518:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801351c:	602a      	str	r2, [r5, #0]
					break;
 801351e:	e7dc      	b.n	80134da <xTaskIncrementTick+0x3e>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8013520:	f8da 2000 	ldr.w	r2, [sl]
 8013524:	68d2      	ldr	r2, [r2, #12]
 8013526:	f8d2 800c 	ldr.w	r8, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 801352a:	f8d8 1004 	ldr.w	r1, [r8, #4]
					if( xConstTickCount < xItemValue )
 801352e:	428c      	cmp	r4, r1
 8013530:	d201      	bcs.n	8013536 <xTaskIncrementTick+0x9a>
						xNextTaskUnblockTime = xItemValue;
 8013532:	6029      	str	r1, [r5, #0]
						break;
 8013534:	e7d1      	b.n	80134da <xTaskIncrementTick+0x3e>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8013536:	f108 0304 	add.w	r3, r8, #4
 801353a:	4618      	mov	r0, r3
 801353c:	9301      	str	r3, [sp, #4]
 801353e:	f000 fa8d 	bl	8013a5c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8013542:	f8d8 1028 	ldr.w	r1, [r8, #40]	@ 0x28
 8013546:	b119      	cbz	r1, 8013550 <xTaskIncrementTick+0xb4>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8013548:	f108 0018 	add.w	r0, r8, #24
 801354c:	f000 fa86 	bl	8013a5c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8013550:	f8d8 002c 	ldr.w	r0, [r8, #44]	@ 0x2c
 8013554:	f8d9 3000 	ldr.w	r3, [r9]
 8013558:	2201      	movs	r2, #1
 801355a:	fa02 f100 	lsl.w	r1, r2, r0
 801355e:	4319      	orrs	r1, r3
 8013560:	f04f 0c14 	mov.w	ip, #20
 8013564:	f8c9 1000 	str.w	r1, [r9]
 8013568:	fb0c 6000 	mla	r0, ip, r0, r6
 801356c:	f108 0104 	add.w	r1, r8, #4
 8013570:	f000 fa52 	bl	8013a18 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8013574:	6838      	ldr	r0, [r7, #0]
 8013576:	f8d8 102c 	ldr.w	r1, [r8, #44]	@ 0x2c
 801357a:	6ac2      	ldr	r2, [r0, #44]	@ 0x2c
							xSwitchRequired = pdTRUE;
 801357c:	4291      	cmp	r1, r2
 801357e:	bf28      	it	cs
 8013580:	f04f 0b01 	movcs.w	fp, #1
 8013584:	e7c4      	b.n	8013510 <xTaskIncrementTick+0x74>
		++uxPendedTicks;
 8013586:	4a0c      	ldr	r2, [pc, #48]	@ (80135b8 <xTaskIncrementTick+0x11c>)
 8013588:	6813      	ldr	r3, [r2, #0]
 801358a:	3301      	adds	r3, #1
 801358c:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 801358e:	f04f 0b00 	mov.w	fp, #0
			vApplicationTickHook();
 8013592:	f7ff fcb1 	bl	8012ef8 <vApplicationTickHook>
 8013596:	e7ae      	b.n	80134f6 <xTaskIncrementTick+0x5a>
 8013598:	20002cc0 	.word	0x20002cc0
 801359c:	20002ce4 	.word	0x20002ce4
 80135a0:	20002d30 	.word	0x20002d30
 80135a4:	20002d2c 	.word	0x20002d2c
 80135a8:	20002cd0 	.word	0x20002cd0
 80135ac:	20002cc8 	.word	0x20002cc8
 80135b0:	20002d5c 	.word	0x20002d5c
 80135b4:	20002dc0 	.word	0x20002dc0
 80135b8:	20002cd8 	.word	0x20002cd8
 80135bc:	20002cd4 	.word	0x20002cd4
 80135c0:	20002ce0 	.word	0x20002ce0

080135c4 <xTaskResumeAll>:
{
 80135c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	taskENTER_CRITICAL();
 80135c8:	f000 fcbc 	bl	8013f44 <vPortEnterCritical>
		--uxSchedulerSuspended;
 80135cc:	4b2b      	ldr	r3, [pc, #172]	@ (801367c <xTaskResumeAll+0xb8>)
 80135ce:	681a      	ldr	r2, [r3, #0]
 80135d0:	3a01      	subs	r2, #1
 80135d2:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80135d4:	681c      	ldr	r4, [r3, #0]
 80135d6:	b12c      	cbz	r4, 80135e4 <xTaskResumeAll+0x20>
BaseType_t xAlreadyYielded = pdFALSE;
 80135d8:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 80135da:	f000 fcc3 	bl	8013f64 <vPortExitCritical>
}
 80135de:	4620      	mov	r0, r4
 80135e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 80135e4:	4b26      	ldr	r3, [pc, #152]	@ (8013680 <xTaskResumeAll+0xbc>)
 80135e6:	681b      	ldr	r3, [r3, #0]
 80135e8:	2b00      	cmp	r3, #0
 80135ea:	d0f5      	beq.n	80135d8 <xTaskResumeAll+0x14>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80135ec:	4d25      	ldr	r5, [pc, #148]	@ (8013684 <xTaskResumeAll+0xc0>)
					prvAddTaskToReadyList( pxTCB );
 80135ee:	4e26      	ldr	r6, [pc, #152]	@ (8013688 <xTaskResumeAll+0xc4>)
 80135f0:	f8df 8098 	ldr.w	r8, [pc, #152]	@ 801368c <xTaskResumeAll+0xc8>
 80135f4:	e01f      	b.n	8013636 <xTaskResumeAll+0x72>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 80135f6:	68eb      	ldr	r3, [r5, #12]
 80135f8:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80135fa:	f104 0904 	add.w	r9, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80135fe:	f104 0018 	add.w	r0, r4, #24
 8013602:	f000 fa2b 	bl	8013a5c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8013606:	4648      	mov	r0, r9
 8013608:	f000 fa28 	bl	8013a5c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 801360c:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801360e:	6831      	ldr	r1, [r6, #0]
 8013610:	2701      	movs	r7, #1
 8013612:	fa07 f302 	lsl.w	r3, r7, r2
 8013616:	2014      	movs	r0, #20
 8013618:	430b      	orrs	r3, r1
 801361a:	fb00 8002 	mla	r0, r0, r2, r8
 801361e:	4649      	mov	r1, r9
 8013620:	6033      	str	r3, [r6, #0]
 8013622:	f000 f9f9 	bl	8013a18 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8013626:	4b1a      	ldr	r3, [pc, #104]	@ (8013690 <xTaskResumeAll+0xcc>)
 8013628:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801362a:	681b      	ldr	r3, [r3, #0]
 801362c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801362e:	429a      	cmp	r2, r3
 8013630:	d301      	bcc.n	8013636 <xTaskResumeAll+0x72>
						xYieldPending = pdTRUE;
 8013632:	4b18      	ldr	r3, [pc, #96]	@ (8013694 <xTaskResumeAll+0xd0>)
 8013634:	601f      	str	r7, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8013636:	682b      	ldr	r3, [r5, #0]
 8013638:	2b00      	cmp	r3, #0
 801363a:	d1dc      	bne.n	80135f6 <xTaskResumeAll+0x32>
				if( pxTCB != NULL )
 801363c:	b10c      	cbz	r4, 8013642 <xTaskResumeAll+0x7e>
					prvResetNextTaskUnblockTime();
 801363e:	f7ff fe05 	bl	801324c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8013642:	4d15      	ldr	r5, [pc, #84]	@ (8013698 <xTaskResumeAll+0xd4>)
 8013644:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8013646:	b144      	cbz	r4, 801365a <xTaskResumeAll+0x96>
								xYieldPending = pdTRUE;
 8013648:	4e12      	ldr	r6, [pc, #72]	@ (8013694 <xTaskResumeAll+0xd0>)
 801364a:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 801364c:	f7ff ff26 	bl	801349c <xTaskIncrementTick>
 8013650:	b100      	cbz	r0, 8013654 <xTaskResumeAll+0x90>
								xYieldPending = pdTRUE;
 8013652:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8013654:	3c01      	subs	r4, #1
 8013656:	d1f9      	bne.n	801364c <xTaskResumeAll+0x88>
						uxPendedTicks = 0;
 8013658:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 801365a:	4b0e      	ldr	r3, [pc, #56]	@ (8013694 <xTaskResumeAll+0xd0>)
 801365c:	681b      	ldr	r3, [r3, #0]
 801365e:	2b00      	cmp	r3, #0
 8013660:	d0ba      	beq.n	80135d8 <xTaskResumeAll+0x14>
					taskYIELD_IF_USING_PREEMPTION();
 8013662:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013666:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801366a:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801366e:	f3bf 8f4f 	dsb	sy
 8013672:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8013676:	2401      	movs	r4, #1
 8013678:	e7af      	b.n	80135da <xTaskResumeAll+0x16>
 801367a:	bf00      	nop
 801367c:	20002cc0 	.word	0x20002cc0
 8013680:	20002ce8 	.word	0x20002ce8
 8013684:	20002d18 	.word	0x20002d18
 8013688:	20002ce0 	.word	0x20002ce0
 801368c:	20002d5c 	.word	0x20002d5c
 8013690:	20002dc0 	.word	0x20002dc0
 8013694:	20002cd4 	.word	0x20002cd4
 8013698:	20002cd8 	.word	0x20002cd8

0801369c <vTaskDelayUntil>:
	{
 801369c:	b510      	push	{r4, lr}
		vTaskSuspendAll();
 801369e:	f7ff feef 	bl	8013480 <vTaskSuspendAll>
			const TickType_t xConstTickCount = xTickCount;
 80136a2:	4b11      	ldr	r3, [pc, #68]	@ (80136e8 <vTaskDelayUntil+0x4c>)
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80136a4:	6804      	ldr	r4, [r0, #0]
			const TickType_t xConstTickCount = xTickCount;
 80136a6:	681a      	ldr	r2, [r3, #0]
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 80136a8:	1863      	adds	r3, r4, r1
 80136aa:	bf2c      	ite	cs
 80136ac:	2101      	movcs	r1, #1
 80136ae:	2100      	movcc	r1, #0
			if( xConstTickCount < *pxPreviousWakeTime )
 80136b0:	4294      	cmp	r4, r2
 80136b2:	d90f      	bls.n	80136d4 <vTaskDelayUntil+0x38>
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 80136b4:	b979      	cbnz	r1, 80136d6 <vTaskDelayUntil+0x3a>
			*pxPreviousWakeTime = xTimeToWake;
 80136b6:	6003      	str	r3, [r0, #0]
		xAlreadyYielded = xTaskResumeAll();
 80136b8:	f7ff ff84 	bl	80135c4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80136bc:	b948      	cbnz	r0, 80136d2 <vTaskDelayUntil+0x36>
			portYIELD_WITHIN_API();
 80136be:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 80136c2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 80136c6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 80136ca:	f3bf 8f4f 	dsb	sy
 80136ce:	f3bf 8f6f 	isb	sy
	}
 80136d2:	bd10      	pop	{r4, pc}
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 80136d4:	b909      	cbnz	r1, 80136da <vTaskDelayUntil+0x3e>
 80136d6:	429a      	cmp	r2, r3
 80136d8:	d2ed      	bcs.n	80136b6 <vTaskDelayUntil+0x1a>
			*pxPreviousWakeTime = xTimeToWake;
 80136da:	6003      	str	r3, [r0, #0]
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 80136dc:	2100      	movs	r1, #0
 80136de:	1a98      	subs	r0, r3, r2
 80136e0:	f7ff fd6c 	bl	80131bc <prvAddCurrentTaskToDelayedList>
 80136e4:	e7e8      	b.n	80136b8 <vTaskDelayUntil+0x1c>
 80136e6:	bf00      	nop
 80136e8:	20002ce4 	.word	0x20002ce4

080136ec <prvIdleTask>:
{
 80136ec:	b508      	push	{r3, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80136ee:	4c19      	ldr	r4, [pc, #100]	@ (8013754 <prvIdleTask+0x68>)
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 80136f0:	4e19      	ldr	r6, [pc, #100]	@ (8013758 <prvIdleTask+0x6c>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80136f2:	6823      	ldr	r3, [r4, #0]
 80136f4:	b983      	cbnz	r3, 8013718 <prvIdleTask+0x2c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80136f6:	4b19      	ldr	r3, [pc, #100]	@ (801375c <prvIdleTask+0x70>)
 80136f8:	681b      	ldr	r3, [r3, #0]
 80136fa:	2b01      	cmp	r3, #1
 80136fc:	d909      	bls.n	8013712 <prvIdleTask+0x26>
				taskYIELD();
 80136fe:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013702:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013706:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 801370a:	f3bf 8f4f 	dsb	sy
 801370e:	f3bf 8f6f 	isb	sy
			vApplicationIdleHook();
 8013712:	f7ff fbf3 	bl	8012efc <vApplicationIdleHook>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8013716:	e7ec      	b.n	80136f2 <prvIdleTask+0x6>
			vTaskSuspendAll();
 8013718:	f7ff feb2 	bl	8013480 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 801371c:	6835      	ldr	r5, [r6, #0]
			( void ) xTaskResumeAll();
 801371e:	f7ff ff51 	bl	80135c4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 8013722:	2d00      	cmp	r5, #0
 8013724:	d0e5      	beq.n	80136f2 <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 8013726:	f000 fc0d 	bl	8013f44 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 801372a:	68f3      	ldr	r3, [r6, #12]
 801372c:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 801372e:	1d28      	adds	r0, r5, #4
 8013730:	f000 f994 	bl	8013a5c <uxListRemove>
					--uxCurrentNumberOfTasks;
 8013734:	4a0a      	ldr	r2, [pc, #40]	@ (8013760 <prvIdleTask+0x74>)
 8013736:	6813      	ldr	r3, [r2, #0]
 8013738:	3b01      	subs	r3, #1
 801373a:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 801373c:	6823      	ldr	r3, [r4, #0]
 801373e:	3b01      	subs	r3, #1
 8013740:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 8013742:	f000 fc0f 	bl	8013f64 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 8013746:	6b28      	ldr	r0, [r5, #48]	@ 0x30
 8013748:	f000 fd1a 	bl	8014180 <vPortFree>
			vPortFree( pxTCB );
 801374c:	4628      	mov	r0, r5
 801374e:	f000 fd17 	bl	8014180 <vPortFree>
	}
 8013752:	e7ce      	b.n	80136f2 <prvIdleTask+0x6>
 8013754:	20002d00 	.word	0x20002d00
 8013758:	20002d04 	.word	0x20002d04
 801375c:	20002d5c 	.word	0x20002d5c
 8013760:	20002ce8 	.word	0x20002ce8

08013764 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8013764:	4b11      	ldr	r3, [pc, #68]	@ (80137ac <vTaskSwitchContext+0x48>)
 8013766:	681a      	ldr	r2, [r3, #0]
 8013768:	4b11      	ldr	r3, [pc, #68]	@ (80137b0 <vTaskSwitchContext+0x4c>)
{
 801376a:	b530      	push	{r4, r5, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 801376c:	b112      	cbz	r2, 8013774 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 801376e:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8013770:	601a      	str	r2, [r3, #0]
}
 8013772:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
 8013774:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8013776:	4b0f      	ldr	r3, [pc, #60]	@ (80137b4 <vTaskSwitchContext+0x50>)
 8013778:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 801377a:	fab3 f383 	clz	r3, r3
 801377e:	b2db      	uxtb	r3, r3
 8013780:	490d      	ldr	r1, [pc, #52]	@ (80137b8 <vTaskSwitchContext+0x54>)
 8013782:	f1c3 031f 	rsb	r3, r3, #31
 8013786:	2514      	movs	r5, #20
 8013788:	fb05 f203 	mul.w	r2, r5, r3
 801378c:	1888      	adds	r0, r1, r2
 801378e:	3208      	adds	r2, #8
 8013790:	6844      	ldr	r4, [r0, #4]
 8013792:	6864      	ldr	r4, [r4, #4]
 8013794:	6044      	str	r4, [r0, #4]
 8013796:	440a      	add	r2, r1
 8013798:	4294      	cmp	r4, r2
 801379a:	bf04      	itt	eq
 801379c:	6862      	ldreq	r2, [r4, #4]
 801379e:	6042      	streq	r2, [r0, #4]
 80137a0:	fb05 1103 	mla	r1, r5, r3, r1
 80137a4:	684b      	ldr	r3, [r1, #4]
 80137a6:	68da      	ldr	r2, [r3, #12]
 80137a8:	4b04      	ldr	r3, [pc, #16]	@ (80137bc <vTaskSwitchContext+0x58>)
 80137aa:	e7e1      	b.n	8013770 <vTaskSwitchContext+0xc>
 80137ac:	20002cc0 	.word	0x20002cc0
 80137b0:	20002cd4 	.word	0x20002cd4
 80137b4:	20002ce0 	.word	0x20002ce0
 80137b8:	20002d5c 	.word	0x20002d5c
 80137bc:	20002dc0 	.word	0x20002dc0

080137c0 <vTaskPlaceOnEventList>:
{
 80137c0:	b510      	push	{r4, lr}
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80137c2:	4b06      	ldr	r3, [pc, #24]	@ (80137dc <vTaskPlaceOnEventList+0x1c>)
{
 80137c4:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80137c6:	6819      	ldr	r1, [r3, #0]
 80137c8:	3118      	adds	r1, #24
 80137ca:	f000 f930 	bl	8013a2e <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80137ce:	4620      	mov	r0, r4
 80137d0:	2101      	movs	r1, #1
}
 80137d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80137d6:	f7ff bcf1 	b.w	80131bc <prvAddCurrentTaskToDelayedList>
 80137da:	bf00      	nop
 80137dc:	20002dc0 	.word	0x20002dc0

080137e0 <xTaskRemoveFromEventList>:
{
 80137e0:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80137e2:	68c3      	ldr	r3, [r0, #12]
 80137e4:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80137e6:	f104 0518 	add.w	r5, r4, #24
 80137ea:	4628      	mov	r0, r5
 80137ec:	f000 f936 	bl	8013a5c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80137f0:	4b11      	ldr	r3, [pc, #68]	@ (8013838 <xTaskRemoveFromEventList+0x58>)
 80137f2:	681b      	ldr	r3, [r3, #0]
 80137f4:	b9e3      	cbnz	r3, 8013830 <xTaskRemoveFromEventList+0x50>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 80137f6:	1d25      	adds	r5, r4, #4
 80137f8:	4628      	mov	r0, r5
 80137fa:	f000 f92f 	bl	8013a5c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 80137fe:	490f      	ldr	r1, [pc, #60]	@ (801383c <xTaskRemoveFromEventList+0x5c>)
 8013800:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 8013802:	6808      	ldr	r0, [r1, #0]
 8013804:	2301      	movs	r3, #1
 8013806:	4093      	lsls	r3, r2
 8013808:	4303      	orrs	r3, r0
 801380a:	600b      	str	r3, [r1, #0]
 801380c:	4b0c      	ldr	r3, [pc, #48]	@ (8013840 <xTaskRemoveFromEventList+0x60>)
 801380e:	2014      	movs	r0, #20
 8013810:	4629      	mov	r1, r5
 8013812:	fb00 3002 	mla	r0, r0, r2, r3
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8013816:	f000 f8ff 	bl	8013a18 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 801381a:	4b0a      	ldr	r3, [pc, #40]	@ (8013844 <xTaskRemoveFromEventList+0x64>)
 801381c:	6ae2      	ldr	r2, [r4, #44]	@ 0x2c
 801381e:	681b      	ldr	r3, [r3, #0]
 8013820:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8013822:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
 8013824:	bf83      	ittte	hi
 8013826:	4b08      	ldrhi	r3, [pc, #32]	@ (8013848 <xTaskRemoveFromEventList+0x68>)
 8013828:	2001      	movhi	r0, #1
 801382a:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
 801382c:	2000      	movls	r0, #0
}
 801382e:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8013830:	4806      	ldr	r0, [pc, #24]	@ (801384c <xTaskRemoveFromEventList+0x6c>)
 8013832:	4629      	mov	r1, r5
 8013834:	e7ef      	b.n	8013816 <xTaskRemoveFromEventList+0x36>
 8013836:	bf00      	nop
 8013838:	20002cc0 	.word	0x20002cc0
 801383c:	20002ce0 	.word	0x20002ce0
 8013840:	20002d5c 	.word	0x20002d5c
 8013844:	20002dc0 	.word	0x20002dc0
 8013848:	20002cd4 	.word	0x20002cd4
 801384c:	20002d18 	.word	0x20002d18

08013850 <vTaskSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8013850:	4b03      	ldr	r3, [pc, #12]	@ (8013860 <vTaskSetTimeOutState+0x10>)
 8013852:	681b      	ldr	r3, [r3, #0]
 8013854:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8013856:	4b03      	ldr	r3, [pc, #12]	@ (8013864 <vTaskSetTimeOutState+0x14>)
 8013858:	681b      	ldr	r3, [r3, #0]
 801385a:	6043      	str	r3, [r0, #4]
}
 801385c:	4770      	bx	lr
 801385e:	bf00      	nop
 8013860:	20002cd0 	.word	0x20002cd0
 8013864:	20002ce4 	.word	0x20002ce4

08013868 <xTaskCheckForTimeOut>:
{
 8013868:	b570      	push	{r4, r5, r6, lr}
 801386a:	460d      	mov	r5, r1
 801386c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 801386e:	f000 fb69 	bl	8013f44 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 8013872:	4b13      	ldr	r3, [pc, #76]	@ (80138c0 <xTaskCheckForTimeOut+0x58>)
 8013874:	6819      	ldr	r1, [r3, #0]
			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
 8013876:	4b13      	ldr	r3, [pc, #76]	@ (80138c4 <xTaskCheckForTimeOut+0x5c>)
 8013878:	681a      	ldr	r2, [r3, #0]
 801387a:	f892 204c 	ldrb.w	r2, [r2, #76]	@ 0x4c
 801387e:	b142      	cbz	r2, 8013892 <xTaskCheckForTimeOut+0x2a>
				pxCurrentTCB->ucDelayAborted = pdFALSE;
 8013880:	681b      	ldr	r3, [r3, #0]
 8013882:	2200      	movs	r2, #0
 8013884:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
				xReturn = pdTRUE;
 8013888:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
 801388a:	f000 fb6b 	bl	8013f64 <vPortExitCritical>
}
 801388e:	4620      	mov	r0, r4
 8013890:	bd70      	pop	{r4, r5, r6, pc}
			if( *pxTicksToWait == portMAX_DELAY )
 8013892:	682a      	ldr	r2, [r5, #0]
 8013894:	1c53      	adds	r3, r2, #1
 8013896:	d010      	beq.n	80138ba <xTaskCheckForTimeOut+0x52>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8013898:	4b0b      	ldr	r3, [pc, #44]	@ (80138c8 <xTaskCheckForTimeOut+0x60>)
 801389a:	6818      	ldr	r0, [r3, #0]
 801389c:	e9d4 6300 	ldrd	r6, r3, [r4]
 80138a0:	4286      	cmp	r6, r0
 80138a2:	d001      	beq.n	80138a8 <xTaskCheckForTimeOut+0x40>
 80138a4:	428b      	cmp	r3, r1
 80138a6:	d9ef      	bls.n	8013888 <xTaskCheckForTimeOut+0x20>
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80138a8:	1ac8      	subs	r0, r1, r3
 80138aa:	4282      	cmp	r2, r0
 80138ac:	d9ec      	bls.n	8013888 <xTaskCheckForTimeOut+0x20>
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 80138ae:	1a5b      	subs	r3, r3, r1
 80138b0:	4413      	add	r3, r2
 80138b2:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 80138b4:	4620      	mov	r0, r4
 80138b6:	f7ff ffcb 	bl	8013850 <vTaskSetTimeOutState>
				xReturn = pdFALSE;
 80138ba:	2400      	movs	r4, #0
 80138bc:	e7e5      	b.n	801388a <xTaskCheckForTimeOut+0x22>
 80138be:	bf00      	nop
 80138c0:	20002ce4 	.word	0x20002ce4
 80138c4:	20002dc0 	.word	0x20002dc0
 80138c8:	20002cd0 	.word	0x20002cd0

080138cc <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 80138cc:	4b01      	ldr	r3, [pc, #4]	@ (80138d4 <vTaskMissedYield+0x8>)
 80138ce:	2201      	movs	r2, #1
 80138d0:	601a      	str	r2, [r3, #0]
}
 80138d2:	4770      	bx	lr
 80138d4:	20002cd4 	.word	0x20002cd4

080138d8 <xTaskGetCurrentTaskHandle>:
		xReturn = pxCurrentTCB;
 80138d8:	4b01      	ldr	r3, [pc, #4]	@ (80138e0 <xTaskGetCurrentTaskHandle+0x8>)
 80138da:	6818      	ldr	r0, [r3, #0]
	}
 80138dc:	4770      	bx	lr
 80138de:	bf00      	nop
 80138e0:	20002dc0 	.word	0x20002dc0

080138e4 <vTaskPriorityInherit>:
	{
 80138e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if( pxMutexHolder != NULL )
 80138e8:	4604      	mov	r4, r0
 80138ea:	2800      	cmp	r0, #0
 80138ec:	d02e      	beq.n	801394c <vTaskPriorityInherit+0x68>
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 80138ee:	4d1e      	ldr	r5, [pc, #120]	@ (8013968 <vTaskPriorityInherit+0x84>)
 80138f0:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
 80138f2:	682a      	ldr	r2, [r5, #0]
 80138f4:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 80138f6:	4293      	cmp	r3, r2
 80138f8:	d228      	bcs.n	801394c <vTaskPriorityInherit+0x68>
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80138fa:	6982      	ldr	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 80138fc:	4f1b      	ldr	r7, [pc, #108]	@ (801396c <vTaskPriorityInherit+0x88>)
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 80138fe:	2a00      	cmp	r2, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013900:	bfa1      	itttt	ge
 8013902:	682a      	ldrge	r2, [r5, #0]
 8013904:	6ad2      	ldrge	r2, [r2, #44]	@ 0x2c
 8013906:	f1c2 0205 	rsbge	r2, r2, #5
 801390a:	6182      	strge	r2, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 801390c:	2614      	movs	r6, #20
 801390e:	6942      	ldr	r2, [r0, #20]
 8013910:	fb06 7303 	mla	r3, r6, r3, r7
 8013914:	429a      	cmp	r2, r3
 8013916:	d116      	bne.n	8013946 <vTaskPriorityInherit+0x62>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8013918:	f100 0804 	add.w	r8, r0, #4
 801391c:	4640      	mov	r0, r8
 801391e:	f000 f89d 	bl	8013a5c <uxListRemove>
 8013922:	4a13      	ldr	r2, [pc, #76]	@ (8013970 <vTaskPriorityInherit+0x8c>)
 8013924:	b1a0      	cbz	r0, 8013950 <vTaskPriorityInherit+0x6c>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8013926:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 8013928:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 801392a:	6ad8      	ldr	r0, [r3, #44]	@ 0x2c
 801392c:	62e0      	str	r0, [r4, #44]	@ 0x2c
					prvAddTaskToReadyList( pxTCB );
 801392e:	2301      	movs	r3, #1
 8013930:	4083      	lsls	r3, r0
 8013932:	430b      	orrs	r3, r1
 8013934:	6013      	str	r3, [r2, #0]
 8013936:	2314      	movs	r3, #20
 8013938:	4641      	mov	r1, r8
 801393a:	fb03 7000 	mla	r0, r3, r0, r7
	}
 801393e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
					prvAddTaskToReadyList( pxTCB );
 8013942:	f000 b869 	b.w	8013a18 <vListInsertEnd>
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8013946:	682b      	ldr	r3, [r5, #0]
 8013948:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801394a:	62c3      	str	r3, [r0, #44]	@ 0x2c
	}
 801394c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8013950:	6ae0      	ldr	r0, [r4, #44]	@ 0x2c
 8013952:	4346      	muls	r6, r0
 8013954:	59bb      	ldr	r3, [r7, r6]
 8013956:	2b00      	cmp	r3, #0
 8013958:	d1e5      	bne.n	8013926 <vTaskPriorityInherit+0x42>
 801395a:	6813      	ldr	r3, [r2, #0]
 801395c:	2101      	movs	r1, #1
 801395e:	4081      	lsls	r1, r0
 8013960:	ea23 0301 	bic.w	r3, r3, r1
 8013964:	6013      	str	r3, [r2, #0]
 8013966:	e7de      	b.n	8013926 <vTaskPriorityInherit+0x42>
 8013968:	20002dc0 	.word	0x20002dc0
 801396c:	20002d5c 	.word	0x20002d5c
 8013970:	20002ce0 	.word	0x20002ce0

08013974 <xTaskPriorityDisinherit>:
	{
 8013974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		if( pxMutexHolder != NULL )
 8013976:	4604      	mov	r4, r0
 8013978:	b908      	cbnz	r0, 801397e <xTaskPriorityDisinherit+0xa>
	BaseType_t xReturn = pdFALSE;
 801397a:	2000      	movs	r0, #0
	}
 801397c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			( pxTCB->uxMutexesHeld )--;
 801397e:	6c83      	ldr	r3, [r0, #72]	@ 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8013980:	6ac1      	ldr	r1, [r0, #44]	@ 0x2c
 8013982:	6c42      	ldr	r2, [r0, #68]	@ 0x44
			( pxTCB->uxMutexesHeld )--;
 8013984:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8013986:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8013988:	6483      	str	r3, [r0, #72]	@ 0x48
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 801398a:	d0f6      	beq.n	801397a <xTaskPriorityDisinherit+0x6>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 801398c:	2b00      	cmp	r3, #0
 801398e:	d1f4      	bne.n	801397a <xTaskPriorityDisinherit+0x6>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8013990:	1d06      	adds	r6, r0, #4
 8013992:	4630      	mov	r0, r6
 8013994:	f000 f862 	bl	8013a5c <uxListRemove>
 8013998:	4f10      	ldr	r7, [pc, #64]	@ (80139dc <xTaskPriorityDisinherit+0x68>)
 801399a:	4a11      	ldr	r2, [pc, #68]	@ (80139e0 <xTaskPriorityDisinherit+0x6c>)
 801399c:	b950      	cbnz	r0, 80139b4 <xTaskPriorityDisinherit+0x40>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 801399e:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 80139a0:	2314      	movs	r3, #20
 80139a2:	434b      	muls	r3, r1
 80139a4:	58fb      	ldr	r3, [r7, r3]
 80139a6:	b92b      	cbnz	r3, 80139b4 <xTaskPriorityDisinherit+0x40>
 80139a8:	6813      	ldr	r3, [r2, #0]
 80139aa:	2501      	movs	r5, #1
 80139ac:	408d      	lsls	r5, r1
 80139ae:	ea23 0305 	bic.w	r3, r3, r5
 80139b2:	6013      	str	r3, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80139b4:	6c63      	ldr	r3, [r4, #68]	@ 0x44
 80139b6:	62e3      	str	r3, [r4, #44]	@ 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80139b8:	f1c3 0105 	rsb	r1, r3, #5
 80139bc:	61a1      	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 80139be:	6811      	ldr	r1, [r2, #0]
 80139c0:	2401      	movs	r4, #1
 80139c2:	fa04 f503 	lsl.w	r5, r4, r3
 80139c6:	2014      	movs	r0, #20
 80139c8:	430d      	orrs	r5, r1
 80139ca:	fb00 7003 	mla	r0, r0, r3, r7
 80139ce:	4631      	mov	r1, r6
 80139d0:	6015      	str	r5, [r2, #0]
 80139d2:	f000 f821 	bl	8013a18 <vListInsertEnd>
					xReturn = pdTRUE;
 80139d6:	4620      	mov	r0, r4
		return xReturn;
 80139d8:	e7d0      	b.n	801397c <xTaskPriorityDisinherit+0x8>
 80139da:	bf00      	nop
 80139dc:	20002d5c 	.word	0x20002d5c
 80139e0:	20002ce0 	.word	0x20002ce0

080139e4 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
 80139e4:	4b04      	ldr	r3, [pc, #16]	@ (80139f8 <pvTaskIncrementMutexHeldCount+0x14>)
 80139e6:	681a      	ldr	r2, [r3, #0]
 80139e8:	b11a      	cbz	r2, 80139f2 <pvTaskIncrementMutexHeldCount+0xe>
			( pxCurrentTCB->uxMutexesHeld )++;
 80139ea:	6819      	ldr	r1, [r3, #0]
 80139ec:	6c8a      	ldr	r2, [r1, #72]	@ 0x48
 80139ee:	3201      	adds	r2, #1
 80139f0:	648a      	str	r2, [r1, #72]	@ 0x48
		return pxCurrentTCB;
 80139f2:	6818      	ldr	r0, [r3, #0]
	}
 80139f4:	4770      	bx	lr
 80139f6:	bf00      	nop
 80139f8:	20002dc0 	.word	0x20002dc0

080139fc <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80139fc:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8013a00:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013a04:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013a08:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013a0a:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8013a0c:	2300      	movs	r3, #0
 8013a0e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8013a10:	4770      	bx	lr

08013a12 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8013a12:	2300      	movs	r3, #0
 8013a14:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8013a16:	4770      	bx	lr

08013a18 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8013a18:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8013a1a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8013a1c:	689a      	ldr	r2, [r3, #8]
 8013a1e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8013a20:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8013a22:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8013a24:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8013a26:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8013a28:	3301      	adds	r3, #1
 8013a2a:	6003      	str	r3, [r0, #0]
}
 8013a2c:	4770      	bx	lr

08013a2e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8013a2e:	b530      	push	{r4, r5, lr}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8013a30:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8013a32:	1c63      	adds	r3, r4, #1
 8013a34:	d10a      	bne.n	8013a4c <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8013a36:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8013a38:	685a      	ldr	r2, [r3, #4]
 8013a3a:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8013a3c:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8013a3e:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8013a40:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8013a42:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8013a44:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8013a46:	3301      	adds	r3, #1
 8013a48:	6003      	str	r3, [r0, #0]
}
 8013a4a:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8013a4c:	f100 0208 	add.w	r2, r0, #8
 8013a50:	4613      	mov	r3, r2
 8013a52:	6852      	ldr	r2, [r2, #4]
 8013a54:	6815      	ldr	r5, [r2, #0]
 8013a56:	42a5      	cmp	r5, r4
 8013a58:	d9fa      	bls.n	8013a50 <vListInsert+0x22>
 8013a5a:	e7ed      	b.n	8013a38 <vListInsert+0xa>

08013a5c <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8013a5c:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8013a60:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8013a62:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8013a64:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8013a66:	6859      	ldr	r1, [r3, #4]
 8013a68:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8013a6a:	bf08      	it	eq
 8013a6c:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8013a6e:	2200      	movs	r2, #0
 8013a70:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8013a72:	6818      	ldr	r0, [r3, #0]
 8013a74:	3801      	subs	r0, #1
 8013a76:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8013a78:	4770      	bx	lr

08013a7a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8013a7a:	b570      	push	{r4, r5, r6, lr}
 8013a7c:	4616      	mov	r6, r2

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8013a7e:	6c02      	ldr	r2, [r0, #64]	@ 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8013a80:	6b85      	ldr	r5, [r0, #56]	@ 0x38
{
 8013a82:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8013a84:	b942      	cbnz	r2, 8013a98 <prvCopyDataToQueue+0x1e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8013a86:	6806      	ldr	r6, [r0, #0]
 8013a88:	b99e      	cbnz	r6, 8013ab2 <prvCopyDataToQueue+0x38>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8013a8a:	6840      	ldr	r0, [r0, #4]
 8013a8c:	f7ff ff72 	bl	8013974 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8013a90:	6066      	str	r6, [r4, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8013a92:	3501      	adds	r5, #1
 8013a94:	63a5      	str	r5, [r4, #56]	@ 0x38

	return xReturn;
}
 8013a96:	bd70      	pop	{r4, r5, r6, pc}
	else if( xPosition == queueSEND_TO_BACK )
 8013a98:	b96e      	cbnz	r6, 8013ab6 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8013a9a:	6880      	ldr	r0, [r0, #8]
 8013a9c:	f00f fdbf 	bl	802361e <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8013aa0:	68a3      	ldr	r3, [r4, #8]
 8013aa2:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8013aa4:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8013aa6:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8013aa8:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8013aaa:	4293      	cmp	r3, r2
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8013aac:	bf24      	itt	cs
 8013aae:	6823      	ldrcs	r3, [r4, #0]
 8013ab0:	60a3      	strcs	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
 8013ab2:	2000      	movs	r0, #0
 8013ab4:	e7ed      	b.n	8013a92 <prvCopyDataToQueue+0x18>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013ab6:	68c0      	ldr	r0, [r0, #12]
 8013ab8:	f00f fdb1 	bl	802361e <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8013abc:	6c22      	ldr	r2, [r4, #64]	@ 0x40
 8013abe:	68e3      	ldr	r3, [r4, #12]
 8013ac0:	4251      	negs	r1, r2
 8013ac2:	1a9b      	subs	r3, r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8013ac4:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8013ac6:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8013ac8:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8013aca:	bf3e      	ittt	cc
 8013acc:	6863      	ldrcc	r3, [r4, #4]
 8013ace:	185b      	addcc	r3, r3, r1
 8013ad0:	60e3      	strcc	r3, [r4, #12]
		if( xPosition == queueOVERWRITE )
 8013ad2:	2e02      	cmp	r6, #2
 8013ad4:	d1ed      	bne.n	8013ab2 <prvCopyDataToQueue+0x38>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8013ad6:	b10d      	cbz	r5, 8013adc <prvCopyDataToQueue+0x62>
				--uxMessagesWaiting;
 8013ad8:	3d01      	subs	r5, #1
 8013ada:	e7ea      	b.n	8013ab2 <prvCopyDataToQueue+0x38>
BaseType_t xReturn = pdFALSE;
 8013adc:	4628      	mov	r0, r5
 8013ade:	e7d8      	b.n	8013a92 <prvCopyDataToQueue+0x18>

08013ae0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8013ae0:	4603      	mov	r3, r0
 8013ae2:	b410      	push	{r4}
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8013ae4:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
{
 8013ae6:	4608      	mov	r0, r1
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8013ae8:	b162      	cbz	r2, 8013b04 <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8013aea:	68dc      	ldr	r4, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8013aec:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8013aee:	4414      	add	r4, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8013af0:	428c      	cmp	r4, r1
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8013af2:	bf28      	it	cs
 8013af4:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8013af6:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8013af8:	bf28      	it	cs
 8013afa:	60d9      	strcs	r1, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8013afc:	68d9      	ldr	r1, [r3, #12]
	}
}
 8013afe:	bc10      	pop	{r4}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8013b00:	f00f bd8d 	b.w	802361e <memcpy>
}
 8013b04:	bc10      	pop	{r4}
 8013b06:	4770      	bx	lr

08013b08 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8013b08:	b570      	push	{r4, r5, r6, lr}
 8013b0a:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8013b0c:	f000 fa1a 	bl	8013f44 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8013b10:	f894 5045 	ldrb.w	r5, [r4, #69]	@ 0x45
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8013b14:	f104 0624 	add.w	r6, r4, #36	@ 0x24
		int8_t cTxLock = pxQueue->cTxLock;
 8013b18:	b26d      	sxtb	r5, r5
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8013b1a:	2d00      	cmp	r5, #0
 8013b1c:	dc14      	bgt.n	8013b48 <prvUnlockQueue+0x40>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8013b1e:	23ff      	movs	r3, #255	@ 0xff
 8013b20:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
	}
	taskEXIT_CRITICAL();
 8013b24:	f000 fa1e 	bl	8013f64 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8013b28:	f000 fa0c 	bl	8013f44 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8013b2c:	f894 5044 	ldrb.w	r5, [r4, #68]	@ 0x44

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8013b30:	f104 0610 	add.w	r6, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
 8013b34:	b26d      	sxtb	r5, r5
		while( cRxLock > queueLOCKED_UNMODIFIED )
 8013b36:	2d00      	cmp	r5, #0
 8013b38:	dc12      	bgt.n	8013b60 <prvUnlockQueue+0x58>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8013b3a:	23ff      	movs	r3, #255	@ 0xff
 8013b3c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
	}
	taskEXIT_CRITICAL();
}
 8013b40:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 8013b44:	f000 ba0e 	b.w	8013f64 <vPortExitCritical>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8013b48:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8013b4a:	2b00      	cmp	r3, #0
 8013b4c:	d0e7      	beq.n	8013b1e <prvUnlockQueue+0x16>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8013b4e:	4630      	mov	r0, r6
 8013b50:	f7ff fe46 	bl	80137e0 <xTaskRemoveFromEventList>
 8013b54:	b108      	cbz	r0, 8013b5a <prvUnlockQueue+0x52>
						vTaskMissedYield();
 8013b56:	f7ff feb9 	bl	80138cc <vTaskMissedYield>
			--cTxLock;
 8013b5a:	3d01      	subs	r5, #1
 8013b5c:	b26d      	sxtb	r5, r5
 8013b5e:	e7dc      	b.n	8013b1a <prvUnlockQueue+0x12>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8013b60:	6923      	ldr	r3, [r4, #16]
 8013b62:	2b00      	cmp	r3, #0
 8013b64:	d0e9      	beq.n	8013b3a <prvUnlockQueue+0x32>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8013b66:	4630      	mov	r0, r6
 8013b68:	f7ff fe3a 	bl	80137e0 <xTaskRemoveFromEventList>
 8013b6c:	b108      	cbz	r0, 8013b72 <prvUnlockQueue+0x6a>
					vTaskMissedYield();
 8013b6e:	f7ff fead 	bl	80138cc <vTaskMissedYield>
				--cRxLock;
 8013b72:	3d01      	subs	r5, #1
 8013b74:	b26d      	sxtb	r5, r5
 8013b76:	e7de      	b.n	8013b36 <prvUnlockQueue+0x2e>

08013b78 <xQueueGenericReset>:
{
 8013b78:	b538      	push	{r3, r4, r5, lr}
 8013b7a:	4604      	mov	r4, r0
 8013b7c:	460d      	mov	r5, r1
	taskENTER_CRITICAL();
 8013b7e:	f000 f9e1 	bl	8013f44 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8013b82:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	@ 0x3c
 8013b86:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8013b88:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8013b8a:	434b      	muls	r3, r1
 8013b8c:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8013b8e:	1a5b      	subs	r3, r3, r1
 8013b90:	441a      	add	r2, r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8013b92:	6060      	str	r0, [r4, #4]
		pxQueue->cRxLock = queueUNLOCKED;
 8013b94:	23ff      	movs	r3, #255	@ 0xff
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 8013b96:	2000      	movs	r0, #0
 8013b98:	63a0      	str	r0, [r4, #56]	@ 0x38
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 8013b9a:	60e2      	str	r2, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8013b9c:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 8013ba0:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
		if( xNewQueue == pdFALSE )
 8013ba4:	b9a5      	cbnz	r5, 8013bd0 <xQueueGenericReset+0x58>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8013ba6:	6923      	ldr	r3, [r4, #16]
 8013ba8:	b173      	cbz	r3, 8013bc8 <xQueueGenericReset+0x50>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8013baa:	f104 0010 	add.w	r0, r4, #16
 8013bae:	f7ff fe17 	bl	80137e0 <xTaskRemoveFromEventList>
 8013bb2:	b148      	cbz	r0, 8013bc8 <xQueueGenericReset+0x50>
					queueYIELD_IF_USING_PREEMPTION();
 8013bb4:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013bb8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013bbc:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8013bc0:	f3bf 8f4f 	dsb	sy
 8013bc4:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
 8013bc8:	f000 f9cc 	bl	8013f64 <vPortExitCritical>
}
 8013bcc:	2001      	movs	r0, #1
 8013bce:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8013bd0:	f104 0010 	add.w	r0, r4, #16
 8013bd4:	f7ff ff12 	bl	80139fc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8013bd8:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8013bdc:	f7ff ff0e 	bl	80139fc <vListInitialise>
 8013be0:	e7f2      	b.n	8013bc8 <xQueueGenericReset+0x50>

08013be2 <xQueueGenericCreate>:
	{
 8013be2:	b570      	push	{r4, r5, r6, lr}
 8013be4:	4606      	mov	r6, r0
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8013be6:	4348      	muls	r0, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8013be8:	3048      	adds	r0, #72	@ 0x48
	{
 8013bea:	460d      	mov	r5, r1
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 8013bec:	f000 fa4a 	bl	8014084 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8013bf0:	4604      	mov	r4, r0
 8013bf2:	b148      	cbz	r0, 8013c08 <xQueueGenericCreate+0x26>
	if( uxItemSize == ( UBaseType_t ) 0 )
 8013bf4:	b155      	cbz	r5, 8013c0c <xQueueGenericCreate+0x2a>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 8013bf6:	f100 0348 	add.w	r3, r0, #72	@ 0x48
	pxNewQueue->uxItemSize = uxItemSize;
 8013bfa:	e9c4 650f 	strd	r6, r5, [r4, #60]	@ 0x3c
 8013bfe:	6023      	str	r3, [r4, #0]
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8013c00:	2101      	movs	r1, #1
 8013c02:	4620      	mov	r0, r4
 8013c04:	f7ff ffb8 	bl	8013b78 <xQueueGenericReset>
	}
 8013c08:	4620      	mov	r0, r4
 8013c0a:	bd70      	pop	{r4, r5, r6, pc}
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8013c0c:	4603      	mov	r3, r0
 8013c0e:	e7f4      	b.n	8013bfa <xQueueGenericCreate+0x18>

08013c10 <xQueueGenericSend>:
{
 8013c10:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 8013c14:	2700      	movs	r7, #0
{
 8013c16:	4604      	mov	r4, r0
 8013c18:	460e      	mov	r6, r1
 8013c1a:	9201      	str	r2, [sp, #4]
 8013c1c:	461d      	mov	r5, r3
		prvLockQueue( pxQueue );
 8013c1e:	46b8      	mov	r8, r7
		taskENTER_CRITICAL();
 8013c20:	f000 f990 	bl	8013f44 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8013c24:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8013c26:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8013c28:	429a      	cmp	r2, r3
 8013c2a:	d301      	bcc.n	8013c30 <xQueueGenericSend+0x20>
 8013c2c:	2d02      	cmp	r5, #2
 8013c2e:	d11b      	bne.n	8013c68 <xQueueGenericSend+0x58>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8013c30:	462a      	mov	r2, r5
 8013c32:	4631      	mov	r1, r6
 8013c34:	4620      	mov	r0, r4
 8013c36:	f7ff ff20 	bl	8013a7a <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8013c3a:	6a63      	ldr	r3, [r4, #36]	@ 0x24
 8013c3c:	b11b      	cbz	r3, 8013c46 <xQueueGenericSend+0x36>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8013c3e:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8013c42:	f7ff fdcd 	bl	80137e0 <xTaskRemoveFromEventList>
					else if( xYieldRequired != pdFALSE )
 8013c46:	b148      	cbz	r0, 8013c5c <xQueueGenericSend+0x4c>
						queueYIELD_IF_USING_PREEMPTION();
 8013c48:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013c4c:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013c50:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8013c54:	f3bf 8f4f 	dsb	sy
 8013c58:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8013c5c:	f000 f982 	bl	8013f64 <vPortExitCritical>
				return pdPASS;
 8013c60:	2001      	movs	r0, #1
}
 8013c62:	b004      	add	sp, #16
 8013c64:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( xTicksToWait == ( TickType_t ) 0 )
 8013c68:	9b01      	ldr	r3, [sp, #4]
 8013c6a:	b91b      	cbnz	r3, 8013c74 <xQueueGenericSend+0x64>
					taskEXIT_CRITICAL();
 8013c6c:	f000 f97a 	bl	8013f64 <vPortExitCritical>
					return errQUEUE_FULL;
 8013c70:	2000      	movs	r0, #0
 8013c72:	e7f6      	b.n	8013c62 <xQueueGenericSend+0x52>
				else if( xEntryTimeSet == pdFALSE )
 8013c74:	b917      	cbnz	r7, 8013c7c <xQueueGenericSend+0x6c>
					vTaskSetTimeOutState( &xTimeOut );
 8013c76:	a802      	add	r0, sp, #8
 8013c78:	f7ff fdea 	bl	8013850 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8013c7c:	f000 f972 	bl	8013f64 <vPortExitCritical>
		vTaskSuspendAll();
 8013c80:	f7ff fbfe 	bl	8013480 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8013c84:	f000 f95e 	bl	8013f44 <vPortEnterCritical>
 8013c88:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8013c8c:	2bff      	cmp	r3, #255	@ 0xff
 8013c8e:	bf08      	it	eq
 8013c90:	f884 8044 	strbeq.w	r8, [r4, #68]	@ 0x44
 8013c94:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8013c98:	2bff      	cmp	r3, #255	@ 0xff
 8013c9a:	bf08      	it	eq
 8013c9c:	f884 8045 	strbeq.w	r8, [r4, #69]	@ 0x45
 8013ca0:	f000 f960 	bl	8013f64 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8013ca4:	a901      	add	r1, sp, #4
 8013ca6:	a802      	add	r0, sp, #8
 8013ca8:	f7ff fdde 	bl	8013868 <xTaskCheckForTimeOut>
 8013cac:	bb38      	cbnz	r0, 8013cfe <xQueueGenericSend+0xee>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8013cae:	f000 f949 	bl	8013f44 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8013cb2:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8013cb4:	6be3      	ldr	r3, [r4, #60]	@ 0x3c
 8013cb6:	429a      	cmp	r2, r3
 8013cb8:	d10e      	bne.n	8013cd8 <xQueueGenericSend+0xc8>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8013cba:	f000 f953 	bl	8013f64 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8013cbe:	9901      	ldr	r1, [sp, #4]
 8013cc0:	f104 0010 	add.w	r0, r4, #16
 8013cc4:	f7ff fd7c 	bl	80137c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8013cc8:	4620      	mov	r0, r4
 8013cca:	f7ff ff1d 	bl	8013b08 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8013cce:	f7ff fc79 	bl	80135c4 <xTaskResumeAll>
 8013cd2:	b148      	cbz	r0, 8013ce8 <xQueueGenericSend+0xd8>
{
 8013cd4:	2701      	movs	r7, #1
 8013cd6:	e7a3      	b.n	8013c20 <xQueueGenericSend+0x10>
	taskEXIT_CRITICAL();
 8013cd8:	f000 f944 	bl	8013f64 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8013cdc:	4620      	mov	r0, r4
 8013cde:	f7ff ff13 	bl	8013b08 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8013ce2:	f7ff fc6f 	bl	80135c4 <xTaskResumeAll>
 8013ce6:	e7f5      	b.n	8013cd4 <xQueueGenericSend+0xc4>
					portYIELD_WITHIN_API();
 8013ce8:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013cec:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013cf0:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8013cf4:	f3bf 8f4f 	dsb	sy
 8013cf8:	f3bf 8f6f 	isb	sy
 8013cfc:	e7ea      	b.n	8013cd4 <xQueueGenericSend+0xc4>
			prvUnlockQueue( pxQueue );
 8013cfe:	4620      	mov	r0, r4
 8013d00:	f7ff ff02 	bl	8013b08 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8013d04:	f7ff fc5e 	bl	80135c4 <xTaskResumeAll>
			return errQUEUE_FULL;
 8013d08:	e7b2      	b.n	8013c70 <xQueueGenericSend+0x60>

08013d0a <xQueueCreateMutex>:
	{
 8013d0a:	b510      	push	{r4, lr}
 8013d0c:	4602      	mov	r2, r0
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 8013d0e:	2100      	movs	r1, #0
 8013d10:	2001      	movs	r0, #1
 8013d12:	f7ff ff66 	bl	8013be2 <xQueueGenericCreate>
		if( pxNewQueue != NULL )
 8013d16:	4604      	mov	r4, r0
 8013d18:	b138      	cbz	r0, 8013d2a <xQueueCreateMutex+0x20>
			pxNewQueue->pxMutexHolder = NULL;
 8013d1a:	2300      	movs	r3, #0
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8013d1c:	e9c0 3300 	strd	r3, r3, [r0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
 8013d20:	60c3      	str	r3, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 8013d22:	461a      	mov	r2, r3
 8013d24:	4619      	mov	r1, r3
 8013d26:	f7ff ff73 	bl	8013c10 <xQueueGenericSend>
	}
 8013d2a:	4620      	mov	r0, r4
 8013d2c:	bd10      	pop	{r4, pc}

08013d2e <xQueueGiveMutexRecursive>:
	{
 8013d2e:	b538      	push	{r3, r4, r5, lr}
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 8013d30:	6845      	ldr	r5, [r0, #4]
	{
 8013d32:	4604      	mov	r4, r0
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 8013d34:	f7ff fdd0 	bl	80138d8 <xTaskGetCurrentTaskHandle>
 8013d38:	4285      	cmp	r5, r0
 8013d3a:	d10b      	bne.n	8013d54 <xQueueGiveMutexRecursive+0x26>
			( pxMutex->u.uxRecursiveCallCount )--;
 8013d3c:	68e3      	ldr	r3, [r4, #12]
 8013d3e:	3b01      	subs	r3, #1
 8013d40:	60e3      	str	r3, [r4, #12]
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 8013d42:	b10b      	cbz	r3, 8013d48 <xQueueGiveMutexRecursive+0x1a>
			xReturn = pdPASS;
 8013d44:	2001      	movs	r0, #1
	}
 8013d46:	bd38      	pop	{r3, r4, r5, pc}
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 8013d48:	461a      	mov	r2, r3
 8013d4a:	4619      	mov	r1, r3
 8013d4c:	4620      	mov	r0, r4
 8013d4e:	f7ff ff5f 	bl	8013c10 <xQueueGenericSend>
 8013d52:	e7f7      	b.n	8013d44 <xQueueGiveMutexRecursive+0x16>
			xReturn = pdFAIL;
 8013d54:	2000      	movs	r0, #0
		return xReturn;
 8013d56:	e7f6      	b.n	8013d46 <xQueueGiveMutexRecursive+0x18>

08013d58 <xQueueGenericReceive>:
{
 8013d58:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8013d5c:	b085      	sub	sp, #20
BaseType_t xEntryTimeSet = pdFALSE;
 8013d5e:	f04f 0800 	mov.w	r8, #0
{
 8013d62:	4604      	mov	r4, r0
 8013d64:	460e      	mov	r6, r1
 8013d66:	9201      	str	r2, [sp, #4]
 8013d68:	461f      	mov	r7, r3
		prvLockQueue( pxQueue );
 8013d6a:	46c1      	mov	r9, r8
		taskENTER_CRITICAL();
 8013d6c:	f000 f8ea 	bl	8013f44 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8013d70:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8013d72:	b365      	cbz	r5, 8013dce <xQueueGenericReceive+0x76>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8013d74:	4631      	mov	r1, r6
 8013d76:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 8013d78:	f8d4 800c 	ldr.w	r8, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8013d7c:	f7ff feb0 	bl	8013ae0 <prvCopyDataFromQueue>
				if( xJustPeeking == pdFALSE )
 8013d80:	b9ef      	cbnz	r7, 8013dbe <xQueueGenericReceive+0x66>
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8013d82:	6823      	ldr	r3, [r4, #0]
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 8013d84:	3d01      	subs	r5, #1
 8013d86:	63a5      	str	r5, [r4, #56]	@ 0x38
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8013d88:	b913      	cbnz	r3, 8013d90 <xQueueGenericReceive+0x38>
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8013d8a:	f7ff fe2b 	bl	80139e4 <pvTaskIncrementMutexHeldCount>
 8013d8e:	6060      	str	r0, [r4, #4]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8013d90:	6923      	ldr	r3, [r4, #16]
 8013d92:	b173      	cbz	r3, 8013db2 <xQueueGenericReceive+0x5a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8013d94:	f104 0010 	add.w	r0, r4, #16
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8013d98:	f7ff fd22 	bl	80137e0 <xTaskRemoveFromEventList>
 8013d9c:	b148      	cbz	r0, 8013db2 <xQueueGenericReceive+0x5a>
							queueYIELD_IF_USING_PREEMPTION();
 8013d9e:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013da2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013da6:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8013daa:	f3bf 8f4f 	dsb	sy
 8013dae:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8013db2:	f000 f8d7 	bl	8013f64 <vPortExitCritical>
				return pdPASS;
 8013db6:	2001      	movs	r0, #1
}
 8013db8:	b005      	add	sp, #20
 8013dba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8013dbe:	6a63      	ldr	r3, [r4, #36]	@ 0x24
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8013dc0:	f8c4 800c 	str.w	r8, [r4, #12]
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8013dc4:	2b00      	cmp	r3, #0
 8013dc6:	d0f4      	beq.n	8013db2 <xQueueGenericReceive+0x5a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8013dc8:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8013dcc:	e7e4      	b.n	8013d98 <xQueueGenericReceive+0x40>
				if( xTicksToWait == ( TickType_t ) 0 )
 8013dce:	9b01      	ldr	r3, [sp, #4]
 8013dd0:	b91b      	cbnz	r3, 8013dda <xQueueGenericReceive+0x82>
					taskEXIT_CRITICAL();
 8013dd2:	f000 f8c7 	bl	8013f64 <vPortExitCritical>
					return errQUEUE_EMPTY;
 8013dd6:	2000      	movs	r0, #0
 8013dd8:	e7ee      	b.n	8013db8 <xQueueGenericReceive+0x60>
				else if( xEntryTimeSet == pdFALSE )
 8013dda:	f1b8 0f00 	cmp.w	r8, #0
 8013dde:	d102      	bne.n	8013de6 <xQueueGenericReceive+0x8e>
					vTaskSetTimeOutState( &xTimeOut );
 8013de0:	a802      	add	r0, sp, #8
 8013de2:	f7ff fd35 	bl	8013850 <vTaskSetTimeOutState>
		taskEXIT_CRITICAL();
 8013de6:	f000 f8bd 	bl	8013f64 <vPortExitCritical>
		vTaskSuspendAll();
 8013dea:	f7ff fb49 	bl	8013480 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8013dee:	f000 f8a9 	bl	8013f44 <vPortEnterCritical>
 8013df2:	f894 3044 	ldrb.w	r3, [r4, #68]	@ 0x44
 8013df6:	2bff      	cmp	r3, #255	@ 0xff
 8013df8:	bf08      	it	eq
 8013dfa:	f884 9044 	strbeq.w	r9, [r4, #68]	@ 0x44
 8013dfe:	f894 3045 	ldrb.w	r3, [r4, #69]	@ 0x45
 8013e02:	2bff      	cmp	r3, #255	@ 0xff
 8013e04:	bf08      	it	eq
 8013e06:	f884 9045 	strbeq.w	r9, [r4, #69]	@ 0x45
 8013e0a:	f000 f8ab 	bl	8013f64 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8013e0e:	a901      	add	r1, sp, #4
 8013e10:	a802      	add	r0, sp, #8
 8013e12:	f7ff fd29 	bl	8013868 <xTaskCheckForTimeOut>
 8013e16:	bb70      	cbnz	r0, 8013e76 <xQueueGenericReceive+0x11e>
	taskENTER_CRITICAL();
 8013e18:	f000 f894 	bl	8013f44 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8013e1c:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8013e1e:	bb03      	cbnz	r3, 8013e62 <xQueueGenericReceive+0x10a>
	taskEXIT_CRITICAL();
 8013e20:	f000 f8a0 	bl	8013f64 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8013e24:	6823      	ldr	r3, [r4, #0]
 8013e26:	b933      	cbnz	r3, 8013e36 <xQueueGenericReceive+0xde>
						taskENTER_CRITICAL();
 8013e28:	f000 f88c 	bl	8013f44 <vPortEnterCritical>
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8013e2c:	6860      	ldr	r0, [r4, #4]
 8013e2e:	f7ff fd59 	bl	80138e4 <vTaskPriorityInherit>
						taskEXIT_CRITICAL();
 8013e32:	f000 f897 	bl	8013f64 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8013e36:	9901      	ldr	r1, [sp, #4]
 8013e38:	f104 0024 	add.w	r0, r4, #36	@ 0x24
 8013e3c:	f7ff fcc0 	bl	80137c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8013e40:	4620      	mov	r0, r4
 8013e42:	f7ff fe61 	bl	8013b08 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8013e46:	f7ff fbbd 	bl	80135c4 <xTaskResumeAll>
 8013e4a:	b988      	cbnz	r0, 8013e70 <xQueueGenericReceive+0x118>
					portYIELD_WITHIN_API();
 8013e4c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013e50:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013e54:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
 8013e58:	f3bf 8f4f 	dsb	sy
 8013e5c:	f3bf 8f6f 	isb	sy
 8013e60:	e006      	b.n	8013e70 <xQueueGenericReceive+0x118>
	taskEXIT_CRITICAL();
 8013e62:	f000 f87f 	bl	8013f64 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8013e66:	4620      	mov	r0, r4
 8013e68:	f7ff fe4e 	bl	8013b08 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8013e6c:	f7ff fbaa 	bl	80135c4 <xTaskResumeAll>
{
 8013e70:	f04f 0801 	mov.w	r8, #1
 8013e74:	e77a      	b.n	8013d6c <xQueueGenericReceive+0x14>
			prvUnlockQueue( pxQueue );
 8013e76:	4620      	mov	r0, r4
 8013e78:	f7ff fe46 	bl	8013b08 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8013e7c:	f7ff fba2 	bl	80135c4 <xTaskResumeAll>
	taskENTER_CRITICAL();
 8013e80:	f000 f860 	bl	8013f44 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8013e84:	6ba3      	ldr	r3, [r4, #56]	@ 0x38
 8013e86:	2b00      	cmp	r3, #0
 8013e88:	d0a3      	beq.n	8013dd2 <xQueueGenericReceive+0x7a>
	taskEXIT_CRITICAL();
 8013e8a:	f000 f86b 	bl	8013f64 <vPortExitCritical>
	return xReturn;
 8013e8e:	e7ef      	b.n	8013e70 <xQueueGenericReceive+0x118>

08013e90 <xQueueTakeMutexRecursive>:
	{
 8013e90:	b570      	push	{r4, r5, r6, lr}
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8013e92:	6846      	ldr	r6, [r0, #4]
	{
 8013e94:	4604      	mov	r4, r0
 8013e96:	460d      	mov	r5, r1
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8013e98:	f7ff fd1e 	bl	80138d8 <xTaskGetCurrentTaskHandle>
 8013e9c:	4286      	cmp	r6, r0
 8013e9e:	d104      	bne.n	8013eaa <xQueueTakeMutexRecursive+0x1a>
			( pxMutex->u.uxRecursiveCallCount )++;
 8013ea0:	68e3      	ldr	r3, [r4, #12]
 8013ea2:	3301      	adds	r3, #1
 8013ea4:	60e3      	str	r3, [r4, #12]
			xReturn = pdPASS;
 8013ea6:	2001      	movs	r0, #1
	}
 8013ea8:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 8013eaa:	2300      	movs	r3, #0
 8013eac:	462a      	mov	r2, r5
 8013eae:	4619      	mov	r1, r3
 8013eb0:	4620      	mov	r0, r4
 8013eb2:	f7ff ff51 	bl	8013d58 <xQueueGenericReceive>
			if( xReturn != pdFAIL )
 8013eb6:	2800      	cmp	r0, #0
 8013eb8:	d0f6      	beq.n	8013ea8 <xQueueTakeMutexRecursive+0x18>
				( pxMutex->u.uxRecursiveCallCount )++;
 8013eba:	68e3      	ldr	r3, [r4, #12]
 8013ebc:	3301      	adds	r3, #1
 8013ebe:	60e3      	str	r3, [r4, #12]
		return xReturn;
 8013ec0:	e7f2      	b.n	8013ea8 <xQueueTakeMutexRecursive+0x18>

08013ec2 <prvTaskExitError>:
	__asm volatile
 8013ec2:	f04f 03bf 	mov.w	r3, #191	@ 0xbf
 8013ec6:	f383 8811 	msr	BASEPRI, r3
 8013eca:	f3bf 8f6f 	isb	sy
 8013ece:	f3bf 8f4f 	dsb	sy

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	for( ;; );
 8013ed2:	e7fe      	b.n	8013ed2 <prvTaskExitError+0x10>

08013ed4 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8013ed4:	4806      	ldr	r0, [pc, #24]	@ (8013ef0 <prvPortStartFirstTask+0x1c>)
 8013ed6:	6800      	ldr	r0, [r0, #0]
 8013ed8:	6800      	ldr	r0, [r0, #0]
 8013eda:	f380 8808 	msr	MSP, r0
 8013ede:	b662      	cpsie	i
 8013ee0:	b661      	cpsie	f
 8013ee2:	f3bf 8f4f 	dsb	sy
 8013ee6:	f3bf 8f6f 	isb	sy
 8013eea:	df00      	svc	0
 8013eec:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 8013eee:	0000      	.short	0x0000
 8013ef0:	e000ed08 	.word	0xe000ed08

08013ef4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8013ef4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8013ef8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8013efc:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8013f00:	4b04      	ldr	r3, [pc, #16]	@ (8013f14 <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8013f02:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8013f06:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8013f0a:	f840 2c20 	str.w	r2, [r0, #-32]
}
 8013f0e:	3840      	subs	r0, #64	@ 0x40
 8013f10:	4770      	bx	lr
 8013f12:	bf00      	nop
 8013f14:	08013ec3 	.word	0x08013ec3
	...

08013f20 <vPortSVCHandler>:
	__asm volatile (
 8013f20:	4b07      	ldr	r3, [pc, #28]	@ (8013f40 <pxCurrentTCBConst2>)
 8013f22:	6819      	ldr	r1, [r3, #0]
 8013f24:	6808      	ldr	r0, [r1, #0]
 8013f26:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8013f2a:	f380 8809 	msr	PSP, r0
 8013f2e:	f3bf 8f6f 	isb	sy
 8013f32:	f04f 0000 	mov.w	r0, #0
 8013f36:	f380 8811 	msr	BASEPRI, r0
 8013f3a:	f04e 0e0d 	orr.w	lr, lr, #13
 8013f3e:	4770      	bx	lr

08013f40 <pxCurrentTCBConst2>:
 8013f40:	20002dc0 	.word	0x20002dc0

08013f44 <vPortEnterCritical>:
 8013f44:	f04f 03bf 	mov.w	r3, #191	@ 0xbf
 8013f48:	f383 8811 	msr	BASEPRI, r3
 8013f4c:	f3bf 8f6f 	isb	sy
 8013f50:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8013f54:	4a02      	ldr	r2, [pc, #8]	@ (8013f60 <vPortEnterCritical+0x1c>)
 8013f56:	6813      	ldr	r3, [r2, #0]
 8013f58:	3301      	adds	r3, #1
 8013f5a:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 8013f5c:	4770      	bx	lr
 8013f5e:	bf00      	nop
 8013f60:	20000000 	.word	0x20000000

08013f64 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
 8013f64:	4a03      	ldr	r2, [pc, #12]	@ (8013f74 <vPortExitCritical+0x10>)
 8013f66:	6813      	ldr	r3, [r2, #0]
 8013f68:	3b01      	subs	r3, #1
 8013f6a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8013f6c:	b90b      	cbnz	r3, 8013f72 <vPortExitCritical+0xe>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8013f6e:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 8013f72:	4770      	bx	lr
 8013f74:	20000000 	.word	0x20000000
	...

08013f80 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8013f80:	f3ef 8009 	mrs	r0, PSP
 8013f84:	f3bf 8f6f 	isb	sy
 8013f88:	4b0d      	ldr	r3, [pc, #52]	@ (8013fc0 <pxCurrentTCBConst>)
 8013f8a:	681a      	ldr	r2, [r3, #0]
 8013f8c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8013f90:	6010      	str	r0, [r2, #0]
 8013f92:	e92d 4008 	stmdb	sp!, {r3, lr}
 8013f96:	f04f 00bf 	mov.w	r0, #191	@ 0xbf
 8013f9a:	f380 8811 	msr	BASEPRI, r0
 8013f9e:	f7ff fbe1 	bl	8013764 <vTaskSwitchContext>
 8013fa2:	f04f 0000 	mov.w	r0, #0
 8013fa6:	f380 8811 	msr	BASEPRI, r0
 8013faa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8013fae:	6819      	ldr	r1, [r3, #0]
 8013fb0:	6808      	ldr	r0, [r1, #0]
 8013fb2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8013fb6:	f380 8809 	msr	PSP, r0
 8013fba:	f3bf 8f6f 	isb	sy
 8013fbe:	4770      	bx	lr

08013fc0 <pxCurrentTCBConst>:
 8013fc0:	20002dc0 	.word	0x20002dc0

08013fc4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8013fc4:	b508      	push	{r3, lr}
	__asm volatile
 8013fc6:	f04f 03bf 	mov.w	r3, #191	@ 0xbf
 8013fca:	f383 8811 	msr	BASEPRI, r3
 8013fce:	f3bf 8f6f 	isb	sy
 8013fd2:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8013fd6:	f7ff fa61 	bl	801349c <xTaskIncrementTick>
 8013fda:	b128      	cbz	r0, 8013fe8 <xPortSysTickHandler+0x24>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8013fdc:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013fe0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8013fe4:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
	__asm volatile
 8013fe8:	2300      	movs	r3, #0
 8013fea:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 8013fee:	bd08      	pop	{r3, pc}

08013ff0 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8013ff0:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8013ff4:	4a02      	ldr	r2, [pc, #8]	@ (8014000 <vPortSetupTimerInterrupt+0x10>)
 8013ff6:	615a      	str	r2, [r3, #20]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8013ff8:	2207      	movs	r2, #7
 8013ffa:	611a      	str	r2, [r3, #16]
}
 8013ffc:	4770      	bx	lr
 8013ffe:	bf00      	nop
 8014000:	0002903f 	.word	0x0002903f

08014004 <xPortStartScheduler>:
{
 8014004:	b508      	push	{r3, lr}
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8014006:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 801400a:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	@ 0xd20
 801400e:	f442 027f 	orr.w	r2, r2, #16711680	@ 0xff0000
 8014012:	f8c3 2d20 	str.w	r2, [r3, #3360]	@ 0xd20
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8014016:	f8d3 2d20 	ldr.w	r2, [r3, #3360]	@ 0xd20
 801401a:	f042 427f 	orr.w	r2, r2, #4278190080	@ 0xff000000
 801401e:	f8c3 2d20 	str.w	r2, [r3, #3360]	@ 0xd20
	vPortSetupTimerInterrupt();
 8014022:	f7ff ffe5 	bl	8013ff0 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8014026:	4b03      	ldr	r3, [pc, #12]	@ (8014034 <xPortStartScheduler+0x30>)
 8014028:	2200      	movs	r2, #0
 801402a:	601a      	str	r2, [r3, #0]
	prvPortStartFirstTask();
 801402c:	f7ff ff52 	bl	8013ed4 <prvPortStartFirstTask>
	prvTaskExitError();
 8014030:	f7ff ff47 	bl	8013ec2 <prvTaskExitError>
 8014034:	20000000 	.word	0x20000000

08014038 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8014038:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 801403a:	4b10      	ldr	r3, [pc, #64]	@ (801407c <prvInsertBlockIntoFreeList+0x44>)
 801403c:	461a      	mov	r2, r3
 801403e:	681b      	ldr	r3, [r3, #0]
 8014040:	4283      	cmp	r3, r0
 8014042:	d3fb      	bcc.n	801403c <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8014044:	6854      	ldr	r4, [r2, #4]
 8014046:	1911      	adds	r1, r2, r4
 8014048:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 801404a:	bf01      	itttt	eq
 801404c:	6841      	ldreq	r1, [r0, #4]
 801404e:	4610      	moveq	r0, r2
 8014050:	1909      	addeq	r1, r1, r4
 8014052:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8014054:	6844      	ldr	r4, [r0, #4]
 8014056:	1901      	adds	r1, r0, r4
 8014058:	428b      	cmp	r3, r1
 801405a:	d10c      	bne.n	8014076 <prvInsertBlockIntoFreeList+0x3e>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 801405c:	4908      	ldr	r1, [pc, #32]	@ (8014080 <prvInsertBlockIntoFreeList+0x48>)
 801405e:	6809      	ldr	r1, [r1, #0]
 8014060:	428b      	cmp	r3, r1
 8014062:	d003      	beq.n	801406c <prvInsertBlockIntoFreeList+0x34>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8014064:	6859      	ldr	r1, [r3, #4]
 8014066:	4421      	add	r1, r4
 8014068:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 801406a:	6819      	ldr	r1, [r3, #0]
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 801406c:	6001      	str	r1, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 801406e:	4290      	cmp	r0, r2
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8014070:	bf18      	it	ne
 8014072:	6010      	strne	r0, [r2, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8014074:	bd10      	pop	{r4, pc}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8014076:	4619      	mov	r1, r3
 8014078:	e7f8      	b.n	801406c <prvInsertBlockIntoFreeList+0x34>
 801407a:	bf00      	nop
 801407c:	20002dd4 	.word	0x20002dd4
 8014080:	20002dd0 	.word	0x20002dd0

08014084 <pvPortMalloc>:
{
 8014084:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8014088:	4604      	mov	r4, r0
	vTaskSuspendAll();
 801408a:	f7ff f9f9 	bl	8013480 <vTaskSuspendAll>
		if( pxEnd == NULL )
 801408e:	4936      	ldr	r1, [pc, #216]	@ (8014168 <pvPortMalloc+0xe4>)
 8014090:	4d36      	ldr	r5, [pc, #216]	@ (801416c <pvPortMalloc+0xe8>)
 8014092:	680b      	ldr	r3, [r1, #0]
 8014094:	bb0b      	cbnz	r3, 80140da <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 8014096:	4a36      	ldr	r2, [pc, #216]	@ (8014170 <pvPortMalloc+0xec>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8014098:	4e36      	ldr	r6, [pc, #216]	@ (8014174 <pvPortMalloc+0xf0>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 801409a:	0750      	lsls	r0, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 801409c:	bf1f      	itttt	ne
 801409e:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80140a0:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 80140a4:	f502 5220 	addne.w	r2, r2, #10240	@ 0x2800
 80140a8:	1a13      	subne	r3, r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80140aa:	bf0c      	ite	eq
 80140ac:	f44f 5320 	moveq.w	r3, #10240	@ 0x2800
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80140b0:	4602      	movne	r2, r0
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 80140b2:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 80140b4:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 80140b6:	f023 0307 	bic.w	r3, r3, #7
	xStart.xBlockSize = ( size_t ) 0;
 80140ba:	2000      	movs	r0, #0
 80140bc:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 80140be:	6032      	str	r2, [r6, #0]
	pxEnd->pxNextFreeBlock = NULL;
 80140c0:	e9c3 0000 	strd	r0, r0, [r3]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 80140c4:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 80140c6:	e9c2 3000 	strd	r3, r0, [r2]
	pxEnd = ( void * ) uxAddress;
 80140ca:	600b      	str	r3, [r1, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80140cc:	4b2a      	ldr	r3, [pc, #168]	@ (8014178 <pvPortMalloc+0xf4>)
 80140ce:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80140d0:	4b2a      	ldr	r3, [pc, #168]	@ (801417c <pvPortMalloc+0xf8>)
 80140d2:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80140d4:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 80140d8:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80140da:	682f      	ldr	r7, [r5, #0]
 80140dc:	4227      	tst	r7, r4
 80140de:	d007      	beq.n	80140f0 <pvPortMalloc+0x6c>
	( void ) xTaskResumeAll();
 80140e0:	f7ff fa70 	bl	80135c4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
 80140e4:	f7fe ff2c 	bl	8012f40 <vApplicationMallocFailedHook>
 80140e8:	2600      	movs	r6, #0
}
 80140ea:	4630      	mov	r0, r6
 80140ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if( xWantedSize > 0 )
 80140f0:	2c00      	cmp	r4, #0
 80140f2:	d0f5      	beq.n	80140e0 <pvPortMalloc+0x5c>
				xWantedSize += xHeapStructSize;
 80140f4:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80140f8:	0762      	lsls	r2, r4, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 80140fa:	bf1c      	itt	ne
 80140fc:	f023 0307 	bicne.w	r3, r3, #7
 8014100:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8014102:	2b00      	cmp	r3, #0
 8014104:	d0ec      	beq.n	80140e0 <pvPortMalloc+0x5c>
 8014106:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 801417c <pvPortMalloc+0xf8>
 801410a:	f8d8 5000 	ldr.w	r5, [r8]
 801410e:	429d      	cmp	r5, r3
 8014110:	d3e6      	bcc.n	80140e0 <pvPortMalloc+0x5c>
				pxBlock = xStart.pxNextFreeBlock;
 8014112:	4a18      	ldr	r2, [pc, #96]	@ (8014174 <pvPortMalloc+0xf0>)
 8014114:	6814      	ldr	r4, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8014116:	6860      	ldr	r0, [r4, #4]
 8014118:	4298      	cmp	r0, r3
 801411a:	d201      	bcs.n	8014120 <pvPortMalloc+0x9c>
 801411c:	6826      	ldr	r6, [r4, #0]
 801411e:	b9fe      	cbnz	r6, 8014160 <pvPortMalloc+0xdc>
				if( pxBlock != pxEnd )
 8014120:	6809      	ldr	r1, [r1, #0]
 8014122:	42a1      	cmp	r1, r4
 8014124:	d0dc      	beq.n	80140e0 <pvPortMalloc+0x5c>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8014126:	6821      	ldr	r1, [r4, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8014128:	6816      	ldr	r6, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 801412a:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 801412c:	1ac2      	subs	r2, r0, r3
 801412e:	2a10      	cmp	r2, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8014130:	f106 0608 	add.w	r6, r6, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8014134:	d904      	bls.n	8014140 <pvPortMalloc+0xbc>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8014136:	18e0      	adds	r0, r4, r3
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8014138:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 801413a:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 801413c:	f7ff ff7c 	bl	8014038 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8014140:	490d      	ldr	r1, [pc, #52]	@ (8014178 <pvPortMalloc+0xf4>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8014142:	6862      	ldr	r2, [r4, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8014144:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8014146:	1aad      	subs	r5, r5, r2
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8014148:	4317      	orrs	r7, r2
					pxBlock->pxNextFreeBlock = NULL;
 801414a:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 801414c:	4285      	cmp	r5, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 801414e:	6067      	str	r7, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8014150:	6023      	str	r3, [r4, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8014152:	f8c8 5000 	str.w	r5, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8014156:	bf38      	it	cc
 8014158:	600d      	strcc	r5, [r1, #0]
	( void ) xTaskResumeAll();
 801415a:	f7ff fa33 	bl	80135c4 <xTaskResumeAll>
	return pvReturn;
 801415e:	e7c4      	b.n	80140ea <pvPortMalloc+0x66>
 8014160:	4622      	mov	r2, r4
 8014162:	4634      	mov	r4, r6
 8014164:	e7d7      	b.n	8014116 <pvPortMalloc+0x92>
 8014166:	bf00      	nop
 8014168:	20002dd0 	.word	0x20002dd0
 801416c:	20002dc4 	.word	0x20002dc4
 8014170:	200004c0 	.word	0x200004c0
 8014174:	20002dd4 	.word	0x20002dd4
 8014178:	20002dc8 	.word	0x20002dc8
 801417c:	20002dcc 	.word	0x20002dcc

08014180 <vPortFree>:
{
 8014180:	b510      	push	{r4, lr}
	if( pv != NULL )
 8014182:	4604      	mov	r4, r0
 8014184:	b1e0      	cbz	r0, 80141c0 <vPortFree+0x40>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 8014186:	4a0f      	ldr	r2, [pc, #60]	@ (80141c4 <vPortFree+0x44>)
 8014188:	f850 3c04 	ldr.w	r3, [r0, #-4]
 801418c:	6812      	ldr	r2, [r2, #0]
 801418e:	4213      	tst	r3, r2
 8014190:	d016      	beq.n	80141c0 <vPortFree+0x40>
			if( pxLink->pxNextFreeBlock == NULL )
 8014192:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8014196:	b999      	cbnz	r1, 80141c0 <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8014198:	ea23 0302 	bic.w	r3, r3, r2
 801419c:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 80141a0:	f7ff f96e 	bl	8013480 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80141a4:	4a08      	ldr	r2, [pc, #32]	@ (80141c8 <vPortFree+0x48>)
 80141a6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80141aa:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80141ac:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 80141b0:	440b      	add	r3, r1
 80141b2:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80141b4:	f7ff ff40 	bl	8014038 <prvInsertBlockIntoFreeList>
}
 80141b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 80141bc:	f7ff ba02 	b.w	80135c4 <xTaskResumeAll>
}
 80141c0:	bd10      	pop	{r4, pc}
 80141c2:	bf00      	nop
 80141c4:	20002dc4 	.word	0x20002dc4
 80141c8:	20002dcc 	.word	0x20002dcc

080141cc <Default_Handler>:
*/

void Default_Handler(void) 
{
  /* Go into an infinite loop. */
  while (1) 
 80141cc:	e7fe      	b.n	80141cc <Default_Handler>
	...

080141d0 <Reset_Handler>:
{
 80141d0:	4668      	mov	r0, sp
 80141d2:	f020 0107 	bic.w	r1, r0, #7
 80141d6:	468d      	mov	sp, r1
    *(pulDest++) = *(pulSrc++);
 80141d8:	4b15      	ldr	r3, [pc, #84]	@ (8014230 <Reset_Handler+0x60>)
{
 80141da:	b501      	push	{r0, lr}
    *(pulDest++) = *(pulSrc++);
 80141dc:	4815      	ldr	r0, [pc, #84]	@ (8014234 <Reset_Handler+0x64>)
 80141de:	1cda      	adds	r2, r3, #3
 80141e0:	1a12      	subs	r2, r2, r0
 80141e2:	1ec1      	subs	r1, r0, #3
 80141e4:	f022 0203 	bic.w	r2, r2, #3
 80141e8:	428b      	cmp	r3, r1
 80141ea:	bf38      	it	cc
 80141ec:	2200      	movcc	r2, #0
 80141ee:	4912      	ldr	r1, [pc, #72]	@ (8014238 <Reset_Handler+0x68>)
 80141f0:	f00f fa15 	bl	802361e <memcpy>
    *(pulDest++) = 0;
 80141f4:	4b11      	ldr	r3, [pc, #68]	@ (801423c <Reset_Handler+0x6c>)
 80141f6:	4812      	ldr	r0, [pc, #72]	@ (8014240 <Reset_Handler+0x70>)
 80141f8:	1cda      	adds	r2, r3, #3
 80141fa:	1a12      	subs	r2, r2, r0
 80141fc:	1ec1      	subs	r1, r0, #3
 80141fe:	f022 0203 	bic.w	r2, r2, #3
 8014202:	4299      	cmp	r1, r3
 8014204:	bf88      	it	hi
 8014206:	2200      	movhi	r2, #0
 8014208:	2100      	movs	r1, #0
 801420a:	f00f f9a2 	bl	8023552 <memset>
    *(pulDest++) = 0;
 801420e:	4b0d      	ldr	r3, [pc, #52]	@ (8014244 <Reset_Handler+0x74>)
 8014210:	480d      	ldr	r0, [pc, #52]	@ (8014248 <Reset_Handler+0x78>)
 8014212:	1cda      	adds	r2, r3, #3
 8014214:	1a12      	subs	r2, r2, r0
 8014216:	1ec1      	subs	r1, r0, #3
 8014218:	f022 0203 	bic.w	r2, r2, #3
 801421c:	4299      	cmp	r1, r3
 801421e:	bf88      	it	hi
 8014220:	2200      	movhi	r2, #0
 8014222:	2100      	movs	r1, #0
 8014224:	f00f f995 	bl	8023552 <memset>
  main();
 8014228:	f7fe fdfa 	bl	8012e20 <main>
  while( 1 );
 801422c:	e7fe      	b.n	801422c <Reset_Handler+0x5c>
 801422e:	bf00      	nop
 8014230:	200000d0 	.word	0x200000d0
 8014234:	20000000 	.word	0x20000000
 8014238:	080293e8 	.word	0x080293e8
 801423c:	200076a0 	.word	0x200076a0
 8014240:	200000d0 	.word	0x200000d0
 8014244:	10000000 	.word	0x10000000
 8014248:	10000000 	.word	0x10000000

0801424c <_init>:
}
 801424c:	4770      	bx	lr
	...

08014250 <MIOS32_SRIO_DMA_Callback>:
/////////////////////////////////////////////////////////////////////////////
// DMA callback function is called by MIOS32_SPI driver once the complete SRIO chain
// has been scanned
/////////////////////////////////////////////////////////////////////////////
static void MIOS32_SRIO_DMA_Callback(void)
{
 8014250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // notify that new values have been transfered
  srio_values_transfered = 1;

  // latch DOUT registers by pulsing RCLK: 1->0->1
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 8014252:	2200      	movs	r2, #0
  srio_values_transfered = 1;
 8014254:	2401      	movs	r4, #1
 8014256:	4b22      	ldr	r3, [pc, #136]	@ (80142e0 <MIOS32_SRIO_DMA_Callback+0x90>)
#endif

  // copy/or buffered DIN values/changed flags
  int i;
  for(i=0; i<num_sr; ++i) {
    u8 change_mask = mios32_srio_din[i] ^ mios32_srio_din_buffer[i]; // these are the changed pins
 8014258:	4d22      	ldr	r5, [pc, #136]	@ (80142e4 <MIOS32_SRIO_DMA_Callback+0x94>)
  srio_values_transfered = 1;
 801425a:	701c      	strb	r4, [r3, #0]
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 801425c:	4611      	mov	r1, r2
 801425e:	4620      	mov	r0, r4
 8014260:	f002 fbc2 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 0); // spi, rc_pin, pin_value
 8014264:	4621      	mov	r1, r4
 8014266:	2200      	movs	r2, #0
 8014268:	4620      	mov	r0, r4
 801426a:	f002 fbbd 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 801426e:	4622      	mov	r2, r4
 8014270:	2100      	movs	r1, #0
 8014272:	4620      	mov	r0, r4
 8014274:	f002 fbb8 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 1); // spi, rc_pin, pin_value
 8014278:	4622      	mov	r2, r4
 801427a:	4621      	mov	r1, r4
 801427c:	4620      	mov	r0, r4
  for(i=0; i<num_sr; ++i) {
 801427e:	4c1a      	ldr	r4, [pc, #104]	@ (80142e8 <MIOS32_SRIO_DMA_Callback+0x98>)
    mios32_srio_din_changed[i] |= change_mask;
 8014280:	4e1a      	ldr	r6, [pc, #104]	@ (80142ec <MIOS32_SRIO_DMA_Callback+0x9c>)
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 1); // spi, rc_pin, pin_value
 8014282:	f002 fbb1 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  for(i=0; i<num_sr; ++i) {
 8014286:	7827      	ldrb	r7, [r4, #0]
    u8 change_mask = mios32_srio_din[i] ^ mios32_srio_din_buffer[i]; // these are the changed pins
 8014288:	4819      	ldr	r0, [pc, #100]	@ (80142f0 <MIOS32_SRIO_DMA_Callback+0xa0>)
  for(i=0; i<num_sr; ++i) {
 801428a:	2300      	movs	r3, #0
 801428c:	429f      	cmp	r7, r3
 801428e:	dc13      	bgt.n	80142b8 <MIOS32_SRIO_DMA_Callback+0x68>

  // call user specific hook if requested
  // it has to be called before button debouncing is handled
  // to ensure that the encoder driver, but also other drivers (e.g. BLM) are working properly
  // regardless if debouncing is enabled or not
  if( srio_scan_finished_hook != NULL )
 8014290:	4b18      	ldr	r3, [pc, #96]	@ (80142f4 <MIOS32_SRIO_DMA_Callback+0xa4>)
 8014292:	681b      	ldr	r3, [r3, #0]
 8014294:	b103      	cbz	r3, 8014298 <MIOS32_SRIO_DMA_Callback+0x48>
    srio_scan_finished_hook();
 8014296:	4798      	blx	r3
  // at this time. In order to ensure, that a new final state of a button won't get lost, 
  // the DIN values are XORed with the "changed" flags (yes, this idea is ill, but it works! :)
  // Even the encoder handler (or others which are notified by the scan_finished_hook) still
  // work properly, because they are clearing the appr. "changed" flags, so that the DIN
  // values won't be touched by the XOR operation.
  if( debounce_time && debounce_ctr ) {
 8014298:	4b17      	ldr	r3, [pc, #92]	@ (80142f8 <MIOS32_SRIO_DMA_Callback+0xa8>)
 801429a:	881b      	ldrh	r3, [r3, #0]
 801429c:	b15b      	cbz	r3, 80142b6 <MIOS32_SRIO_DMA_Callback+0x66>
 801429e:	4a17      	ldr	r2, [pc, #92]	@ (80142fc <MIOS32_SRIO_DMA_Callback+0xac>)
 80142a0:	8813      	ldrh	r3, [r2, #0]
 80142a2:	b143      	cbz	r3, 80142b6 <MIOS32_SRIO_DMA_Callback+0x66>
    --debounce_ctr;
 80142a4:	3b01      	subs	r3, #1
 80142a6:	8013      	strh	r3, [r2, #0]

    for(i=0; i<num_sr; ++i) {
 80142a8:	7824      	ldrb	r4, [r4, #0]
      mios32_srio_din[i] ^= mios32_srio_din_changed[i];
 80142aa:	4910      	ldr	r1, [pc, #64]	@ (80142ec <MIOS32_SRIO_DMA_Callback+0x9c>)
 80142ac:	4810      	ldr	r0, [pc, #64]	@ (80142f0 <MIOS32_SRIO_DMA_Callback+0xa0>)
    for(i=0; i<num_sr; ++i) {
 80142ae:	2300      	movs	r3, #0
      mios32_srio_din_changed[i] = 0;
 80142b0:	461d      	mov	r5, r3
    for(i=0; i<num_sr; ++i) {
 80142b2:	429c      	cmp	r4, r3
 80142b4:	dc0d      	bgt.n	80142d2 <MIOS32_SRIO_DMA_Callback+0x82>
    }
  }

  // next transfer has to be started with MIOS32_SRIO_ScanStart
}
 80142b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    u8 change_mask = mios32_srio_din[i] ^ mios32_srio_din_buffer[i]; // these are the changed pins
 80142b8:	5cc1      	ldrb	r1, [r0, r3]
 80142ba:	f815 c003 	ldrb.w	ip, [r5, r3]
    mios32_srio_din_changed[i] |= change_mask;
 80142be:	5cf2      	ldrb	r2, [r6, r3]
    u8 change_mask = mios32_srio_din[i] ^ mios32_srio_din_buffer[i]; // these are the changed pins
 80142c0:	ea81 010c 	eor.w	r1, r1, ip
    mios32_srio_din_changed[i] |= change_mask;
 80142c4:	430a      	orrs	r2, r1
 80142c6:	54f2      	strb	r2, [r6, r3]
    mios32_srio_din[i] = mios32_srio_din_buffer[i];
 80142c8:	5cea      	ldrb	r2, [r5, r3]
 80142ca:	b2d2      	uxtb	r2, r2
 80142cc:	54c2      	strb	r2, [r0, r3]
  for(i=0; i<num_sr; ++i) {
 80142ce:	3301      	adds	r3, #1
 80142d0:	e7dc      	b.n	801428c <MIOS32_SRIO_DMA_Callback+0x3c>
      mios32_srio_din[i] ^= mios32_srio_din_changed[i];
 80142d2:	5cce      	ldrb	r6, [r1, r3]
 80142d4:	5cc2      	ldrb	r2, [r0, r3]
 80142d6:	4072      	eors	r2, r6
 80142d8:	54c2      	strb	r2, [r0, r3]
      mios32_srio_din_changed[i] = 0;
 80142da:	54cd      	strb	r5, [r1, r3]
    for(i=0; i<num_sr; ++i) {
 80142dc:	3301      	adds	r3, #1
 80142de:	e7e8      	b.n	80142b2 <MIOS32_SRIO_DMA_Callback+0x62>
 80142e0:	20002ddc 	.word	0x20002ddc
 80142e4:	20002df9 	.word	0x20002df9
 80142e8:	20002de8 	.word	0x20002de8
 80142ec:	20002de9 	.word	0x20002de9
 80142f0:	20002e09 	.word	0x20002e09
 80142f4:	20002de0 	.word	0x20002de0
 80142f8:	20002de6 	.word	0x20002de6
 80142fc:	20002de4 	.word	0x20002de4

08014300 <MIOS32_SRIO_Init>:
{
 8014300:	b570      	push	{r4, r5, r6, lr}
  if( mode != 0 )
 8014302:	bb68      	cbnz	r0, 8014360 <MIOS32_SRIO_Init+0x60>
  srio_scan_finished_hook = NULL;
 8014304:	4b18      	ldr	r3, [pc, #96]	@ (8014368 <MIOS32_SRIO_Init+0x68>)
    mios32_srio_dout[0][i] = 0x00;       // passive state (LEDs off)
 8014306:	4e19      	ldr	r6, [pc, #100]	@ (801436c <MIOS32_SRIO_Init+0x6c>)
  srio_scan_finished_hook = NULL;
 8014308:	6018      	str	r0, [r3, #0]
  num_sr = MIOS32_SRIO_NUM_SR;
 801430a:	4b19      	ldr	r3, [pc, #100]	@ (8014370 <MIOS32_SRIO_Init+0x70>)
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 801430c:	4d19      	ldr	r5, [pc, #100]	@ (8014374 <MIOS32_SRIO_Init+0x74>)
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 801430e:	4c1a      	ldr	r4, [pc, #104]	@ (8014378 <MIOS32_SRIO_Init+0x78>)
    mios32_srio_din_changed[i] = 0;   // no change
 8014310:	491a      	ldr	r1, [pc, #104]	@ (801437c <MIOS32_SRIO_Init+0x7c>)
  num_sr = MIOS32_SRIO_NUM_SR;
 8014312:	2210      	movs	r2, #16
 8014314:	701a      	strb	r2, [r3, #0]
    mios32_srio_dout[0][i] = 0x00;       // passive state (LEDs off)
 8014316:	4603      	mov	r3, r0
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 8014318:	22ff      	movs	r2, #255	@ 0xff
    mios32_srio_dout[0][i] = 0x00;       // passive state (LEDs off)
 801431a:	5433      	strb	r3, [r6, r0]
    mios32_srio_din[i] = 0xff;        // passive state (Buttons depressed)
 801431c:	542a      	strb	r2, [r5, r0]
    mios32_srio_din_buffer[i] = 0xff; // passive state (Buttons depressed)
 801431e:	5422      	strb	r2, [r4, r0]
    mios32_srio_din_changed[i] = 0;   // no change
 8014320:	540b      	strb	r3, [r1, r0]
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8014322:	3001      	adds	r0, #1
 8014324:	2810      	cmp	r0, #16
 8014326:	d1f8      	bne.n	801431a <MIOS32_SRIO_Init+0x1a>
  debounce_time = 0;
 8014328:	4a15      	ldr	r2, [pc, #84]	@ (8014380 <MIOS32_SRIO_Init+0x80>)
 801432a:	8013      	strh	r3, [r2, #0]
  debounce_ctr = 0;
 801432c:	4a15      	ldr	r2, [pc, #84]	@ (8014384 <MIOS32_SRIO_Init+0x84>)
 801432e:	8013      	strh	r3, [r2, #0]
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 8014330:	2201      	movs	r2, #1
 8014332:	2100      	movs	r1, #0
 8014334:	4610      	mov	r0, r2
 8014336:	f002 fb57 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 1); // spi, rc_pin, pin_value
 801433a:	2201      	movs	r2, #1
 801433c:	4611      	mov	r1, r2
 801433e:	4610      	mov	r0, r2
 8014340:	f002 fb52 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_IO_Init(MIOS32_SRIO_SPI, MIOS32_SPI_PIN_DRIVER_WEAK);
 8014344:	2102      	movs	r1, #2
 8014346:	2001      	movs	r0, #1
 8014348:	f002 fa1a 	bl	8016780 <MIOS32_SPI_IO_Init>
  MIOS32_SPI_TransferModeInit(MIOS32_SRIO_SPI, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 801434c:	2206      	movs	r2, #6
 801434e:	2103      	movs	r1, #3
 8014350:	2001      	movs	r0, #1
 8014352:	f002 fb99 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
  srio_values_transfered = 1;
 8014356:	4b0c      	ldr	r3, [pc, #48]	@ (8014388 <MIOS32_SRIO_Init+0x88>)
 8014358:	2201      	movs	r2, #1
 801435a:	701a      	strb	r2, [r3, #0]
  return 0;
 801435c:	2000      	movs	r0, #0
}
 801435e:	bd70      	pop	{r4, r5, r6, pc}
    return -1; // unsupported mode
 8014360:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8014364:	e7fb      	b.n	801435e <MIOS32_SRIO_Init+0x5e>
 8014366:	bf00      	nop
 8014368:	20002de0 	.word	0x20002de0
 801436c:	20002e19 	.word	0x20002e19
 8014370:	20002de8 	.word	0x20002de8
 8014374:	20002e09 	.word	0x20002e09
 8014378:	20002df9 	.word	0x20002df9
 801437c:	20002de9 	.word	0x20002de9
 8014380:	20002de6 	.word	0x20002de6
 8014384:	20002de4 	.word	0x20002de4
 8014388:	20002ddc 	.word	0x20002ddc

0801438c <MIOS32_SRIO_ScanNumGet>:
}
 801438c:	4b01      	ldr	r3, [pc, #4]	@ (8014394 <MIOS32_SRIO_ScanNumGet+0x8>)
 801438e:	7818      	ldrb	r0, [r3, #0]
 8014390:	4770      	bx	lr
 8014392:	bf00      	nop
 8014394:	20002de8 	.word	0x20002de8

08014398 <MIOS32_SRIO_ScanNumSet>:
  if( new_num_sr > MIOS32_SRIO_NUM_SR )
 8014398:	2810      	cmp	r0, #16
 801439a:	4b03      	ldr	r3, [pc, #12]	@ (80143a8 <MIOS32_SRIO_ScanNumSet+0x10>)
 801439c:	bf28      	it	cs
 801439e:	2010      	movcs	r0, #16
 80143a0:	7018      	strb	r0, [r3, #0]
}
 80143a2:	2000      	movs	r0, #0
 80143a4:	4770      	bx	lr
 80143a6:	bf00      	nop
 80143a8:	20002de8 	.word	0x20002de8

080143ac <MIOS32_SRIO_DebounceStart>:
  debounce_ctr = debounce_time;
 80143ac:	4b02      	ldr	r3, [pc, #8]	@ (80143b8 <MIOS32_SRIO_DebounceStart+0xc>)
 80143ae:	881a      	ldrh	r2, [r3, #0]
 80143b0:	4b02      	ldr	r3, [pc, #8]	@ (80143bc <MIOS32_SRIO_DebounceStart+0x10>)
}
 80143b2:	2000      	movs	r0, #0
  debounce_ctr = debounce_time;
 80143b4:	801a      	strh	r2, [r3, #0]
}
 80143b6:	4770      	bx	lr
 80143b8:	20002de6 	.word	0x20002de6
 80143bc:	20002de4 	.word	0x20002de4

080143c0 <MIOS32_SRIO_ScanStart>:
{
 80143c0:	b537      	push	{r0, r1, r2, r4, r5, lr}
  if( num_sr == 0 )
 80143c2:	4d17      	ldr	r5, [pc, #92]	@ (8014420 <MIOS32_SRIO_ScanStart+0x60>)
 80143c4:	782b      	ldrb	r3, [r5, #0]
 80143c6:	b32b      	cbz	r3, 8014414 <MIOS32_SRIO_ScanStart+0x54>
  if( !srio_values_transfered )
 80143c8:	4b16      	ldr	r3, [pc, #88]	@ (8014424 <MIOS32_SRIO_ScanStart+0x64>)
 80143ca:	781a      	ldrb	r2, [r3, #0]
 80143cc:	b32a      	cbz	r2, 801441a <MIOS32_SRIO_ScanStart+0x5a>
  srio_values_transfered = 0;
 80143ce:	2400      	movs	r4, #0
 80143d0:	701c      	strb	r4, [r3, #0]
  srio_scan_finished_hook = _notify_hook;
 80143d2:	4b15      	ldr	r3, [pc, #84]	@ (8014428 <MIOS32_SRIO_ScanStart+0x68>)
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80143d4:	4622      	mov	r2, r4
  srio_scan_finished_hook = _notify_hook;
 80143d6:	6018      	str	r0, [r3, #0]
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 0); // spi, rc_pin, pin_value
 80143d8:	4621      	mov	r1, r4
 80143da:	2001      	movs	r0, #1
 80143dc:	f002 fb04 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 0); // spi, rc_pin, pin_value
 80143e0:	2101      	movs	r1, #1
 80143e2:	4622      	mov	r2, r4
 80143e4:	4608      	mov	r0, r1
 80143e6:	f002 faff 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN, 1); // spi, rc_pin, pin_value
 80143ea:	2201      	movs	r2, #1
 80143ec:	4621      	mov	r1, r4
 80143ee:	4610      	mov	r0, r2
 80143f0:	f002 fafa 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_RC_PinSet(MIOS32_SRIO_SPI, MIOS32_SRIO_SPI_RC_PIN2, 1); // spi, rc_pin, pin_value
 80143f4:	2201      	movs	r2, #1
 80143f6:	4611      	mov	r1, r2
 80143f8:	4610      	mov	r0, r2
 80143fa:	f002 faf5 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_TransferBlock(MIOS32_SRIO_SPI,
 80143fe:	4b0b      	ldr	r3, [pc, #44]	@ (801442c <MIOS32_SRIO_ScanStart+0x6c>)
 8014400:	9300      	str	r3, [sp, #0]
 8014402:	782b      	ldrb	r3, [r5, #0]
 8014404:	4a0a      	ldr	r2, [pc, #40]	@ (8014430 <MIOS32_SRIO_ScanStart+0x70>)
 8014406:	490b      	ldr	r1, [pc, #44]	@ (8014434 <MIOS32_SRIO_ScanStart+0x74>)
 8014408:	2001      	movs	r0, #1
 801440a:	f002 fcdd 	bl	8016dc8 <MIOS32_SPI_TransferBlock>
  return 0;
 801440e:	4620      	mov	r0, r4
}
 8014410:	b003      	add	sp, #12
 8014412:	bd30      	pop	{r4, r5, pc}
    return -1; // SRIO disabled during runtime
 8014414:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8014418:	e7fa      	b.n	8014410 <MIOS32_SRIO_ScanStart+0x50>
    return -2; // notify this special scenario - we could retry here
 801441a:	f06f 0001 	mvn.w	r0, #1
 801441e:	e7f7      	b.n	8014410 <MIOS32_SRIO_ScanStart+0x50>
 8014420:	20002de8 	.word	0x20002de8
 8014424:	20002ddc 	.word	0x20002ddc
 8014428:	20002de0 	.word	0x20002de0
 801442c:	08014251 	.word	0x08014251
 8014430:	20002df9 	.word	0x20002df9
 8014434:	20002e19 	.word	0x20002e19

08014438 <MIOS32_DIN_Init>:
//! Initializes DIN driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Init(u32 mode)
{
 8014438:	b510      	push	{r4, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 801443a:	b950      	cbnz	r0, 8014452 <MIOS32_DIN_Init+0x1a>
    return -1; // unsupported mode

  // clear DIN part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
    mios32_srio_din[i] = 0xff; // passive state
 801443c:	4906      	ldr	r1, [pc, #24]	@ (8014458 <MIOS32_DIN_Init+0x20>)
    mios32_srio_din_changed[i] = 0;
 801443e:	4b07      	ldr	r3, [pc, #28]	@ (801445c <MIOS32_DIN_Init+0x24>)
    mios32_srio_din[i] = 0xff; // passive state
 8014440:	24ff      	movs	r4, #255	@ 0xff
    mios32_srio_din_changed[i] = 0;
 8014442:	4602      	mov	r2, r0
    mios32_srio_din[i] = 0xff; // passive state
 8014444:	540c      	strb	r4, [r1, r0]
    mios32_srio_din_changed[i] = 0;
 8014446:	541a      	strb	r2, [r3, r0]
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8014448:	3001      	adds	r0, #1
 801444a:	2810      	cmp	r0, #16
 801444c:	d1fa      	bne.n	8014444 <MIOS32_DIN_Init+0xc>
  }

  return 0;
 801444e:	2000      	movs	r0, #0
}
 8014450:	bd10      	pop	{r4, pc}
    return -1; // unsupported mode
 8014452:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8014456:	e7fb      	b.n	8014450 <MIOS32_DIN_Init+0x18>
 8014458:	20002e09 	.word	0x20002e09
 801445c:	20002de9 	.word	0x20002de9

08014460 <MIOS32_DIN_SRGet>:
//! \param[in] sr shift register number (0..15)
//! \return 8bit value of shift register
//! \return -1 if shift register not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_SRGet(u32 sr)
{
 8014460:	b510      	push	{r4, lr}
 8014462:	4604      	mov	r4, r0
  u8 num_sr = MIOS32_SRIO_ScanNumGet();
 8014464:	f7ff ff92 	bl	801438c <MIOS32_SRIO_ScanNumGet>

  // check if SR available
  if( sr >= num_sr )
 8014468:	42a0      	cmp	r0, r4
    return -1;

  return mios32_srio_din[sr];
 801446a:	bf85      	ittet	hi
 801446c:	4b02      	ldrhi	r3, [pc, #8]	@ (8014478 <MIOS32_DIN_SRGet+0x18>)
 801446e:	5d18      	ldrbhi	r0, [r3, r4]
    return -1;
 8014470:	f04f 30ff 	movls.w	r0, #4294967295	@ 0xffffffff
  return mios32_srio_din[sr];
 8014474:	b2c0      	uxtbhi	r0, r0
}
 8014476:	bd10      	pop	{r4, pc}
 8014478:	20002e09 	.word	0x20002e09

0801447c <MIOS32_DIN_SRChangedGetAndClear>:
//! \param[in] mask pin mask (8bit value)
//! \return 8bit value which contains the selected (masked) change flags
//! \return no error status (-1)! - if unavailable SR selected, 0x00 will be returned
/////////////////////////////////////////////////////////////////////////////
u8 MIOS32_DIN_SRChangedGetAndClear(u32 sr, u8 mask)
{
 801447c:	b570      	push	{r4, r5, r6, lr}
 801447e:	4604      	mov	r4, r0
 8014480:	460e      	mov	r6, r1
  u8 num_sr = MIOS32_SRIO_ScanNumGet();
 8014482:	f7ff ff83 	bl	801438c <MIOS32_SRIO_ScanNumGet>
  u8 changed;

  // check if SR available
  if( sr >= num_sr )
 8014486:	42a0      	cmp	r0, r4
 8014488:	d90c      	bls.n	80144a4 <MIOS32_DIN_SRChangedGetAndClear+0x28>
    return 0x00;

  // get and clear changed flags - must be atomic!
  MIOS32_IRQ_Disable();
 801448a:	f002 f92f 	bl	80166ec <MIOS32_IRQ_Disable>
  changed = mios32_srio_din_changed[sr] & mask;
 801448e:	4b06      	ldr	r3, [pc, #24]	@ (80144a8 <MIOS32_DIN_SRChangedGetAndClear+0x2c>)
 8014490:	5d1d      	ldrb	r5, [r3, r4]
  mios32_srio_din_changed[sr] &= ~mask;
 8014492:	5d1a      	ldrb	r2, [r3, r4]
 8014494:	ea22 0206 	bic.w	r2, r2, r6
 8014498:	551a      	strb	r2, [r3, r4]
  changed = mios32_srio_din_changed[sr] & mask;
 801449a:	4035      	ands	r5, r6
  MIOS32_IRQ_Enable();
 801449c:	f002 f93a 	bl	8016714 <MIOS32_IRQ_Enable>

  return changed;
}
 80144a0:	4628      	mov	r0, r5
 80144a2:	bd70      	pop	{r4, r5, r6, pc}
    return 0x00;
 80144a4:	2500      	movs	r5, #0
 80144a6:	e7fb      	b.n	80144a0 <MIOS32_DIN_SRChangedGetAndClear+0x24>
 80144a8:	20002de9 	.word	0x20002de9

080144ac <MIOS32_DIN_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DIN_Handler(void *_callback)
{
 80144ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80144b0:	4606      	mov	r6, r0
  s32 sr;
  s32 sr_pin;
  u8 changed;
  void (*callback)(u32 pin, u32 value) = _callback;
  u8 num_sr = MIOS32_SRIO_ScanNumGet();
 80144b2:	f7ff ff6b 	bl	801438c <MIOS32_SRIO_ScanNumGet>
  // no SRIOs?
#if MIOS32_SRIO_NUM_SR == 0
  return -1;
#endif

  if( num_sr == 0 )
 80144b6:	4607      	mov	r7, r0
 80144b8:	b320      	cbz	r0, 8014504 <MIOS32_DIN_Handler+0x58>
    return -1;

  // no callback function?
  if( _callback == NULL )
 80144ba:	b31e      	cbz	r6, 8014504 <MIOS32_DIN_Handler+0x58>

    // check all 8 pins of the SR
    for(sr_pin=0; sr_pin<8; ++sr_pin)
      if( changed & (1 << sr_pin) ) {
	// call the notification function
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80144bc:	f8df 904c 	ldr.w	r9, [pc, #76]	@ 801450c <MIOS32_DIN_Handler+0x60>
  for(sr=0; sr<num_sr; ++sr) {
 80144c0:	2400      	movs	r4, #0
    changed = MIOS32_DIN_SRChangedGetAndClear(sr, 0xff);
 80144c2:	21ff      	movs	r1, #255	@ 0xff
 80144c4:	4620      	mov	r0, r4
 80144c6:	f7ff ffd9 	bl	801447c <MIOS32_DIN_SRChangedGetAndClear>
    if( !changed )
 80144ca:	4680      	mov	r8, r0
 80144cc:	b928      	cbnz	r0, 80144da <MIOS32_DIN_Handler+0x2e>
  for(sr=0; sr<num_sr; ++sr) {
 80144ce:	3401      	adds	r4, #1
 80144d0:	42bc      	cmp	r4, r7
 80144d2:	dbf6      	blt.n	80144c2 <MIOS32_DIN_Handler+0x16>
	// start debouncing (if enabled in SRIO driver)
	MIOS32_SRIO_DebounceStart();
      }
  }

  return 0;
 80144d4:	2000      	movs	r0, #0
}
 80144d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80144da:	ea4f 0ac4 	mov.w	sl, r4, lsl #3
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 80144de:	2500      	movs	r5, #0
      if( changed & (1 << sr_pin) ) {
 80144e0:	fa48 f305 	asr.w	r3, r8, r5
 80144e4:	07db      	lsls	r3, r3, #31
 80144e6:	d509      	bpl.n	80144fc <MIOS32_DIN_Handler+0x50>
	callback(8*sr+sr_pin, (mios32_srio_din[sr] & (1 << sr_pin)) ? 1 : 0);
 80144e8:	f819 1004 	ldrb.w	r1, [r9, r4]
 80144ec:	4129      	asrs	r1, r5
 80144ee:	f001 0101 	and.w	r1, r1, #1
 80144f2:	eb05 000a 	add.w	r0, r5, sl
 80144f6:	47b0      	blx	r6
	MIOS32_SRIO_DebounceStart();
 80144f8:	f7ff ff58 	bl	80143ac <MIOS32_SRIO_DebounceStart>
    for(sr_pin=0; sr_pin<8; ++sr_pin)
 80144fc:	3501      	adds	r5, #1
 80144fe:	2d08      	cmp	r5, #8
 8014500:	d1ee      	bne.n	80144e0 <MIOS32_DIN_Handler+0x34>
 8014502:	e7e4      	b.n	80144ce <MIOS32_DIN_Handler+0x22>
    return -1;
 8014504:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8014508:	e7e5      	b.n	80144d6 <MIOS32_DIN_Handler+0x2a>
 801450a:	bf00      	nop
 801450c:	20002e09 	.word	0x20002e09

08014510 <MIOS32_DOUT_Init>:
s32 MIOS32_DOUT_Init(u32 mode)
{
  int i;

  // currently only mode 0 supported
  if( mode != 0 )
 8014510:	b938      	cbnz	r0, 8014522 <MIOS32_DOUT_Init+0x12>

  // clear DOUT part of SRIO chain
  // TODO: here we could provide an option to invert the default value
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
#if MIOS32_SRIO_NUM_DOUT_PAGES < 2
    mios32_srio_dout[0][i] = 0;
 8014512:	4b05      	ldr	r3, [pc, #20]	@ (8014528 <MIOS32_DOUT_Init+0x18>)
 8014514:	4602      	mov	r2, r0
 8014516:	541a      	strb	r2, [r3, r0]
  for(i=0; i<MIOS32_SRIO_NUM_SR; ++i) {
 8014518:	3001      	adds	r0, #1
 801451a:	2810      	cmp	r0, #16
 801451c:	d1fb      	bne.n	8014516 <MIOS32_DOUT_Init+0x6>
    for(j=0; j<MIOS32_SRIO_NUM_DOUT_PAGES; ++j)
      mios32_srio_dout[j][i] = 0;
#endif
  }

  return 0;
 801451e:	2000      	movs	r0, #0
 8014520:	4770      	bx	lr
    return -1; // unsupported mode
 8014522:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8014526:	4770      	bx	lr
 8014528:	20002e19 	.word	0x20002e19

0801452c <MIOS32_DOUT_SRSet>:
//! \param[in] sr shift register number (0..15)
//! \param[in] value 8bit value of shift register
//! \return -1 if shift register not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DOUT_SRSet(u32 sr, u8 value)
{
 801452c:	b538      	push	{r3, r4, r5, lr}
 801452e:	4604      	mov	r4, r0
 8014530:	460d      	mov	r5, r1
  u8 num_sr = MIOS32_SRIO_ScanNumGet();
 8014532:	f7ff ff2b 	bl	801438c <MIOS32_SRIO_ScanNumGet>

  // check if SR available
  if( sr >= num_sr )
 8014536:	42a0      	cmp	r0, r4
    return -1;

  u8 *dout = (u8 *)&mios32_srio_dout[0][num_sr - sr - 1];
  u8 mapped_value = mios32_dout_reverse_tab[value];
 8014538:	bf81      	itttt	hi
 801453a:	4b06      	ldrhi	r3, [pc, #24]	@ (8014554 <MIOS32_DOUT_SRSet+0x28>)
  u8 *dout = (u8 *)&mios32_srio_dout[0][num_sr - sr - 1];
 801453c:	1b00      	subhi	r0, r0, r4
  u8 mapped_value = mios32_dout_reverse_tab[value];
 801453e:	5d5a      	ldrbhi	r2, [r3, r5]

#if MIOS32_SRIO_NUM_DOUT_PAGES < 2
  *dout = mapped_value;
 8014540:	4b05      	ldrhi	r3, [pc, #20]	@ (8014558 <MIOS32_DOUT_SRSet+0x2c>)
  u8 *dout = (u8 *)&mios32_srio_dout[0][num_sr - sr - 1];
 8014542:	bf89      	itett	hi
 8014544:	f100 30ff 	addhi.w	r0, r0, #4294967295	@ 0xffffffff
    return -1;
 8014548:	f04f 30ff 	movls.w	r0, #4294967295	@ 0xffffffff
  *dout = mapped_value;
 801454c:	541a      	strbhi	r2, [r3, r0]
  int i;
  for(i=0; i<MIOS32_SRIO_NUM_DOUT_PAGES; ++i, dout += MIOS32_SRIO_NUM_SR)
    *dout = mapped_value;
#endif

  return 0;
 801454e:	2000      	movhi	r0, #0
}
 8014550:	bd38      	pop	{r3, r4, r5, pc}
 8014552:	bf00      	nop
 8014554:	08026b5e 	.word	0x08026b5e
 8014558:	20002e19 	.word	0x20002e19

0801455c <MIOS32_ENC_Init>:
//! Initializes encoder driver
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Init(u32 mode)
{
 801455c:	b570      	push	{r4, r5, r6, lr}
  u8 i;

  // currently only mode 0 supported
  if( mode != 0 )
 801455e:	b9c0      	cbnz	r0, 8014592 <MIOS32_ENC_Init+0x36>
    return -1; // unsupported mode

  // clear encoder variables
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8014560:	4d0d      	ldr	r5, [pc, #52]	@ (8014598 <MIOS32_ENC_Init+0x3c>)
 8014562:	4a0e      	ldr	r2, [pc, #56]	@ (801459c <MIOS32_ENC_Init+0x40>)
    enc_state[i].decinc = 0;
    enc_state[i].incrementer = 0;
    enc_state[i].accelerator = 0;
    enc_state[i].prev_state_dec = 0;
    enc_state[i].prev_state_inc = 0;
    enc_state[i].prev_acc = 0;
 8014564:	4c0e      	ldr	r4, [pc, #56]	@ (80145a0 <MIOS32_ENC_Init+0x44>)
    enc_config[i].cfg.type = DISABLED; // disable encoder
 8014566:	4606      	mov	r6, r0
    enc_state[i].state = 0xf; // all pins released
 8014568:	f852 3030 	ldr.w	r3, [r2, r0, lsl #3]
    enc_config[i].cfg.type = DISABLED; // disable encoder
 801456c:	f805 6020 	strb.w	r6, [r5, r0, lsl #2]
    enc_state[i].state = 0xf; // all pins released
 8014570:	f003 03e0 	and.w	r3, r3, #224	@ 0xe0
 8014574:	f043 030f 	orr.w	r3, r3, #15
 8014578:	f842 3030 	str.w	r3, [r2, r0, lsl #3]
 801457c:	eb02 01c0 	add.w	r1, r2, r0, lsl #3
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 8014580:	3001      	adds	r0, #1
    enc_state[i].prev_acc = 0;
 8014582:	888b      	ldrh	r3, [r1, #4]
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 8014584:	2840      	cmp	r0, #64	@ 0x40
    enc_state[i].prev_acc = 0;
 8014586:	ea03 0304 	and.w	r3, r3, r4
 801458a:	808b      	strh	r3, [r1, #4]
  for(i=0; i<MIOS32_ENC_NUM_MAX; ++i) {
 801458c:	d1ec      	bne.n	8014568 <MIOS32_ENC_Init+0xc>
    enc_state[i].predivider = 0;
  }

  return 0; // no error
 801458e:	2000      	movs	r0, #0
}
 8014590:	bd70      	pop	{r4, r5, r6, pc}
    return -1; // unsupported mode
 8014592:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8014596:	e7fb      	b.n	8014590 <MIOS32_ENC_Init+0x34>
 8014598:	20003030 	.word	0x20003030
 801459c:	20002e30 	.word	0x20002e30
 80145a0:	fffff000 	.word	0xfffff000

080145a4 <MIOS32_ENC_Handler>:
//! \endcode
//! \param[in] _callback pointer to callback function
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC_Handler(void *_callback)
{
 80145a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u8 enc;
  s32 incrementer;
  void (*callback)(u32 pin, u32 value) = _callback;

  // no callback function?
  if( _callback == NULL )
 80145a8:	4605      	mov	r5, r0
 80145aa:	b1c8      	cbz	r0, 80145e0 <MIOS32_ENC_Handler+0x3c>
 80145ac:	2400      	movs	r4, #0
  // check all encoders
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {

    // following check/modify operation must be atomic
    MIOS32_IRQ_Disable();
    if( (incrementer = enc_state[enc].incrementer) ) {
 80145ae:	4f0e      	ldr	r7, [pc, #56]	@ (80145e8 <MIOS32_ENC_Handler+0x44>)
      enc_state[enc].incrementer = 0;
 80145b0:	46a0      	mov	r8, r4
    MIOS32_IRQ_Disable();
 80145b2:	f002 f89b 	bl	80166ec <MIOS32_IRQ_Disable>
    if( (incrementer = enc_state[enc].incrementer) ) {
 80145b6:	eb07 03c4 	add.w	r3, r7, r4, lsl #3
 80145ba:	f993 6001 	ldrsb.w	r6, [r3, #1]
 80145be:	b166      	cbz	r6, 80145da <MIOS32_ENC_Handler+0x36>
      enc_state[enc].incrementer = 0;
 80145c0:	f883 8001 	strb.w	r8, [r3, #1]
      MIOS32_IRQ_Enable();
 80145c4:	f002 f8a6 	bl	8016714 <MIOS32_IRQ_Enable>

      // call the hook
      callback(enc, incrementer);
 80145c8:	4631      	mov	r1, r6
 80145ca:	4620      	mov	r0, r4
 80145cc:	47a8      	blx	r5
  for(enc=0; enc<MIOS32_ENC_NUM_MAX; ++enc) {
 80145ce:	3401      	adds	r4, #1
 80145d0:	2c40      	cmp	r4, #64	@ 0x40
 80145d2:	d1ee      	bne.n	80145b2 <MIOS32_ENC_Handler+0xe>
    } else {
      MIOS32_IRQ_Enable();
    }
  }

  return 0; // no error
 80145d4:	2000      	movs	r0, #0
}
 80145d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      MIOS32_IRQ_Enable();
 80145da:	f002 f89b 	bl	8016714 <MIOS32_IRQ_Enable>
 80145de:	e7f6      	b.n	80145ce <MIOS32_ENC_Handler+0x2a>
    return -1;
 80145e0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80145e4:	e7f7      	b.n	80145d6 <MIOS32_ENC_Handler+0x32>
 80145e6:	bf00      	nop
 80145e8:	20002e30 	.word	0x20002e30

080145ec <MIOS32_LCD_ParametersFetchFromBslInfoRange>:
    .num_y = 1,
    .width = 20, // since most people will (probably) build the SCS
    .height = 2,
    .colour_depth = 1,
  };
  mios32_lcd_parameters = default_parameters;
 80145ec:	4a10      	ldr	r2, [pc, #64]	@ (8014630 <MIOS32_LCD_ParametersFetchFromBslInfoRange+0x44>)
 80145ee:	4b11      	ldr	r3, [pc, #68]	@ (8014634 <MIOS32_LCD_ParametersFetchFromBslInfoRange+0x48>)
 80145f0:	6811      	ldr	r1, [r2, #0]
 80145f2:	6019      	str	r1, [r3, #0]
 80145f4:	6851      	ldr	r1, [r2, #4]
 80145f6:	8912      	ldrh	r2, [r2, #8]
 80145f8:	811a      	strh	r2, [r3, #8]

#ifdef MIOS32_SYS_ADDR_BSL_INFO_BEGIN
  // read from bootloader info range
  u8 *lcd_par_confirm = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_CONFIRM;
  if( *lcd_par_confirm == 0x42 ) {
 80145fa:	4a0f      	ldr	r2, [pc, #60]	@ (8014638 <MIOS32_LCD_ParametersFetchFromBslInfoRange+0x4c>)
  mios32_lcd_parameters = default_parameters;
 80145fc:	6059      	str	r1, [r3, #4]
  if( *lcd_par_confirm == 0x42 ) {
 80145fe:	f892 10c0 	ldrb.w	r1, [r2, #192]	@ 0xc0
 8014602:	2942      	cmp	r1, #66	@ 0x42
 8014604:	d112      	bne.n	801462c <MIOS32_LCD_ParametersFetchFromBslInfoRange+0x40>
    u8 *lcd_par_type = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_TYPE;
    mios32_lcd_parameters.lcd_type = *lcd_par_type;
 8014606:	f892 10c1 	ldrb.w	r1, [r2, #193]	@ 0xc1
 801460a:	7019      	strb	r1, [r3, #0]
    u8 *lcd_par_num_x = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_NUM_X;
    mios32_lcd_parameters.num_x = *lcd_par_num_x;
 801460c:	f892 10c2 	ldrb.w	r1, [r2, #194]	@ 0xc2
 8014610:	7059      	strb	r1, [r3, #1]
    u8 *lcd_par_num_y = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_NUM_Y;
    mios32_lcd_parameters.num_y = *lcd_par_num_y;
 8014612:	f892 10c3 	ldrb.w	r1, [r2, #195]	@ 0xc3
 8014616:	7099      	strb	r1, [r3, #2]
    u8 *lcd_par_width = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_WIDTH;
    mios32_lcd_parameters.width = *lcd_par_width;
 8014618:	f892 10c4 	ldrb.w	r1, [r2, #196]	@ 0xc4
    // extra: if width == 255, increase to 256 (255 is very uncommon, and 256 can't be configured due to byte limitation)
    if( mios32_lcd_parameters.width == 255 )
      mios32_lcd_parameters.width = 256; // in future, we could also provide additional codings for higher widths, e.g. 254 for 320 pixel
 801461c:	29ff      	cmp	r1, #255	@ 0xff
 801461e:	bf08      	it	eq
 8014620:	f44f 7180 	moveq.w	r1, #256	@ 0x100
 8014624:	8099      	strh	r1, [r3, #4]
    u8 *lcd_par_height = (u8 *)MIOS32_SYS_ADDR_LCD_PAR_HEIGHT;
    mios32_lcd_parameters.height = *lcd_par_height;
 8014626:	f892 20c5 	ldrb.w	r2, [r2, #197]	@ 0xc5
 801462a:	80da      	strh	r2, [r3, #6]
  }
#endif

  return 0; // no error
}
 801462c:	2000      	movs	r0, #0
 801462e:	4770      	bx	lr
 8014630:	08026c7e 	.word	0x08026c7e
 8014634:	2000314a 	.word	0x2000314a
 8014638:	08003f00 	.word	0x08003f00

0801463c <MIOS32_LCD_TypeIsGLCD>:
//! setting - if bit #7 is set (>= 0x80), the LCD is a GLCD
//! \return 1 or 0
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_TypeIsGLCD(void)
{
  return mios32_lcd_parameters.lcd_type >= 0x80;
 801463c:	4b02      	ldr	r3, [pc, #8]	@ (8014648 <MIOS32_LCD_TypeIsGLCD+0xc>)
 801463e:	f993 0000 	ldrsb.w	r0, [r3]
}
 8014642:	0fc0      	lsrs	r0, r0, #31
 8014644:	4770      	bx	lr
 8014646:	bf00      	nop
 8014648:	2000314a 	.word	0x2000314a

0801464c <MIOS32_LCD_DeviceSet>:
//! \param[in] device LCD device number
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_DeviceSet(u8 device)
{
  mios32_lcd_device = device;
 801464c:	4b01      	ldr	r3, [pc, #4]	@ (8014654 <MIOS32_LCD_DeviceSet+0x8>)
 801464e:	7018      	strb	r0, [r3, #0]

  return 0; // no error
}
 8014650:	2000      	movs	r0, #0
 8014652:	4770      	bx	lr
 8014654:	20003148 	.word	0x20003148

08014658 <MIOS32_LCD_CursorSet>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorSet(u16 column, u16 line)
{
  // set character position
  mios32_lcd_column = column;
 8014658:	4b0b      	ldr	r3, [pc, #44]	@ (8014688 <MIOS32_LCD_CursorSet+0x30>)
  mios32_lcd_line = line;

  // set graphical cursor depending on font width
  u8 font_width = 6;
  u8 font_height = 8;
  if( font_bitmap.width ) {
 801465a:	4a0c      	ldr	r2, [pc, #48]	@ (801468c <MIOS32_LCD_CursorSet+0x34>)
{
 801465c:	b410      	push	{r4}
  mios32_lcd_column = column;
 801465e:	8018      	strh	r0, [r3, #0]
  mios32_lcd_line = line;
 8014660:	4b0b      	ldr	r3, [pc, #44]	@ (8014690 <MIOS32_LCD_CursorSet+0x38>)
 8014662:	8019      	strh	r1, [r3, #0]
  if( font_bitmap.width ) {
 8014664:	8893      	ldrh	r3, [r2, #4]
 8014666:	b163      	cbz	r3, 8014682 <MIOS32_LCD_CursorSet+0x2a>
    font_width = font_bitmap.width;
    font_height = font_bitmap.height;
 8014668:	7992      	ldrb	r2, [r2, #6]
    font_width = font_bitmap.width;
 801466a:	b2db      	uxtb	r3, r3
  }

  mios32_lcd_x = column * font_width;
 801466c:	4c09      	ldr	r4, [pc, #36]	@ (8014694 <MIOS32_LCD_CursorSet+0x3c>)
 801466e:	fb13 f300 	smulbb	r3, r3, r0
 8014672:	8023      	strh	r3, [r4, #0]
  mios32_lcd_y = line * font_height;
 8014674:	4b08      	ldr	r3, [pc, #32]	@ (8014698 <MIOS32_LCD_CursorSet+0x40>)

  // forward new cursor position to app driver
  return APP_LCD_CursorSet(column, line);
}
 8014676:	bc10      	pop	{r4}
  mios32_lcd_y = line * font_height;
 8014678:	fb12 f201 	smulbb	r2, r2, r1
 801467c:	801a      	strh	r2, [r3, #0]
  return APP_LCD_CursorSet(column, line);
 801467e:	f009 bb0f 	b.w	801dca0 <APP_LCD_CursorSet>
  u8 font_height = 8;
 8014682:	2208      	movs	r2, #8
  u8 font_width = 6;
 8014684:	2306      	movs	r3, #6
 8014686:	e7f1      	b.n	801466c <MIOS32_LCD_CursorSet+0x14>
 8014688:	20003146 	.word	0x20003146
 801468c:	20003130 	.word	0x20003130
 8014690:	20003144 	.word	0x20003144
 8014694:	2000313e 	.word	0x2000313e
 8014698:	2000313c 	.word	0x2000313c

0801469c <MIOS32_LCD_GCursorSet>:
//! \param[in] y position
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_GCursorSet(u16 x, u16 y)
{
  mios32_lcd_x = x;
 801469c:	4b02      	ldr	r3, [pc, #8]	@ (80146a8 <MIOS32_LCD_GCursorSet+0xc>)
 801469e:	8018      	strh	r0, [r3, #0]
  mios32_lcd_y = y;
 80146a0:	4b02      	ldr	r3, [pc, #8]	@ (80146ac <MIOS32_LCD_GCursorSet+0x10>)
 80146a2:	8019      	strh	r1, [r3, #0]

  // forward new cursor position to app driver
  return APP_LCD_GCursorSet(x, y);
 80146a4:	f009 ba94 	b.w	801dbd0 <APP_LCD_GCursorSet>
 80146a8:	2000313e 	.word	0x2000313e
 80146ac:	2000313c 	.word	0x2000313c

080146b0 <MIOS32_LCD_CursorMapSet>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_CursorMapSet(u8 map_table[])
{
  s32 i;

  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80146b0:	4a05      	ldr	r2, [pc, #20]	@ (80146c8 <MIOS32_LCD_CursorMapSet+0x18>)
 80146b2:	1e43      	subs	r3, r0, #1
 80146b4:	3003      	adds	r0, #3
    mios32_lcd_cursor_map[i] = map_table[i];
 80146b6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80146ba:	f802 1b01 	strb.w	r1, [r2], #1
  for(i=0; i<MIOS32_LCD_MAX_MAP_LINES; ++i)
 80146be:	4283      	cmp	r3, r0
 80146c0:	d1f9      	bne.n	80146b6 <MIOS32_LCD_CursorMapSet+0x6>

  return 0; // no error
}
 80146c2:	2000      	movs	r0, #0
 80146c4:	4770      	bx	lr
 80146c6:	bf00      	nop
 80146c8:	20003140 	.word	0x20003140

080146cc <MIOS32_LCD_FontInit>:
//! \param[in] *font pointer to font
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FontInit(u8 *font)
{
  font_bitmap.memory = (u8 *)&font[MIOS32_LCD_FONT_BITMAP_IX] + (size_t)font[MIOS32_LCD_FONT_X0_IX];
 80146cc:	7882      	ldrb	r2, [r0, #2]
 80146ce:	4b07      	ldr	r3, [pc, #28]	@ (80146ec <MIOS32_LCD_FontInit+0x20>)
 80146d0:	3204      	adds	r2, #4
 80146d2:	4402      	add	r2, r0
 80146d4:	601a      	str	r2, [r3, #0]
  font_bitmap.width = font[MIOS32_LCD_FONT_WIDTH_IX];
 80146d6:	7802      	ldrb	r2, [r0, #0]
 80146d8:	809a      	strh	r2, [r3, #4]
  font_bitmap.height = font[MIOS32_LCD_FONT_HEIGHT_IX];
 80146da:	7842      	ldrb	r2, [r0, #1]
 80146dc:	80da      	strh	r2, [r3, #6]
  font_bitmap.line_offset = font[MIOS32_LCD_FONT_OFFSET_IX];
 80146de:	78c2      	ldrb	r2, [r0, #3]
 80146e0:	811a      	strh	r2, [r3, #8]
  font_bitmap.colour_depth = 1;
 80146e2:	2201      	movs	r2, #1
 80146e4:	729a      	strb	r2, [r3, #10]

  return 0; // no error
}
 80146e6:	2000      	movs	r0, #0
 80146e8:	4770      	bx	lr
 80146ea:	bf00      	nop
 80146ec:	20003130 	.word	0x20003130

080146f0 <MIOS32_LCD_Clear>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_Clear(void)
{
  // -> forward to app_lcd
  return APP_LCD_Clear();
 80146f0:	f009 b9d6 	b.w	801daa0 <APP_LCD_Clear>

080146f4 <MIOS32_LCD_Init>:
{
 80146f4:	b513      	push	{r0, r1, r4, lr}
  if( mode != 0 )
 80146f6:	4604      	mov	r4, r0
 80146f8:	b9f0      	cbnz	r0, 8014738 <MIOS32_LCD_Init+0x44>
  MIOS32_LCD_ParametersFetchFromBslInfoRange();
 80146fa:	f7ff ff77 	bl	80145ec <MIOS32_LCD_ParametersFetchFromBslInfoRange>
  font_bitmap.width = 0;
 80146fe:	4b10      	ldr	r3, [pc, #64]	@ (8014740 <MIOS32_LCD_Init+0x4c>)
  MIOS32_LCD_CursorMapSet(cursor_map);
 8014700:	a801      	add	r0, sp, #4
  font_bitmap.width = 0;
 8014702:	809c      	strh	r4, [r3, #4]
  u8 cursor_map[] = {0x00, 0x40, 0x14, 0x54}; // offset line 0/1/2/3
 8014704:	4b0f      	ldr	r3, [pc, #60]	@ (8014744 <MIOS32_LCD_Init+0x50>)
 8014706:	9301      	str	r3, [sp, #4]
  MIOS32_LCD_CursorMapSet(cursor_map);
 8014708:	f7ff ffd2 	bl	80146b0 <MIOS32_LCD_CursorMapSet>
  MIOS32_DELAY_Wait_uS(50000);
 801470c:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8014710:	f002 fe58 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
  if( (ret=APP_LCD_Init(mode)) < 0 )
 8014714:	4620      	mov	r0, r4
 8014716:	f008 ff43 	bl	801d5a0 <APP_LCD_Init>
 801471a:	2800      	cmp	r0, #0
 801471c:	db0a      	blt.n	8014734 <MIOS32_LCD_Init+0x40>
  MIOS32_LCD_Clear();
 801471e:	f7ff ffe7 	bl	80146f0 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 8014722:	4621      	mov	r1, r4
 8014724:	4620      	mov	r0, r4
 8014726:	f7ff ff97 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_GCursorSet(0, 0);
 801472a:	4621      	mov	r1, r4
 801472c:	4620      	mov	r0, r4
 801472e:	f7ff ffb5 	bl	801469c <MIOS32_LCD_GCursorSet>
  return 0; // no error
 8014732:	4620      	mov	r0, r4
}
 8014734:	b002      	add	sp, #8
 8014736:	bd10      	pop	{r4, pc}
    return -1; // unsupported mode
 8014738:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801473c:	e7fa      	b.n	8014734 <MIOS32_LCD_Init+0x40>
 801473e:	bf00      	nop
 8014740:	20003130 	.word	0x20003130
 8014744:	54144000 	.word	0x54144000

08014748 <MIOS32_LCD_PrintChar>:
//! Prints a single character
//! \param[in] c character to be print
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_PrintChar(char c)
{
 8014748:	b530      	push	{r4, r5, lr}
  return mios32_lcd_parameters.lcd_type >= 0x80;
 801474a:	4b14      	ldr	r3, [pc, #80]	@ (801479c <MIOS32_LCD_PrintChar+0x54>)
  s32 status;

  if( MIOS32_LCD_TypeIsGLCD() ) { // GLCD
 801474c:	f993 3000 	ldrsb.w	r3, [r3]
 8014750:	2b00      	cmp	r3, #0
{
 8014752:	b085      	sub	sp, #20
 8014754:	4605      	mov	r5, r0
  if( MIOS32_LCD_TypeIsGLCD() ) { // GLCD
 8014756:	da1d      	bge.n	8014794 <MIOS32_LCD_PrintChar+0x4c>
    if( !font_bitmap.width )
 8014758:	4c11      	ldr	r4, [pc, #68]	@ (80147a0 <MIOS32_LCD_PrintChar+0x58>)
 801475a:	88a3      	ldrh	r3, [r4, #4]
 801475c:	b91b      	cbnz	r3, 8014766 <MIOS32_LCD_PrintChar+0x1e>
      return -1;    // font not initialized yet!
 801475e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    // increment cursor
    ++mios32_lcd_column;
  }

  return status;
}
 8014762:	b005      	add	sp, #20
 8014764:	bd30      	pop	{r4, r5, pc}
    mios32_lcd_bitmap_t bitmap = font_bitmap;
 8014766:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
 801476a:	ab01      	add	r3, sp, #4
 801476c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    bitmap.memory += (bitmap.height>>3) * bitmap.line_offset * (size_t)c;
 8014770:	88e2      	ldrh	r2, [r4, #6]
 8014772:	8921      	ldrh	r1, [r4, #8]
 8014774:	08d2      	lsrs	r2, r2, #3
 8014776:	434a      	muls	r2, r1
 8014778:	fb05 0002 	mla	r0, r5, r2, r0
    status = APP_LCD_BitmapPrint(bitmap);
 801477c:	9001      	str	r0, [sp, #4]
 801477e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8014782:	f009 fab9 	bl	801dcf8 <APP_LCD_BitmapPrint>
  if( status >= 0 ) {
 8014786:	2800      	cmp	r0, #0
    ++mios32_lcd_column;
 8014788:	bfa1      	itttt	ge
 801478a:	4a06      	ldrge	r2, [pc, #24]	@ (80147a4 <MIOS32_LCD_PrintChar+0x5c>)
 801478c:	8813      	ldrhge	r3, [r2, #0]
 801478e:	3301      	addge	r3, #1
 8014790:	8013      	strhge	r3, [r2, #0]
 8014792:	e7e6      	b.n	8014762 <MIOS32_LCD_PrintChar+0x1a>
    status = APP_LCD_Data(c);
 8014794:	f009 f89c 	bl	801d8d0 <APP_LCD_Data>
 8014798:	e7f5      	b.n	8014786 <MIOS32_LCD_PrintChar+0x3e>
 801479a:	bf00      	nop
 801479c:	2000314a 	.word	0x2000314a
 80147a0:	20003130 	.word	0x20003130
 80147a4:	20003146 	.word	0x20003146

080147a8 <MIOS32_LCD_PrintString>:
{
 80147a8:	b538      	push	{r3, r4, r5, lr}
 80147aa:	1e44      	subs	r4, r0, #1
  s32 status = 0;
 80147ac:	2500      	movs	r5, #0
  while( *str != '\0' )
 80147ae:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 80147b2:	b908      	cbnz	r0, 80147b8 <MIOS32_LCD_PrintString+0x10>
}
 80147b4:	4628      	mov	r0, r5
 80147b6:	bd38      	pop	{r3, r4, r5, pc}
    status |= MIOS32_LCD_PrintChar(*str++);
 80147b8:	f7ff ffc6 	bl	8014748 <MIOS32_LCD_PrintChar>
 80147bc:	4305      	orrs	r5, r0
 80147be:	e7f6      	b.n	80147ae <MIOS32_LCD_PrintString+0x6>

080147c0 <MIOS32_LCD_PrintFormattedString>:
{
 80147c0:	b40f      	push	{r0, r1, r2, r3}
 80147c2:	b500      	push	{lr}
 80147c4:	b093      	sub	sp, #76	@ 0x4c
 80147c6:	aa14      	add	r2, sp, #80	@ 0x50
  vsprintf((char *)buffer, format, args);
 80147c8:	a802      	add	r0, sp, #8
{
 80147ca:	f852 1b04 	ldr.w	r1, [r2], #4
  va_start(args, format);
 80147ce:	9201      	str	r2, [sp, #4]
  vsprintf((char *)buffer, format, args);
 80147d0:	f004 fb07 	bl	8018de2 <vsprintf>
  return MIOS32_LCD_PrintString(buffer);
 80147d4:	a802      	add	r0, sp, #8
 80147d6:	f7ff ffe7 	bl	80147a8 <MIOS32_LCD_PrintString>
}
 80147da:	b013      	add	sp, #76	@ 0x4c
 80147dc:	f85d eb04 	ldr.w	lr, [sp], #4
 80147e0:	b004      	add	sp, #16
 80147e2:	4770      	bx	lr

080147e4 <MIOS32_LCD_PrintBootMessage>:
{
 80147e4:	b538      	push	{r3, r4, r5, lr}
  mios32_lcd_device = device;
 80147e6:	4b0b      	ldr	r3, [pc, #44]	@ (8014814 <MIOS32_LCD_PrintBootMessage+0x30>)
 80147e8:	2500      	movs	r5, #0
  status |= MIOS32_LCD_CursorSet(0, 0);
 80147ea:	4629      	mov	r1, r5
 80147ec:	4628      	mov	r0, r5
  mios32_lcd_device = device;
 80147ee:	701d      	strb	r5, [r3, #0]
  status |= MIOS32_LCD_CursorSet(0, 0);
 80147f0:	f7ff ff32 	bl	8014658 <MIOS32_LCD_CursorSet>
 80147f4:	4604      	mov	r4, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80147f6:	4808      	ldr	r0, [pc, #32]	@ (8014818 <MIOS32_LCD_PrintBootMessage+0x34>)
 80147f8:	f7ff ffd6 	bl	80147a8 <MIOS32_LCD_PrintString>
  status |= MIOS32_LCD_CursorSet(0, 1);
 80147fc:	2101      	movs	r1, #1
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE1);
 80147fe:	4304      	orrs	r4, r0
  status |= MIOS32_LCD_CursorSet(0, 1);
 8014800:	4628      	mov	r0, r5
 8014802:	f7ff ff29 	bl	8014658 <MIOS32_LCD_CursorSet>
 8014806:	4304      	orrs	r4, r0
  status |= MIOS32_LCD_PrintString(MIOS32_LCD_BOOT_MSG_LINE2);
 8014808:	4804      	ldr	r0, [pc, #16]	@ (801481c <MIOS32_LCD_PrintBootMessage+0x38>)
 801480a:	f7ff ffcd 	bl	80147a8 <MIOS32_LCD_PrintString>
}
 801480e:	4320      	orrs	r0, r4
 8014810:	bd38      	pop	{r3, r4, r5, pc}
 8014812:	bf00      	nop
 8014814:	20003148 	.word	0x20003148
 8014818:	080239e2 	.word	0x080239e2
 801481c:	08026c5e 	.word	0x08026c5e

08014820 <MIOS32_LCD_BColourSet>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_BColourSet(u32 rgb)
{
  // -> forward to app_lcd
  return APP_LCD_BColourSet(rgb);
 8014820:	f009 ba64 	b.w	801dcec <APP_LCD_BColourSet>

08014824 <MIOS32_LCD_FColourSet>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_LCD_FColourSet(u32 rgb)
{
  // -> forward to app_lcd
  return APP_LCD_FColourSet(rgb);
 8014824:	f009 ba65 	b.w	801dcf2 <APP_LCD_FColourSet>

08014828 <MIOS32_MIDI_Init>:
//! Initializes MIDI layer
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_Init(u32 mode)
{
 8014828:	b538      	push	{r3, r4, r5, lr}
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 801482a:	4604      	mov	r4, r0
 801482c:	2800      	cmp	r0, #0
 801482e:	d137      	bne.n	80148a0 <MIOS32_MIDI_Init+0x78>
    return -1; // unsupported mode

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_MIDI_DEFAULT_PORT;
 8014830:	4a1d      	ldr	r2, [pc, #116]	@ (80148a8 <MIOS32_MIDI_Init+0x80>)
 8014832:	2310      	movs	r3, #16
 8014834:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_MIDI_DEBUG_PORT;
 8014836:	4a1d      	ldr	r2, [pc, #116]	@ (80148ac <MIOS32_MIDI_Init+0x84>)
 8014838:	7013      	strb	r3, [r2, #0]

  // disable callback functions
  direct_rx_callback_func = NULL;
 801483a:	4b1d      	ldr	r3, [pc, #116]	@ (80148b0 <MIOS32_MIDI_Init+0x88>)
 801483c:	6018      	str	r0, [r3, #0]
  direct_tx_callback_func = NULL;
 801483e:	4b1d      	ldr	r3, [pc, #116]	@ (80148b4 <MIOS32_MIDI_Init+0x8c>)
 8014840:	6018      	str	r0, [r3, #0]
  sysex_callback_func = NULL;
 8014842:	4b1d      	ldr	r3, [pc, #116]	@ (80148b8 <MIOS32_MIDI_Init+0x90>)
 8014844:	6018      	str	r0, [r3, #0]
  timeout_callback_func = NULL;
 8014846:	4b1d      	ldr	r3, [pc, #116]	@ (80148bc <MIOS32_MIDI_Init+0x94>)
 8014848:	6018      	str	r0, [r3, #0]
  debug_command_callback_func = NULL;
 801484a:	4b1d      	ldr	r3, [pc, #116]	@ (80148c0 <MIOS32_MIDI_Init+0x98>)
 801484c:	6018      	str	r0, [r3, #0]
  filebrowser_command_callback_func = NULL;
 801484e:	4b1d      	ldr	r3, [pc, #116]	@ (80148c4 <MIOS32_MIDI_Init+0x9c>)
 8014850:	6018      	str	r0, [r3, #0]

  // initialize interfaces
#if !defined(MIOS32_DONT_USE_USB) && !defined(MIOS32_DONT_USE_USB_MIDI)
  if( MIOS32_USB_MIDI_Init(0) < 0 )
 8014852:	f003 fb81 	bl	8017f58 <MIOS32_USB_MIDI_Init>
 8014856:	0fc5      	lsrs	r5, r0, #31
    ret |= (1 << 0);
#endif

#if !defined(MIOS32_DONT_USE_UART) && !defined(MIOS32_DONT_USE_UART_MIDI)
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 8014858:	4620      	mov	r0, r4
 801485a:	f001 f87f 	bl	801595c <MIOS32_UART_MIDI_Init>
#if !defined(MIOS32_DONT_USE_SPI) && !defined(MIOS32_DONT_USE_SPI_MIDI)
  if( MIOS32_SPI_MIDI_Init(0) < 0 )
    ret |= (1 << 3);
#endif

  last_sysex_port = DEFAULT;
 801485e:	4a1a      	ldr	r2, [pc, #104]	@ (80148c8 <MIOS32_MIDI_Init+0xa0>)
 8014860:	2300      	movs	r3, #0
 8014862:	7013      	strb	r3, [r2, #0]
  sysex_state.ALL = 0;
 8014864:	4a19      	ldr	r2, [pc, #100]	@ (80148cc <MIOS32_MIDI_Init+0xa4>)
 8014866:	7013      	strb	r3, [r2, #0]

  sysex_device_id = 0x00;
 8014868:	4a19      	ldr	r2, [pc, #100]	@ (80148d0 <MIOS32_MIDI_Init+0xa8>)
 801486a:	7013      	strb	r3, [r2, #0]
#ifdef MIOS32_SYS_ADDR_BSL_INFO_BEGIN
  // read from bootloader info range
  u8 *device_id_confirm = (u8 *)MIOS32_SYS_ADDR_DEVICE_ID_CONFIRM;
  u8 *device_id = (u8 *)MIOS32_SYS_ADDR_DEVICE_ID;
  if( *device_id_confirm == 0x42 && *device_id < 0x80 )
 801486c:	4b19      	ldr	r3, [pc, #100]	@ (80148d4 <MIOS32_MIDI_Init+0xac>)
 801486e:	f893 10d0 	ldrb.w	r1, [r3, #208]	@ 0xd0
  if( MIOS32_UART_MIDI_Init(0) < 0 )
 8014872:	2800      	cmp	r0, #0
    ret |= (1 << 1);
 8014874:	bfb8      	it	lt
 8014876:	f045 0502 	orrlt.w	r5, r5, #2
  if( *device_id_confirm == 0x42 && *device_id < 0x80 )
 801487a:	2942      	cmp	r1, #66	@ 0x42
 801487c:	d106      	bne.n	801488c <MIOS32_MIDI_Init+0x64>
 801487e:	f893 10d1 	ldrb.w	r1, [r3, #209]	@ 0xd1
 8014882:	f993 30d1 	ldrsb.w	r3, [r3, #209]	@ 0xd1
 8014886:	2b00      	cmp	r3, #0
    sysex_device_id = *device_id;
 8014888:	bfa8      	it	ge
 801488a:	7011      	strbge	r1, [r2, #0]
#endif

  // SysEx timeout mechanism
  sysex_timeout_ctr = 0;
 801488c:	4b12      	ldr	r3, [pc, #72]	@ (80148d8 <MIOS32_MIDI_Init+0xb0>)
 801488e:	2200      	movs	r2, #0
 8014890:	801a      	strh	r2, [r3, #0]
  sysex_timeout_ctr_flags.ALL = 0;
 8014892:	4b12      	ldr	r3, [pc, #72]	@ (80148dc <MIOS32_MIDI_Init+0xb4>)
 8014894:	2000      	movs	r0, #0
 8014896:	2100      	movs	r1, #0
 8014898:	e9c3 0100 	strd	r0, r1, [r3]

  return -ret;
 801489c:	4268      	negs	r0, r5
}
 801489e:	bd38      	pop	{r3, r4, r5, pc}
    return -1; // unsupported mode
 80148a0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80148a4:	e7fb      	b.n	801489e <MIOS32_MIDI_Init+0x76>
 80148a6:	bf00      	nop
 80148a8:	20000006 	.word	0x20000006
 80148ac:	20000005 	.word	0x20000005
 80148b0:	20003184 	.word	0x20003184
 80148b4:	20003180 	.word	0x20003180
 80148b8:	2000317c 	.word	0x2000317c
 80148bc:	20003178 	.word	0x20003178
 80148c0:	20003174 	.word	0x20003174
 80148c4:	20003170 	.word	0x20003170
 80148c8:	20003162 	.word	0x20003162
 80148cc:	20003168 	.word	0x20003168
 80148d0:	20003164 	.word	0x20003164
 80148d4:	08003f00 	.word	0x08003f00
 80148d8:	20003160 	.word	0x20003160
 80148dc:	20003158 	.word	0x20003158

080148e0 <MIOS32_MIDI_CheckAvailable>:
//! \return 0: port not available
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_CheckAvailable(mios32_midi_port_t port)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 80148e0:	280f      	cmp	r0, #15
 80148e2:	d804      	bhi.n	80148ee <MIOS32_MIDI_CheckAvailable+0xe>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 80148e4:	2801      	cmp	r0, #1
 80148e6:	bf0c      	ite	eq
 80148e8:	4b09      	ldreq	r3, [pc, #36]	@ (8014910 <MIOS32_MIDI_CheckAvailable+0x30>)
 80148ea:	4b0a      	ldrne	r3, [pc, #40]	@ (8014914 <MIOS32_MIDI_CheckAvailable+0x34>)
 80148ec:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 80148ee:	f000 03f0 	and.w	r3, r0, #240	@ 0xf0
 80148f2:	2b10      	cmp	r3, #16
 80148f4:	d003      	beq.n	80148fe <MIOS32_MIDI_CheckAvailable+0x1e>
 80148f6:	2b20      	cmp	r3, #32
 80148f8:	d005      	beq.n	8014906 <MIOS32_MIDI_CheckAvailable+0x26>
      return 0; // IIC_MIDI has been disabled
#endif
  }

  return 0; // invalid port
}
 80148fa:	2000      	movs	r0, #0
 80148fc:	4770      	bx	lr
      return MIOS32_USB_MIDI_CheckAvailable(port & 0xf);
 80148fe:	f000 000f 	and.w	r0, r0, #15
 8014902:	f003 bb61 	b.w	8017fc8 <MIOS32_USB_MIDI_CheckAvailable>
      return MIOS32_UART_MIDI_CheckAvailable(port & 0xf);
 8014906:	f000 000f 	and.w	r0, r0, #15
 801490a:	f001 b807 	b.w	801591c <MIOS32_UART_MIDI_CheckAvailable>
 801490e:	bf00      	nop
 8014910:	20000005 	.word	0x20000005
 8014914:	20000006 	.word	0x20000006

08014918 <MIOS32_MIDI_SendPackage>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendPackage(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 8014918:	280f      	cmp	r0, #15
{
 801491a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801491c:	4604      	mov	r4, r0
 801491e:	460d      	mov	r5, r1
  if( !(port & 0xf0) ) {
 8014920:	d804      	bhi.n	801492c <MIOS32_MIDI_SendPackage+0x14>
    port = (port == MIDI_DEBUG) ? debug_port : default_port;
 8014922:	2801      	cmp	r0, #1
 8014924:	bf0c      	ite	eq
 8014926:	4b14      	ldreq	r3, [pc, #80]	@ (8014978 <MIOS32_MIDI_SendPackage+0x60>)
 8014928:	4b14      	ldrne	r3, [pc, #80]	@ (801497c <MIOS32_MIDI_SendPackage+0x64>)
 801492a:	781c      	ldrb	r4, [r3, #0]

  // insert subport number into package
  package.cable = port & 0xf;

  // forward to Tx callback function and break if package has been filtered
  if( direct_tx_callback_func != NULL ) {
 801492c:	4b14      	ldr	r3, [pc, #80]	@ (8014980 <MIOS32_MIDI_SendPackage+0x68>)
 801492e:	681b      	ldr	r3, [r3, #0]
  package.cable = port & 0xf;
 8014930:	f004 070f 	and.w	r7, r4, #15
 8014934:	463e      	mov	r6, r7
  if( direct_tx_callback_func != NULL ) {
 8014936:	b943      	cbnz	r3, 801494a <MIOS32_MIDI_SendPackage+0x32>
    if( (status=direct_tx_callback_func(port, package)) )
      return status;
  }

  // branch depending on selected port
  switch( port & 0xf0 ) {
 8014938:	f004 04f0 	and.w	r4, r4, #240	@ 0xf0
 801493c:	2c10      	cmp	r4, #16
 801493e:	d00c      	beq.n	801495a <MIOS32_MIDI_SendPackage+0x42>
 8014940:	2c20      	cmp	r4, #32
 8014942:	d011      	beq.n	8014968 <MIOS32_MIDI_SendPackage+0x50>
 8014944:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
      
    default:
      // invalid port
      return -1;
  }
}
 8014948:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( (status=direct_tx_callback_func(port, package)) )
 801494a:	f367 1507 	bfi	r5, r7, #4, #4
 801494e:	4629      	mov	r1, r5
 8014950:	4620      	mov	r0, r4
 8014952:	4798      	blx	r3
 8014954:	2800      	cmp	r0, #0
 8014956:	d0ef      	beq.n	8014938 <MIOS32_MIDI_SendPackage+0x20>
 8014958:	e7f6      	b.n	8014948 <MIOS32_MIDI_SendPackage+0x30>
      return MIOS32_USB_MIDI_PackageSend(package);
 801495a:	f366 1507 	bfi	r5, r6, #4, #4
 801495e:	4628      	mov	r0, r5
}
 8014960:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      return MIOS32_USB_MIDI_PackageSend(package);
 8014964:	f003 bc0a 	b.w	801817c <MIOS32_USB_MIDI_PackageSend>
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 8014968:	f366 1507 	bfi	r5, r6, #4, #4
 801496c:	4629      	mov	r1, r5
 801496e:	4638      	mov	r0, r7
}
 8014970:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      return MIOS32_UART_MIDI_PackageSend(package.cable, package);
 8014974:	f001 b8a2 	b.w	8015abc <MIOS32_UART_MIDI_PackageSend>
 8014978:	20000005 	.word	0x20000005
 801497c:	20000006 	.word	0x20000006
 8014980:	20003180 	.word	0x20003180

08014984 <MIOS32_MIDI_SendEvent>:
//! \param[in] evnt2 third MIDI byte
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendEvent(mios32_midi_port_t port, u8 evnt0, u8 evnt1, u8 evnt2)
{
 8014984:	b430      	push	{r4, r5}
 8014986:	460c      	mov	r4, r1

  // MEMO: don't optimize this function by calling MIOS32_MIDI_SendSpecialEvent
  // from here, because the 4 * u8 parameter list of this function leads
  // to best compile results (4*u8 combined to a single u32)

  package.type  = evnt0 >> 4;
 8014988:	090d      	lsrs	r5, r1, #4
 801498a:	2100      	movs	r1, #0
 801498c:	f365 0103 	bfi	r1, r5, #0, #4
  package.evnt0 = evnt0;
 8014990:	f364 210f 	bfi	r1, r4, #8, #8
  package.evnt1 = evnt1;
 8014994:	f362 4117 	bfi	r1, r2, #16, #8
  package.evnt2 = evnt2;
  return MIOS32_MIDI_SendPackage(port, package);
}
 8014998:	bc30      	pop	{r4, r5}
  package.evnt2 = evnt2;
 801499a:	f363 611f 	bfi	r1, r3, #24, #8
  return MIOS32_MIDI_SendPackage(port, package);
 801499e:	f7ff bfbb 	b.w	8014918 <MIOS32_MIDI_SendPackage>

080149a2 <MIOS32_MIDI_SendNoteOff>:

s32 MIOS32_MIDI_SendNoteOff(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x80 | chn, note, vel); }
 80149a2:	f041 0180 	orr.w	r1, r1, #128	@ 0x80
 80149a6:	f7ff bfed 	b.w	8014984 <MIOS32_MIDI_SendEvent>

080149aa <MIOS32_MIDI_SendNoteOn>:

s32 MIOS32_MIDI_SendNoteOn(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 vel)
{ return MIOS32_MIDI_SendEvent(port, 0x90 | chn, note, vel); }
 80149aa:	f041 0190 	orr.w	r1, r1, #144	@ 0x90
 80149ae:	f7ff bfe9 	b.w	8014984 <MIOS32_MIDI_SendEvent>

080149b2 <MIOS32_MIDI_SendCC>:

s32 MIOS32_MIDI_SendPolyPressure(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 note, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xa0 | chn, note, val); }

s32 MIOS32_MIDI_SendCC(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 cc_number, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xb0 | chn, cc_number,   val); }
 80149b2:	f041 01b0 	orr.w	r1, r1, #176	@ 0xb0
 80149b6:	f7ff bfe5 	b.w	8014984 <MIOS32_MIDI_SendEvent>

080149ba <MIOS32_MIDI_SendAftertouch>:

s32 MIOS32_MIDI_SendProgramChange(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 prg)
{ return MIOS32_MIDI_SendEvent(port, 0xc0 | chn, prg,  0x00); }

s32 MIOS32_MIDI_SendAftertouch(mios32_midi_port_t port, mios32_midi_chn_t chn, u8 val)
{ return MIOS32_MIDI_SendEvent(port, 0xd0 | chn, val,  0x00); }
 80149ba:	2300      	movs	r3, #0
 80149bc:	f041 01d0 	orr.w	r1, r1, #208	@ 0xd0
 80149c0:	f7ff bfe0 	b.w	8014984 <MIOS32_MIDI_SendEvent>

080149c4 <MIOS32_MIDI_SendPitchBend>:

s32 MIOS32_MIDI_SendPitchBend(mios32_midi_port_t port, mios32_midi_chn_t chn, u16 val)
{ return MIOS32_MIDI_SendEvent(port, 0xe0 | chn, val & 0x7f, val >> 7); }
 80149c4:	f3c2 13c7 	ubfx	r3, r2, #7, #8
 80149c8:	f041 01e0 	orr.w	r1, r1, #224	@ 0xe0
 80149cc:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 80149d0:	f7ff bfd8 	b.w	8014984 <MIOS32_MIDI_SendEvent>

080149d4 <MIOS32_MIDI_SendSysEx>:
//! \param[in] count number of bytes
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_MIDI_SendSysEx(mios32_midi_port_t port, u8 *stream, u32 count)
{
 80149d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80149d8:	4680      	mov	r8, r0
 80149da:	460e      	mov	r6, r1
 80149dc:	4617      	mov	r7, r2
  u32 offset;
  mios32_midi_package_t package;

  // MEMO: have a look into the project.lss file - gcc optimizes this code pretty well :)

  for(offset=0; offset<count;) {
 80149de:	2400      	movs	r4, #0
	package.evnt0 = stream[offset++];
	package.evnt1 = 0x00;
	package.evnt2 = 0x00;
	break;
      case 2:
	package.type = 0x6; // SysEx ends with following two bytes.
 80149e0:	f04f 0906 	mov.w	r9, #6
	package.evnt0 = stream[offset++];
	package.evnt1 = stream[offset++];
	package.evnt2 = 0x00;
	break;
      case 3:
	package.type = 0x7; // SysEx ends with following three bytes. 
 80149e4:	f04f 0a07 	mov.w	sl, #7
  for(offset=0; offset<count;) {
 80149e8:	42bc      	cmp	r4, r7
 80149ea:	d301      	bcc.n	80149f0 <MIOS32_MIDI_SendSysEx+0x1c>
    // expection? (e.g., port not available)
    if( res < 0 )
      return res;
  }

  return 0;
 80149ec:	2000      	movs	r0, #0
 80149ee:	e01a      	b.n	8014a26 <MIOS32_MIDI_SendSysEx+0x52>
    switch( count-offset ) {
 80149f0:	1b39      	subs	r1, r7, r4
 80149f2:	2902      	cmp	r1, #2
	package.evnt0 = stream[offset++];
 80149f4:	5d32      	ldrb	r2, [r6, r4]
 80149f6:	f104 0301 	add.w	r3, r4, #1
    switch( count-offset ) {
 80149fa:	d016      	beq.n	8014a2a <MIOS32_MIDI_SendSysEx+0x56>
 80149fc:	2903      	cmp	r1, #3
 80149fe:	d01d      	beq.n	8014a3c <MIOS32_MIDI_SendSysEx+0x68>
 8014a00:	2901      	cmp	r1, #1
 8014a02:	d126      	bne.n	8014a52 <MIOS32_MIDI_SendSysEx+0x7e>
	package.type = 0x5; // SysEx ends with following single byte. 
 8014a04:	2105      	movs	r1, #5
 8014a06:	f361 0503 	bfi	r5, r1, #0, #4
	package.evnt0 = stream[offset++];
 8014a0a:	f362 250f 	bfi	r5, r2, #8, #8
	package.evnt1 = 0x00;
 8014a0e:	f36f 4517 	bfc	r5, #16, #8
	package.evnt0 = stream[offset++];
 8014a12:	461c      	mov	r4, r3
	break;
 8014a14:	2300      	movs	r3, #0
	package.evnt2 = 0x00;
 8014a16:	f363 651f 	bfi	r5, r3, #24, #8
    res=MIOS32_MIDI_SendPackage(port, package);
 8014a1a:	4629      	mov	r1, r5
 8014a1c:	4640      	mov	r0, r8
 8014a1e:	f7ff ff7b 	bl	8014918 <MIOS32_MIDI_SendPackage>
    if( res < 0 )
 8014a22:	2800      	cmp	r0, #0
 8014a24:	dae0      	bge.n	80149e8 <MIOS32_MIDI_SendSysEx+0x14>
}
 8014a26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	package.evnt1 = stream[offset++];
 8014a2a:	5cf3      	ldrb	r3, [r6, r3]
	package.type = 0x6; // SysEx ends with following two bytes.
 8014a2c:	f369 0503 	bfi	r5, r9, #0, #4
	package.evnt0 = stream[offset++];
 8014a30:	f362 250f 	bfi	r5, r2, #8, #8
	package.evnt1 = stream[offset++];
 8014a34:	3402      	adds	r4, #2
 8014a36:	f363 4517 	bfi	r5, r3, #16, #8
 8014a3a:	e7eb      	b.n	8014a14 <MIOS32_MIDI_SendSysEx+0x40>
	package.type = 0x7; // SysEx ends with following three bytes. 
 8014a3c:	f36a 0503 	bfi	r5, sl, #0, #4
	package.evnt1 = stream[offset++];
 8014a40:	5cf3      	ldrb	r3, [r6, r3]
	package.evnt0 = stream[offset++];
 8014a42:	f362 250f 	bfi	r5, r2, #8, #8
	package.evnt1 = stream[offset++];
 8014a46:	1ca2      	adds	r2, r4, #2
 8014a48:	f363 4517 	bfi	r5, r3, #16, #8
	package.evnt2 = stream[offset++];
 8014a4c:	3403      	adds	r4, #3
 8014a4e:	5cb3      	ldrb	r3, [r6, r2]
 8014a50:	e7e1      	b.n	8014a16 <MIOS32_MIDI_SendSysEx+0x42>
	package.type = 0x4; // SysEx starts or continues
 8014a52:	2104      	movs	r1, #4
 8014a54:	f361 0503 	bfi	r5, r1, #0, #4
 8014a58:	e7f2      	b.n	8014a40 <MIOS32_MIDI_SendSysEx+0x6c>
	...

08014a5c <MIOS32_MIDI_SYSEX_SendAckStr.isra.0>:
}

/////////////////////////////////////////////////////////////////////////////
// This function sends an SysEx acknowledge with a string (used on queries)
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_SYSEX_SendAckStr(mios32_midi_port_t port, char *str)
 8014a5c:	b530      	push	{r4, r5, lr}
 8014a5e:	b0a1      	sub	sp, #132	@ 0x84
  u8 sysex_buffer[128]; // should be enough?
  u8 *sysex_buffer_ptr = &sysex_buffer[0];
  int i;

  for(i=0; i<sizeof(mios32_midi_sysex_header); ++i)
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8014a60:	4b11      	ldr	r3, [pc, #68]	@ (8014aa8 <MIOS32_MIDI_SYSEX_SendAckStr.isra.0+0x4c>)
 8014a62:	9300      	str	r3, [sp, #0]
 8014a64:	2332      	movs	r3, #50	@ 0x32
 8014a66:	f88d 3004 	strb.w	r3, [sp, #4]
  return sysex_device_id;
 8014a6a:	4b10      	ldr	r3, [pc, #64]	@ (8014aac <MIOS32_MIDI_SYSEX_SendAckStr.isra.0+0x50>)

  // device ID
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8014a6c:	781b      	ldrb	r3, [r3, #0]
 8014a6e:	f88d 3005 	strb.w	r3, [sp, #5]

  // send ack code
  *sysex_buffer_ptr++ = MIOS32_MIDI_SYSEX_ACK;
 8014a72:	230f      	movs	r3, #15
 8014a74:	f88d 3006 	strb.w	r3, [sp, #6]
 8014a78:	f10d 0207 	add.w	r2, sp, #7
 8014a7c:	1e4b      	subs	r3, r1, #1
 8014a7e:	3163      	adds	r1, #99	@ 0x63

  // send string
  for(i=0; i<100 && (str[i] != 0); ++i)
 8014a80:	f813 4f01 	ldrb.w	r4, [r3, #1]!
 8014a84:	4615      	mov	r5, r2
    *sysex_buffer_ptr++ = str[i];
 8014a86:	3201      	adds	r2, #1
  for(i=0; i<100 && (str[i] != 0); ++i)
 8014a88:	b90c      	cbnz	r4, 8014a8e <MIOS32_MIDI_SYSEX_SendAckStr.isra.0+0x32>
 8014a8a:	462a      	mov	r2, r5
 8014a8c:	e003      	b.n	8014a96 <MIOS32_MIDI_SYSEX_SendAckStr.isra.0+0x3a>
 8014a8e:	428b      	cmp	r3, r1
    *sysex_buffer_ptr++ = str[i];
 8014a90:	f802 4c01 	strb.w	r4, [r2, #-1]
  for(i=0; i<100 && (str[i] != 0); ++i)
 8014a94:	d1f4      	bne.n	8014a80 <MIOS32_MIDI_SYSEX_SendAckStr.isra.0+0x24>

  // send footer
  *sysex_buffer_ptr++ = 0xf7;
 8014a96:	23f7      	movs	r3, #247	@ 0xf7
 8014a98:	f802 3b01 	strb.w	r3, [r2], #1

  // finally send SysEx stream
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8014a9c:	4669      	mov	r1, sp
 8014a9e:	1a52      	subs	r2, r2, r1
 8014aa0:	f7ff ff98 	bl	80149d4 <MIOS32_MIDI_SendSysEx>
}
 8014aa4:	b021      	add	sp, #132	@ 0x84
 8014aa6:	bd30      	pop	{r4, r5, pc}
 8014aa8:	7e0000f0 	.word	0x7e0000f0
 8014aac:	20003164 	.word	0x20003164

08014ab0 <MIOS32_MIDI_SYSEX_SendAck.isra.0>:
static s32 MIOS32_MIDI_SYSEX_SendAck(mios32_midi_port_t port, u8 ack_code, u8 ack_arg)
 8014ab0:	b500      	push	{lr}
 8014ab2:	b089      	sub	sp, #36	@ 0x24
    *sysex_buffer_ptr++ = mios32_midi_sysex_header[i];
 8014ab4:	4b0b      	ldr	r3, [pc, #44]	@ (8014ae4 <MIOS32_MIDI_SYSEX_SendAck.isra.0+0x34>)
 8014ab6:	9300      	str	r3, [sp, #0]
 8014ab8:	2332      	movs	r3, #50	@ 0x32
 8014aba:	f88d 3004 	strb.w	r3, [sp, #4]
  return sysex_device_id;
 8014abe:	4b0a      	ldr	r3, [pc, #40]	@ (8014ae8 <MIOS32_MIDI_SYSEX_SendAck.isra.0+0x38>)
  *sysex_buffer_ptr++ = ack_code;
 8014ac0:	f88d 1006 	strb.w	r1, [sp, #6]
  *sysex_buffer_ptr++ = MIOS32_MIDI_DeviceIDGet();
 8014ac4:	781b      	ldrb	r3, [r3, #0]
 8014ac6:	f88d 3005 	strb.w	r3, [sp, #5]
  *sysex_buffer_ptr++ = ack_arg;
 8014aca:	f88d 2007 	strb.w	r2, [sp, #7]
  *sysex_buffer_ptr++ = 0xf7;
 8014ace:	23f7      	movs	r3, #247	@ 0xf7
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8014ad0:	2209      	movs	r2, #9
 8014ad2:	4669      	mov	r1, sp
  *sysex_buffer_ptr++ = 0xf7;
 8014ad4:	f88d 3008 	strb.w	r3, [sp, #8]
  return MIOS32_MIDI_SendSysEx(port, (u8 *)sysex_buffer, (u32)sysex_buffer_ptr - ((u32)&sysex_buffer[0]));
 8014ad8:	f7ff ff7c 	bl	80149d4 <MIOS32_MIDI_SendSysEx>
}
 8014adc:	b009      	add	sp, #36	@ 0x24
 8014ade:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ae2:	bf00      	nop
 8014ae4:	7e0000f0 	.word	0x7e0000f0
 8014ae8:	20003164 	.word	0x20003164

08014aec <MIOS32_MIDI_SendDebugStringHeader>:
{
 8014aec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  package.type = 0x4; // SysEx starts or continues
 8014af0:	f24f 0404 	movw	r4, #61444	@ 0xf004
{
 8014af4:	4688      	mov	r8, r1
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014af6:	4621      	mov	r1, r4
{
 8014af8:	4617      	mov	r7, r2
 8014afa:	4606      	mov	r6, r0
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014afc:	f7ff ff0c 	bl	8014918 <MIOS32_MIDI_SendPackage>
  package.evnt0 = mios32_midi_sysex_header[3];
 8014b00:	237e      	movs	r3, #126	@ 0x7e
 8014b02:	f363 240f 	bfi	r4, r3, #8, #8
  package.evnt1 = mios32_midi_sysex_header[4];
 8014b06:	2332      	movs	r3, #50	@ 0x32
 8014b08:	f363 4417 	bfi	r4, r3, #16, #8
  return sysex_device_id;
 8014b0c:	4b0b      	ldr	r3, [pc, #44]	@ (8014b3c <MIOS32_MIDI_SendDebugStringHeader+0x50>)
  package.evnt2 = MIOS32_MIDI_DeviceIDGet();
 8014b0e:	781b      	ldrb	r3, [r3, #0]
 8014b10:	f363 641f 	bfi	r4, r3, #24, #8
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014b14:	4621      	mov	r1, r4
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014b16:	4605      	mov	r5, r0
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014b18:	4630      	mov	r0, r6
 8014b1a:	f7ff fefd 	bl	8014918 <MIOS32_MIDI_SendPackage>
  package.evnt0 = MIOS32_MIDI_SYSEX_DEBUG;
 8014b1e:	230d      	movs	r3, #13
 8014b20:	f363 240f 	bfi	r4, r3, #8, #8
  package.evnt1 = command; // output string, usually 0x40
 8014b24:	f368 4417 	bfi	r4, r8, #16, #8
  package.evnt2 = first_byte; // will be 0x00 if string already ends (""), thats ok, MIOS Studio can handle this
 8014b28:	f367 641f 	bfi	r4, r7, #24, #8
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014b2c:	4305      	orrs	r5, r0
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014b2e:	4621      	mov	r1, r4
 8014b30:	4630      	mov	r0, r6
 8014b32:	f7ff fef1 	bl	8014918 <MIOS32_MIDI_SendPackage>
}
 8014b36:	4328      	orrs	r0, r5
 8014b38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8014b3c:	20003164 	.word	0x20003164

08014b40 <MIOS32_MIDI_SendDebugStringBody>:
{
 8014b40:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014b44:	4681      	mov	r9, r0
 8014b46:	4688      	mov	r8, r1
  if( len > 0 ) {
 8014b48:	4616      	mov	r6, r2
 8014b4a:	b35a      	cbz	r2, 8014ba4 <MIOS32_MIDI_SendDebugStringBody+0x64>
 8014b4c:	460c      	mov	r4, r1
  s32 status = 0;
 8014b4e:	2700      	movs	r7, #0
      package.type = 0x4; // SysEx starts or continues
 8014b50:	f04f 0a04 	mov.w	sl, #4
      if( (b=str[i+0]) ) {
 8014b54:	7823      	ldrb	r3, [r4, #0]
      package.type = 0x4; // SysEx starts or continues
 8014b56:	f36a 0503 	bfi	r5, sl, #0, #4
      if( (b=str[i+0]) ) {
 8014b5a:	b14b      	cbz	r3, 8014b70 <MIOS32_MIDI_SendDebugStringBody+0x30>
	package.evnt0 = b & 0x7f;
 8014b5c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8014b60:	f363 250f 	bfi	r5, r3, #8, #8
      if( !terminated && (b=str[i+1]) ) {
 8014b64:	7863      	ldrb	r3, [r4, #1]
 8014b66:	b933      	cbnz	r3, 8014b76 <MIOS32_MIDI_SendDebugStringBody+0x36>
	package.evnt1 = 0x00;
 8014b68:	f36f 4517 	bfc	r5, #16, #8
	package.evnt2 = 0x00;
 8014b6c:	2300      	movs	r3, #0
 8014b6e:	e009      	b.n	8014b84 <MIOS32_MIDI_SendDebugStringBody+0x44>
	package.evnt0 = 0x00;
 8014b70:	f363 250f 	bfi	r5, r3, #8, #8
      if( !terminated && (b=str[i+1]) ) {
 8014b74:	e7f8      	b.n	8014b68 <MIOS32_MIDI_SendDebugStringBody+0x28>
	package.evnt1 = b & 0x7f;
 8014b76:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8014b7a:	f363 4517 	bfi	r5, r3, #16, #8
	package.evnt2 = b & 0x7f;
 8014b7e:	78a3      	ldrb	r3, [r4, #2]
 8014b80:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8014b84:	f363 651f 	bfi	r5, r3, #24, #8
      status |= MIOS32_MIDI_SendPackage(port, package);
 8014b88:	4629      	mov	r1, r5
 8014b8a:	4648      	mov	r0, r9
 8014b8c:	f7ff fec4 	bl	8014918 <MIOS32_MIDI_SendPackage>
    for(i=0; i<len; i+=3) {
 8014b90:	3403      	adds	r4, #3
 8014b92:	eba4 0308 	sub.w	r3, r4, r8
 8014b96:	429e      	cmp	r6, r3
      status |= MIOS32_MIDI_SendPackage(port, package);
 8014b98:	ea47 0700 	orr.w	r7, r7, r0
    for(i=0; i<len; i+=3) {
 8014b9c:	d8da      	bhi.n	8014b54 <MIOS32_MIDI_SendDebugStringBody+0x14>
}
 8014b9e:	4638      	mov	r0, r7
 8014ba0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  s32 status = 0;
 8014ba4:	4617      	mov	r7, r2
  return status;
 8014ba6:	e7fa      	b.n	8014b9e <MIOS32_MIDI_SendDebugStringBody+0x5e>

08014ba8 <MIOS32_MIDI_SendDebugStringFooter>:
  status |= MIOS32_MIDI_SendPackage(port, package);
 8014ba8:	f24f 7105 	movw	r1, #63237	@ 0xf705
 8014bac:	f7ff beb4 	b.w	8014918 <MIOS32_MIDI_SendPackage>

08014bb0 <MIOS32_MIDI_SendDebugString>:
{
 8014bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8014bb2:	4605      	mov	r5, r0
  u32 len = strlen(str);
 8014bb4:	f00e fcaa 	bl	802350c <strlen>
  status |= MIOS32_MIDI_SendDebugStringHeader(debug_port, 0x40, str[0]);
 8014bb8:	4f0a      	ldr	r7, [pc, #40]	@ (8014be4 <MIOS32_MIDI_SendDebugString+0x34>)
 8014bba:	782a      	ldrb	r2, [r5, #0]
  u32 len = strlen(str);
 8014bbc:	4606      	mov	r6, r0
  status |= MIOS32_MIDI_SendDebugStringHeader(debug_port, 0x40, str[0]);
 8014bbe:	2140      	movs	r1, #64	@ 0x40
 8014bc0:	7838      	ldrb	r0, [r7, #0]
 8014bc2:	f7ff ff93 	bl	8014aec <MIOS32_MIDI_SendDebugStringHeader>
  if( len >= 2 )
 8014bc6:	2e01      	cmp	r6, #1
  status |= MIOS32_MIDI_SendDebugStringHeader(debug_port, 0x40, str[0]);
 8014bc8:	4604      	mov	r4, r0
  if( len >= 2 )
 8014bca:	d905      	bls.n	8014bd8 <MIOS32_MIDI_SendDebugString+0x28>
    status |= MIOS32_MIDI_SendDebugStringBody(debug_port, (char *)&str[1], len-1);
 8014bcc:	7838      	ldrb	r0, [r7, #0]
 8014bce:	1e72      	subs	r2, r6, #1
 8014bd0:	1c69      	adds	r1, r5, #1
 8014bd2:	f7ff ffb5 	bl	8014b40 <MIOS32_MIDI_SendDebugStringBody>
 8014bd6:	4304      	orrs	r4, r0
  status |= MIOS32_MIDI_SendDebugStringFooter(debug_port);
 8014bd8:	7838      	ldrb	r0, [r7, #0]
 8014bda:	f7ff ffe5 	bl	8014ba8 <MIOS32_MIDI_SendDebugStringFooter>
}
 8014bde:	4320      	orrs	r0, r4
 8014be0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014be2:	bf00      	nop
 8014be4:	20000005 	.word	0x20000005

08014be8 <MIOS32_MIDI_SendDebugMessage>:
{
 8014be8:	b40f      	push	{r0, r1, r2, r3}
 8014bea:	b510      	push	{r4, lr}
 8014bec:	b0a2      	sub	sp, #136	@ 0x88
 8014bee:	9c24      	ldr	r4, [sp, #144]	@ 0x90
  if( strlen(format) > 100 ) {
 8014bf0:	4620      	mov	r0, r4
 8014bf2:	f00e fc8b 	bl	802350c <strlen>
 8014bf6:	2864      	cmp	r0, #100	@ 0x64
 8014bf8:	d907      	bls.n	8014c0a <MIOS32_MIDI_SendDebugMessage+0x22>
    return MIOS32_MIDI_SendDebugString("(ERROR: string passed to MIOS32_MIDI_SendDebugMessage() is longer than 100 chars!\n");
 8014bfa:	480f      	ldr	r0, [pc, #60]	@ (8014c38 <MIOS32_MIDI_SendDebugMessage+0x50>)
  return MIOS32_MIDI_SendDebugString(str);
 8014bfc:	f7ff ffd8 	bl	8014bb0 <MIOS32_MIDI_SendDebugString>
}
 8014c00:	b022      	add	sp, #136	@ 0x88
 8014c02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8014c06:	b004      	add	sp, #16
 8014c08:	4770      	bx	lr
    va_start(args, format);
 8014c0a:	aa25      	add	r2, sp, #148	@ 0x94
    vsprintf(str, format, args);
 8014c0c:	4621      	mov	r1, r4
 8014c0e:	a802      	add	r0, sp, #8
    va_start(args, format);
 8014c10:	9201      	str	r2, [sp, #4]
    vsprintf(str, format, args);
 8014c12:	f004 f8e6 	bl	8018de2 <vsprintf>
  u32 len = strlen(str);
 8014c16:	a802      	add	r0, sp, #8
 8014c18:	f00e fc78 	bl	802350c <strlen>
  for(i=0; i<len; ++i) {
 8014c1c:	2300      	movs	r3, #0
  u8 *str_ptr = (u8 *)str;
 8014c1e:	aa02      	add	r2, sp, #8
  for(i=0; i<len; ++i) {
 8014c20:	4283      	cmp	r3, r0
 8014c22:	d101      	bne.n	8014c28 <MIOS32_MIDI_SendDebugMessage+0x40>
  return MIOS32_MIDI_SendDebugString(str);
 8014c24:	a802      	add	r0, sp, #8
 8014c26:	e7e9      	b.n	8014bfc <MIOS32_MIDI_SendDebugMessage+0x14>
    *str_ptr++ &= 0x7f; // ensure that MIDI protocol won't be violated
 8014c28:	f812 1b01 	ldrb.w	r1, [r2], #1
 8014c2c:	f001 017f 	and.w	r1, r1, #127	@ 0x7f
 8014c30:	f802 1c01 	strb.w	r1, [r2, #-1]
  for(i=0; i<len; ++i) {
 8014c34:	3301      	adds	r3, #1
 8014c36:	e7f3      	b.n	8014c20 <MIOS32_MIDI_SendDebugMessage+0x38>
 8014c38:	08026c88 	.word	0x08026c88

08014c3c <MIOS32_MIDI_TimeOut.isra.0>:
// This function is called if a MIDI parser runs into timeout
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
{
  // if MIOS32 receives a SysEx command (MY_SYSEX flag set), abort parser if port matches
  if( sysex_state.general.MY_SYSEX && port == last_sysex_port )
 8014c3c:	4a0c      	ldr	r2, [pc, #48]	@ (8014c70 <MIOS32_MIDI_TimeOut.isra.0+0x34>)
 8014c3e:	7813      	ldrb	r3, [r2, #0]
 8014c40:	071b      	lsls	r3, r3, #28
static s32 MIOS32_MIDI_TimeOut(mios32_midi_port_t port)
 8014c42:	b510      	push	{r4, lr}
 8014c44:	4604      	mov	r4, r0
  if( sysex_state.general.MY_SYSEX && port == last_sysex_port )
 8014c46:	d507      	bpl.n	8014c58 <MIOS32_MIDI_TimeOut.isra.0+0x1c>
 8014c48:	4b0a      	ldr	r3, [pc, #40]	@ (8014c74 <MIOS32_MIDI_TimeOut.isra.0+0x38>)
 8014c4a:	781b      	ldrb	r3, [r3, #0]
 8014c4c:	4283      	cmp	r3, r0
  sysex_state.ALL = 0;
 8014c4e:	bf01      	itttt	eq
 8014c50:	2300      	moveq	r3, #0
 8014c52:	7013      	strbeq	r3, [r2, #0]
  sysex_cmd = 0;
 8014c54:	4a08      	ldreq	r2, [pc, #32]	@ (8014c78 <MIOS32_MIDI_TimeOut.isra.0+0x3c>)
 8014c56:	7013      	strbeq	r3, [r2, #0]
    MIOS32_MIDI_SYSEX_CmdFinished();

  // optional hook to application
  if( timeout_callback_func != NULL )
 8014c58:	4b08      	ldr	r3, [pc, #32]	@ (8014c7c <MIOS32_MIDI_TimeOut.isra.0+0x40>)
 8014c5a:	681b      	ldr	r3, [r3, #0]
 8014c5c:	b10b      	cbz	r3, 8014c62 <MIOS32_MIDI_TimeOut.isra.0+0x26>
    timeout_callback_func(port);
 8014c5e:	4620      	mov	r0, r4
 8014c60:	4798      	blx	r3

#ifndef MIOS32_MIDI_DISABLE_DEBUG_MESSAGE
  // this debug message should always be active, so that common users are informed about the exception
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8014c62:	4621      	mov	r1, r4
 8014c64:	4806      	ldr	r0, [pc, #24]	@ (8014c80 <MIOS32_MIDI_TimeOut.isra.0+0x44>)
#endif

  return 0; // no error
}
 8014c66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  MIOS32_MIDI_SendDebugMessage("[MIOS32_MIDI_Receive_Handler] Timeout on port 0x%02x\n", port);
 8014c6a:	f7ff bfbd 	b.w	8014be8 <MIOS32_MIDI_SendDebugMessage>
 8014c6e:	bf00      	nop
 8014c70:	20003168 	.word	0x20003168
 8014c74:	20003162 	.word	0x20003162
 8014c78:	20003163 	.word	0x20003163
 8014c7c:	20003178 	.word	0x20003178
 8014c80:	08026cdb 	.word	0x08026cdb

08014c84 <MIOS32_MIDI_SendDebugHexDump>:
{
 8014c84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014c88:	4606      	mov	r6, r0
 8014c8a:	b095      	sub	sp, #84	@ 0x54
  if( !len )
 8014c8c:	2900      	cmp	r1, #0
 8014c8e:	d046      	beq.n	8014d1e <MIOS32_MIDI_SendDebugHexDump+0x9a>
  for(src_end=(u8 *)((size_t)src + len - 1); src < src_end;) {
 8014c90:	4401      	add	r1, r0
      sprintf((char *)str_ptr, (src <= src_end) ? " %02X" : "   ", *src);
 8014c92:	f8df 8090 	ldr.w	r8, [pc, #144]	@ 8014d24 <MIOS32_MIDI_SendDebugHexDump+0xa0>
  for(src_end=(u8 *)((size_t)src + len - 1); src < src_end;) {
 8014c96:	1e4f      	subs	r7, r1, #1
 8014c98:	4604      	mov	r4, r0
  s32 status = 0;
 8014c9a:	2500      	movs	r5, #0
  for(src_end=(u8 *)((size_t)src + len - 1); src < src_end;) {
 8014c9c:	42bc      	cmp	r4, r7
 8014c9e:	d303      	bcc.n	8014ca8 <MIOS32_MIDI_SendDebugHexDump+0x24>
}
 8014ca0:	4628      	mov	r0, r5
 8014ca2:	b015      	add	sp, #84	@ 0x54
 8014ca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    sprintf((char *)str_ptr, "%08X ", (u32)(src-src_begin));
 8014ca8:	491f      	ldr	r1, [pc, #124]	@ (8014d28 <MIOS32_MIDI_SendDebugHexDump+0xa4>)
      sprintf((char *)str_ptr, (src <= src_end) ? " %02X" : "   ", *src);
 8014caa:	f8df 9080 	ldr.w	r9, [pc, #128]	@ 8014d2c <MIOS32_MIDI_SendDebugHexDump+0xa8>
    sprintf((char *)str_ptr, "%08X ", (u32)(src-src_begin));
 8014cae:	1ba2      	subs	r2, r4, r6
 8014cb0:	4668      	mov	r0, sp
 8014cb2:	f004 f887 	bl	8018dc4 <sprintf>
    str_ptr += 9;
 8014cb6:	f10d 0a09 	add.w	sl, sp, #9
      sprintf((char *)str_ptr, (src <= src_end) ? " %02X" : "   ", *src);
 8014cba:	4641      	mov	r1, r8
    for(i=0; i<16; ++i) {
 8014cbc:	f104 0b10 	add.w	fp, r4, #16
      sprintf((char *)str_ptr, (src <= src_end) ? " %02X" : "   ", *src);
 8014cc0:	f814 2b01 	ldrb.w	r2, [r4], #1
 8014cc4:	4650      	mov	r0, sl
 8014cc6:	f004 f87d 	bl	8018dc4 <sprintf>
    for(i=0; i<16; ++i) {
 8014cca:	455c      	cmp	r4, fp
      str_ptr += 3;
 8014ccc:	f10a 0a03 	add.w	sl, sl, #3
    for(i=0; i<16; ++i) {
 8014cd0:	d120      	bne.n	8014d14 <MIOS32_MIDI_SendDebugHexDump+0x90>
      *str_ptr++ = ' ';
 8014cd2:	2320      	movs	r3, #32
 8014cd4:	f88d 3039 	strb.w	r3, [sp, #57]	@ 0x39
 8014cd8:	f88d 303a 	strb.w	r3, [sp, #58]	@ 0x3a
    for(i=0; i<16; ++i) {
 8014cdc:	f1a4 0211 	sub.w	r2, r4, #17
      *str_ptr++ = ' ';
 8014ce0:	f10d 033b 	add.w	r3, sp, #59	@ 0x3b
    for(i=0; i<16; ++i) {
 8014ce4:	1e60      	subs	r0, r4, #1
      if( *src_chars < 32 || *src_chars >= 128 )
 8014ce6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8014cea:	f1a1 0c20 	sub.w	ip, r1, #32
	*str_ptr++ = '.';
 8014cee:	f1bc 0f5f 	cmp.w	ip, #95	@ 0x5f
 8014cf2:	bf88      	it	hi
 8014cf4:	212e      	movhi	r1, #46	@ 0x2e
      if( src_chars == src_end )
 8014cf6:	42ba      	cmp	r2, r7
 8014cf8:	f803 1b01 	strb.w	r1, [r3], #1
 8014cfc:	d001      	beq.n	8014d02 <MIOS32_MIDI_SendDebugHexDump+0x7e>
    for(i=0; i<16; ++i) {
 8014cfe:	4282      	cmp	r2, r0
 8014d00:	d1f1      	bne.n	8014ce6 <MIOS32_MIDI_SendDebugHexDump+0x62>
    *str_ptr++ = '\n';
 8014d02:	220a      	movs	r2, #10
 8014d04:	701a      	strb	r2, [r3, #0]
    *str_ptr++ = 0;
 8014d06:	2200      	movs	r2, #0
 8014d08:	705a      	strb	r2, [r3, #1]
    status |= MIOS32_MIDI_SendDebugString(str);
 8014d0a:	4668      	mov	r0, sp
 8014d0c:	f7ff ff50 	bl	8014bb0 <MIOS32_MIDI_SendDebugString>
 8014d10:	4305      	orrs	r5, r0
 8014d12:	e7c3      	b.n	8014c9c <MIOS32_MIDI_SendDebugHexDump+0x18>
      sprintf((char *)str_ptr, (src <= src_end) ? " %02X" : "   ", *src);
 8014d14:	42a7      	cmp	r7, r4
 8014d16:	bf2c      	ite	cs
 8014d18:	4641      	movcs	r1, r8
 8014d1a:	4649      	movcc	r1, r9
 8014d1c:	e7d0      	b.n	8014cc0 <MIOS32_MIDI_SendDebugHexDump+0x3c>
    return 0;
 8014d1e:	460d      	mov	r5, r1
 8014d20:	e7be      	b.n	8014ca0 <MIOS32_MIDI_SendDebugHexDump+0x1c>
 8014d22:	bf00      	nop
 8014d24:	08026d11 	.word	0x08026d11
 8014d28:	08026d1b 	.word	0x08026d1b
 8014d2c:	08026d17 	.word	0x08026d17

08014d30 <MIOS32_MIDI_Periodic_mS>:
{
 8014d30:	b510      	push	{r4, lr}
  status |= MIOS32_USB_MIDI_Periodic_mS();
 8014d32:	f003 fa65 	bl	8018200 <MIOS32_USB_MIDI_Periodic_mS>
 8014d36:	4604      	mov	r4, r0
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8014d38:	f000 fe38 	bl	80159ac <MIOS32_UART_MIDI_Periodic_mS>
  if( sysex_timeout_ctr < 65535 )
 8014d3c:	4a05      	ldr	r2, [pc, #20]	@ (8014d54 <MIOS32_MIDI_Periodic_mS+0x24>)
 8014d3e:	8813      	ldrh	r3, [r2, #0]
 8014d40:	f64f 71ff 	movw	r1, #65535	@ 0xffff
 8014d44:	428b      	cmp	r3, r1
    ++sysex_timeout_ctr;
 8014d46:	bf18      	it	ne
 8014d48:	3301      	addne	r3, #1
  status |= MIOS32_UART_MIDI_Periodic_mS();
 8014d4a:	ea40 0004 	orr.w	r0, r0, r4
    ++sysex_timeout_ctr;
 8014d4e:	bf18      	it	ne
 8014d50:	8013      	strhne	r3, [r2, #0]
}
 8014d52:	bd10      	pop	{r4, pc}
 8014d54:	20003160 	.word	0x20003160

08014d58 <MIOS32_MIDI_DirectTxCallback_Init>:
  direct_tx_callback_func = callback_tx;
 8014d58:	4b01      	ldr	r3, [pc, #4]	@ (8014d60 <MIOS32_MIDI_DirectTxCallback_Init+0x8>)
 8014d5a:	6018      	str	r0, [r3, #0]
}
 8014d5c:	2000      	movs	r0, #0
 8014d5e:	4770      	bx	lr
 8014d60:	20003180 	.word	0x20003180

08014d64 <MIOS32_MIDI_DirectRxCallback_Init>:
  direct_rx_callback_func = callback_rx;
 8014d64:	4b01      	ldr	r3, [pc, #4]	@ (8014d6c <MIOS32_MIDI_DirectRxCallback_Init+0x8>)
 8014d66:	6018      	str	r0, [r3, #0]
}
 8014d68:	2000      	movs	r0, #0
 8014d6a:	4770      	bx	lr
 8014d6c:	20003184 	.word	0x20003184

08014d70 <MIOS32_MIDI_SendByteToRxCallback>:
  if( direct_rx_callback_func != NULL )
 8014d70:	4b02      	ldr	r3, [pc, #8]	@ (8014d7c <MIOS32_MIDI_SendByteToRxCallback+0xc>)
 8014d72:	681b      	ldr	r3, [r3, #0]
 8014d74:	b103      	cbz	r3, 8014d78 <MIOS32_MIDI_SendByteToRxCallback+0x8>
    return direct_rx_callback_func(port, midi_byte);
 8014d76:	4718      	bx	r3
}
 8014d78:	4618      	mov	r0, r3
 8014d7a:	4770      	bx	lr
 8014d7c:	20003184 	.word	0x20003184

08014d80 <MIOS32_MIDI_SendPackageToRxCallback>:
{
 8014d80:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if( direct_rx_callback_func != NULL ) {
 8014d84:	4f13      	ldr	r7, [pc, #76]	@ (8014dd4 <MIOS32_MIDI_SendPackageToRxCallback+0x54>)
 8014d86:	683c      	ldr	r4, [r7, #0]
{
 8014d88:	4606      	mov	r6, r0
  if( direct_rx_callback_func != NULL ) {
 8014d8a:	b1b4      	cbz	r4, 8014dba <MIOS32_MIDI_SendPackageToRxCallback+0x3a>
    u8 buffer[3] = {midi_package.evnt0, midi_package.evnt1, midi_package.evnt2};
 8014d8c:	f3c1 2307 	ubfx	r3, r1, #8, #8
 8014d90:	f88d 3004 	strb.w	r3, [sp, #4]
 8014d94:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8014d98:	f88d 3005 	strb.w	r3, [sp, #5]
 8014d9c:	f3c1 6307 	ubfx	r3, r1, #24, #8
 8014da0:	f88d 3006 	strb.w	r3, [sp, #6]
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8014da4:	f001 010f 	and.w	r1, r1, #15
 8014da8:	4b0b      	ldr	r3, [pc, #44]	@ (8014dd8 <MIOS32_MIDI_SendPackageToRxCallback+0x58>)
    s32 status = 0;
 8014daa:	2400      	movs	r4, #0
    int len = mios32_midi_pcktype_num_bytes[midi_package.cin];
 8014dac:	f813 8001 	ldrb.w	r8, [r3, r1]
    for(i=0; i<len; ++i)
 8014db0:	4625      	mov	r5, r4
      status |= direct_rx_callback_func(port, buffer[i]);
 8014db2:	f10d 0904 	add.w	r9, sp, #4
    for(i=0; i<len; ++i)
 8014db6:	4545      	cmp	r5, r8
 8014db8:	db03      	blt.n	8014dc2 <MIOS32_MIDI_SendPackageToRxCallback+0x42>
}
 8014dba:	4620      	mov	r0, r4
 8014dbc:	b003      	add	sp, #12
 8014dbe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      status |= direct_rx_callback_func(port, buffer[i]);
 8014dc2:	f819 1005 	ldrb.w	r1, [r9, r5]
 8014dc6:	683b      	ldr	r3, [r7, #0]
 8014dc8:	4630      	mov	r0, r6
 8014dca:	4798      	blx	r3
    for(i=0; i<len; ++i)
 8014dcc:	3501      	adds	r5, #1
      status |= direct_rx_callback_func(port, buffer[i]);
 8014dce:	4304      	orrs	r4, r0
    for(i=0; i<len; ++i)
 8014dd0:	e7f1      	b.n	8014db6 <MIOS32_MIDI_SendPackageToRxCallback+0x36>
 8014dd2:	bf00      	nop
 8014dd4:	20003184 	.word	0x20003184
 8014dd8:	08026daf 	.word	0x08026daf

08014ddc <MIOS32_MIDI_DebugPortSet>:
  if( port == MIDI_DEBUG ) // avoid recursion
 8014ddc:	2801      	cmp	r0, #1
  debug_port = port;
 8014dde:	bf1d      	ittte	ne
 8014de0:	4b02      	ldrne	r3, [pc, #8]	@ (8014dec <MIOS32_MIDI_DebugPortSet+0x10>)
 8014de2:	7018      	strbne	r0, [r3, #0]
  return 0; // no error
 8014de4:	2000      	movne	r0, #0
    return -1;
 8014de6:	f04f 30ff 	moveq.w	r0, #4294967295	@ 0xffffffff
}
 8014dea:	4770      	bx	lr
 8014dec:	20000005 	.word	0x20000005

08014df0 <MIOS32_MIDI_SYSEX_Cmd.isra.0>:
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
 8014df0:	b570      	push	{r4, r5, r6, lr}
  switch( sysex_cmd ) {
 8014df2:	4e59      	ldr	r6, [pc, #356]	@ (8014f58 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x168>)
 8014df4:	7835      	ldrb	r5, [r6, #0]
 8014df6:	2d0e      	cmp	r5, #14
static s32 MIOS32_MIDI_SYSEX_Cmd(mios32_midi_port_t port, mios32_midi_sysex_cmd_state_t cmd_state, u8 midi_in)
 8014df8:	460b      	mov	r3, r1
 8014dfa:	b08a      	sub	sp, #40	@ 0x28
 8014dfc:	4604      	mov	r4, r0
 8014dfe:	4611      	mov	r1, r2
  switch( sysex_cmd ) {
 8014e00:	d02c      	beq.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
 8014e02:	d80c      	bhi.n	8014e1e <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x2e>
 8014e04:	b1c5      	cbz	r5, 8014e38 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x48>
 8014e06:	2d0d      	cmp	r5, #13
 8014e08:	d066      	beq.n	8014ed8 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xe8>
      MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_INVALID_COMMAND);
 8014e0a:	220e      	movs	r2, #14
 8014e0c:	4611      	mov	r1, r2
 8014e0e:	4620      	mov	r0, r4
 8014e10:	f7ff fe4e 	bl	8014ab0 <MIOS32_MIDI_SYSEX_SendAck.isra.0>
  sysex_state.ALL = 0;
 8014e14:	4a51      	ldr	r2, [pc, #324]	@ (8014f5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x16c>)
 8014e16:	2300      	movs	r3, #0
 8014e18:	7013      	strb	r3, [r2, #0]
  sysex_cmd = 0;
 8014e1a:	7033      	strb	r3, [r6, #0]
  return 0; // no error
 8014e1c:	e01e      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
  switch( sysex_cmd ) {
 8014e1e:	2d0f      	cmp	r5, #15
 8014e20:	d1f3      	bne.n	8014e0a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x1a>
  switch( cmd_state ) {
 8014e22:	4a4e      	ldr	r2, [pc, #312]	@ (8014f5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x16c>)
 8014e24:	2b00      	cmp	r3, #0
 8014e26:	f000 8095 	beq.w	8014f54 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x164>
 8014e2a:	2b01      	cmp	r3, #1
 8014e2c:	f000 8092 	beq.w	8014f54 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x164>
      if( !sysex_state.ping.PING_BYTE_RECEIVED )
 8014e30:	6852      	ldr	r2, [r2, #4]
 8014e32:	b99a      	cbnz	r2, 8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8014e34:	4629      	mov	r1, r5
 8014e36:	e01a      	b.n	8014e6e <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x7e>
  switch( cmd_state ) {
 8014e38:	4a49      	ldr	r2, [pc, #292]	@ (8014f60 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x170>)
 8014e3a:	b173      	cbz	r3, 8014e5a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6a>
 8014e3c:	2b01      	cmp	r3, #1
 8014e3e:	d00f      	beq.n	8014e60 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x70>
      switch( query_req ) {
 8014e40:	7813      	ldrb	r3, [r2, #0]
 8014e42:	2b09      	cmp	r3, #9
 8014e44:	d80e      	bhi.n	8014e64 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x74>
 8014e46:	b17b      	cbz	r3, 8014e68 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x78>
 8014e48:	3b02      	subs	r3, #2
 8014e4a:	2b07      	cmp	r3, #7
 8014e4c:	d814      	bhi.n	8014e78 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x88>
 8014e4e:	e8df f003 	tbb	[pc, r3]
 8014e52:	1c1a      	.short	0x1c1a
 8014e54:	3732261e 	.word	0x3732261e
 8014e58:	3c3a      	.short	0x3c3a
      query_req = 0;
 8014e5a:	7013      	strb	r3, [r2, #0]
}
 8014e5c:	b00a      	add	sp, #40	@ 0x28
 8014e5e:	bd70      	pop	{r4, r5, r6, pc}
      query_req = midi_in;
 8014e60:	7011      	strb	r1, [r2, #0]
      break;
 8014e62:	e7fb      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
 8014e64:	2b7f      	cmp	r3, #127	@ 0x7f
 8014e66:	d032      	beq.n	8014ece <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xde>
	  MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNKNOWN_QUERY);
 8014e68:	220d      	movs	r2, #13
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 8014e6a:	210e      	movs	r1, #14
 8014e6c:	4620      	mov	r0, r4
}
 8014e6e:	b00a      	add	sp, #40	@ 0x28
 8014e70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8014e74:	f7ff be1c 	b.w	8014ab0 <MIOS32_MIDI_SYSEX_SendAck.isra.0>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, "MIOS32");
 8014e78:	493a      	ldr	r1, [pc, #232]	@ (8014f64 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x174>)
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 8014e7a:	4620      	mov	r0, r4
}
 8014e7c:	b00a      	add	sp, #40	@ 0x28
 8014e7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_BOARD_STR);
 8014e82:	f7ff bdeb 	b.w	8014a5c <MIOS32_MIDI_SYSEX_SendAckStr.isra.0>
 8014e86:	4938      	ldr	r1, [pc, #224]	@ (8014f68 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x178>)
 8014e88:	e7f7      	b.n	8014e7a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x8a>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_FAMILY_STR);
 8014e8a:	4938      	ldr	r1, [pc, #224]	@ (8014f6c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x17c>)
 8014e8c:	e7f5      	b.n	8014e7a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x8a>
	  sprintf(str_buffer, "%08x", MIOS32_SYS_ChipIDGet());
 8014e8e:	f001 fb2b 	bl	80164e8 <MIOS32_SYS_ChipIDGet>
 8014e92:	4937      	ldr	r1, [pc, #220]	@ (8014f70 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x180>)
 8014e94:	4602      	mov	r2, r0
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 8014e96:	4668      	mov	r0, sp
 8014e98:	f003 ff94 	bl	8018dc4 <sprintf>
 8014e9c:	e004      	b.n	8014ea8 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xb8>
	  if( MIOS32_SYS_SerialNumberGet((char *)str_buffer) >= 0 )
 8014e9e:	4668      	mov	r0, sp
 8014ea0:	f001 fb34 	bl	801650c <MIOS32_SYS_SerialNumberGet>
 8014ea4:	2800      	cmp	r0, #0
 8014ea6:	db01      	blt.n	8014eac <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xbc>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, str_buffer);
 8014ea8:	4669      	mov	r1, sp
 8014eaa:	e000      	b.n	8014eae <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xbe>
	    MIOS32_MIDI_SYSEX_SendAckStr(port, "?");
 8014eac:	4931      	ldr	r1, [pc, #196]	@ (8014f74 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x184>)
 8014eae:	4620      	mov	r0, r4
 8014eb0:	f7ff fdd4 	bl	8014a5c <MIOS32_MIDI_SYSEX_SendAckStr.isra.0>
 8014eb4:	e7d2      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	  sprintf(str_buffer, "%d", MIOS32_SYS_FlashSizeGet());
 8014eb6:	f001 fb1d 	bl	80164f4 <MIOS32_SYS_FlashSizeGet>
 8014eba:	492f      	ldr	r1, [pc, #188]	@ (8014f78 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x188>)
 8014ebc:	4602      	mov	r2, r0
 8014ebe:	e7ea      	b.n	8014e96 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xa6>
	  sprintf(str_buffer, "%d", MIOS32_SYS_RAMSizeGet());
 8014ec0:	f001 fb20 	bl	8016504 <MIOS32_SYS_RAMSizeGet>
 8014ec4:	e7f9      	b.n	8014eba <MIOS32_MIDI_SYSEX_Cmd.isra.0+0xca>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE1);
 8014ec6:	492d      	ldr	r1, [pc, #180]	@ (8014f7c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x18c>)
 8014ec8:	e7d7      	b.n	8014e7a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x8a>
	  MIOS32_MIDI_SYSEX_SendAckStr(port, MIOS32_LCD_BOOT_MSG_LINE2);
 8014eca:	492d      	ldr	r1, [pc, #180]	@ (8014f80 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x190>)
 8014ecc:	e7d5      	b.n	8014e7a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x8a>
}
 8014ece:	b00a      	add	sp, #40	@ 0x28
 8014ed0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  MIOS32_SYS_Reset();
 8014ed4:	f001 bab2 	b.w	801643c <MIOS32_SYS_Reset>
  switch( cmd_state ) {
 8014ed8:	4d2a      	ldr	r5, [pc, #168]	@ (8014f84 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x194>)
 8014eda:	b1e3      	cbz	r3, 8014f16 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x126>
 8014edc:	2b01      	cmp	r3, #1
 8014ede:	d01d      	beq.n	8014f1c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x12c>
      if( debug_req == 0x00 ) {
 8014ee0:	782a      	ldrb	r2, [r5, #0]
 8014ee2:	2a00      	cmp	r2, #0
 8014ee4:	d12e      	bne.n	8014f44 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x154>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_ACK, 0x00);
 8014ee6:	210f      	movs	r1, #15
 8014ee8:	f7ff fde2 	bl	8014ab0 <MIOS32_MIDI_SYSEX_SendAck.isra.0>
	if( debug_req == 0 && debug_command_callback_func == NULL ) {
 8014eec:	782b      	ldrb	r3, [r5, #0]
 8014eee:	2b00      	cmp	r3, #0
 8014ef0:	d1b4      	bne.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
 8014ef2:	4b25      	ldr	r3, [pc, #148]	@ (8014f88 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x198>)
 8014ef4:	681b      	ldr	r3, [r3, #0]
 8014ef6:	2b00      	cmp	r3, #0
 8014ef8:	d1b0      	bne.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
  return debug_port;
 8014efa:	4b24      	ldr	r3, [pc, #144]	@ (8014f8c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x19c>)
	  MIOS32_MIDI_DebugPortSet(port);
 8014efc:	4620      	mov	r0, r4
  return debug_port;
 8014efe:	781d      	ldrb	r5, [r3, #0]
	  MIOS32_MIDI_DebugPortSet(port);
 8014f00:	f7ff ff6c 	bl	8014ddc <MIOS32_MIDI_DebugPortSet>
	  MIOS32_MIDI_SendDebugString("[MIOS32_MIDI_SYSEX_Cmd_Debug] command handler not implemented by application\n");
 8014f04:	4822      	ldr	r0, [pc, #136]	@ (8014f90 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x1a0>)
 8014f06:	f7ff fe53 	bl	8014bb0 <MIOS32_MIDI_SendDebugString>
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
 8014f0a:	4628      	mov	r0, r5
}
 8014f0c:	b00a      	add	sp, #40	@ 0x28
 8014f0e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  MIOS32_MIDI_DebugPortSet(prev_debug_port);
 8014f12:	f7ff bf63 	b.w	8014ddc <MIOS32_MIDI_DebugPortSet>
      debug_req = 0xff;
 8014f16:	23ff      	movs	r3, #255	@ 0xff
 8014f18:	702b      	strb	r3, [r5, #0]
      break;
 8014f1a:	e79f      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
      if( debug_req == 0xff ) {
 8014f1c:	782b      	ldrb	r3, [r5, #0]
 8014f1e:	2bff      	cmp	r3, #255	@ 0xff
 8014f20:	d101      	bne.n	8014f26 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x136>
	debug_req = midi_in;
 8014f22:	702a      	strb	r2, [r5, #0]
 8014f24:	e79a      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	switch( debug_req ) {
 8014f26:	b11b      	cbz	r3, 8014f30 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x140>
 8014f28:	2b01      	cmp	r3, #1
 8014f2a:	d197      	bne.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	    if( filebrowser_command_callback_func != NULL )
 8014f2c:	4b19      	ldr	r3, [pc, #100]	@ (8014f94 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x1a4>)
 8014f2e:	e000      	b.n	8014f32 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x142>
	    if( debug_command_callback_func != NULL )
 8014f30:	4b15      	ldr	r3, [pc, #84]	@ (8014f88 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x198>)
	    if( filebrowser_command_callback_func != NULL )
 8014f32:	681b      	ldr	r3, [r3, #0]
 8014f34:	2b00      	cmp	r3, #0
 8014f36:	d091      	beq.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	      filebrowser_command_callback_func(last_sysex_port, (char)midi_in);
 8014f38:	4a17      	ldr	r2, [pc, #92]	@ (8014f98 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x1a8>)
 8014f3a:	7810      	ldrb	r0, [r2, #0]
}
 8014f3c:	b00a      	add	sp, #40	@ 0x28
 8014f3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	      filebrowser_command_callback_func(last_sysex_port, (char)midi_in);
 8014f42:	4718      	bx	r3
      } else if( debug_req == 0x01 && filebrowser_command_callback_func != NULL ) {
 8014f44:	2a01      	cmp	r2, #1
 8014f46:	d103      	bne.n	8014f50 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x160>
 8014f48:	4b12      	ldr	r3, [pc, #72]	@ (8014f94 <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x1a4>)
 8014f4a:	681b      	ldr	r3, [r3, #0]
 8014f4c:	2b00      	cmp	r3, #0
 8014f4e:	d185      	bne.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
	MIOS32_MIDI_SYSEX_SendAck(port, MIOS32_MIDI_SYSEX_DISACK, MIOS32_MIDI_SYSEX_DISACK_UNSUPPORTED_DEBUG);
 8014f50:	2210      	movs	r2, #16
 8014f52:	e78a      	b.n	8014e6a <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x7a>
      sysex_state.ping.PING_BYTE_RECEIVED = 1;
 8014f54:	6053      	str	r3, [r2, #4]
      break;
 8014f56:	e781      	b.n	8014e5c <MIOS32_MIDI_SYSEX_Cmd.isra.0+0x6c>
 8014f58:	20003163 	.word	0x20003163
 8014f5c:	20003168 	.word	0x20003168
 8014f60:	20003154 	.word	0x20003154
 8014f64:	08026d21 	.word	0x08026d21
 8014f68:	08026d28 	.word	0x08026d28
 8014f6c:	08026d3a 	.word	0x08026d3a
 8014f70:	08026b54 	.word	0x08026b54
 8014f74:	08024431 	.word	0x08024431
 8014f78:	080250b2 	.word	0x080250b2
 8014f7c:	080239e2 	.word	0x080239e2
 8014f80:	08026c5e 	.word	0x08026c5e
 8014f84:	20000004 	.word	0x20000004
 8014f88:	20003174 	.word	0x20003174
 8014f8c:	20000005 	.word	0x20000005
 8014f90:	08026d44 	.word	0x08026d44
 8014f94:	20003170 	.word	0x20003170
 8014f98:	20003162 	.word	0x20003162

08014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>:
  if( midi_in >= 0xf8 )
 8014f9c:	29f7      	cmp	r1, #247	@ 0xf7
static s32 MIOS32_MIDI_SYSEX_Parser(mios32_midi_port_t port, u8 midi_in)
 8014f9e:	b538      	push	{r3, r4, r5, lr}
 8014fa0:	460a      	mov	r2, r1
  if( midi_in >= 0xf8 )
 8014fa2:	d824      	bhi.n	8014fee <MIOS32_MIDI_SYSEX_Parser.isra.0+0x52>
  if( sysex_state.general.MY_SYSEX && port != last_sysex_port )
 8014fa4:	4c26      	ldr	r4, [pc, #152]	@ (8015040 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xa4>)
 8014fa6:	7821      	ldrb	r1, [r4, #0]
 8014fa8:	f011 0308 	ands.w	r3, r1, #8
 8014fac:	d003      	beq.n	8014fb6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x1a>
 8014fae:	4d25      	ldr	r5, [pc, #148]	@ (8015044 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xa8>)
 8014fb0:	782d      	ldrb	r5, [r5, #0]
 8014fb2:	4285      	cmp	r5, r0
 8014fb4:	d11b      	bne.n	8014fee <MIOS32_MIDI_SYSEX_Parser.isra.0+0x52>
  if( port >= USB1 && port <= USB7 )
 8014fb6:	f1a0 0511 	sub.w	r5, r0, #17
 8014fba:	2d06      	cmp	r5, #6
 8014fbc:	d917      	bls.n	8014fee <MIOS32_MIDI_SYSEX_Parser.isra.0+0x52>
  last_sysex_port = port;
 8014fbe:	4d21      	ldr	r5, [pc, #132]	@ (8015044 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xa8>)
 8014fc0:	7028      	strb	r0, [r5, #0]
  if( !sysex_state.general.MY_SYSEX ) {
 8014fc2:	bb1b      	cbnz	r3, 801500c <MIOS32_MIDI_SYSEX_Parser.isra.0+0x70>
    if( (sysex_state.general.CTR < sizeof(mios32_midi_sysex_header) && midi_in != mios32_midi_sysex_header[sysex_state.general.CTR]) ||
 8014fc4:	7823      	ldrb	r3, [r4, #0]
 8014fc6:	f003 0307 	and.w	r3, r3, #7
 8014fca:	2b04      	cmp	r3, #4
 8014fcc:	d803      	bhi.n	8014fd6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x3a>
 8014fce:	481e      	ldr	r0, [pc, #120]	@ (8015048 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xac>)
 8014fd0:	5cc0      	ldrb	r0, [r0, r3]
 8014fd2:	4290      	cmp	r0, r2
 8014fd4:	d107      	bne.n	8014fe6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x4a>
 8014fd6:	f001 0107 	and.w	r1, r1, #7
 8014fda:	2905      	cmp	r1, #5
 8014fdc:	d108      	bne.n	8014ff0 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x54>
	(sysex_state.general.CTR == sizeof(mios32_midi_sysex_header) && midi_in != sysex_device_id) ) {
 8014fde:	491b      	ldr	r1, [pc, #108]	@ (801504c <MIOS32_MIDI_SYSEX_Parser.isra.0+0xb0>)
 8014fe0:	7809      	ldrb	r1, [r1, #0]
 8014fe2:	4291      	cmp	r1, r2
 8014fe4:	d004      	beq.n	8014ff0 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x54>
  sysex_cmd = 0;
 8014fe6:	4a1a      	ldr	r2, [pc, #104]	@ (8015050 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xb4>)
  sysex_state.ALL = 0;
 8014fe8:	2300      	movs	r3, #0
 8014fea:	7023      	strb	r3, [r4, #0]
  sysex_cmd = 0;
 8014fec:	7013      	strb	r3, [r2, #0]
}
 8014fee:	bd38      	pop	{r3, r4, r5, pc}
      if( ++sysex_state.general.CTR > sizeof(mios32_midi_sysex_header) ) {
 8014ff0:	7822      	ldrb	r2, [r4, #0]
 8014ff2:	3301      	adds	r3, #1
 8014ff4:	f003 0307 	and.w	r3, r3, #7
 8014ff8:	f363 0202 	bfi	r2, r3, #0, #3
 8014ffc:	2b05      	cmp	r3, #5
 8014ffe:	7022      	strb	r2, [r4, #0]
 8015000:	d9f5      	bls.n	8014fee <MIOS32_MIDI_SYSEX_Parser.isra.0+0x52>
	sysex_state.general.MY_SYSEX = 1;
 8015002:	b2d3      	uxtb	r3, r2
 8015004:	f043 0308 	orr.w	r3, r3, #8
 8015008:	7023      	strb	r3, [r4, #0]
 801500a:	e7f0      	b.n	8014fee <MIOS32_MIDI_SYSEX_Parser.isra.0+0x52>
    if( midi_in >= 0x80 ) {
 801500c:	0615      	lsls	r5, r2, #24
 801500e:	d507      	bpl.n	8015020 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x84>
      if( midi_in == 0xf7 && sysex_state.general.CMD ) {
 8015010:	2af7      	cmp	r2, #247	@ 0xf7
 8015012:	d1e8      	bne.n	8014fe6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x4a>
 8015014:	06cb      	lsls	r3, r1, #27
 8015016:	d5e6      	bpl.n	8014fe6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x4a>
      	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_END, midi_in);
 8015018:	2102      	movs	r1, #2
 801501a:	f7ff fee9 	bl	8014df0 <MIOS32_MIDI_SYSEX_Cmd.isra.0>
 801501e:	e7e2      	b.n	8014fe6 <MIOS32_MIDI_SYSEX_Parser.isra.0+0x4a>
      if( !sysex_state.general.CMD ) {
 8015020:	f011 0110 	ands.w	r1, r1, #16
	sysex_state.general.CMD = 1;
 8015024:	bf01      	itttt	eq
 8015026:	7823      	ldrbeq	r3, [r4, #0]
 8015028:	f043 0310 	orreq.w	r3, r3, #16
 801502c:	7023      	strbeq	r3, [r4, #0]
	sysex_cmd = midi_in;
 801502e:	4b08      	ldreq	r3, [pc, #32]	@ (8015050 <MIOS32_MIDI_SYSEX_Parser.isra.0+0xb4>)
 8015030:	bf08      	it	eq
 8015032:	701a      	strbeq	r2, [r3, #0]
}
 8015034:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	MIOS32_MIDI_SYSEX_Cmd(port, MIOS32_MIDI_SYSEX_CMD_STATE_CONT, midi_in);
 8015038:	bf18      	it	ne
 801503a:	2101      	movne	r1, #1
 801503c:	f7ff bed8 	b.w	8014df0 <MIOS32_MIDI_SYSEX_Cmd.isra.0>
 8015040:	20003168 	.word	0x20003168
 8015044:	20003162 	.word	0x20003162
 8015048:	08026d92 	.word	0x08026d92
 801504c:	20003164 	.word	0x20003164
 8015050:	20003163 	.word	0x20003163

08015054 <MIOS32_MIDI_ReceivePackage>:
{
 8015054:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015058:	f001 080f 	and.w	r8, r1, #15
  if( package.type >= 0x8 && package.type < 0xf ) {
 801505c:	f1b8 0f07 	cmp.w	r8, #7
{
 8015060:	4604      	mov	r4, r0
 8015062:	460d      	mov	r5, r1
 8015064:	4616      	mov	r6, r2
 8015066:	f3c1 2b07 	ubfx	fp, r1, #8, #8
 801506a:	f3c1 4907 	ubfx	r9, r1, #16, #8
 801506e:	ea4f 6a11 	mov.w	sl, r1, lsr #24
  if( package.type >= 0x8 && package.type < 0xf ) {
 8015072:	d90d      	bls.n	8015090 <MIOS32_MIDI_ReceivePackage+0x3c>
 8015074:	f36f 1507 	bfc	r5, #4, #4
 8015078:	f005 020f 	and.w	r2, r5, #15
 801507c:	2a0f      	cmp	r2, #15
 801507e:	f000 8125 	beq.w	80152cc <MIOS32_MIDI_ReceivePackage+0x278>
    if( callback_package != NULL )
 8015082:	b10e      	cbz	r6, 8015088 <MIOS32_MIDI_ReceivePackage+0x34>
      callback_package(port, package);
 8015084:	4629      	mov	r1, r5
	  callback_package(port, package);
 8015086:	47b0      	blx	r6
}
 8015088:	2000      	movs	r0, #0
 801508a:	b003      	add	sp, #12
 801508c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( package.evnt0 == 0xf0 || // for package.type == 0xf
 8015090:	f1bb 0ff0 	cmp.w	fp, #240	@ 0xf0
 8015094:	d009      	beq.n	80150aa <MIOS32_MIDI_ReceivePackage+0x56>
    ((package.type >= 4 && package.type <= 7) && package.evnt0 != 0xf6) ) { // no timeout on tune request
 8015096:	f108 020c 	add.w	r2, r8, #12
    if( package.evnt0 == 0xf0 || // for package.type == 0xf
 801509a:	f002 020f 	and.w	r2, r2, #15
 801509e:	2a03      	cmp	r2, #3
 80150a0:	d819      	bhi.n	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
    ((package.type >= 4 && package.type <= 7) && package.evnt0 != 0xf6) ) { // no timeout on tune request
 80150a2:	f1bb 0ff6 	cmp.w	fp, #246	@ 0xf6
 80150a6:	f000 8102 	beq.w	80152ae <MIOS32_MIDI_ReceivePackage+0x25a>
      if( !sysex_timeout_ctr_flags.ALL ) {
 80150aa:	488b      	ldr	r0, [pc, #556]	@ (80152d8 <MIOS32_MIDI_ReceivePackage+0x284>)
 80150ac:	e9d0 1200 	ldrd	r1, r2, [r0]
 80150b0:	430a      	orrs	r2, r1
 80150b2:	d110      	bne.n	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
	switch( port & 0xf0 ) {
 80150b4:	f004 01f0 	and.w	r1, r4, #240	@ 0xf0
 80150b8:	2930      	cmp	r1, #48	@ 0x30
 80150ba:	f04f 0200 	mov.w	r2, #0
 80150be:	d02d      	beq.n	801511c <MIOS32_MIDI_ReceivePackage+0xc8>
 80150c0:	2950      	cmp	r1, #80	@ 0x50
 80150c2:	d033      	beq.n	801512c <MIOS32_MIDI_ReceivePackage+0xd8>
 80150c4:	2910      	cmp	r1, #16
 80150c6:	d106      	bne.n	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
	  sysex_timeout_ctr = 0;
 80150c8:	4984      	ldr	r1, [pc, #528]	@ (80152dc <MIOS32_MIDI_ReceivePackage+0x288>)
 80150ca:	800a      	strh	r2, [r1, #0]
	  sysex_timeout_ctr_flags.usb_receives = (1 << (port & 0xf));
 80150cc:	f004 010f 	and.w	r1, r4, #15
 80150d0:	2201      	movs	r2, #1
 80150d2:	408a      	lsls	r2, r1
 80150d4:	8002      	strh	r2, [r0, #0]
    switch( package.type ) {
 80150d6:	f1a8 0202 	sub.w	r2, r8, #2
 80150da:	2a0d      	cmp	r2, #13
 80150dc:	d8d4      	bhi.n	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
 80150de:	a101      	add	r1, pc, #4	@ (adr r1, 80150e4 <MIOS32_MIDI_ReceivePackage+0x90>)
 80150e0:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 80150e4:	08015143 	.word	0x08015143
 80150e8:	08015143 	.word	0x08015143
 80150ec:	0801513d 	.word	0x0801513d
 80150f0:	080151c7 	.word	0x080151c7
 80150f4:	080151e1 	.word	0x080151e1
 80150f8:	080151e1 	.word	0x080151e1
 80150fc:	08015089 	.word	0x08015089
 8015100:	08015089 	.word	0x08015089
 8015104:	08015089 	.word	0x08015089
 8015108:	08015089 	.word	0x08015089
 801510c:	08015089 	.word	0x08015089
 8015110:	08015089 	.word	0x08015089
 8015114:	08015089 	.word	0x08015089
 8015118:	0801513d 	.word	0x0801513d
	  sysex_timeout_ctr = 0;
 801511c:	496f      	ldr	r1, [pc, #444]	@ (80152dc <MIOS32_MIDI_ReceivePackage+0x288>)
 801511e:	800a      	strh	r2, [r1, #0]
	  sysex_timeout_ctr_flags.iic_receives = (1 << (port & 0xf));
 8015120:	f004 010f 	and.w	r1, r4, #15
 8015124:	2201      	movs	r2, #1
 8015126:	408a      	lsls	r2, r1
 8015128:	8042      	strh	r2, [r0, #2]
	  break;
 801512a:	e7d4      	b.n	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
	  sysex_timeout_ctr = 0;
 801512c:	496b      	ldr	r1, [pc, #428]	@ (80152dc <MIOS32_MIDI_ReceivePackage+0x288>)
 801512e:	800a      	strh	r2, [r1, #0]
	  sysex_timeout_ctr_flags.spi_receives = (1 << (port & 0xf));
 8015130:	f004 010f 	and.w	r1, r4, #15
 8015134:	2201      	movs	r2, #1
 8015136:	408a      	lsls	r2, r1
 8015138:	8082      	strh	r2, [r0, #4]
	  break;
 801513a:	e7cc      	b.n	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
      if( package.evnt0 >= 0xf8 ) { // relevant for package type 0xf
 801513c:	f1bb 0ff7 	cmp.w	fp, #247	@ 0xf7
 8015140:	d905      	bls.n	801514e <MIOS32_MIDI_ReceivePackage+0xfa>
	if( callback_package != NULL )
 8015142:	2e00      	cmp	r6, #0
 8015144:	d0a0      	beq.n	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	  callback_package(port, package); // -> realtime event is forwarded as event
 8015146:	f025 01f0 	bic.w	r1, r5, #240	@ 0xf0
	  callback_package(port, package);
 801514a:	4620      	mov	r0, r4
 801514c:	e79b      	b.n	8015086 <MIOS32_MIDI_ReceivePackage+0x32>
      if( package.type != 0x0f ) {
 801514e:	f36f 1507 	bfc	r5, #4, #4
      MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 8015152:	4659      	mov	r1, fp
 8015154:	4620      	mov	r0, r4
      if( package.type != 0x0f ) {
 8015156:	f005 070f 	and.w	r7, r5, #15
      MIOS32_MIDI_SYSEX_Parser(port, package.evnt0); // -> forward to MIOS32 SysEx Parser
 801515a:	f7ff ff1f 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
      if( package.type != 0x0f ) {
 801515e:	2f0f      	cmp	r7, #15
 8015160:	d007      	beq.n	8015172 <MIOS32_MIDI_ReceivePackage+0x11e>
	MIOS32_MIDI_SYSEX_Parser(port, package.evnt1); // -> forward to MIOS32 SysEx Parser
 8015162:	4649      	mov	r1, r9
 8015164:	4620      	mov	r0, r4
 8015166:	f7ff ff19 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
	MIOS32_MIDI_SYSEX_Parser(port, package.evnt2); // -> forward to MIOS32 SysEx Parser
 801516a:	4651      	mov	r1, sl
 801516c:	4620      	mov	r0, r4
 801516e:	f7ff ff15 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
      if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 8015172:	4a5b      	ldr	r2, [pc, #364]	@ (80152e0 <MIOS32_MIDI_ReceivePackage+0x28c>)
 8015174:	7812      	ldrb	r2, [r2, #0]
 8015176:	0710      	lsls	r0, r2, #28
 8015178:	d486      	bmi.n	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	if( sysex_callback_func != NULL ) {
 801517a:	f8df 8168 	ldr.w	r8, [pc, #360]	@ 80152e4 <MIOS32_MIDI_ReceivePackage+0x290>
 801517e:	f8d8 2000 	ldr.w	r2, [r8]
 8015182:	2a00      	cmp	r2, #0
 8015184:	f000 808f 	beq.w	80152a6 <MIOS32_MIDI_ReceivePackage+0x252>
	  filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8015188:	4659      	mov	r1, fp
 801518a:	4620      	mov	r0, r4
 801518c:	4790      	blx	r2
	  if( package.type != 0x0f ) {
 801518e:	2f0f      	cmp	r7, #15
	  filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8015190:	4683      	mov	fp, r0
	  if( package.type != 0x0f ) {
 8015192:	d108      	bne.n	80151a6 <MIOS32_MIDI_ReceivePackage+0x152>
	  filter_sysex |= sysex_callback_func(port, package.evnt0); // -> forwarded as SysEx
 8015194:	b2c0      	uxtb	r0, r0
	if( callback_package != NULL && !filter_sysex )
 8015196:	2e00      	cmp	r6, #0
 8015198:	f43f af76 	beq.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
 801519c:	2800      	cmp	r0, #0
 801519e:	f47f af73 	bne.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	  callback_package(port, package);
 80151a2:	4629      	mov	r1, r5
 80151a4:	e7d1      	b.n	801514a <MIOS32_MIDI_ReceivePackage+0xf6>
	    filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 80151a6:	f8d8 3000 	ldr.w	r3, [r8]
 80151aa:	4649      	mov	r1, r9
 80151ac:	4620      	mov	r0, r4
 80151ae:	4798      	blx	r3
	    filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 80151b0:	f8d8 3000 	ldr.w	r3, [r8]
	    filter_sysex |= sysex_callback_func(port, package.evnt1); // -> forwarded as SysEx
 80151b4:	4607      	mov	r7, r0
	    filter_sysex |= sysex_callback_func(port, package.evnt2); // -> forwarded as SysEx
 80151b6:	4651      	mov	r1, sl
 80151b8:	4620      	mov	r0, r4
 80151ba:	4798      	blx	r3
 80151bc:	4338      	orrs	r0, r7
 80151be:	ea40 000b 	orr.w	r0, r0, fp
 80151c2:	b2c0      	uxtb	r0, r0
 80151c4:	e7e7      	b.n	8015196 <MIOS32_MIDI_ReceivePackage+0x142>
      if( (package.evnt0 >= 0xf8) || (package.evnt0 == 0xf6) ) {
 80151c6:	f1bb 0ff7 	cmp.w	fp, #247	@ 0xf7
 80151ca:	d802      	bhi.n	80151d2 <MIOS32_MIDI_ReceivePackage+0x17e>
 80151cc:	f1bb 0ff6 	cmp.w	fp, #246	@ 0xf6
 80151d0:	d15a      	bne.n	8015288 <MIOS32_MIDI_ReceivePackage+0x234>
	if( callback_package != NULL )
 80151d2:	2e00      	cmp	r6, #0
 80151d4:	f43f af58 	beq.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	  callback_package(port, package); // -> forwarded as event
 80151d8:	2305      	movs	r3, #5
 80151da:	f363 0507 	bfi	r5, r3, #0, #8
 80151de:	e7e0      	b.n	80151a2 <MIOS32_MIDI_ReceivePackage+0x14e>
      u8 num_bytes = package.type - 0x5 + 1;
 80151e0:	f1a8 0804 	sub.w	r8, r8, #4
 80151e4:	fa5f f388 	uxtb.w	r3, r8
	if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 80151e8:	f8df 80f4 	ldr.w	r8, [pc, #244]	@ 80152e0 <MIOS32_MIDI_ReceivePackage+0x28c>
      u8 num_bytes = package.type - 0x5 + 1;
 80151ec:	9301      	str	r3, [sp, #4]
	MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 80151ee:	4659      	mov	r1, fp
 80151f0:	4620      	mov	r0, r4
 80151f2:	f7ff fed3 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
	if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 80151f6:	f898 7000 	ldrb.w	r7, [r8]
 80151fa:	f017 0708 	ands.w	r7, r7, #8
 80151fe:	d145      	bne.n	801528c <MIOS32_MIDI_ReceivePackage+0x238>
	  if( sysex_callback_func != NULL )
 8015200:	4a38      	ldr	r2, [pc, #224]	@ (80152e4 <MIOS32_MIDI_ReceivePackage+0x290>)
 8015202:	6812      	ldr	r2, [r2, #0]
 8015204:	b11a      	cbz	r2, 801520e <MIOS32_MIDI_ReceivePackage+0x1ba>
	    filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8015206:	4659      	mov	r1, fp
 8015208:	4620      	mov	r0, r4
 801520a:	4790      	blx	r2
 801520c:	b2c7      	uxtb	r7, r0
      if( num_bytes >= 2 ) {
 801520e:	9b01      	ldr	r3, [sp, #4]
 8015210:	2b01      	cmp	r3, #1
 8015212:	d03d      	beq.n	8015290 <MIOS32_MIDI_ReceivePackage+0x23c>
	MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 8015214:	4649      	mov	r1, r9
 8015216:	4620      	mov	r0, r4
 8015218:	f7ff fec0 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
	if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 801521c:	f898 3000 	ldrb.w	r3, [r8]
 8015220:	0719      	lsls	r1, r3, #28
 8015222:	d407      	bmi.n	8015234 <MIOS32_MIDI_ReceivePackage+0x1e0>
	  if( sysex_callback_func != NULL )
 8015224:	4b2f      	ldr	r3, [pc, #188]	@ (80152e4 <MIOS32_MIDI_ReceivePackage+0x290>)
 8015226:	681b      	ldr	r3, [r3, #0]
 8015228:	b123      	cbz	r3, 8015234 <MIOS32_MIDI_ReceivePackage+0x1e0>
	    filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 801522a:	4649      	mov	r1, r9
 801522c:	4620      	mov	r0, r4
 801522e:	4798      	blx	r3
 8015230:	4338      	orrs	r0, r7
 8015232:	b2c7      	uxtb	r7, r0
      if( num_bytes >= 3 ) {
 8015234:	9b01      	ldr	r3, [sp, #4]
 8015236:	2b03      	cmp	r3, #3
 8015238:	d110      	bne.n	801525c <MIOS32_MIDI_ReceivePackage+0x208>
	MIOS32_MIDI_SYSEX_Parser(port, current_byte); // -> forward to MIOS32 SysEx Parser
 801523a:	4651      	mov	r1, sl
 801523c:	4620      	mov	r0, r4
 801523e:	f7ff fead 	bl	8014f9c <MIOS32_MIDI_SYSEX_Parser.isra.0>
	if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 8015242:	f898 3000 	ldrb.w	r3, [r8]
 8015246:	071a      	lsls	r2, r3, #28
 8015248:	d424      	bmi.n	8015294 <MIOS32_MIDI_ReceivePackage+0x240>
	  if( sysex_callback_func != NULL )
 801524a:	4b26      	ldr	r3, [pc, #152]	@ (80152e4 <MIOS32_MIDI_ReceivePackage+0x290>)
 801524c:	681b      	ldr	r3, [r3, #0]
 801524e:	b333      	cbz	r3, 801529e <MIOS32_MIDI_ReceivePackage+0x24a>
	    filter_sysex |= sysex_callback_func(port, current_byte); // -> forwarded as SysEx
 8015250:	4651      	mov	r1, sl
 8015252:	4620      	mov	r0, r4
 8015254:	4798      	blx	r3
 8015256:	4338      	orrs	r0, r7
 8015258:	b2c7      	uxtb	r7, r0
	current_byte = package.evnt2;
 801525a:	46d1      	mov	r9, sl
      if( current_byte == 0xf7 )
 801525c:	f1b9 0ff7 	cmp.w	r9, #247	@ 0xf7
 8015260:	d104      	bne.n	801526c <MIOS32_MIDI_ReceivePackage+0x218>
	sysex_timeout_ctr_flags.ALL = 0;
 8015262:	491d      	ldr	r1, [pc, #116]	@ (80152d8 <MIOS32_MIDI_ReceivePackage+0x284>)
 8015264:	2200      	movs	r2, #0
 8015266:	2300      	movs	r3, #0
 8015268:	e9c1 2300 	strd	r2, r3, [r1]
      if( !sysex_state.general.MY_SYSEX ) { // don't forward to application if we receive a MIOS32 command
 801526c:	f898 3000 	ldrb.w	r3, [r8]
 8015270:	071b      	lsls	r3, r3, #28
 8015272:	f53f af09 	bmi.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	if( callback_package != NULL && !filter_sysex )
 8015276:	2e00      	cmp	r6, #0
 8015278:	f43f af06 	beq.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
 801527c:	2f00      	cmp	r7, #0
 801527e:	f47f af03 	bne.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
	  callback_package(port, package);
 8015282:	f367 1507 	bfi	r5, r7, #4, #4
 8015286:	e78c      	b.n	80151a2 <MIOS32_MIDI_ReceivePackage+0x14e>
      u8 num_bytes = package.type - 0x5 + 1;
 8015288:	2301      	movs	r3, #1
 801528a:	e7ad      	b.n	80151e8 <MIOS32_MIDI_ReceivePackage+0x194>
    u8 filter_sysex = 0;
 801528c:	2700      	movs	r7, #0
 801528e:	e7be      	b.n	801520e <MIOS32_MIDI_ReceivePackage+0x1ba>
 8015290:	46d9      	mov	r9, fp
 8015292:	e7e3      	b.n	801525c <MIOS32_MIDI_ReceivePackage+0x208>
      if( current_byte == 0xf7 )
 8015294:	f1ba 0ff7 	cmp.w	sl, #247	@ 0xf7
 8015298:	f47f aef6 	bne.w	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
 801529c:	e7e1      	b.n	8015262 <MIOS32_MIDI_ReceivePackage+0x20e>
 801529e:	f1ba 0ff7 	cmp.w	sl, #247	@ 0xf7
 80152a2:	d1e8      	bne.n	8015276 <MIOS32_MIDI_ReceivePackage+0x222>
 80152a4:	e7dd      	b.n	8015262 <MIOS32_MIDI_ReceivePackage+0x20e>
	if( callback_package != NULL && !filter_sysex )
 80152a6:	2e00      	cmp	r6, #0
 80152a8:	f47f af7b 	bne.w	80151a2 <MIOS32_MIDI_ReceivePackage+0x14e>
 80152ac:	e6ec      	b.n	8015088 <MIOS32_MIDI_ReceivePackage+0x34>
    switch( package.type ) {
 80152ae:	f1a8 0205 	sub.w	r2, r8, #5
 80152b2:	2a02      	cmp	r2, #2
 80152b4:	f63f af4b 	bhi.w	801514e <MIOS32_MIDI_ReceivePackage+0xfa>
 80152b8:	a101      	add	r1, pc, #4	@ (adr r1, 80152c0 <MIOS32_MIDI_ReceivePackage+0x26c>)
 80152ba:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 80152be:	bf00      	nop
 80152c0:	080151d3 	.word	0x080151d3
 80152c4:	080151e1 	.word	0x080151e1
 80152c8:	080151e1 	.word	0x080151e1
    if( package.evnt0 == 0xf0 || // for package.type == 0xf
 80152cc:	f1bb 0ff0 	cmp.w	fp, #240	@ 0xf0
 80152d0:	f47f af01 	bne.w	80150d6 <MIOS32_MIDI_ReceivePackage+0x82>
 80152d4:	e6e9      	b.n	80150aa <MIOS32_MIDI_ReceivePackage+0x56>
 80152d6:	bf00      	nop
 80152d8:	20003158 	.word	0x20003158
 80152dc:	20003160 	.word	0x20003160
 80152e0:	20003168 	.word	0x20003168
 80152e4:	2000317c 	.word	0x2000317c

080152e8 <MIOS32_MIDI_Receive_Handler>:
{
 80152e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80152ec:	4606      	mov	r6, r0
 80152ee:	b08c      	sub	sp, #48	@ 0x30
    while( (status=MIOS32_USB_MIDI_PackageReceive(&package)) >= 0 ) {
 80152f0:	a802      	add	r0, sp, #8
 80152f2:	f002 ff5b 	bl	80181ac <MIOS32_USB_MIDI_PackageReceive>
 80152f6:	2800      	cmp	r0, #0
 80152f8:	da3e      	bge.n	8015378 <MIOS32_MIDI_Receive_Handler+0x90>
    const midi_intf_table_t midi_intf_table[] = {
 80152fa:	4d43      	ldr	r5, [pc, #268]	@ (8015408 <MIOS32_MIDI_Receive_Handler+0x120>)
 80152fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80152fe:	ac02      	add	r4, sp, #8
 8015300:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015302:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8015304:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8015306:	e895 0003 	ldmia.w	r5, {r0, r1}
 801530a:	e884 0003 	stmia.w	r4, {r0, r1}
      int intf = 0;
 801530e:	2400      	movs	r4, #0
      int packages_forwarded_this_round = 0;
 8015310:	4625      	mov	r5, r4
      int packages_forwarded = 0;
 8015312:	4627      	mov	r7, r4
	if( !midi_intf_table[intf].port ) {
 8015314:	ab0c      	add	r3, sp, #48	@ 0x30
 8015316:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 801531a:	f813 3c28 	ldrb.w	r3, [r3, #-40]
 801531e:	b913      	cbnz	r3, 8015326 <MIOS32_MIDI_Receive_Handler+0x3e>
	  if( !packages_forwarded_this_round )
 8015320:	b1b5      	cbz	r5, 8015350 <MIOS32_MIDI_Receive_Handler+0x68>
	  intf = 0; // at least one package: restart
 8015322:	461c      	mov	r4, r3
	  packages_forwarded_this_round = 0;
 8015324:	461d      	mov	r5, r3
	mios32_midi_port_t port = midi_intf_table[intf].port;
 8015326:	ab0c      	add	r3, sp, #48	@ 0x30
 8015328:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
	s32 status = midi_intf_table[intf].receive_func(port & 0x0f, &package);
 801532c:	a901      	add	r1, sp, #4
	mios32_midi_port_t port = midi_intf_table[intf].port;
 801532e:	f813 8c28 	ldrb.w	r8, [r3, #-40]
	s32 status = midi_intf_table[intf].receive_func(port & 0x0f, &package);
 8015332:	f853 3c24 	ldr.w	r3, [r3, #-36]
 8015336:	f008 000f 	and.w	r0, r8, #15
 801533a:	4798      	blx	r3
	if( status == -10 ) { // receive timeout?
 801533c:	f110 0f0a 	cmn.w	r0, #10
 8015340:	d123      	bne.n	801538a <MIOS32_MIDI_Receive_Handler+0xa2>
	  MIOS32_MIDI_TimeOut(port);
 8015342:	4640      	mov	r0, r8
 8015344:	f7ff fc7a 	bl	8014c3c <MIOS32_MIDI_TimeOut.isra.0>
      } while( packages_forwarded < 10 );
 8015348:	2f0a      	cmp	r7, #10
	++intf;
 801534a:	f104 0401 	add.w	r4, r4, #1
      } while( packages_forwarded < 10 );
 801534e:	d1e1      	bne.n	8015314 <MIOS32_MIDI_Receive_Handler+0x2c>
  if( sysex_timeout_ctr_flags.ALL && sysex_timeout_ctr > 1000 ) {
 8015350:	4c2e      	ldr	r4, [pc, #184]	@ (801540c <MIOS32_MIDI_Receive_Handler+0x124>)
 8015352:	e9d4 3200 	ldrd	r3, r2, [r4]
 8015356:	4313      	orrs	r3, r2
 8015358:	d03f      	beq.n	80153da <MIOS32_MIDI_Receive_Handler+0xf2>
 801535a:	4b2d      	ldr	r3, [pc, #180]	@ (8015410 <MIOS32_MIDI_Receive_Handler+0x128>)
 801535c:	881b      	ldrh	r3, [r3, #0]
 801535e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8015362:	d93a      	bls.n	80153da <MIOS32_MIDI_Receive_Handler+0xf2>
    if( sysex_timeout_ctr_flags.usb_receives ) {
 8015364:	8820      	ldrh	r0, [r4, #0]
 8015366:	b308      	cbz	r0, 80153ac <MIOS32_MIDI_Receive_Handler+0xc4>
	if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 8015368:	f010 0301 	ands.w	r3, r0, #1
 801536c:	d102      	bne.n	8015374 <MIOS32_MIDI_Receive_Handler+0x8c>
      for(i=0; i<16; ++i)
 801536e:	3301      	adds	r3, #1
 8015370:	2b10      	cmp	r3, #16
 8015372:	d114      	bne.n	801539e <MIOS32_MIDI_Receive_Handler+0xb6>
 8015374:	2300      	movs	r3, #0
 8015376:	e016      	b.n	80153a6 <MIOS32_MIDI_Receive_Handler+0xbe>
      MIOS32_MIDI_ReceivePackage(USB0 + package.cable, package, _callback_package);
 8015378:	f89d 0008 	ldrb.w	r0, [sp, #8]
 801537c:	9902      	ldr	r1, [sp, #8]
 801537e:	0900      	lsrs	r0, r0, #4
 8015380:	4632      	mov	r2, r6
 8015382:	3010      	adds	r0, #16
 8015384:	f7ff fe66 	bl	8015054 <MIOS32_MIDI_ReceivePackage>
 8015388:	e7b2      	b.n	80152f0 <MIOS32_MIDI_Receive_Handler+0x8>
	} else if( status >= 0 ) { // message received?
 801538a:	2800      	cmp	r0, #0
 801538c:	dbdc      	blt.n	8015348 <MIOS32_MIDI_Receive_Handler+0x60>
	  MIOS32_MIDI_ReceivePackage(port, package, _callback_package);
 801538e:	9901      	ldr	r1, [sp, #4]
 8015390:	4632      	mov	r2, r6
 8015392:	4640      	mov	r0, r8
	  ++packages_forwarded;
 8015394:	3701      	adds	r7, #1
	  ++packages_forwarded_this_round;
 8015396:	3501      	adds	r5, #1
	  MIOS32_MIDI_ReceivePackage(port, package, _callback_package);
 8015398:	f7ff fe5c 	bl	8015054 <MIOS32_MIDI_ReceivePackage>
 801539c:	e7d4      	b.n	8015348 <MIOS32_MIDI_Receive_Handler+0x60>
	if( sysex_timeout_ctr_flags.usb_receives & (1 << i) )
 801539e:	fa40 f203 	asr.w	r2, r0, r3
 80153a2:	07d5      	lsls	r5, r2, #31
 80153a4:	d5e3      	bpl.n	801536e <MIOS32_MIDI_Receive_Handler+0x86>
      timeout_port = USB0 + i;
 80153a6:	3310      	adds	r3, #16
      timeout_port = SPIM0 + i;
 80153a8:	b2d8      	uxtb	r0, r3
 80153aa:	e010      	b.n	80153ce <MIOS32_MIDI_Receive_Handler+0xe6>
    } else if( sysex_timeout_ctr_flags.iic_receives ) {
 80153ac:	8863      	ldrh	r3, [r4, #2]
 80153ae:	b1c3      	cbz	r3, 80153e2 <MIOS32_MIDI_Receive_Handler+0xfa>
	if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 80153b0:	f013 0201 	ands.w	r2, r3, #1
 80153b4:	d109      	bne.n	80153ca <MIOS32_MIDI_Receive_Handler+0xe2>
      for(i=0; i<16; ++i)
 80153b6:	4610      	mov	r0, r2
 80153b8:	3001      	adds	r0, #1
 80153ba:	2810      	cmp	r0, #16
 80153bc:	d101      	bne.n	80153c2 <MIOS32_MIDI_Receive_Handler+0xda>
	i = 0;
 80153be:	2000      	movs	r0, #0
 80153c0:	e003      	b.n	80153ca <MIOS32_MIDI_Receive_Handler+0xe2>
	if( sysex_timeout_ctr_flags.iic_receives & (1 << i) )
 80153c2:	fa43 f200 	asr.w	r2, r3, r0
 80153c6:	07d1      	lsls	r1, r2, #31
 80153c8:	d5f6      	bpl.n	80153b8 <MIOS32_MIDI_Receive_Handler+0xd0>
      timeout_port = IIC0 + i;
 80153ca:	3030      	adds	r0, #48	@ 0x30
 80153cc:	b2c0      	uxtb	r0, r0
    MIOS32_MIDI_TimeOut(timeout_port);
 80153ce:	f7ff fc35 	bl	8014c3c <MIOS32_MIDI_TimeOut.isra.0>
    sysex_timeout_ctr_flags.ALL = 0;
 80153d2:	2200      	movs	r2, #0
 80153d4:	2300      	movs	r3, #0
 80153d6:	e9c4 2300 	strd	r2, r3, [r4]
}
 80153da:	2000      	movs	r0, #0
 80153dc:	b00c      	add	sp, #48	@ 0x30
 80153de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else if( sysex_timeout_ctr_flags.spi_receives ) {
 80153e2:	88a0      	ldrh	r0, [r4, #4]
 80153e4:	2800      	cmp	r0, #0
 80153e6:	d0f2      	beq.n	80153ce <MIOS32_MIDI_Receive_Handler+0xe6>
	if( sysex_timeout_ctr_flags.spi_receives & (1 << i) )
 80153e8:	f010 0201 	ands.w	r2, r0, #1
 80153ec:	d109      	bne.n	8015402 <MIOS32_MIDI_Receive_Handler+0x11a>
      for(i=0; i<16; ++i)
 80153ee:	4613      	mov	r3, r2
 80153f0:	3301      	adds	r3, #1
 80153f2:	2b10      	cmp	r3, #16
 80153f4:	d101      	bne.n	80153fa <MIOS32_MIDI_Receive_Handler+0x112>
	i = 0;
 80153f6:	2300      	movs	r3, #0
 80153f8:	e003      	b.n	8015402 <MIOS32_MIDI_Receive_Handler+0x11a>
	if( sysex_timeout_ctr_flags.spi_receives & (1 << i) )
 80153fa:	fa40 f203 	asr.w	r2, r0, r3
 80153fe:	07d2      	lsls	r2, r2, #31
 8015400:	d5f6      	bpl.n	80153f0 <MIOS32_MIDI_Receive_Handler+0x108>
      timeout_port = SPIM0 + i;
 8015402:	3350      	adds	r3, #80	@ 0x50
 8015404:	e7d0      	b.n	80153a8 <MIOS32_MIDI_Receive_Handler+0xc0>
 8015406:	bf00      	nop
 8015408:	08026dc0 	.word	0x08026dc0
 801540c:	20003158 	.word	0x20003158
 8015410:	20003160 	.word	0x20003160

08015414 <MIOS32_MIDI_DebugPortGet>:
}
 8015414:	4b01      	ldr	r3, [pc, #4]	@ (801541c <MIOS32_MIDI_DebugPortGet+0x8>)
 8015416:	7818      	ldrb	r0, [r3, #0]
 8015418:	4770      	bx	lr
 801541a:	bf00      	nop
 801541c:	20000005 	.word	0x20000005

08015420 <MIOS32_MIDI_SysExCallback_Init>:
  sysex_callback_func = callback_sysex;
 8015420:	4b01      	ldr	r3, [pc, #4]	@ (8015428 <MIOS32_MIDI_SysExCallback_Init+0x8>)
 8015422:	6018      	str	r0, [r3, #0]
}
 8015424:	2000      	movs	r0, #0
 8015426:	4770      	bx	lr
 8015428:	2000317c 	.word	0x2000317c

0801542c <MIOS32_MIDI_DebugCommandCallback_Init>:
  debug_command_callback_func = callback_debug_command;
 801542c:	4b01      	ldr	r3, [pc, #4]	@ (8015434 <MIOS32_MIDI_DebugCommandCallback_Init+0x8>)
 801542e:	6018      	str	r0, [r3, #0]
}
 8015430:	2000      	movs	r0, #0
 8015432:	4770      	bx	lr
 8015434:	20003174 	.word	0x20003174

08015438 <MIOS32_MIDI_TimeOutCallback_Init>:
  timeout_callback_func = callback_timeout;
 8015438:	4b01      	ldr	r3, [pc, #4]	@ (8015440 <MIOS32_MIDI_TimeOutCallback_Init+0x8>)
 801543a:	6018      	str	r0, [r3, #0]
}
 801543c:	2000      	movs	r0, #0
 801543e:	4770      	bx	lr
 8015440:	20003178 	.word	0x20003178

08015444 <MIOS32_OSC_SearchPath>:
// Internal function:
// searches in search_tree for matching OSC addresses
// returns -4 if MIOS32_OSC_MAX_PATH_PARTS has been exceeded
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_OSC_SearchPath(char *path, mios32_osc_args_t *osc_args, u32 method_arg, const mios32_osc_search_tree_t *search_tree)
{
 8015444:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8015448:	4617      	mov	r7, r2
  if( osc_args->num_path_parts >= MIOS32_OSC_MAX_PATH_PARTS )
 801544a:	7a0a      	ldrb	r2, [r1, #8]
 801544c:	2a07      	cmp	r2, #7
{
 801544e:	4606      	mov	r6, r0
 8015450:	460d      	mov	r5, r1
  if( osc_args->num_path_parts >= MIOS32_OSC_MAX_PATH_PARTS )
 8015452:	d84f      	bhi.n	80154f4 <MIOS32_OSC_SearchPath+0xb0>
 8015454:	f103 0410 	add.w	r4, r3, #16
    return -4; // maximum number of path parts exceeded

  while( search_tree->address != NULL ) {
 8015458:	f854 0c10 	ldr.w	r0, [r4, #-16]
 801545c:	2800      	cmp	r0, #0
 801545e:	d047      	beq.n	80154f0 <MIOS32_OSC_SearchPath+0xac>
 8015460:	46b6      	mov	lr, r6
 8015462:	4680      	mov	r8, r0
    u8 match = 1;
    u8 wildcard = 0;

    char *str1 = path;
    char *str2 = (char *)search_tree->address;
    size_t sep_pos = 0;
 8015464:	2300      	movs	r3, #0
 8015466:	e02c      	b.n	80154c2 <MIOS32_OSC_SearchPath+0x7e>

    while( *str1 != 0 && *str1 != '/' ) {
      if( *str1 == '*' || *str2 == '*' ) {
 8015468:	292a      	cmp	r1, #42	@ 0x2a
 801546a:	d003      	beq.n	8015474 <MIOS32_OSC_SearchPath+0x30>
 801546c:	f818 2b01 	ldrb.w	r2, [r8], #1
 8015470:	2a2a      	cmp	r2, #42	@ 0x2a
 8015472:	d11e      	bne.n	80154b2 <MIOS32_OSC_SearchPath+0x6e>
 8015474:	4662      	mov	r2, ip
 8015476:	eba3 030c 	sub.w	r3, r3, ip
 801547a:	eb02 0c03 	add.w	ip, r2, r3
	// '*' wildcard: continue to end of address part
	while( *str1 != 0 && *str1 != '/' ) {
 801547e:	f812 1b01 	ldrb.w	r1, [r2], #1
 8015482:	b109      	cbz	r1, 8015488 <MIOS32_OSC_SearchPath+0x44>
 8015484:	292f      	cmp	r1, #47	@ 0x2f
 8015486:	d1f8      	bne.n	801547a <MIOS32_OSC_SearchPath+0x36>
      match = 0;

    if( match ) {
      // store number of path parts in local variable, since content of osc_args is changed recursively
      // we don't want to copy the whole structure to save (a lot of...) memory
      u8 num_path_parts = osc_args->num_path_parts;
 8015488:	f895 8008 	ldrb.w	r8, [r5, #8]
      // add pointer to path part
      osc_args->path_part[num_path_parts] = (char *)search_tree->address;
 801548c:	eb05 0388 	add.w	r3, r5, r8, lsl #2
 8015490:	60d8      	str	r0, [r3, #12]
      osc_args->num_path_parts = num_path_parts + 1;
 8015492:	f108 0301 	add.w	r3, r8, #1
 8015496:	722b      	strb	r3, [r5, #8]

      // OR method args of current node to the args to propagate optional parameters
      u32 combined_method_arg = method_arg | search_tree->method_arg;
 8015498:	f854 2c04 	ldr.w	r2, [r4, #-4]

      if( search_tree->osc_method ) {
 801549c:	f854 3c08 	ldr.w	r3, [r4, #-8]
      u32 combined_method_arg = method_arg | search_tree->method_arg;
 80154a0:	433a      	orrs	r2, r7
      if( search_tree->osc_method ) {
 80154a2:	b1cb      	cbz	r3, 80154d8 <MIOS32_OSC_SearchPath+0x94>
	s32 (*osc_method)(mios32_osc_args_t *osc_args, u32 method_arg) = search_tree->osc_method;
	osc_method(osc_args, combined_method_arg);
 80154a4:	4611      	mov	r1, r2
 80154a6:	4628      	mov	r0, r5
 80154a8:	4798      	blx	r3
	if( status < 0 )
	  return status;
      }

      // restore number of path parts (which has been changed recursively)
      osc_args->num_path_parts = num_path_parts;
 80154aa:	f885 8008 	strb.w	r8, [r5, #8]
    }

    ++search_tree;
 80154ae:	3410      	adds	r4, #16
 80154b0:	e7d2      	b.n	8015458 <MIOS32_OSC_SearchPath+0x14>
	++sep_pos;
 80154b2:	3301      	adds	r3, #1
	if( *str2 == 0 || (*str2 != *str1 && *str1 != '?' && *str2 != '?') ) {
 80154b4:	b312      	cbz	r2, 80154fc <MIOS32_OSC_SearchPath+0xb8>
 80154b6:	428a      	cmp	r2, r1
 80154b8:	d003      	beq.n	80154c2 <MIOS32_OSC_SearchPath+0x7e>
 80154ba:	293f      	cmp	r1, #63	@ 0x3f
 80154bc:	d001      	beq.n	80154c2 <MIOS32_OSC_SearchPath+0x7e>
 80154be:	2a3f      	cmp	r2, #63	@ 0x3f
 80154c0:	d11b      	bne.n	80154fa <MIOS32_OSC_SearchPath+0xb6>
    while( *str1 != 0 && *str1 != '/' ) {
 80154c2:	f89e 1000 	ldrb.w	r1, [lr]
 80154c6:	46f4      	mov	ip, lr
 80154c8:	46c1      	mov	r9, r8
 80154ca:	f10e 0e01 	add.w	lr, lr, #1
 80154ce:	b109      	cbz	r1, 80154d4 <MIOS32_OSC_SearchPath+0x90>
 80154d0:	292f      	cmp	r1, #47	@ 0x2f
 80154d2:	d1c9      	bne.n	8015468 <MIOS32_OSC_SearchPath+0x24>
    u8 match = 1;
 80154d4:	2201      	movs	r2, #1
 80154d6:	e011      	b.n	80154fc <MIOS32_OSC_SearchPath+0xb8>
      } else if( search_tree->next ) {
 80154d8:	f854 3c0c 	ldr.w	r3, [r4, #-12]
 80154dc:	2b00      	cmp	r3, #0
 80154de:	d0e4      	beq.n	80154aa <MIOS32_OSC_SearchPath+0x66>
	s32 status = MIOS32_OSC_SearchPath((char *)&path[sep_pos+1], osc_args, combined_method_arg, search_tree->next);
 80154e0:	f10c 0001 	add.w	r0, ip, #1
 80154e4:	4629      	mov	r1, r5
 80154e6:	4430      	add	r0, r6
 80154e8:	f7ff ffac 	bl	8015444 <MIOS32_OSC_SearchPath>
	if( status < 0 )
 80154ec:	2800      	cmp	r0, #0
 80154ee:	dadc      	bge.n	80154aa <MIOS32_OSC_SearchPath+0x66>
  }

  return 0; // no error
}
 80154f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return -4; // maximum number of path parts exceeded
 80154f4:	f06f 0003 	mvn.w	r0, #3
 80154f8:	e7fa      	b.n	80154f0 <MIOS32_OSC_SearchPath+0xac>
	  match = 0;
 80154fa:	2200      	movs	r2, #0
    if( !wildcard && *str2 != 0 ) // we haven't parsed the complete string
 80154fc:	f899 1000 	ldrb.w	r1, [r9]
 8015500:	2900      	cmp	r1, #0
 8015502:	d1d4      	bne.n	80154ae <MIOS32_OSC_SearchPath+0x6a>
    if( match ) {
 8015504:	2a00      	cmp	r2, #0
 8015506:	d0d2      	beq.n	80154ae <MIOS32_OSC_SearchPath+0x6a>
 8015508:	469c      	mov	ip, r3
 801550a:	e7bd      	b.n	8015488 <MIOS32_OSC_SearchPath+0x44>

0801550c <MIOS32_OSC_Init>:
  if( mode > 0 )
 801550c:	3800      	subs	r0, #0
 801550e:	bf18      	it	ne
 8015510:	2001      	movne	r0, #1
}
 8015512:	4240      	negs	r0, r0
 8015514:	4770      	bx	lr

08015516 <MIOS32_OSC_GetWord>:
  return 
 8015516:	6800      	ldr	r0, [r0, #0]
}
 8015518:	ba00      	rev	r0, r0
 801551a:	4770      	bx	lr

0801551c <MIOS32_OSC_SearchElement.part.0>:
static s32 MIOS32_OSC_SearchElement(u8 *buffer, u32 len, mios32_osc_args_t *osc_args, const mios32_osc_search_tree_t *search_tree)
 801551c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015520:	460f      	mov	r7, r1
 8015522:	4611      	mov	r1, r2
  if( *path == ',' )
 8015524:	7802      	ldrb	r2, [r0, #0]
 8015526:	2a2c      	cmp	r2, #44	@ 0x2c
static s32 MIOS32_OSC_SearchElement(u8 *buffer, u32 len, mios32_osc_args_t *osc_args, const mios32_osc_search_tree_t *search_tree)
 8015528:	4605      	mov	r5, r0
  if( *path == ',' )
 801552a:	f000 80af 	beq.w	801568c <MIOS32_OSC_SearchElement.part.0+0x170>

//
// strnlen() not available for all libc's, therefore we use a local solution here
static size_t my_strnlen(char *str, size_t max_len)
{
  size_t len = 0;
 801552e:	2400      	movs	r4, #0

  while( *str++ && (len < max_len) )
 8015530:	5d28      	ldrb	r0, [r5, r4]
 8015532:	b108      	cbz	r0, 8015538 <MIOS32_OSC_SearchElement.part.0+0x1c>
 8015534:	42a7      	cmp	r7, r4
 8015536:	d106      	bne.n	8015546 <MIOS32_OSC_SearchElement.part.0+0x2a>
  if( path_len < 2 || path[path_len] != 0 ) // expect at least two characters, e.g. "/*"
 8015538:	2c01      	cmp	r4, #1
 801553a:	d806      	bhi.n	801554a <MIOS32_OSC_SearchElement.part.0+0x2e>
    return -2; // invalid element format
 801553c:	f06f 0001 	mvn.w	r0, #1
}
 8015540:	b001      	add	sp, #4
 8015542:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ++len;
 8015546:	3401      	adds	r4, #1
 8015548:	e7f2      	b.n	8015530 <MIOS32_OSC_SearchElement.part.0+0x14>
  if( path_len < 2 || path[path_len] != 0 ) // expect at least two characters, e.g. "/*"
 801554a:	5d28      	ldrb	r0, [r5, r4]
 801554c:	2800      	cmp	r0, #0
 801554e:	d1f5      	bne.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
  if( *path != '/' )
 8015550:	2a2f      	cmp	r2, #47	@ 0x2f
 8015552:	d1f3      	bne.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
  size_t tags_pos = (path_len+1 + 3) & 0xfffffc;
 8015554:	3404      	adds	r4, #4
 8015556:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
 801555a:	f024 0403 	bic.w	r4, r4, #3
  if( tags_pos >= len )
 801555e:	42a7      	cmp	r7, r4
  osc_args->original_path = (char *)path;
 8015560:	62cd      	str	r5, [r1, #44]	@ 0x2c
  if( tags_pos >= len )
 8015562:	d9eb      	bls.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
  u8 *tags = (u8 *)(buffer + tags_pos);
 8015564:	192e      	adds	r6, r5, r4
  size_t tags_len = my_strnlen((char *)tags, len-tags_pos);
 8015566:	1b3a      	subs	r2, r7, r4
  while( *str++ && (len < max_len) )
 8015568:	f816 c000 	ldrb.w	ip, [r6, r0]
 801556c:	f1bc 0f00 	cmp.w	ip, #0
 8015570:	d045      	beq.n	80155fe <MIOS32_OSC_SearchElement.part.0+0xe2>
 8015572:	4282      	cmp	r2, r0
 8015574:	d141      	bne.n	80155fa <MIOS32_OSC_SearchElement.part.0+0xde>
  if( tags_len == 0 || tags[tags_len] != 0 )
 8015576:	5c32      	ldrb	r2, [r6, r0]
 8015578:	2a00      	cmp	r2, #0
 801557a:	d1df      	bne.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
  if( *tags != ',' )
 801557c:	f815 c004 	ldrb.w	ip, [r5, r4]
 8015580:	f1bc 0f2c 	cmp.w	ip, #44	@ 0x2c
 8015584:	d1da      	bne.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
  size_t arg_pos = (tags_pos + tags_len+1 + 3) & 0xfffffc;
 8015586:	3404      	adds	r4, #4
 8015588:	4404      	add	r4, r0
 801558a:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
  u32 num_args = tags_len - 1;
 801558e:	3801      	subs	r0, #1
  size_t arg_pos = (tags_pos + tags_len+1 + 3) & 0xfffffc;
 8015590:	f024 0403 	bic.w	r4, r4, #3
  for(arg=0; arg<num_args; ++arg) {
 8015594:	2808      	cmp	r0, #8
 8015596:	bf94      	ite	ls
 8015598:	eb06 0900 	addls.w	r9, r6, r0
 801559c:	f106 0908 	addhi.w	r9, r6, #8
 80155a0:	f04f 0801 	mov.w	r8, #1
    switch( tags[arg+1] ) {
 80155a4:	f248 4a49 	movw	sl, #33865	@ 0x8449
  for(arg=0; arg<num_args; ++arg) {
 80155a8:	45b1      	cmp	r9, r6
  osc_args->num_args = 0;
 80155aa:	f881 2030 	strb.w	r2, [r1, #48]	@ 0x30
  for(arg=0; arg<num_args; ++arg) {
 80155ae:	d057      	beq.n	8015660 <MIOS32_OSC_SearchElement.part.0+0x144>
    if( arg_pos > len ) // TK: use > instead of >= to cover non-value parameters like T/F/I/...
 80155b0:	42a7      	cmp	r7, r4
 80155b2:	d3c3      	bcc.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
    osc_args->arg_type[osc_args->num_args] = tags[arg+1];
 80155b4:	1888      	adds	r0, r1, r2
 80155b6:	f816 cf01 	ldrb.w	ip, [r6, #1]!
 80155ba:	f880 c031 	strb.w	ip, [r0, #49]	@ 0x31
    osc_args->arg_ptr[osc_args->num_args] = (u8 *)(buffer + arg_pos);
 80155be:	eb01 0c82 	add.w	ip, r1, r2, lsl #2
 80155c2:	1928      	adds	r0, r5, r4
 80155c4:	f8cc 003c 	str.w	r0, [ip, #60]	@ 0x3c
    switch( tags[arg+1] ) {
 80155c8:	f896 c000 	ldrb.w	ip, [r6]
 80155cc:	f1bc 0f62 	cmp.w	ip, #98	@ 0x62
 80155d0:	d83f      	bhi.n	8015652 <MIOS32_OSC_SearchElement.part.0+0x136>
 80155d2:	f1bc 0f45 	cmp.w	ip, #69	@ 0x45
 80155d6:	d943      	bls.n	8015660 <MIOS32_OSC_SearchElement.part.0+0x144>
 80155d8:	f1ac 0e46 	sub.w	lr, ip, #70	@ 0x46
 80155dc:	f8df b0b4 	ldr.w	fp, [pc, #180]	@ 8015694 <MIOS32_OSC_SearchElement.part.0+0x178>
 80155e0:	fa5f fe8e 	uxtb.w	lr, lr
 80155e4:	fa08 fe0e 	lsl.w	lr, r8, lr
 80155e8:	ea1e 0f0b 	tst.w	lr, fp
 80155ec:	d141      	bne.n	8015672 <MIOS32_OSC_SearchElement.part.0+0x156>
 80155ee:	f1bc 0f62 	cmp.w	ip, #98	@ 0x62
 80155f2:	d044      	beq.n	801567e <MIOS32_OSC_SearchElement.part.0+0x162>
 80155f4:	f1bc 0f53 	cmp.w	ip, #83	@ 0x53
 80155f8:	e010      	b.n	801561c <MIOS32_OSC_SearchElement.part.0+0x100>
    ++len;
 80155fa:	3001      	adds	r0, #1
 80155fc:	e7b4      	b.n	8015568 <MIOS32_OSC_SearchElement.part.0+0x4c>
  if( tags_len == 0 || tags[tags_len] != 0 )
 80155fe:	2800      	cmp	r0, #0
 8015600:	d1b9      	bne.n	8015576 <MIOS32_OSC_SearchElement.part.0+0x5a>
 8015602:	e79b      	b.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
 8015604:	fa08 fe0c 	lsl.w	lr, r8, ip
    switch( tags[arg+1] ) {
 8015608:	ea1e 0f0a 	tst.w	lr, sl
 801560c:	d130      	bne.n	8015670 <MIOS32_OSC_SearchElement.part.0+0x154>
 801560e:	f8df b088 	ldr.w	fp, [pc, #136]	@ 8015698 <MIOS32_OSC_SearchElement.part.0+0x17c>
 8015612:	ea1e 0f0b 	tst.w	lr, fp
 8015616:	d137      	bne.n	8015688 <MIOS32_OSC_SearchElement.part.0+0x16c>
 8015618:	f1bc 0f10 	cmp.w	ip, #16
 801561c:	d120      	bne.n	8015660 <MIOS32_OSC_SearchElement.part.0+0x144>
	size_t str_len = my_strnlen(str, len-arg_pos);
 801561e:	eba7 0e04 	sub.w	lr, r7, r4
  size_t len = 0;
 8015622:	f04f 0c00 	mov.w	ip, #0
  while( *str++ && (len < max_len) )
 8015626:	f810 b00c 	ldrb.w	fp, [r0, ip]
 801562a:	f1bb 0f00 	cmp.w	fp, #0
 801562e:	d001      	beq.n	8015634 <MIOS32_OSC_SearchElement.part.0+0x118>
 8015630:	45e6      	cmp	lr, ip
 8015632:	d121      	bne.n	8015678 <MIOS32_OSC_SearchElement.part.0+0x15c>
	if( str_len == 0 || str[str_len] != 0 )
 8015634:	f1bc 0f00 	cmp.w	ip, #0
 8015638:	d080      	beq.n	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
 801563a:	f810 000c 	ldrb.w	r0, [r0, ip]
 801563e:	2800      	cmp	r0, #0
 8015640:	f47f af7c 	bne.w	801553c <MIOS32_OSC_SearchElement.part.0+0x20>
	arg_pos = (arg_pos + str_len+1 + 3) & 0xfffffc;
 8015644:	3404      	adds	r4, #4
 8015646:	4464      	add	r4, ip
	arg_pos = (arg_pos + 4 + blob_len + 3) & 0xfffffc;
 8015648:	f024 447f 	bic.w	r4, r4, #4278190080	@ 0xff000000
 801564c:	f024 0403 	bic.w	r4, r4, #3
    if( known_arg )
 8015650:	e00f      	b.n	8015672 <MIOS32_OSC_SearchElement.part.0+0x156>
    switch( tags[arg+1] ) {
 8015652:	f1ac 0c63 	sub.w	ip, ip, #99	@ 0x63
 8015656:	fa5f fc8c 	uxtb.w	ip, ip
 801565a:	f1bc 0f11 	cmp.w	ip, #17
 801565e:	d9d1      	bls.n	8015604 <MIOS32_OSC_SearchElement.part.0+0xe8>
  osc_args->num_path_parts = 0;
 8015660:	2200      	movs	r2, #0
  return MIOS32_OSC_SearchPath((char *)&path[1], osc_args, 0x00000000, search_tree);
 8015662:	1c68      	adds	r0, r5, #1
  osc_args->num_path_parts = 0;
 8015664:	720a      	strb	r2, [r1, #8]
}
 8015666:	b001      	add	sp, #4
 8015668:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return MIOS32_OSC_SearchPath((char *)&path[1], osc_args, 0x00000000, search_tree);
 801566c:	f7ff beea 	b.w	8015444 <MIOS32_OSC_SearchPath>
	arg_pos += 4;
 8015670:	3404      	adds	r4, #4
      ++osc_args->num_args;
 8015672:	3201      	adds	r2, #1
 8015674:	b2d2      	uxtb	r2, r2
  for(arg=0; arg<num_args; ++arg) {
 8015676:	e797      	b.n	80155a8 <MIOS32_OSC_SearchElement.part.0+0x8c>
    ++len;
 8015678:	f10c 0c01 	add.w	ip, ip, #1
 801567c:	e7d3      	b.n	8015626 <MIOS32_OSC_SearchElement.part.0+0x10a>
  return MIOS32_OSC_GetWord(buffer);
 801567e:	f7ff ff4a 	bl	8015516 <MIOS32_OSC_GetWord>
	arg_pos = (arg_pos + 4 + blob_len + 3) & 0xfffffc;
 8015682:	3407      	adds	r4, #7
 8015684:	4404      	add	r4, r0
 8015686:	e7df      	b.n	8015648 <MIOS32_OSC_SearchElement.part.0+0x12c>
	arg_pos += 8;
 8015688:	3408      	adds	r4, #8
    if( known_arg )
 801568a:	e7f2      	b.n	8015672 <MIOS32_OSC_SearchElement.part.0+0x156>
    return -3; // unsupported element format
 801568c:	f06f 0002 	mvn.w	r0, #2
 8015690:	e756      	b.n	8015540 <MIOS32_OSC_SearchElement.part.0+0x24>
 8015692:	bf00      	nop
 8015694:	00a04109 	.word	0x00a04109
 8015698:	00020022 	.word	0x00020022

0801569c <MIOS32_OSC_PutWord>:
  *buffer++ = (word >> 24) & 0xff;
 801569c:	0e0b      	lsrs	r3, r1, #24
 801569e:	7003      	strb	r3, [r0, #0]
  *buffer++ = (word >> 16) & 0xff;
 80156a0:	0c0b      	lsrs	r3, r1, #16
 80156a2:	7043      	strb	r3, [r0, #1]
  *buffer++ = (word >>  8) & 0xff;
 80156a4:	0a0b      	lsrs	r3, r1, #8
 80156a6:	7083      	strb	r3, [r0, #2]
  *buffer++ = (word >>  0) & 0xff;
 80156a8:	70c1      	strb	r1, [r0, #3]
}
 80156aa:	3004      	adds	r0, #4
 80156ac:	4770      	bx	lr

080156ae <MIOS32_OSC_GetTimetag>:
{
 80156ae:	b508      	push	{r3, lr}
 80156b0:	4603      	mov	r3, r0
  timetag.seconds = MIOS32_OSC_GetWord(buffer);
 80156b2:	4608      	mov	r0, r1
 80156b4:	f7ff ff2f 	bl	8015516 <MIOS32_OSC_GetWord>
 80156b8:	4602      	mov	r2, r0
  timetag.fraction = MIOS32_OSC_GetWord(buffer+4);
 80156ba:	1d08      	adds	r0, r1, #4
 80156bc:	f7ff ff2b 	bl	8015516 <MIOS32_OSC_GetWord>
  return timetag;
 80156c0:	e9c3 2000 	strd	r2, r0, [r3]
}
 80156c4:	4618      	mov	r0, r3
 80156c6:	bd08      	pop	{r3, pc}

080156c8 <MIOS32_OSC_GetInt>:
  return (s32)MIOS32_OSC_GetWord(buffer);
 80156c8:	f7ff bf25 	b.w	8015516 <MIOS32_OSC_GetWord>

080156cc <MIOS32_OSC_PutInt>:
  return MIOS32_OSC_PutWord(buffer, (u32)value);
 80156cc:	f7ff bfe6 	b.w	801569c <MIOS32_OSC_PutWord>

080156d0 <MIOS32_OSC_GetFloat>:
{
 80156d0:	b508      	push	{r3, lr}
  converted.word = MIOS32_OSC_GetWord(buffer);
 80156d2:	f7ff ff20 	bl	8015516 <MIOS32_OSC_GetWord>
}
 80156d6:	bd08      	pop	{r3, pc}

080156d8 <MIOS32_OSC_PutFloat>:
  return MIOS32_OSC_PutWord(buffer, converted.word);
 80156d8:	f7ff bfe0 	b.w	801569c <MIOS32_OSC_PutWord>

080156dc <MIOS32_OSC_PutString>:
{
 80156dc:	b510      	push	{r4, lr}
 80156de:	4604      	mov	r4, r0
  buffer = (u8 *)stpcpy((char *)buffer, str);
 80156e0:	f00d ff2e 	bl	8023540 <stpcpy>
  *buffer++ = 0;
 80156e4:	2300      	movs	r3, #0
    *buffer++ = 0;
 80156e6:	f800 3b01 	strb.w	r3, [r0], #1
  while( (u32)(buffer-buffer_start) % 4 )
 80156ea:	1b02      	subs	r2, r0, r4
 80156ec:	0792      	lsls	r2, r2, #30
 80156ee:	d1fa      	bne.n	80156e6 <MIOS32_OSC_PutString+0xa>
}
 80156f0:	bd10      	pop	{r4, pc}

080156f2 <MIOS32_OSC_GetBlobLength>:
  return MIOS32_OSC_GetWord(buffer);
 80156f2:	f7ff bf10 	b.w	8015516 <MIOS32_OSC_GetWord>

080156f6 <MIOS32_OSC_GetBlobData>:
}
 80156f6:	3004      	adds	r0, #4
 80156f8:	4770      	bx	lr

080156fa <MIOS32_OSC_PutBlob>:
{
 80156fa:	b538      	push	{r3, r4, r5, lr}
 80156fc:	460c      	mov	r4, r1
  u32 aligned_len = (len+3) & 0xfffffffc;
 80156fe:	1cd1      	adds	r1, r2, #3
  buffer = MIOS32_OSC_PutWord(buffer, aligned_len);
 8015700:	f021 0103 	bic.w	r1, r1, #3
 8015704:	f7ff ffca 	bl	801569c <MIOS32_OSC_PutWord>
 8015708:	4603      	mov	r3, r0
  for(i=0; i<len; ++i)
 801570a:	1e41      	subs	r1, r0, #1
 801570c:	18a0      	adds	r0, r4, r2
 801570e:	4284      	cmp	r4, r0
 8015710:	d106      	bne.n	8015720 <MIOS32_OSC_PutBlob+0x26>
 8015712:	1898      	adds	r0, r3, r2
    *buffer++ = 0;
 8015714:	2100      	movs	r1, #0
  while( i % 4 ) {
 8015716:	425b      	negs	r3, r3
 8015718:	18c2      	adds	r2, r0, r3
 801571a:	0792      	lsls	r2, r2, #30
 801571c:	d105      	bne.n	801572a <MIOS32_OSC_PutBlob+0x30>
}
 801571e:	bd38      	pop	{r3, r4, r5, pc}
    *buffer++ = *data++;
 8015720:	f814 5b01 	ldrb.w	r5, [r4], #1
 8015724:	f801 5f01 	strb.w	r5, [r1, #1]!
  for(i=0; i<len; ++i)
 8015728:	e7f1      	b.n	801570e <MIOS32_OSC_PutBlob+0x14>
    *buffer++ = 0;
 801572a:	f800 1b01 	strb.w	r1, [r0], #1
    ++i;
 801572e:	e7f3      	b.n	8015718 <MIOS32_OSC_PutBlob+0x1e>

08015730 <MIOS32_OSC_GetMIDI>:
{
 8015730:	b510      	push	{r4, lr}
  p.type = *(buffer+1) >> 4;
 8015732:	7843      	ldrb	r3, [r0, #1]
  p.evnt1 = *(buffer+2);
 8015734:	7881      	ldrb	r1, [r0, #2]
  p.evnt2 = *(buffer+3);
 8015736:	78c2      	ldrb	r2, [r0, #3]
  p.type = *(buffer+1) >> 4;
 8015738:	091c      	lsrs	r4, r3, #4
  return p;
 801573a:	2000      	movs	r0, #0
 801573c:	f364 0007 	bfi	r0, r4, #0, #8
 8015740:	f363 200f 	bfi	r0, r3, #8, #8
 8015744:	f361 4017 	bfi	r0, r1, #16, #8
 8015748:	f362 601f 	bfi	r0, r2, #24, #8
}
 801574c:	bd10      	pop	{r4, pc}

0801574e <MIOS32_OSC_PutMIDI>:
  u32 word = (port_id << 24) | (p.evnt0 << 16) | (p.evnt1 << 8) | (p.evnt2 << 0); // see also http://opensoundcontrol.org/spec-1_0
 801574e:	f3c1 4307 	ubfx	r3, r1, #16, #8
 8015752:	f3c1 2207 	ubfx	r2, r1, #8, #8
 8015756:	021b      	lsls	r3, r3, #8
 8015758:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  return MIOS32_OSC_PutWord(buffer, word);
 801575c:	ea43 6111 	orr.w	r1, r3, r1, lsr #24
 8015760:	f7ff bf9c 	b.w	801569c <MIOS32_OSC_PutWord>

08015764 <MIOS32_OSC_ParsePacket>:
{
 8015764:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015768:	460c      	mov	r4, r1
 801576a:	b098      	sub	sp, #96	@ 0x60
 801576c:	4616      	mov	r6, r2
  if( strncmp((char *)packet, "#bundle", len) == 0 ) {
 801576e:	460a      	mov	r2, r1
 8015770:	491c      	ldr	r1, [pc, #112]	@ (80157e4 <MIOS32_OSC_ParsePacket+0x80>)
{
 8015772:	4605      	mov	r5, r0
  if( strncmp((char *)packet, "#bundle", len) == 0 ) {
 8015774:	f00d fed2 	bl	802351c <strncmp>
 8015778:	bb28      	cbnz	r0, 80157c6 <MIOS32_OSC_ParsePacket+0x62>
    if( (pos+8) > len )
 801577a:	2c0f      	cmp	r4, #15
 801577c:	d804      	bhi.n	8015788 <MIOS32_OSC_ParsePacket+0x24>
      return -1; // invalid format
 801577e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8015782:	b018      	add	sp, #96	@ 0x60
 8015784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    osc_args.timetag = MIOS32_OSC_GetTimetag((u8 *)packet+pos);
 8015788:	f105 0108 	add.w	r1, r5, #8
 801578c:	a801      	add	r0, sp, #4
 801578e:	f7ff ff8e 	bl	80156ae <MIOS32_OSC_GetTimetag>
    pos += 8;
 8015792:	2710      	movs	r7, #16
    while( (pos+4) <= len ) {
 8015794:	f107 0804 	add.w	r8, r7, #4
 8015798:	45a0      	cmp	r8, r4
 801579a:	d901      	bls.n	80157a0 <MIOS32_OSC_ParsePacket+0x3c>
  return 0; // no error
 801579c:	2000      	movs	r0, #0
 801579e:	e7f0      	b.n	8015782 <MIOS32_OSC_ParsePacket+0x1e>
      u32 elem_size = MIOS32_OSC_GetWord((u8 *)(packet+pos));
 80157a0:	19e8      	adds	r0, r5, r7
 80157a2:	f7ff feb8 	bl	8015516 <MIOS32_OSC_GetWord>
      if( (pos+elem_size) > len )
 80157a6:	eb08 0700 	add.w	r7, r8, r0
 80157aa:	42a7      	cmp	r7, r4
      u32 elem_size = MIOS32_OSC_GetWord((u8 *)(packet+pos));
 80157ac:	4601      	mov	r1, r0
      if( (pos+elem_size) > len )
 80157ae:	d8e6      	bhi.n	801577e <MIOS32_OSC_ParsePacket+0x1a>
      if( elem_size ) {
 80157b0:	2800      	cmp	r0, #0
 80157b2:	d0ef      	beq.n	8015794 <MIOS32_OSC_ParsePacket+0x30>
  if( !len )
 80157b4:	4633      	mov	r3, r6
 80157b6:	aa01      	add	r2, sp, #4
 80157b8:	eb05 0008 	add.w	r0, r5, r8
 80157bc:	f7ff feae 	bl	801551c <MIOS32_OSC_SearchElement.part.0>
	if( status < 0 )
 80157c0:	2800      	cmp	r0, #0
 80157c2:	dae7      	bge.n	8015794 <MIOS32_OSC_ParsePacket+0x30>
 80157c4:	e7dd      	b.n	8015782 <MIOS32_OSC_ParsePacket+0x1e>
    osc_args.timetag.fraction = 1;
 80157c6:	2200      	movs	r2, #0
 80157c8:	2301      	movs	r3, #1
 80157ca:	e9cd 2301 	strd	r2, r3, [sp, #4]
  if( !len )
 80157ce:	2c00      	cmp	r4, #0
 80157d0:	d0e4      	beq.n	801579c <MIOS32_OSC_ParsePacket+0x38>
 80157d2:	4633      	mov	r3, r6
 80157d4:	aa01      	add	r2, sp, #4
 80157d6:	4621      	mov	r1, r4
 80157d8:	4628      	mov	r0, r5
 80157da:	f7ff fe9f 	bl	801551c <MIOS32_OSC_SearchElement.part.0>
    if( status < 0 )
 80157de:	ea00 70e0 	and.w	r0, r0, r0, asr #31
 80157e2:	e7ce      	b.n	8015782 <MIOS32_OSC_ParsePacket+0x1e>
 80157e4:	08026de8 	.word	0x08026de8

080157e8 <MIOS32_COM_Init>:
s32 MIOS32_COM_Init(u32 mode)
{
  s32 ret = 0;

  // currently only mode 0 supported
  if( mode != 0 )
 80157e8:	b938      	cbnz	r0, 80157fa <MIOS32_COM_Init+0x12>
    return -1; // unsupported mode

  // disable callback by default
  receive_callback_func = NULL;
 80157ea:	4b05      	ldr	r3, [pc, #20]	@ (8015800 <MIOS32_COM_Init+0x18>)

  // set default/debug port as defined in mios32.h/mios32_config.h
  default_port = MIOS32_COM_DEFAULT_PORT;
 80157ec:	4a05      	ldr	r2, [pc, #20]	@ (8015804 <MIOS32_COM_Init+0x1c>)
  receive_callback_func = NULL;
 80157ee:	6018      	str	r0, [r3, #0]
  default_port = MIOS32_COM_DEFAULT_PORT;
 80157f0:	2310      	movs	r3, #16
 80157f2:	7013      	strb	r3, [r2, #0]
  debug_port = MIOS32_COM_DEBUG_PORT;
 80157f4:	4a04      	ldr	r2, [pc, #16]	@ (8015808 <MIOS32_COM_Init+0x20>)
 80157f6:	7013      	strb	r3, [r2, #0]
#if MIOS32_UART0_ASSIGNMENT == 2 || MIOS32_UART1_ASSIGNMENT == 2 || MIOS32_UART2_ASSIGNMENT == 2 || MIOS32_UART3_ASSIGNMENT == 2
  if( MIOS32_UART_Init(0) < 0 )
    ret |= (1 << 1);
#endif

  return -ret;
 80157f8:	4770      	bx	lr
    return -1; // unsupported mode
 80157fa:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 80157fe:	4770      	bx	lr
 8015800:	20003188 	.word	0x20003188
 8015804:	20000008 	.word	0x20000008
 8015808:	20000007 	.word	0x20000007

0801580c <MIOS32_COM_SendBuffer>:
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendBuffer(mios32_com_port_t port, u8 *buffer, u16 len)
{
  // if default/debug port: select mapped port
  if( !(port & 0xf0) ) {
 801580c:	280f      	cmp	r0, #15
 801580e:	d804      	bhi.n	801581a <MIOS32_COM_SendBuffer+0xe>
    port = (port == COM_DEBUG) ? debug_port : default_port;
 8015810:	2801      	cmp	r0, #1
 8015812:	bf0c      	ite	eq
 8015814:	4b06      	ldreq	r3, [pc, #24]	@ (8015830 <MIOS32_COM_SendBuffer+0x24>)
 8015816:	4b07      	ldrne	r3, [pc, #28]	@ (8015834 <MIOS32_COM_SendBuffer+0x28>)
 8015818:	7818      	ldrb	r0, [r3, #0]
  }

  // branch depending on selected port
  switch( port >> 4 ) {
 801581a:	0903      	lsrs	r3, r0, #4
 801581c:	2b02      	cmp	r3, #2
 801581e:	d103      	bne.n	8015828 <MIOS32_COM_SendBuffer+0x1c>
      return -1; // USB has been disabled
#endif

    case 2:
#if !defined(MIOS32_DONT_USE_UART)
      return MIOS32_UART_TxBufferPutMore(port & 0xf, buffer, len);
 8015820:	f000 000f 	and.w	r0, r0, #15
 8015824:	f002 bf9c 	b.w	8018760 <MIOS32_UART_TxBufferPutMore>
      
    default:
      // invalid port
      return -1;
  }
}
 8015828:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801582c:	4770      	bx	lr
 801582e:	bf00      	nop
 8015830:	20000007 	.word	0x20000007
 8015834:	20000008 	.word	0x20000008

08015838 <MIOS32_COM_SendChar>:
//! \param[in] c character
//! \return -1 if port not available
//! \return 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_SendChar(mios32_com_port_t port, char c)
{
 8015838:	b507      	push	{r0, r1, r2, lr}
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 801583a:	2201      	movs	r2, #1
{
 801583c:	f88d 1007 	strb.w	r1, [sp, #7]
  return MIOS32_COM_SendBuffer(port, (u8 *)&c, 1);
 8015840:	f10d 0107 	add.w	r1, sp, #7
 8015844:	f7ff ffe2 	bl	801580c <MIOS32_COM_SendBuffer>
}
 8015848:	b003      	add	sp, #12
 801584a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08015850 <MIOS32_COM_Receive_Handler>:
//! by a task in the programming model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_COM_Receive_Handler(void)
{
 8015850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // no callback -> no polling
  if( receive_callback_func == NULL )
 8015852:	4e2b      	ldr	r6, [pc, #172]	@ (8015900 <MIOS32_COM_Receive_Handler+0xb0>)
 8015854:	6833      	ldr	r3, [r6, #0]
 8015856:	2b00      	cmp	r3, #0
 8015858:	d045      	beq.n	80158e6 <MIOS32_COM_Receive_Handler+0x96>

  u8 port = DEFAULT;

  u8 intf = 0; // interface to be checked
  u8 total_bytes_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
  u8 bytes_forwarded = 0;
 801585a:	2400      	movs	r4, #0
  u8 total_bytes_forwarded = 0; // number of forwards - stop after 10 forwards to yield some CPU time for other tasks
 801585c:	4625      	mov	r5, r4
  u8 intf = 0; // interface to be checked
 801585e:	4627      	mov	r7, r4
    // TODO: maybe a list based approach would be better
    // it would allow to add/remove interfaces dynamically
    // this would also allow to give certain ports a higher priority (to add them multiple times to the list)
    // it would also improve this spagetthi code ;)
    s32 status = -1;
    switch( intf++ ) {
 8015860:	2f04      	cmp	r7, #4
 8015862:	d839      	bhi.n	80158d8 <MIOS32_COM_Receive_Handler+0x88>
 8015864:	e8df f007 	tbb	[pc, r7]
 8015868:	2217033d 	.word	0x2217033d
 801586c:	2d          	.byte	0x2d
 801586d:	00          	.byte	0x00
      case 0: status = MIOS32_USB_COM_RxBufferGet(0); port = USB0; break;
#else
      case 0: status = -1; break;
#endif
#if !defined(MIOS32_DONT_USE_UART)
      case 1: if( MIOS32_UART_IsAssignedToMIDI(0) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(0); port = UART0; } break;
 801586e:	2000      	movs	r0, #0
 8015870:	f002 fcf4 	bl	801825c <MIOS32_UART_IsAssignedToMIDI>
 8015874:	bbd0      	cbnz	r0, 80158ec <MIOS32_COM_Receive_Handler+0x9c>
 8015876:	f002 fe95 	bl	80185a4 <MIOS32_UART_RxBufferGet>
    switch( intf++ ) {
 801587a:	2702      	movs	r7, #2
      case 1: if( MIOS32_UART_IsAssignedToMIDI(0) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(0); port = UART0; } break;
 801587c:	4601      	mov	r1, r0
 801587e:	2020      	movs	r0, #32
	}
	status = -1; // empty round - no message
    }

    // message received?
    if( status >= 0 ) {
 8015880:	2900      	cmp	r1, #0
 8015882:	dbed      	blt.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
      // notify that a package has been forwarded
      ++bytes_forwarded;
      ++total_bytes_forwarded;

      // call function
      if( receive_callback_func != NULL )
 8015884:	6833      	ldr	r3, [r6, #0]
 8015886:	b10b      	cbz	r3, 801588c <MIOS32_COM_Receive_Handler+0x3c>
	receive_callback_func(port, (u8)status);
 8015888:	b2c9      	uxtb	r1, r1
 801588a:	4798      	blx	r3
      ++bytes_forwarded;
 801588c:	3401      	adds	r4, #1
      ++total_bytes_forwarded;
 801588e:	3501      	adds	r5, #1
      ++bytes_forwarded;
 8015890:	b2e4      	uxtb	r4, r4
      ++total_bytes_forwarded;
 8015892:	b2ed      	uxtb	r5, r5
 8015894:	e7e4      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
      case 2: if( MIOS32_UART_IsAssignedToMIDI(1) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(1); port = UART1; } break;
 8015896:	2001      	movs	r0, #1
 8015898:	f002 fce0 	bl	801825c <MIOS32_UART_IsAssignedToMIDI>
 801589c:	bb40      	cbnz	r0, 80158f0 <MIOS32_COM_Receive_Handler+0xa0>
 801589e:	2001      	movs	r0, #1
 80158a0:	f002 fe80 	bl	80185a4 <MIOS32_UART_RxBufferGet>
    switch( intf++ ) {
 80158a4:	2703      	movs	r7, #3
      case 2: if( MIOS32_UART_IsAssignedToMIDI(1) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(1); port = UART1; } break;
 80158a6:	4601      	mov	r1, r0
 80158a8:	2021      	movs	r0, #33	@ 0x21
 80158aa:	e7e9      	b.n	8015880 <MIOS32_COM_Receive_Handler+0x30>
      case 3: if( MIOS32_UART_IsAssignedToMIDI(2) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(2); port = UART2; } break;
 80158ac:	2002      	movs	r0, #2
 80158ae:	f002 fcd5 	bl	801825c <MIOS32_UART_IsAssignedToMIDI>
 80158b2:	b9f8      	cbnz	r0, 80158f4 <MIOS32_COM_Receive_Handler+0xa4>
 80158b4:	2002      	movs	r0, #2
 80158b6:	f002 fe75 	bl	80185a4 <MIOS32_UART_RxBufferGet>
    switch( intf++ ) {
 80158ba:	2704      	movs	r7, #4
      case 3: if( MIOS32_UART_IsAssignedToMIDI(2) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(2); port = UART2; } break;
 80158bc:	4601      	mov	r1, r0
 80158be:	2022      	movs	r0, #34	@ 0x22
 80158c0:	e7de      	b.n	8015880 <MIOS32_COM_Receive_Handler+0x30>
      case 4: if( MIOS32_UART_IsAssignedToMIDI(3) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(3); port = UART3; } break;
 80158c2:	2003      	movs	r0, #3
 80158c4:	f002 fcca 	bl	801825c <MIOS32_UART_IsAssignedToMIDI>
 80158c8:	b9b0      	cbnz	r0, 80158f8 <MIOS32_COM_Receive_Handler+0xa8>
 80158ca:	2003      	movs	r0, #3
 80158cc:	f002 fe6a 	bl	80185a4 <MIOS32_UART_RxBufferGet>
    switch( intf++ ) {
 80158d0:	2705      	movs	r7, #5
      case 4: if( MIOS32_UART_IsAssignedToMIDI(3) ) { status = -1; } else { status = MIOS32_UART_RxBufferGet(3); port = UART3; } break;
 80158d2:	4601      	mov	r1, r0
 80158d4:	2023      	movs	r0, #35	@ 0x23
 80158d6:	e7d3      	b.n	8015880 <MIOS32_COM_Receive_Handler+0x30>
	if( bytes_forwarded && total_bytes_forwarded < 64 ) {
 80158d8:	b10c      	cbz	r4, 80158de <MIOS32_COM_Receive_Handler+0x8e>
 80158da:	2d3f      	cmp	r5, #63	@ 0x3f
 80158dc:	d90e      	bls.n	80158fc <MIOS32_COM_Receive_Handler+0xac>
    }
  } while( again );

  return 0;
 80158de:	2000      	movs	r0, #0
}
 80158e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch( intf++ ) {
 80158e2:	2701      	movs	r7, #1
 80158e4:	e7bc      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
    return -1;
 80158e6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80158ea:	e7f9      	b.n	80158e0 <MIOS32_COM_Receive_Handler+0x90>
    switch( intf++ ) {
 80158ec:	2702      	movs	r7, #2
 80158ee:	e7b7      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
 80158f0:	2703      	movs	r7, #3
 80158f2:	e7b5      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
 80158f4:	2704      	movs	r7, #4
 80158f6:	e7b3      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
 80158f8:	2705      	movs	r7, #5
 80158fa:	e7b1      	b.n	8015860 <MIOS32_COM_Receive_Handler+0x10>
	  bytes_forwarded = 0; // for checking, if bytes still have been forwarded in next round
 80158fc:	2400      	movs	r4, #0
 80158fe:	e7ae      	b.n	801585e <MIOS32_COM_Receive_Handler+0xe>
 8015900:	20003188 	.word	0x20003188

08015904 <MIOS32_UART_MIDI_RecordReset.isra.0>:
static s32 MIOS32_UART_MIDI_RecordReset(u8 uart_port)
{
#if MIOS32_UART_NUM > 0
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record

  midix->package.ALL = 0;
 8015904:	4904      	ldr	r1, [pc, #16]	@ (8015918 <MIOS32_UART_MIDI_RecordReset.isra.0+0x14>)
 8015906:	230c      	movs	r3, #12
 8015908:	4358      	muls	r0, r3
 801590a:	180a      	adds	r2, r1, r0
 801590c:	2300      	movs	r3, #0
 801590e:	500b      	str	r3, [r1, r0]
  midix->running_status = 0x00;
  midix->expected_bytes = 0x00;
  midix->wait_bytes = 0x00;
  midix->sysex_ctr = 0x00;
  midix->timeout_ctr = 0;
 8015910:	8113      	strh	r3, [r2, #8]
  midix->running_status = 0x00;
 8015912:	6053      	str	r3, [r2, #4]
#endif
  return 0; // no error
}
 8015914:	4770      	bx	lr
 8015916:	bf00      	nop
 8015918:	2000319c 	.word	0x2000319c

0801591c <MIOS32_UART_MIDI_CheckAvailable>:
//! \return 1: interface available
//! \return 0: interface not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_CheckAvailable(u8 uart_port)
{
 801591c:	b508      	push	{r3, lr}
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  return MIOS32_UART_IsAssignedToMIDI(uart_port) >= 1; // UART assigned to MIDI?
 801591e:	f002 fc9d 	bl	801825c <MIOS32_UART_IsAssignedToMIDI>
#endif
}
 8015922:	2800      	cmp	r0, #0
 8015924:	bfd4      	ite	le
 8015926:	2000      	movle	r0, #0
 8015928:	2001      	movgt	r0, #1
 801592a:	bd08      	pop	{r3, pc}

0801592c <MIOS32_UART_MIDI_RS_Reset>:
s32 MIOS32_UART_MIDI_RS_Reset(u8 uart_port)
{
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  if( uart_port >= MIOS32_UART_NUM )
 801592c:	2803      	cmp	r0, #3
{
 801592e:	b538      	push	{r3, r4, r5, lr}
 8015930:	4605      	mov	r5, r0
  if( uart_port >= MIOS32_UART_NUM )
 8015932:	d80c      	bhi.n	801594e <MIOS32_UART_MIDI_RS_Reset+0x22>
    return -1; // port not available

  MIOS32_IRQ_Disable();
 8015934:	f000 feda 	bl	80166ec <MIOS32_IRQ_Disable>
  rs_last[uart_port] = 0xff;
 8015938:	4b06      	ldr	r3, [pc, #24]	@ (8015954 <MIOS32_UART_MIDI_RS_Reset+0x28>)
 801593a:	22ff      	movs	r2, #255	@ 0xff
 801593c:	555a      	strb	r2, [r3, r5]
  rs_expire_ctr[uart_port] = 0;
 801593e:	4b06      	ldr	r3, [pc, #24]	@ (8015958 <MIOS32_UART_MIDI_RS_Reset+0x2c>)
 8015940:	2400      	movs	r4, #0
 8015942:	f823 4015 	strh.w	r4, [r3, r5, lsl #1]
  MIOS32_IRQ_Enable();
 8015946:	f000 fee5 	bl	8016714 <MIOS32_IRQ_Enable>

  return 0;
 801594a:	4620      	mov	r0, r4
#endif
}
 801594c:	bd38      	pop	{r3, r4, r5, pc}
    return -1; // port not available
 801594e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8015952:	e7fb      	b.n	801594c <MIOS32_UART_MIDI_RS_Reset+0x20>
 8015954:	20003194 	.word	0x20003194
 8015958:	2000318c 	.word	0x2000318c

0801595c <MIOS32_UART_MIDI_Init>:
{
 801595c:	b510      	push	{r4, lr}
  if( mode != 0 )
 801595e:	4604      	mov	r4, r0
 8015960:	b9f0      	cbnz	r0, 80159a0 <MIOS32_UART_MIDI_Init+0x44>
    MIOS32_UART_MIDI_RecordReset(i);
 8015962:	f7ff ffcf 	bl	8015904 <MIOS32_UART_MIDI_RecordReset.isra.0>
 8015966:	2001      	movs	r0, #1
 8015968:	f7ff ffcc 	bl	8015904 <MIOS32_UART_MIDI_RecordReset.isra.0>
 801596c:	2002      	movs	r0, #2
 801596e:	f7ff ffc9 	bl	8015904 <MIOS32_UART_MIDI_RecordReset.isra.0>
 8015972:	2003      	movs	r0, #3
 8015974:	f7ff ffc6 	bl	8015904 <MIOS32_UART_MIDI_RecordReset.isra.0>
  rs_optimisation = ~0; // -> all-one
 8015978:	4b0b      	ldr	r3, [pc, #44]	@ (80159a8 <MIOS32_UART_MIDI_Init+0x4c>)
 801597a:	22ff      	movs	r2, #255	@ 0xff
    MIOS32_UART_MIDI_RS_Reset(i);
 801597c:	4620      	mov	r0, r4
  rs_optimisation = ~0; // -> all-one
 801597e:	701a      	strb	r2, [r3, #0]
    MIOS32_UART_MIDI_RS_Reset(i);
 8015980:	f7ff ffd4 	bl	801592c <MIOS32_UART_MIDI_RS_Reset>
 8015984:	2001      	movs	r0, #1
 8015986:	f7ff ffd1 	bl	801592c <MIOS32_UART_MIDI_RS_Reset>
 801598a:	2002      	movs	r0, #2
 801598c:	f7ff ffce 	bl	801592c <MIOS32_UART_MIDI_RS_Reset>
 8015990:	2003      	movs	r0, #3
 8015992:	f7ff ffcb 	bl	801592c <MIOS32_UART_MIDI_RS_Reset>
  if( MIOS32_UART_Init(0) < 0 )
 8015996:	4620      	mov	r0, r4
 8015998:	f002 fd54 	bl	8018444 <MIOS32_UART_Init>
 801599c:	17c0      	asrs	r0, r0, #31
}
 801599e:	bd10      	pop	{r4, pc}
    return -1; // unsupported mode
 80159a0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80159a4:	e7fb      	b.n	801599e <MIOS32_UART_MIDI_Init+0x42>
 80159a6:	bf00      	nop
 80159a8:	20003198 	.word	0x20003198

080159ac <MIOS32_UART_MIDI_Periodic_mS>:
//! model!
//! 
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_Periodic_mS(void)
{
 80159ac:	b510      	push	{r4, lr}
#if MIOS32_UART_NUM
  u8 uart_port;

  MIOS32_IRQ_Disable();
 80159ae:	f000 fe9d 	bl	80166ec <MIOS32_IRQ_Disable>
  for(uart_port=0; uart_port<MIOS32_UART_NUM; ++uart_port) {
 80159b2:	480e      	ldr	r0, [pc, #56]	@ (80159ec <MIOS32_UART_MIDI_Periodic_mS+0x40>)
 80159b4:	4a0e      	ldr	r2, [pc, #56]	@ (80159f0 <MIOS32_UART_MIDI_Periodic_mS+0x44>)
 80159b6:	2300      	movs	r3, #0
    // increment the expire counters for running status optimisation.
    //
    // The running status will expire after 1000 ticks (1 second) 
    // to ensure, that the current status will be sent at least each second
    // to cover the case that the MIDI cable is (re-)connected during runtime.
    if( rs_expire_ctr[uart_port] < 65535 )
 80159b8:	f64f 74ff 	movw	r4, #65535	@ 0xffff
 80159bc:	f830 1b02 	ldrh.w	r1, [r0], #2
 80159c0:	42a1      	cmp	r1, r4
      ++rs_expire_ctr[uart_port];
 80159c2:	bf1c      	itt	ne
 80159c4:	3101      	addne	r1, #1
 80159c6:	f820 1c02 	strhne.w	r1, [r0, #-2]

    // increment timeout counter for incoming packages
    // an incomplete event will be timed out after 1000 ticks (1 second)
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 80159ca:	8911      	ldrh	r1, [r2, #8]
  for(uart_port=0; uart_port<MIOS32_UART_NUM; ++uart_port) {
 80159cc:	3301      	adds	r3, #1
    if( midi_rec[uart_port].timeout_ctr < 65535 )
 80159ce:	42a1      	cmp	r1, r4
      ++midi_rec[uart_port].timeout_ctr;
 80159d0:	bf18      	it	ne
 80159d2:	3101      	addne	r1, #1
  for(uart_port=0; uart_port<MIOS32_UART_NUM; ++uart_port) {
 80159d4:	b2db      	uxtb	r3, r3
      ++midi_rec[uart_port].timeout_ctr;
 80159d6:	bf18      	it	ne
 80159d8:	8111      	strhne	r1, [r2, #8]
  for(uart_port=0; uart_port<MIOS32_UART_NUM; ++uart_port) {
 80159da:	2b04      	cmp	r3, #4
 80159dc:	f102 020c 	add.w	r2, r2, #12
 80159e0:	d1ec      	bne.n	80159bc <MIOS32_UART_MIDI_Periodic_mS+0x10>
  }
  MIOS32_IRQ_Enable();
 80159e2:	f000 fe97 	bl	8016714 <MIOS32_IRQ_Enable>
  // (atomic operation not required in MIOS32_UART_MIDI_PackageSend_NonBlocking() due to single-byte accesses)
#endif

  return 0; // no error
}
 80159e6:	2000      	movs	r0, #0
 80159e8:	bd10      	pop	{r4, pc}
 80159ea:	bf00      	nop
 80159ec:	2000318c 	.word	0x2000318c
 80159f0:	2000319c 	.word	0x2000319c

080159f4 <MIOS32_UART_MIDI_PackageSend_NonBlocking>:
//! \return -2: UART_MIDI buffer is full
//!             caller should retry until buffer is free again
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend_NonBlocking(u8 uart_port, mios32_midi_package_t package)
{
 80159f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80159f8:	f3c1 2707 	ubfx	r7, r1, #8, #8
 80159fc:	4606      	mov	r6, r0
 80159fe:	460d      	mov	r5, r1
 8015a00:	f001 0b0f 	and.w	fp, r1, #15
 8015a04:	46b8      	mov	r8, r7
 8015a06:	f3c1 4a07 	ubfx	sl, r1, #16, #8
 8015a0a:	f3c1 6907 	ubfx	r9, r1, #24, #8
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
 8015a0e:	f7ff ff85 	bl	801591c <MIOS32_UART_MIDI_CheckAvailable>
 8015a12:	2800      	cmp	r0, #0
 8015a14:	d045      	beq.n	8015aa2 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xae>
    return -1;

  u8 len = mios32_midi_pcktype_num_bytes[package.cin];
 8015a16:	4b25      	ldr	r3, [pc, #148]	@ (8015aac <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb8>)
 8015a18:	f813 400b 	ldrb.w	r4, [r3, fp]
  if( len ) {
 8015a1c:	2c00      	cmp	r4, #0
 8015a1e:	d043      	beq.n	8015aa8 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xb4>
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};

    if( rs_expire_ctr[uart_port] > 1000 ) {
 8015a20:	4a23      	ldr	r2, [pc, #140]	@ (8015ab0 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xbc>)
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8015a22:	f88d 7004 	strb.w	r7, [sp, #4]
    if( rs_expire_ctr[uart_port] > 1000 ) {
 8015a26:	f832 3016 	ldrh.w	r3, [r2, r6, lsl #1]
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8015a2a:	f88d a005 	strb.w	sl, [sp, #5]
    if( rs_expire_ctr[uart_port] > 1000 ) {
 8015a2e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
    u8 buffer[3] = {package.evnt0, package.evnt1, package.evnt2};
 8015a32:	f88d 9006 	strb.w	r9, [sp, #6]
    if( rs_expire_ctr[uart_port] > 1000 ) {
 8015a36:	d916      	bls.n	8015a66 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x72>
      // the current RS is expired each second to ensure that a status byte will be sent
      // if the MIDI cable is (re)connected during runtime
      MIOS32_UART_MIDI_RS_Reset(uart_port);
 8015a38:	4630      	mov	r0, r6
 8015a3a:	f7ff ff77 	bl	801592c <MIOS32_UART_MIDI_RS_Reset>
      }
    }

    // note: packages != Note Off, On, ... Pitch Bend will disable running status - thats acceptable
    // only realtime events won't touch it (according to MIDI spec)
    if( package.evnt0 < 0xf8 )
 8015a3e:	f1b8 0ff7 	cmp.w	r8, #247	@ 0xf7
      rs_last[uart_port] = package.evnt0;
 8015a42:	bf98      	it	ls
 8015a44:	4b1b      	ldrls	r3, [pc, #108]	@ (8015ab4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)


    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 8015a46:	4622      	mov	r2, r4
 8015a48:	a901      	add	r1, sp, #4
 8015a4a:	4630      	mov	r0, r6
      rs_last[uart_port] = package.evnt0;
 8015a4c:	bf98      	it	ls
 8015a4e:	559f      	strbls	r7, [r3, r6]
    switch( MIOS32_UART_TxBufferPutMore(uart_port, buffer, len) ) {
 8015a50:	f002 fe86 	bl	8018760 <MIOS32_UART_TxBufferPutMore>
 8015a54:	1c83      	adds	r3, r0, #2
 8015a56:	d003      	beq.n	8015a60 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x6c>
 8015a58:	3800      	subs	r0, #0
 8015a5a:	bf18      	it	ne
 8015a5c:	2001      	movne	r0, #1
 8015a5e:	4240      	negs	r0, r0

  } else {
    return 0; // no bytes to send -> no error
  }
#endif
}
 8015a60:	b003      	add	sp, #12
 8015a62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if( (rs_optimisation & (1 << uart_port)) &&
 8015a66:	4b14      	ldr	r3, [pc, #80]	@ (8015ab8 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc4>)
 8015a68:	781b      	ldrb	r3, [r3, #0]
 8015a6a:	4133      	asrs	r3, r6
 8015a6c:	07d9      	lsls	r1, r3, #31
 8015a6e:	d5e6      	bpl.n	8015a3e <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x4a>
 8015a70:	f1bb 0f07 	cmp.w	fp, #7
 8015a74:	d9e3      	bls.n	8015a3e <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x4a>
	  package.cin >= NoteOff && package.cin <= PitchBend &&
 8015a76:	f005 050f 	and.w	r5, r5, #15
 8015a7a:	2d0f      	cmp	r5, #15
 8015a7c:	d0df      	beq.n	8015a3e <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x4a>
 8015a7e:	2c01      	cmp	r4, #1
 8015a80:	d0dd      	beq.n	8015a3e <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x4a>
	if( package.evnt0 == rs_last[uart_port] ) {
 8015a82:	4b0c      	ldr	r3, [pc, #48]	@ (8015ab4 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0xc0>)
 8015a84:	5d9b      	ldrb	r3, [r3, r6]
 8015a86:	42bb      	cmp	r3, r7
	  --len;
 8015a88:	bf0d      	iteet	eq
 8015a8a:	f104 34ff 	addeq.w	r4, r4, #4294967295	@ 0xffffffff
	  rs_expire_ctr[uart_port] = 0;
 8015a8e:	2300      	movne	r3, #0
 8015a90:	f822 3016 	strhne.w	r3, [r2, r6, lsl #1]
	  buffer[0] = package.evnt1;
 8015a94:	f88d a004 	strbeq.w	sl, [sp, #4]
	  buffer[1] = package.evnt2;
 8015a98:	bf04      	itt	eq
 8015a9a:	f88d 9005 	strbeq.w	r9, [sp, #5]
	  --len;
 8015a9e:	b2e4      	uxtbeq	r4, r4
	  rs_expire_ctr[uart_port] = 0;
 8015aa0:	e7cd      	b.n	8015a3e <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x4a>
    return -1;
 8015aa2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8015aa6:	e7db      	b.n	8015a60 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x6c>
    return 0; // no bytes to send -> no error
 8015aa8:	4620      	mov	r0, r4
 8015aaa:	e7d9      	b.n	8015a60 <MIOS32_UART_MIDI_PackageSend_NonBlocking+0x6c>
 8015aac:	08026daf 	.word	0x08026daf
 8015ab0:	2000318c 	.word	0x2000318c
 8015ab4:	20003194 	.word	0x20003194
 8015ab8:	20003198 	.word	0x20003198

08015abc <MIOS32_UART_MIDI_PackageSend>:
//! \return 0: no error
//! \return -1: UART_MIDI device not available
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageSend(u8 uart_port, mios32_midi_package_t package)
{
 8015abc:	b538      	push	{r3, r4, r5, lr}
 8015abe:	4604      	mov	r4, r0
 8015ac0:	460d      	mov	r5, r1
  s32 error;

  while( (error=MIOS32_UART_MIDI_PackageSend_NonBlocking(uart_port, package)) == -2);
 8015ac2:	4629      	mov	r1, r5
 8015ac4:	4620      	mov	r0, r4
 8015ac6:	f7ff ff95 	bl	80159f4 <MIOS32_UART_MIDI_PackageSend_NonBlocking>
 8015aca:	1c83      	adds	r3, r0, #2
 8015acc:	d0f9      	beq.n	8015ac2 <MIOS32_UART_MIDI_PackageSend+0x6>

  return error;
}
 8015ace:	bd38      	pop	{r3, r4, r5, pc}

08015ad0 <MIOS32_UART_MIDI_PackageReceive>:
//! \return -1: no package in buffer
//! \return -10: incoming MIDI package timed out (incomplete package received)
//! \note Applications shouldn't call this function directly, instead please use \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_MIDI_PackageReceive(u8 uart_port, mios32_midi_package_t *package)
{
 8015ad0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015ad2:	4607      	mov	r7, r0
 8015ad4:	460e      	mov	r6, r1
#if MIOS32_UART_NUM == 0
  return -1; // all UARTs explicitely disabled - accordingly no package in buffer
#else
  // exit if UART port not available
  if( !MIOS32_UART_MIDI_CheckAvailable(uart_port) )
 8015ad6:	f7ff ff21 	bl	801591c <MIOS32_UART_MIDI_CheckAvailable>
 8015ada:	2800      	cmp	r0, #0
 8015adc:	f000 80d0 	beq.w	8015c80 <MIOS32_UART_MIDI_PackageReceive+0x1b0>
  // parses the next incoming byte(s), stop until we got a complete MIDI event
  // (-> complete package) and forward it to the caller
  midi_rec_t *midix = &midi_rec[uart_port];// simplify addressing of midi record
  u8 package_complete = 0;
  s32 status;
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8015ae0:	250c      	movs	r5, #12
 8015ae2:	4c69      	ldr	r4, [pc, #420]	@ (8015c88 <MIOS32_UART_MIDI_PackageReceive+0x1b8>)

	midix->wait_bytes = midix->expected_bytes;
	midix->timeout_ctr = 0; // reset timeout counter
      }
    } else {
      if( midix->running_status == 0xf0 ) {
 8015ae4:	437d      	muls	r5, r7
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8015ae6:	4638      	mov	r0, r7
 8015ae8:	f002 fd5c 	bl	80185a4 <MIOS32_UART_RxBufferGet>
 8015aec:	2800      	cmp	r0, #0
 8015aee:	da01      	bge.n	8015af4 <MIOS32_UART_MIDI_PackageReceive+0x24>
 8015af0:	2000      	movs	r0, #0
 8015af2:	e00c      	b.n	8015b0e <MIOS32_UART_MIDI_PackageReceive+0x3e>
    if( byte & 0x80 ) { // new MIDI status
 8015af4:	0602      	lsls	r2, r0, #24
    u8 byte = (u8)status;
 8015af6:	b2c3      	uxtb	r3, r0
    if( byte & 0x80 ) { // new MIDI status
 8015af8:	d56e      	bpl.n	8015bd8 <MIOS32_UART_MIDI_PackageReceive+0x108>
      if( byte >= 0xf8 ) { // events >= 0xf8 don't change the running status and can just be forwarded
 8015afa:	2bf7      	cmp	r3, #247	@ 0xf7
 8015afc:	d919      	bls.n	8015b32 <MIOS32_UART_MIDI_PackageReceive+0x62>
	package->cin = 0xf; // F: single byte
 8015afe:	7832      	ldrb	r2, [r6, #0]
	package->evnt0 = byte;
 8015b00:	7073      	strb	r3, [r6, #1]
	package->cin = 0xf; // F: single byte
 8015b02:	f042 020f 	orr.w	r2, r2, #15
	package->evnt1 = 0x00;
 8015b06:	2300      	movs	r3, #0
	package->cin = 0xf; // F: single byte
 8015b08:	7032      	strb	r2, [r6, #0]
	package->evnt1 = 0x00;
 8015b0a:	8073      	strh	r3, [r6, #2]
	
	if( !midix->wait_bytes ) {
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
	  } else {
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 8015b0c:	2001      	movs	r0, #1
      }
    }
  }

  // incoming MIDI package timed out (incomplete package received)
  if( midix->wait_bytes && midix->timeout_ctr > 1000 ) { // 1000 mS = 1 second
 8015b0e:	230c      	movs	r3, #12
 8015b10:	fb03 4407 	mla	r4, r3, r7, r4
 8015b14:	79a3      	ldrb	r3, [r4, #6]
 8015b16:	2b00      	cmp	r3, #0
 8015b18:	f000 80b0 	beq.w	8015c7c <MIOS32_UART_MIDI_PackageReceive+0x1ac>
 8015b1c:	8923      	ldrh	r3, [r4, #8]
 8015b1e:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8015b22:	f240 80ab 	bls.w	8015c7c <MIOS32_UART_MIDI_PackageReceive+0x1ac>
    // stop waiting
    MIOS32_UART_MIDI_RecordReset(uart_port);
 8015b26:	4638      	mov	r0, r7
 8015b28:	f7ff feec 	bl	8015904 <MIOS32_UART_MIDI_RecordReset.isra.0>
    // notify that incomplete package has been received
    return -10;
 8015b2c:	f06f 0009 	mvn.w	r0, #9
  }

  // return 0 if new package in buffer, otherwise -1
  return package_complete ? 0 : -1;
#endif
}
 8015b30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8015b32:	f8df c158 	ldr.w	ip, [pc, #344]	@ 8015c8c <MIOS32_UART_MIDI_PackageReceive+0x1bc>
 8015b36:	f3c3 1102 	ubfx	r1, r3, #4, #3
	midix->running_status = byte;
 8015b3a:	1962      	adds	r2, r4, r5
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8015b3c:	f81c 1001 	ldrb.w	r1, [ip, r1]
	midix->running_status = byte;
 8015b40:	7113      	strb	r3, [r2, #4]
	midix->expected_bytes = mios32_midi_expected_bytes_common[(byte >> 4) & 0x7];
 8015b42:	7151      	strb	r1, [r2, #5]
	if( !midix->expected_bytes ) { // System Message, take number of bytes from expected_bytes_system[] array
 8015b44:	b949      	cbnz	r1, 8015b5a <MIOS32_UART_MIDI_PackageReceive+0x8a>
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 8015b46:	4952      	ldr	r1, [pc, #328]	@ (8015c90 <MIOS32_UART_MIDI_PackageReceive+0x1c0>)
 8015b48:	f000 000f 	and.w	r0, r0, #15
	  if( byte == 0xf0 ) {
 8015b4c:	2bf0      	cmp	r3, #240	@ 0xf0
	  midix->expected_bytes = mios32_midi_expected_bytes_system[byte & 0xf];
 8015b4e:	5c09      	ldrb	r1, [r1, r0]
 8015b50:	7151      	strb	r1, [r2, #5]
	  if( byte == 0xf0 ) {
 8015b52:	d10b      	bne.n	8015b6c <MIOS32_UART_MIDI_PackageReceive+0x9c>
	    midix->package.evnt0 = 0xf0; // midix->package.evnt0 only used by SysEx handler for continuous data streams!
 8015b54:	7053      	strb	r3, [r2, #1]
	    midix->sysex_ctr = 0x01;
 8015b56:	2301      	movs	r3, #1
 8015b58:	71d3      	strb	r3, [r2, #7]
		midix->package.evnt1 = 0x00;
 8015b5a:	2200      	movs	r2, #0
	midix->wait_bytes = midix->expected_bytes;
 8015b5c:	1963      	adds	r3, r4, r5
 8015b5e:	7959      	ldrb	r1, [r3, #5]
 8015b60:	7199      	strb	r1, [r3, #6]
	midix->timeout_ctr = 0; // reset timeout counter
 8015b62:	2100      	movs	r1, #0
 8015b64:	8119      	strh	r1, [r3, #8]
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8015b66:	2a00      	cmp	r2, #0
 8015b68:	d0bd      	beq.n	8015ae6 <MIOS32_UART_MIDI_PackageReceive+0x16>
 8015b6a:	e7cf      	b.n	8015b0c <MIOS32_UART_MIDI_PackageReceive+0x3c>
	  } else if( byte == 0xf7 ) {
 8015b6c:	2bf7      	cmp	r3, #247	@ 0xf7
 8015b6e:	d126      	bne.n	8015bbe <MIOS32_UART_MIDI_PackageReceive+0xee>
	    switch( midix->sysex_ctr ) {
 8015b70:	79d2      	ldrb	r2, [r2, #7]
 8015b72:	b13a      	cbz	r2, 8015b84 <MIOS32_UART_MIDI_PackageReceive+0xb4>
 8015b74:	2a01      	cmp	r2, #1
 8015b76:	5d62      	ldrb	r2, [r4, r5]
 8015b78:	d01b      	beq.n	8015bb2 <MIOS32_UART_MIDI_PackageReceive+0xe2>
		midix->package.cin = 7; // 7: SysEx ends with three bytes
 8015b7a:	2107      	movs	r1, #7
 8015b7c:	f361 0203 	bfi	r2, r1, #0, #4
 8015b80:	5562      	strb	r2, [r4, r5]
		break;
 8015b82:	e00c      	b.n	8015b9e <MIOS32_UART_MIDI_PackageReceive+0xce>
		midix->package.cin = 5; // 5: SysEx ends with single byte
 8015b84:	5b63      	ldrh	r3, [r4, r5]
 8015b86:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8015b8a:	f443 4377 	orr.w	r3, r3, #63232	@ 0xf700
 8015b8e:	f043 0305 	orr.w	r3, r3, #5
 8015b92:	5363      	strh	r3, [r4, r5]
		midix->package.evnt1 = 0x00;
 8015b94:	230c      	movs	r3, #12
 8015b96:	fb03 4307 	mla	r3, r3, r7, r4
 8015b9a:	709a      	strb	r2, [r3, #2]
 8015b9c:	2300      	movs	r3, #0
		midix->package.evnt2 = 0x00;
 8015b9e:	220c      	movs	r2, #12
 8015ba0:	437a      	muls	r2, r7
 8015ba2:	18a1      	adds	r1, r4, r2
 8015ba4:	70cb      	strb	r3, [r1, #3]
	    *package = midix->package;
 8015ba6:	58a3      	ldr	r3, [r4, r2]
 8015ba8:	6033      	str	r3, [r6, #0]
	    midix->sysex_ctr = 0x00; // ensure that next F7 will just send F7
 8015baa:	2300      	movs	r3, #0
 8015bac:	71cb      	strb	r3, [r1, #7]
	    package_complete = 1; // -> forward to caller
 8015bae:	2201      	movs	r2, #1
 8015bb0:	e7d4      	b.n	8015b5c <MIOS32_UART_MIDI_PackageReceive+0x8c>
		midix->package.cin = 6; // 6: SysEx ends with two bytes
 8015bb2:	2106      	movs	r1, #6
 8015bb4:	f361 0203 	bfi	r2, r1, #0, #4
 8015bb8:	5562      	strb	r2, [r4, r5]
		break;
 8015bba:	461a      	mov	r2, r3
 8015bbc:	e7ea      	b.n	8015b94 <MIOS32_UART_MIDI_PackageReceive+0xc4>
	  } else if( !midix->expected_bytes ) {
 8015bbe:	2900      	cmp	r1, #0
 8015bc0:	d1cb      	bne.n	8015b5a <MIOS32_UART_MIDI_PackageReceive+0x8a>
	    midix->package.cin = 5; // 5: SysEx ends with single byte
 8015bc2:	5d60      	ldrb	r0, [r4, r5]
 8015bc4:	f04f 0c05 	mov.w	ip, #5
 8015bc8:	f36c 0003 	bfi	r0, ip, #0, #4
 8015bcc:	5560      	strb	r0, [r4, r5]
	    midix->package.evnt0 = byte;
 8015bce:	7053      	strb	r3, [r2, #1]
	    midix->package.evnt1 = 0x00;
 8015bd0:	8051      	strh	r1, [r2, #2]
	    *package = midix->package;
 8015bd2:	5963      	ldr	r3, [r4, r5]
 8015bd4:	6033      	str	r3, [r6, #0]
	    package_complete = 1; // -> forward to caller
 8015bd6:	e7ea      	b.n	8015bae <MIOS32_UART_MIDI_PackageReceive+0xde>
      if( midix->running_status == 0xf0 ) {
 8015bd8:	1962      	adds	r2, r4, r5
 8015bda:	7910      	ldrb	r0, [r2, #4]
 8015bdc:	28f0      	cmp	r0, #240	@ 0xf0
 8015bde:	d115      	bne.n	8015c0c <MIOS32_UART_MIDI_PackageReceive+0x13c>
	switch( ++midix->sysex_ctr ) {
 8015be0:	79d1      	ldrb	r1, [r2, #7]
 8015be2:	3101      	adds	r1, #1
 8015be4:	b2c9      	uxtb	r1, r1
 8015be6:	2901      	cmp	r1, #1
 8015be8:	71d1      	strb	r1, [r2, #7]
 8015bea:	d00d      	beq.n	8015c08 <MIOS32_UART_MIDI_PackageReceive+0x138>
 8015bec:	2902      	cmp	r1, #2
 8015bee:	d039      	beq.n	8015c64 <MIOS32_UART_MIDI_PackageReceive+0x194>
	    midix->package.evnt2 = byte;
 8015bf0:	70d3      	strb	r3, [r2, #3]
	    midix->package.cin = 4;  // 4: SysEx starts or continues
 8015bf2:	5d63      	ldrb	r3, [r4, r5]
 8015bf4:	2104      	movs	r1, #4
 8015bf6:	f361 0303 	bfi	r3, r1, #0, #4
 8015bfa:	5563      	strb	r3, [r4, r5]
	    *package = midix->package;
 8015bfc:	5963      	ldr	r3, [r4, r5]
 8015bfe:	6033      	str	r3, [r6, #0]
	    midix->sysex_ctr = 0x00; // reset and prepare for next packet
 8015c00:	2300      	movs	r3, #0
 8015c02:	71d3      	strb	r3, [r2, #7]
	    midix->timeout_ctr = 0; // reset timeout counter
 8015c04:	8113      	strh	r3, [r2, #8]
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8015c06:	e781      	b.n	8015b0c <MIOS32_UART_MIDI_PackageReceive+0x3c>
	    midix->package.evnt0 = byte; 
 8015c08:	7053      	strb	r3, [r2, #1]
	    break;
 8015c0a:	e76c      	b.n	8015ae6 <MIOS32_UART_MIDI_PackageReceive+0x16>
	if( !midix->wait_bytes ) {
 8015c0c:	7991      	ldrb	r1, [r2, #6]
 8015c0e:	bb09      	cbnz	r1, 8015c54 <MIOS32_UART_MIDI_PackageReceive+0x184>
	  midix->wait_bytes = midix->expected_bytes - 1;
 8015c10:	f892 c005 	ldrb.w	ip, [r2, #5]
	  midix->timeout_ctr = 0; // reset timeout counter
 8015c14:	8111      	strh	r1, [r2, #8]
	  midix->wait_bytes = midix->expected_bytes - 1;
 8015c16:	f10c 3cff 	add.w	ip, ip, #4294967295	@ 0xffffffff
 8015c1a:	f882 c006 	strb.w	ip, [r2, #6]
	if( midix->expected_bytes == 1 ) {
 8015c1e:	1962      	adds	r2, r4, r5
 8015c20:	7951      	ldrb	r1, [r2, #5]
 8015c22:	2901      	cmp	r1, #1
 8015c24:	d119      	bne.n	8015c5a <MIOS32_UART_MIDI_PackageReceive+0x18a>
	  midix->package.evnt1 = byte;
 8015c26:	7093      	strb	r3, [r2, #2]
	  midix->package.evnt2 = 0x00;
 8015c28:	2300      	movs	r3, #0
 8015c2a:	70d3      	strb	r3, [r2, #3]
	if( !midix->wait_bytes ) {
 8015c2c:	7993      	ldrb	r3, [r2, #6]
 8015c2e:	2b00      	cmp	r3, #0
 8015c30:	f47f af59 	bne.w	8015ae6 <MIOS32_UART_MIDI_PackageReceive+0x16>
	  if( (midix->running_status & 0xf0) != 0xf0 ) {
 8015c34:	f000 03f0 	and.w	r3, r0, #240	@ 0xf0
 8015c38:	2bf0      	cmp	r3, #240	@ 0xf0
 8015c3a:	d017      	beq.n	8015c6c <MIOS32_UART_MIDI_PackageReceive+0x19c>
	    midix->package.cin = midix->running_status >> 4; // common MIDI message
 8015c3c:	0902      	lsrs	r2, r0, #4
 8015c3e:	230c      	movs	r3, #12
 8015c40:	437b      	muls	r3, r7
 8015c42:	18e5      	adds	r5, r4, r3
 8015c44:	5ce1      	ldrb	r1, [r4, r3]
 8015c46:	f362 0103 	bfi	r1, r2, #0, #4
 8015c4a:	54e1      	strb	r1, [r4, r3]
	  midix->package.evnt0 = midix->running_status;
 8015c4c:	7068      	strb	r0, [r5, #1]
	  *package = midix->package;
 8015c4e:	58e3      	ldr	r3, [r4, r3]
 8015c50:	6033      	str	r3, [r6, #0]
  while( !package_complete && (status=MIOS32_UART_RxBufferGet(uart_port)) >= 0 ) {
 8015c52:	e75b      	b.n	8015b0c <MIOS32_UART_MIDI_PackageReceive+0x3c>
	  --midix->wait_bytes;
 8015c54:	3901      	subs	r1, #1
 8015c56:	7191      	strb	r1, [r2, #6]
 8015c58:	e7e1      	b.n	8015c1e <MIOS32_UART_MIDI_PackageReceive+0x14e>
	  if( midix->wait_bytes )
 8015c5a:	f892 c006 	ldrb.w	ip, [r2, #6]
 8015c5e:	f1bc 0f00 	cmp.w	ip, #0
 8015c62:	d001      	beq.n	8015c68 <MIOS32_UART_MIDI_PackageReceive+0x198>
	    midix->package.evnt1 = byte;
 8015c64:	7093      	strb	r3, [r2, #2]
	if( !midix->wait_bytes ) {
 8015c66:	e73e      	b.n	8015ae6 <MIOS32_UART_MIDI_PackageReceive+0x16>
	    midix->package.evnt2 = byte;
 8015c68:	70d3      	strb	r3, [r2, #3]
	if( !midix->wait_bytes ) {
 8015c6a:	e7e3      	b.n	8015c34 <MIOS32_UART_MIDI_PackageReceive+0x164>
	    switch( midix->expected_bytes ) { // MEMO: == 0 comparison was a bug in original MBHP_USB code
 8015c6c:	b121      	cbz	r1, 8015c78 <MIOS32_UART_MIDI_PackageReceive+0x1a8>
 8015c6e:	2901      	cmp	r1, #1
 8015c70:	bf0c      	ite	eq
 8015c72:	2202      	moveq	r2, #2
 8015c74:	2203      	movne	r2, #3
 8015c76:	e7e2      	b.n	8015c3e <MIOS32_UART_MIDI_PackageReceive+0x16e>
 8015c78:	2205      	movs	r2, #5
 8015c7a:	e7e0      	b.n	8015c3e <MIOS32_UART_MIDI_PackageReceive+0x16e>
  return package_complete ? 0 : -1;
 8015c7c:	3801      	subs	r0, #1
 8015c7e:	e757      	b.n	8015b30 <MIOS32_UART_MIDI_PackageReceive+0x60>
    return -1;
 8015c80:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8015c84:	e754      	b.n	8015b30 <MIOS32_UART_MIDI_PackageReceive+0x60>
 8015c86:	bf00      	nop
 8015c88:	2000319c 	.word	0x2000319c
 8015c8c:	08026da7 	.word	0x08026da7
 8015c90:	08026d97 	.word	0x08026d97

08015c94 <MIOS32_IIC_BS_Init>:
  if( MIOS32_IIC_BS_ScanBankSticks() < 0 )
    return -2; // we don't expect that any other task accesses the IIC port yet!

  return 0; // no error
#endif
}
 8015c94:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8015c98:	4770      	bx	lr

08015c9a <MIOS32_MF_Init>:
    mf_state[i].config.cfg.pwm_duty_cycle_up = 1;
  }

  return 0;
#endif
}
 8015c9a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8015c9e:	4770      	bx	lr

08015ca0 <MIOS32_ENC28J60_MAC_AddrGet>:
//! \return u8 pointer with 6 bytes
/////////////////////////////////////////////////////////////////////////////
u8 *MIOS32_ENC28J60_MAC_AddrGet(void)
{
  return mac_addr;
}
 8015ca0:	4800      	ldr	r0, [pc, #0]	@ (8015ca4 <MIOS32_ENC28J60_MAC_AddrGet+0x4>)
 8015ca2:	4770      	bx	lr
 8015ca4:	200031cc 	.word	0x200031cc

08015ca8 <MIOS32_ENC28J60_ReadETHReg>:
s32 MIOS32_ENC28J60_ReadETHReg(u8 address)
{
  s32 status = 0;

  // send opcode
  CSN_0;
 8015ca8:	2200      	movs	r2, #0
{
 8015caa:	b510      	push	{r4, lr}
  CSN_0;
 8015cac:	2101      	movs	r1, #1
{
 8015cae:	4604      	mov	r4, r0
  CSN_0;
 8015cb0:	4610      	mov	r0, r2
 8015cb2:	f000 fe99 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, RCR | address);
 8015cb6:	4621      	mov	r1, r4
 8015cb8:	2000      	movs	r0, #0
 8015cba:	f000 fecb 	bl	8016a54 <MIOS32_SPI_TransferByte>

  // skip if something already failed
  if( status >= 0 ) {
 8015cbe:	1e04      	subs	r4, r0, #0
 8015cc0:	db04      	blt.n	8015ccc <MIOS32_ENC28J60_ReadETHReg+0x24>
    // read register
    status = MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, 0xff);
 8015cc2:	21ff      	movs	r1, #255	@ 0xff
 8015cc4:	2000      	movs	r0, #0
 8015cc6:	f000 fec5 	bl	8016a54 <MIOS32_SPI_TransferByte>
 8015cca:	4604      	mov	r4, r0
  }
  CSN_1;
 8015ccc:	2201      	movs	r2, #1
 8015cce:	4611      	mov	r1, r2
 8015cd0:	2000      	movs	r0, #0
 8015cd2:	f000 fe89 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015cd6:	4620      	mov	r0, r4
 8015cd8:	bd10      	pop	{r4, pc}

08015cda <MIOS32_ENC28J60_ReadMACReg>:
s32 MIOS32_ENC28J60_ReadMACReg(u8 address)
{
  s32 status = 0;

  // send opcode
  CSN_0;
 8015cda:	2200      	movs	r2, #0
{
 8015cdc:	b510      	push	{r4, lr}
  CSN_0;
 8015cde:	2101      	movs	r1, #1
{
 8015ce0:	4604      	mov	r4, r0
  CSN_0;
 8015ce2:	4610      	mov	r0, r2
 8015ce4:	f000 fe80 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, RCR | address);
 8015ce8:	4621      	mov	r1, r4
 8015cea:	2000      	movs	r0, #0
 8015cec:	f000 feb2 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, 0xff); // dummy byte
 8015cf0:	21ff      	movs	r1, #255	@ 0xff
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, RCR | address);
 8015cf2:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, 0xff); // dummy byte
 8015cf4:	2000      	movs	r0, #0
 8015cf6:	f000 fead 	bl	8016a54 <MIOS32_SPI_TransferByte>

  if( status >= 0 ) {
 8015cfa:	4304      	orrs	r4, r0
 8015cfc:	d404      	bmi.n	8015d08 <MIOS32_ENC28J60_ReadMACReg+0x2e>
    // read register
    status = MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, 0xff);
 8015cfe:	21ff      	movs	r1, #255	@ 0xff
 8015d00:	2000      	movs	r0, #0
 8015d02:	f000 fea7 	bl	8016a54 <MIOS32_SPI_TransferByte>
 8015d06:	4604      	mov	r4, r0
  }

  CSN_1;
 8015d08:	2201      	movs	r2, #1
 8015d0a:	4611      	mov	r1, r2
 8015d0c:	2000      	movs	r0, #0
 8015d0e:	f000 fe6b 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015d12:	4620      	mov	r0, r4
 8015d14:	bd10      	pop	{r4, pc}

08015d16 <MIOS32_ENC28J60_WriteReg>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_WriteReg(u8 address, u8 data)
{
  s32 status = 0;

  CSN_0;
 8015d16:	2200      	movs	r2, #0
{
 8015d18:	b538      	push	{r3, r4, r5, lr}
 8015d1a:	4604      	mov	r4, r0
 8015d1c:	460d      	mov	r5, r1
  CSN_0;
 8015d1e:	4610      	mov	r0, r2
 8015d20:	2101      	movs	r1, #1
 8015d22:	f000 fe61 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WCR | address);
 8015d26:	f044 0140 	orr.w	r1, r4, #64	@ 0x40
 8015d2a:	2000      	movs	r0, #0
 8015d2c:	f000 fe92 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d30:	4629      	mov	r1, r5
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WCR | address);
 8015d32:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d34:	2000      	movs	r0, #0
 8015d36:	f000 fe8d 	bl	8016a54 <MIOS32_SPI_TransferByte>
  CSN_1;
 8015d3a:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d3c:	4304      	orrs	r4, r0
  CSN_1;
 8015d3e:	4611      	mov	r1, r2
 8015d40:	2000      	movs	r0, #0
 8015d42:	f000 fe51 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015d46:	4620      	mov	r0, r4
 8015d48:	bd38      	pop	{r3, r4, r5, pc}

08015d4a <MIOS32_ENC28J60_BFCReg>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_BFCReg(u8 address, u8 data)
{
  s32 status = 0;

  CSN_0;
 8015d4a:	2200      	movs	r2, #0
{
 8015d4c:	b538      	push	{r3, r4, r5, lr}
 8015d4e:	4604      	mov	r4, r0
 8015d50:	460d      	mov	r5, r1
  CSN_0;
 8015d52:	4610      	mov	r0, r2
 8015d54:	2101      	movs	r1, #1
 8015d56:	f000 fe47 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, BFC | address);
 8015d5a:	f044 01a0 	orr.w	r1, r4, #160	@ 0xa0
 8015d5e:	2000      	movs	r0, #0
 8015d60:	f000 fe78 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d64:	4629      	mov	r1, r5
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, BFC | address);
 8015d66:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d68:	2000      	movs	r0, #0
 8015d6a:	f000 fe73 	bl	8016a54 <MIOS32_SPI_TransferByte>
  CSN_1;
 8015d6e:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d70:	4304      	orrs	r4, r0
  CSN_1;
 8015d72:	4611      	mov	r1, r2
 8015d74:	2000      	movs	r0, #0
 8015d76:	f000 fe37 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015d7a:	4620      	mov	r0, r4
 8015d7c:	bd38      	pop	{r3, r4, r5, pc}

08015d7e <MIOS32_ENC28J60_BFSReg>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_BFSReg(u8 address, u8 data)
{
  s32 status = 0;

  CSN_0;
 8015d7e:	2200      	movs	r2, #0
{
 8015d80:	b538      	push	{r3, r4, r5, lr}
 8015d82:	4604      	mov	r4, r0
 8015d84:	460d      	mov	r5, r1
  CSN_0;
 8015d86:	4610      	mov	r0, r2
 8015d88:	2101      	movs	r1, #1
 8015d8a:	f000 fe2d 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, BFS | address);
 8015d8e:	f044 0180 	orr.w	r1, r4, #128	@ 0x80
 8015d92:	2000      	movs	r0, #0
 8015d94:	f000 fe5e 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d98:	4629      	mov	r1, r5
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, BFS | address);
 8015d9a:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015d9c:	2000      	movs	r0, #0
 8015d9e:	f000 fe59 	bl	8016a54 <MIOS32_SPI_TransferByte>
  CSN_1;
 8015da2:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, data);
 8015da4:	4304      	orrs	r4, r0
  CSN_1;
 8015da6:	4611      	mov	r1, r2
 8015da8:	2000      	movs	r0, #0
 8015daa:	f000 fe1d 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015dae:	4620      	mov	r0, r4
 8015db0:	bd38      	pop	{r3, r4, r5, pc}

08015db2 <MIOS32_ENC28J60_BankSel>:
//!
//! \param[in] reg Register address with the high byte containing the two bank select bits.
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_BankSel(u16 reg)
{
 8015db2:	b538      	push	{r3, r4, r5, lr}
  s32 status = 0;

  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
 8015db4:	2103      	movs	r1, #3
{
 8015db6:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
 8015db8:	201f      	movs	r0, #31
 8015dba:	f7ff ffc6 	bl	8015d4a <MIOS32_ENC28J60_BFCReg>
  status |= MIOS32_ENC28J60_BFSReg(ECON1, (u8)(reg>>8));
 8015dbe:	0a29      	lsrs	r1, r5, #8
  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0);
 8015dc0:	4604      	mov	r4, r0
  status |= MIOS32_ENC28J60_BFSReg(ECON1, (u8)(reg>>8));
 8015dc2:	201f      	movs	r0, #31
 8015dc4:	f7ff ffdb 	bl	8015d7e <MIOS32_ENC28J60_BFSReg>

  return status;
}
 8015dc8:	4320      	orrs	r0, r4
 8015dca:	bd38      	pop	{r3, r4, r5, pc}

08015dcc <MIOS32_ENC28J60_MAC_AddrSet>:
{
 8015dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 )
 8015dce:	2100      	movs	r1, #0
{
 8015dd0:	b089      	sub	sp, #36	@ 0x24
 8015dd2:	4605      	mov	r5, r0
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 )
 8015dd4:	2201      	movs	r2, #1
 8015dd6:	4608      	mov	r0, r1
 8015dd8:	f000 fe56 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
 8015ddc:	1e06      	subs	r6, r0, #0
 8015dde:	db33      	blt.n	8015e48 <MIOS32_ENC28J60_MAC_AddrSet+0x7c>
 8015de0:	1e6b      	subs	r3, r5, #1
 8015de2:	1d6a      	adds	r2, r5, #5
  int ored = 0;
 8015de4:	2700      	movs	r7, #0
    ored |= new_mac_addr[i];
 8015de6:	f813 1f01 	ldrb.w	r1, [r3, #1]!
  for(i=0; i<6; ++i)
 8015dea:	4293      	cmp	r3, r2
    ored |= new_mac_addr[i];
 8015dec:	ea47 0701 	orr.w	r7, r7, r1
  for(i=0; i<6; ++i)
 8015df0:	d1f9      	bne.n	8015de6 <MIOS32_ENC28J60_MAC_AddrSet+0x1a>
  if( ored ) {
 8015df2:	4c30      	ldr	r4, [pc, #192]	@ (8015eb4 <MIOS32_ENC28J60_MAC_AddrSet+0xe8>)
 8015df4:	b35f      	cbz	r7, 8015e4e <MIOS32_ENC28J60_MAC_AddrSet+0x82>
    memcpy(mac_addr, new_mac_addr, 6);
 8015df6:	682b      	ldr	r3, [r5, #0]
 8015df8:	6023      	str	r3, [r4, #0]
 8015dfa:	88ab      	ldrh	r3, [r5, #4]
 8015dfc:	80a3      	strh	r3, [r4, #4]
  status |= MIOS32_ENC28J60_BankSel(MAADR1);
 8015dfe:	f44f 7041 	mov.w	r0, #772	@ 0x304
 8015e02:	f7ff ffd6 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR1, mac_addr[0]);
 8015e06:	7821      	ldrb	r1, [r4, #0]
  status |= MIOS32_ENC28J60_BankSel(MAADR1);
 8015e08:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR1, mac_addr[0]);
 8015e0a:	2004      	movs	r0, #4
 8015e0c:	f7ff ff83 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR2, mac_addr[1]);
 8015e10:	7861      	ldrb	r1, [r4, #1]
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR1, mac_addr[0]);
 8015e12:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR2, mac_addr[1]);
 8015e14:	2005      	movs	r0, #5
 8015e16:	f7ff ff7e 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR1, mac_addr[0]);
 8015e1a:	4335      	orrs	r5, r6
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR3, mac_addr[2]);
 8015e1c:	78a1      	ldrb	r1, [r4, #2]
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR2, mac_addr[1]);
 8015e1e:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR3, mac_addr[2]);
 8015e20:	2002      	movs	r0, #2
 8015e22:	f7ff ff78 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR4, mac_addr[3]);
 8015e26:	78e1      	ldrb	r1, [r4, #3]
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR3, mac_addr[2]);
 8015e28:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR4, mac_addr[3]);
 8015e2a:	2003      	movs	r0, #3
 8015e2c:	f7ff ff73 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR5, mac_addr[4]);
 8015e30:	7921      	ldrb	r1, [r4, #4]
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR4, mac_addr[3]);
 8015e32:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR5, mac_addr[4]);
 8015e34:	2000      	movs	r0, #0
 8015e36:	f7ff ff6e 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR6, mac_addr[5]);
 8015e3a:	7961      	ldrb	r1, [r4, #5]
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR5, mac_addr[4]);
 8015e3c:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAADR6, mac_addr[5]);
 8015e3e:	2001      	movs	r0, #1
 8015e40:	f7ff ff69 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 8015e44:	ea45 0600 	orr.w	r6, r5, r0
}
 8015e48:	4630      	mov	r0, r6
 8015e4a:	b009      	add	sp, #36	@ 0x24
 8015e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    MIOS32_SYS_SerialNumberGet(serial);
 8015e4e:	4668      	mov	r0, sp
 8015e50:	f000 fb5c 	bl	801650c <MIOS32_SYS_SerialNumberGet>
    int len = strlen(serial);
 8015e54:	4668      	mov	r0, sp
 8015e56:	f00d fb59 	bl	802350c <strlen>
    if( len < 12 ) {
 8015e5a:	280b      	cmp	r0, #11
	mac_addr[i] = i;
 8015e5c:	7027      	strb	r7, [r4, #0]
    if( len < 12 ) {
 8015e5e:	d80a      	bhi.n	8015e76 <MIOS32_ENC28J60_MAC_AddrSet+0xaa>
	mac_addr[i] = i;
 8015e60:	2301      	movs	r3, #1
 8015e62:	7063      	strb	r3, [r4, #1]
 8015e64:	2302      	movs	r3, #2
 8015e66:	70a3      	strb	r3, [r4, #2]
 8015e68:	2303      	movs	r3, #3
 8015e6a:	70e3      	strb	r3, [r4, #3]
 8015e6c:	2304      	movs	r3, #4
 8015e6e:	7123      	strb	r3, [r4, #4]
 8015e70:	2305      	movs	r3, #5
 8015e72:	7163      	strb	r3, [r4, #5]
      for(i=0; i<6; ++i)
 8015e74:	e7c3      	b.n	8015dfe <MIOS32_ENC28J60_MAC_AddrSet+0x32>
      for(i=1; i<6; ++i) {
 8015e76:	4468      	add	r0, sp
 8015e78:	4625      	mov	r5, r4
 8015e7a:	2101      	movs	r1, #1
	char digitl = serial[len-(i-1)*2 - 1];
 8015e7c:	f810 3c01 	ldrb.w	r3, [r0, #-1]
	char digith = serial[len-(i-1)*2 - 2];
 8015e80:	f810 2c02 	ldrb.w	r2, [r0, #-2]
	mac_addr[i] = ((digitl >= 'A') ? (digitl-'A'+10) : (digitl-'0')) |
 8015e84:	2b40      	cmp	r3, #64	@ 0x40
 8015e86:	bf8c      	ite	hi
 8015e88:	3b37      	subhi	r3, #55	@ 0x37
 8015e8a:	3b30      	subls	r3, #48	@ 0x30
 8015e8c:	2a40      	cmp	r2, #64	@ 0x40
	  (((digith >= 'A') ? (digith-'A'+10) : (digith-'0')) << 4);
 8015e8e:	bf85      	ittet	hi
 8015e90:	3a37      	subhi	r2, #55	@ 0x37
 8015e92:	0112      	lslhi	r2, r2, #4
 8015e94:	f342 0203 	sbfxls	r2, r2, #0, #4
	mac_addr[i] = ((digitl >= 'A') ? (digitl-'A'+10) : (digitl-'0')) |
 8015e98:	b252      	sxtbhi	r2, r2
 8015e9a:	bf98      	it	ls
 8015e9c:	0112      	lslls	r2, r2, #4
 8015e9e:	b25b      	sxtb	r3, r3
      for(i=1; i<6; ++i) {
 8015ea0:	3101      	adds	r1, #1
	mac_addr[i] = ((digitl >= 'A') ? (digitl-'A'+10) : (digitl-'0')) |
 8015ea2:	4313      	orrs	r3, r2
      for(i=1; i<6; ++i) {
 8015ea4:	2906      	cmp	r1, #6
	mac_addr[i] = ((digitl >= 'A') ? (digitl-'A'+10) : (digitl-'0')) |
 8015ea6:	f805 3f01 	strb.w	r3, [r5, #1]!
      for(i=1; i<6; ++i) {
 8015eaa:	f1a0 0002 	sub.w	r0, r0, #2
 8015eae:	d1e5      	bne.n	8015e7c <MIOS32_ENC28J60_MAC_AddrSet+0xb0>
 8015eb0:	e7a5      	b.n	8015dfe <MIOS32_ENC28J60_MAC_AddrSet+0x32>
 8015eb2:	bf00      	nop
 8015eb4:	200031cc 	.word	0x200031cc

08015eb8 <MIOS32_ENC28J60_MACDiscardRx>:
{
 8015eb8:	b538      	push	{r3, r4, r5, lr}
  if( WasDiscarded )
 8015eba:	4b13      	ldr	r3, [pc, #76]	@ (8015f08 <MIOS32_ENC28J60_MACDiscardRx+0x50>)
 8015ebc:	781a      	ldrb	r2, [r3, #0]
 8015ebe:	bb02      	cbnz	r2, 8015f02 <MIOS32_ENC28J60_MACDiscardRx+0x4a>
  WasDiscarded = 1;
 8015ec0:	2201      	movs	r2, #1
 8015ec2:	701a      	strb	r2, [r3, #0]
  u16 NewRXRDLocation = NextPacketLocation - 1;
 8015ec4:	4b11      	ldr	r3, [pc, #68]	@ (8015f0c <MIOS32_ENC28J60_MACDiscardRx+0x54>)
 8015ec6:	881d      	ldrh	r5, [r3, #0]
 8015ec8:	3d01      	subs	r5, #1
  if( NewRXRDLocation > RXSTOP )
 8015eca:	f640 73ff 	movw	r3, #4095	@ 0xfff
 8015ece:	b2ad      	uxth	r5, r5
 8015ed0:	429d      	cmp	r5, r3
  status |= MIOS32_ENC28J60_BFSReg(ECON2, ECON2_PKTDEC);
 8015ed2:	f04f 0140 	mov.w	r1, #64	@ 0x40
 8015ed6:	f04f 001e 	mov.w	r0, #30
  if( NewRXRDLocation > RXSTOP )
 8015eda:	bf28      	it	cs
 8015edc:	461d      	movcs	r5, r3
  status |= MIOS32_ENC28J60_BFSReg(ECON2, ECON2_PKTDEC);
 8015ede:	f7ff ff4e 	bl	8015d7e <MIOS32_ENC28J60_BFSReg>
 8015ee2:	4604      	mov	r4, r0
  status |= MIOS32_ENC28J60_BankSel(ERXRDPTL);
 8015ee4:	200c      	movs	r0, #12
 8015ee6:	f7ff ff64 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, NewRXRDLocation & 0xff);
 8015eea:	b2e9      	uxtb	r1, r5
  status |= MIOS32_ENC28J60_BankSel(ERXRDPTL);
 8015eec:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, NewRXRDLocation & 0xff);
 8015eee:	200c      	movs	r0, #12
 8015ef0:	f7ff ff11 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTH, (NewRXRDLocation >> 8) & 0xff);
 8015ef4:	0a29      	lsrs	r1, r5, #8
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, NewRXRDLocation & 0xff);
 8015ef6:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTH, (NewRXRDLocation >> 8) & 0xff);
 8015ef8:	200d      	movs	r0, #13
 8015efa:	f7ff ff0c 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 8015efe:	4320      	orrs	r0, r4
}
 8015f00:	bd38      	pop	{r3, r4, r5, pc}
    return 0;
 8015f02:	2000      	movs	r0, #0
 8015f04:	e7fc      	b.n	8015f00 <MIOS32_ENC28J60_MACDiscardRx+0x48>
 8015f06:	bf00      	nop
 8015f08:	200031d6 	.word	0x200031d6
 8015f0c:	200031d4 	.word	0x200031d4

08015f10 <MIOS32_ENC28J60_WritePHYReg>:
{
 8015f10:	b570      	push	{r4, r5, r6, lr}
 8015f12:	4606      	mov	r6, r0
  status |= MIOS32_ENC28J60_BankSel(MIREGADR);
 8015f14:	f44f 7005 	mov.w	r0, #532	@ 0x214
{
 8015f18:	460d      	mov	r5, r1
  status |= MIOS32_ENC28J60_BankSel(MIREGADR);
 8015f1a:	f7ff ff4a 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg((u8)MIREGADR, reg);
 8015f1e:	4631      	mov	r1, r6
  status |= MIOS32_ENC28J60_BankSel(MIREGADR);
 8015f20:	4604      	mov	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MIREGADR, reg);
 8015f22:	2014      	movs	r0, #20
 8015f24:	f7ff fef7 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MIWRL, data & 0xff);
 8015f28:	b2e9      	uxtb	r1, r5
  status |= MIOS32_ENC28J60_WriteReg((u8)MIREGADR, reg);
 8015f2a:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MIWRL, data & 0xff);
 8015f2c:	2016      	movs	r0, #22
 8015f2e:	f7ff fef2 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MIWRH, data >> 8);
 8015f32:	0a29      	lsrs	r1, r5, #8
  status |= MIOS32_ENC28J60_WriteReg((u8)MIWRL, data & 0xff);
 8015f34:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MIWRH, data >> 8);
 8015f36:	2017      	movs	r0, #23
 8015f38:	f7ff feed 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 8015f3c:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_BankSel(MISTAT);
 8015f3e:	f240 300a 	movw	r0, #778	@ 0x30a
 8015f42:	f7ff ff36 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  if( status >= 0 ) {
 8015f46:	4320      	orrs	r0, r4
 8015f48:	d406      	bmi.n	8015f58 <MIOS32_ENC28J60_WritePHYReg+0x48>
      status = MIOS32_ENC28J60_ReadMACReg((u8)MISTAT);
 8015f4a:	200a      	movs	r0, #10
 8015f4c:	f7ff fec5 	bl	8015cda <MIOS32_ENC28J60_ReadMACReg>
    } while( status >= 0 && (status & MISTAT_BUSY) );
 8015f50:	2800      	cmp	r0, #0
 8015f52:	db01      	blt.n	8015f58 <MIOS32_ENC28J60_WritePHYReg+0x48>
 8015f54:	07c3      	lsls	r3, r0, #31
 8015f56:	d4f8      	bmi.n	8015f4a <MIOS32_ENC28J60_WritePHYReg+0x3a>
}
 8015f58:	bd70      	pop	{r4, r5, r6, pc}

08015f5a <MIOS32_ENC28J60_SendSystemReset>:
  // have all clocks running
  MIOS32_DELAY_Wait_uS(1000); // 1 mS
#endif
  // Execute the System Reset command
  status = 0;
  CSN_0;
 8015f5a:	2200      	movs	r2, #0
{
 8015f5c:	b510      	push	{r4, lr}
  CSN_0;
 8015f5e:	4610      	mov	r0, r2
 8015f60:	2101      	movs	r1, #1
 8015f62:	f000 fd41 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, SR);
 8015f66:	21ff      	movs	r1, #255	@ 0xff
 8015f68:	2000      	movs	r0, #0
 8015f6a:	f000 fd73 	bl	8016a54 <MIOS32_SPI_TransferByte>
  CSN_1;
 8015f6e:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, SR);
 8015f70:	4604      	mov	r4, r0
  CSN_1;
 8015f72:	4611      	mov	r1, r2
 8015f74:	2000      	movs	r0, #0
 8015f76:	f000 fd37 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  if( status < 0 )
 8015f7a:	2c00      	cmp	r4, #0
 8015f7c:	db04      	blt.n	8015f88 <MIOS32_ENC28J60_SendSystemReset+0x2e>
    return status;

  // Wait for the oscillator start up timer and PHY to become ready
  MIOS32_DELAY_Wait_uS(1000); // 1 mS
 8015f7e:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 8015f82:	f001 fa1f 	bl	80173c4 <MIOS32_DELAY_Wait_uS>

  return 0; // no error
 8015f86:	2400      	movs	r4, #0
}
 8015f88:	4620      	mov	r0, r4
 8015f8a:	bd10      	pop	{r4, pc}

08015f8c <MIOS32_ENC28J60_MACGetArray>:
//! \param[in] buffer target buffer
//! \param[in] len number of bytes which should be read
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_MACGetArray(u8 *buffer, u16 len)
{
 8015f8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s32 status = 0;

  CSN_0;
 8015f8e:	2200      	movs	r2, #0
{
 8015f90:	4606      	mov	r6, r0
 8015f92:	460f      	mov	r7, r1
  CSN_0;
 8015f94:	4610      	mov	r0, r2
 8015f96:	2101      	movs	r1, #1
 8015f98:	f000 fd26 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, RBM);
 8015f9c:	213a      	movs	r1, #58	@ 0x3a
 8015f9e:	2000      	movs	r0, #0
 8015fa0:	f000 fd58 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, NULL, buffer, len, NULL);
 8015fa4:	2500      	movs	r5, #0
 8015fa6:	463b      	mov	r3, r7
 8015fa8:	4632      	mov	r2, r6
 8015faa:	4629      	mov	r1, r5
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, RBM);
 8015fac:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, NULL, buffer, len, NULL);
 8015fae:	9500      	str	r5, [sp, #0]
 8015fb0:	4628      	mov	r0, r5
 8015fb2:	f000 ff09 	bl	8016dc8 <MIOS32_SPI_TransferBlock>
  CSN_1;
 8015fb6:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, NULL, buffer, len, NULL);
 8015fb8:	4304      	orrs	r4, r0
  CSN_1;
 8015fba:	4611      	mov	r1, r2
 8015fbc:	4628      	mov	r0, r5
 8015fbe:	f000 fd13 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015fc2:	4620      	mov	r0, r4
 8015fc4:	b003      	add	sp, #12
 8015fc6:	bdf0      	pop	{r4, r5, r6, r7, pc}

08015fc8 <MIOS32_ENC28J60_MACPut>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_MACPut(u8 value)
{
  s32 status = 0;

  CSN_0;
 8015fc8:	2200      	movs	r2, #0
{
 8015fca:	b538      	push	{r3, r4, r5, lr}
  CSN_0;
 8015fcc:	2101      	movs	r1, #1
{
 8015fce:	4605      	mov	r5, r0
  CSN_0;
 8015fd0:	4610      	mov	r0, r2
 8015fd2:	f000 fd09 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WBM);
 8015fd6:	217a      	movs	r1, #122	@ 0x7a
 8015fd8:	2000      	movs	r0, #0
 8015fda:	f000 fd3b 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, value);
 8015fde:	4629      	mov	r1, r5
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WBM);
 8015fe0:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, value);
 8015fe2:	2000      	movs	r0, #0
 8015fe4:	f000 fd36 	bl	8016a54 <MIOS32_SPI_TransferByte>
  CSN_1;
 8015fe8:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, value);
 8015fea:	4304      	orrs	r4, r0
  CSN_1;
 8015fec:	4611      	mov	r1, r2
 8015fee:	2000      	movs	r0, #0
 8015ff0:	f000 fcfa 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8015ff4:	4620      	mov	r0, r4
 8015ff6:	bd38      	pop	{r3, r4, r5, pc}

08015ff8 <MIOS32_ENC28J60_PowerOn>:
  CSN_1;
 8015ff8:	2201      	movs	r2, #1
{
 8015ffa:	b570      	push	{r4, r5, r6, lr}
  CSN_1;
 8015ffc:	4611      	mov	r1, r2
 8015ffe:	2000      	movs	r0, #0
 8016000:	f000 fcf2 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  MIOS32_SPI_IO_Init(MIOS32_ENC28J60_SPI, MIOS32_SPI_PIN_DRIVER_STRONG);
 8016004:	2100      	movs	r1, #0
 8016006:	4608      	mov	r0, r1
 8016008:	f000 fbba 	bl	8016780 <MIOS32_SPI_IO_Init>
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 801600c:	2100      	movs	r1, #0
 801600e:	2201      	movs	r2, #1
 8016010:	4608      	mov	r0, r1
 8016012:	f000 fd39 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
 8016016:	1e06      	subs	r6, r0, #0
 8016018:	f2c0 80be 	blt.w	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
  if( (status=MIOS32_ENC28J60_SendSystemReset()) < 0 )
 801601c:	f7ff ff9d 	bl	8015f5a <MIOS32_ENC28J60_SendSystemReset>
 8016020:	1e06      	subs	r6, r0, #0
 8016022:	f2c0 80b9 	blt.w	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
  if( (status=MIOS32_ENC28J60_ReadETHReg(ESTAT)) < 0 )
 8016026:	201d      	movs	r0, #29
 8016028:	f7ff fe3e 	bl	8015ca8 <MIOS32_ENC28J60_ReadETHReg>
 801602c:	1e06      	subs	r6, r0, #0
 801602e:	f2c0 80b3 	blt.w	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
  if( (status & 0x08) || !(status & ESTAT_CLKRDY) )
 8016032:	f006 0409 	and.w	r4, r6, #9
 8016036:	2c01      	cmp	r4, #1
 8016038:	f040 80b0 	bne.w	801619c <MIOS32_ENC28J60_PowerOn+0x1a4>
  MIOS32_ENC28J60_BankSel(EREVID);
 801603c:	f240 3012 	movw	r0, #786	@ 0x312
 8016040:	f7ff feb7 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  if( (status=MIOS32_ENC28J60_ReadMACReg((u8)EREVID)) < 0 )
 8016044:	2012      	movs	r0, #18
 8016046:	f7ff fe48 	bl	8015cda <MIOS32_ENC28J60_ReadMACReg>
 801604a:	1e06      	subs	r6, r0, #0
 801604c:	f2c0 80a4 	blt.w	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
  rev_id = status;
 8016050:	4a55      	ldr	r2, [pc, #340]	@ (80161a8 <MIOS32_ENC28J60_PowerOn+0x1b0>)
 8016052:	b2f3      	uxtb	r3, r6
 8016054:	7013      	strb	r3, [r2, #0]
  if( !rev_id || rev_id >= 32 ) {
 8016056:	3b01      	subs	r3, #1
 8016058:	2b1e      	cmp	r3, #30
 801605a:	f200 80a2 	bhi.w	80161a2 <MIOS32_ENC28J60_PowerOn+0x1aa>
  WasDiscarded = 1;
 801605e:	4b53      	ldr	r3, [pc, #332]	@ (80161ac <MIOS32_ENC28J60_PowerOn+0x1b4>)
 8016060:	701c      	strb	r4, [r3, #0]
  NextPacketLocation = RXSTART;
 8016062:	4b53      	ldr	r3, [pc, #332]	@ (80161b0 <MIOS32_ENC28J60_PowerOn+0x1b8>)
 8016064:	2500      	movs	r5, #0
  MIOS32_ENC28J60_BankSel(ERXSTL);
 8016066:	2008      	movs	r0, #8
  NextPacketLocation = RXSTART;
 8016068:	801d      	strh	r5, [r3, #0]
  MIOS32_ENC28J60_BankSel(ERXSTL);
 801606a:	f7ff fea2 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg(ERXSTL,   (RXSTART) & 0xff);
 801606e:	4629      	mov	r1, r5
 8016070:	2008      	movs	r0, #8
 8016072:	f7ff fe50 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXSTH,   ((RXSTART) >> 8) & 0xff);
 8016076:	4629      	mov	r1, r5
  status |= MIOS32_ENC28J60_WriteReg(ERXSTL,   (RXSTART) & 0xff);
 8016078:	4604      	mov	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXSTH,   ((RXSTART) >> 8) & 0xff);
 801607a:	2009      	movs	r0, #9
 801607c:	f7ff fe4b 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, (RXSTOP) & 0xff);
 8016080:	21ff      	movs	r1, #255	@ 0xff
  status |= MIOS32_ENC28J60_WriteReg(ERXSTH,   ((RXSTART) >> 8) & 0xff);
 8016082:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, (RXSTOP) & 0xff);
 8016084:	200c      	movs	r0, #12
 8016086:	f7ff fe46 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXSTH,   ((RXSTART) >> 8) & 0xff);
 801608a:	4334      	orrs	r4, r6
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTL, (RXSTOP) & 0xff);
 801608c:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTH, ((RXSTOP) >> 8) & 0xff);
 801608e:	210f      	movs	r1, #15
 8016090:	200d      	movs	r0, #13
 8016092:	f7ff fe40 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXNDL,   (RXSTOP) & 0xff);
 8016096:	21ff      	movs	r1, #255	@ 0xff
  status |= MIOS32_ENC28J60_WriteReg(ERXRDPTH, ((RXSTOP) >> 8) & 0xff);
 8016098:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXNDL,   (RXSTOP) & 0xff);
 801609a:	200a      	movs	r0, #10
 801609c:	f7ff fe3b 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERXNDH,   ((RXSTOP) >> 8) & 0xff);
 80160a0:	210f      	movs	r1, #15
  status |= MIOS32_ENC28J60_WriteReg(ERXNDL,   (RXSTOP) & 0xff);
 80160a2:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ERXNDH,   ((RXSTOP) >> 8) & 0xff);
 80160a4:	200b      	movs	r0, #11
 80160a6:	f7ff fe36 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ETXSTL,   (TXSTART) & 0xff);
 80160aa:	4629      	mov	r1, r5
  status |= MIOS32_ENC28J60_WriteReg(ERXNDH,   ((RXSTOP) >> 8) & 0xff);
 80160ac:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ETXSTL,   (TXSTART) & 0xff);
 80160ae:	2004      	movs	r0, #4
 80160b0:	f7ff fe31 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ETXSTH,   ((TXSTART) >> 8) & 0xff);
 80160b4:	2110      	movs	r1, #16
  status |= MIOS32_ENC28J60_WriteReg(ETXSTL,   (TXSTART) & 0xff);
 80160b6:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(ETXSTH,   ((TXSTART) >> 8) & 0xff);
 80160b8:	2005      	movs	r0, #5
 80160ba:	f7ff fe2c 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL,   (TXSTART) & 0xff);
 80160be:	4629      	mov	r1, r5
  status |= MIOS32_ENC28J60_WriteReg(ETXSTH,   ((TXSTART) >> 8) & 0xff);
 80160c0:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL,   (TXSTART) & 0xff);
 80160c2:	2002      	movs	r0, #2
 80160c4:	f7ff fe27 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(EWRPTH,   ((TXSTART) >> 8) & 0xff);
 80160c8:	2110      	movs	r1, #16
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL,   (TXSTART) & 0xff);
 80160ca:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg(EWRPTH,   ((TXSTART) >> 8) & 0xff);
 80160cc:	2003      	movs	r0, #3
 80160ce:	f7ff fe22 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 80160d2:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_MACPut(0x00);
 80160d4:	4628      	mov	r0, r5
 80160d6:	f7ff ff77 	bl	8015fc8 <MIOS32_ENC28J60_MACPut>
 80160da:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_BankSel(MACON1);
 80160dc:	f44f 7000 	mov.w	r0, #512	@ 0x200
 80160e0:	f7ff fe67 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
 80160e4:	210d      	movs	r1, #13
  status |= MIOS32_ENC28J60_BankSel(MACON1);
 80160e6:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
 80160e8:	4628      	mov	r0, r5
 80160ea:	f7ff fe14 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX);
 80160ee:	2133      	movs	r1, #51	@ 0x33
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN);
 80160f0:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX);
 80160f2:	2002      	movs	r0, #2
 80160f4:	f7ff fe0f 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MABBIPG, 0x15);  
 80160f8:	2115      	movs	r1, #21
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX);
 80160fa:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MABBIPG, 0x15);  
 80160fc:	2004      	movs	r0, #4
 80160fe:	f7ff fe0a 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON4, MACON4_DEFER);
 8016102:	2140      	movs	r1, #64	@ 0x40
  status |= MIOS32_ENC28J60_WriteReg((u8)MABBIPG, 0x15);  
 8016104:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON4, MACON4_DEFER);
 8016106:	2003      	movs	r0, #3
 8016108:	f7ff fe05 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MACLCON2, 63);
 801610c:	213f      	movs	r1, #63	@ 0x3f
  status |= MIOS32_ENC28J60_WriteReg((u8)MACON4, MACON4_DEFER);
 801610e:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MACLCON2, 63);
 8016110:	2009      	movs	r0, #9
 8016112:	f7ff fe00 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGL, 0x12);
 8016116:	2112      	movs	r1, #18
  status |= MIOS32_ENC28J60_WriteReg((u8)MACLCON2, 63);
 8016118:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGL, 0x12);
 801611a:	2006      	movs	r0, #6
 801611c:	f7ff fdfb 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGH, 0x0C);
 8016120:	210c      	movs	r1, #12
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGL, 0x12);
 8016122:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGH, 0x0C);
 8016124:	2007      	movs	r0, #7
 8016126:	f7ff fdf6 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAMXFLL, (MIOS32_ENC28J60_MAX_FRAME_SIZE) & 0xff);
 801612a:	21ee      	movs	r1, #238	@ 0xee
  status |= MIOS32_ENC28J60_WriteReg((u8)MAIPGH, 0x0C);
 801612c:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAMXFLL, (MIOS32_ENC28J60_MAX_FRAME_SIZE) & 0xff);
 801612e:	200a      	movs	r0, #10
 8016130:	f7ff fdf1 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg((u8)MAMXFLH, ((MIOS32_ENC28J60_MAX_FRAME_SIZE) >> 8) & 0xff);
 8016134:	2105      	movs	r1, #5
  status |= MIOS32_ENC28J60_WriteReg((u8)MAMXFLL, (MIOS32_ENC28J60_MAX_FRAME_SIZE) & 0xff);
 8016136:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)MAMXFLH, ((MIOS32_ENC28J60_MAX_FRAME_SIZE) >> 8) & 0xff);
 8016138:	200b      	movs	r0, #11
 801613a:	f7ff fdec 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 801613e:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_MAC_AddrSet(mac_addr);
 8016140:	481c      	ldr	r0, [pc, #112]	@ (80161b4 <MIOS32_ENC28J60_PowerOn+0x1bc>)
 8016142:	f7ff fe43 	bl	8015dcc <MIOS32_ENC28J60_MAC_AddrSet>
 8016146:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_BankSel(ECOCON);
 8016148:	f240 3015 	movw	r0, #789	@ 0x315
 801614c:	f7ff fe31 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg((u8)ECOCON, 0x00);   // Output off (0V)
 8016150:	4629      	mov	r1, r5
  status |= MIOS32_ENC28J60_BankSel(ECOCON);
 8016152:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WriteReg((u8)ECOCON, 0x00);   // Output off (0V)
 8016154:	2015      	movs	r0, #21
 8016156:	f7ff fdde 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WritePHYReg(PHCON2, PHCON2_HDLDIS);
 801615a:	f44f 7180 	mov.w	r1, #256	@ 0x100
  status |= MIOS32_ENC28J60_WriteReg((u8)ECOCON, 0x00);   // Output off (0V)
 801615e:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WritePHYReg(PHCON2, PHCON2_HDLDIS);
 8016160:	2010      	movs	r0, #16
 8016162:	f7ff fed5 	bl	8015f10 <MIOS32_ENC28J60_WritePHYReg>
  status |= MIOS32_ENC28J60_WritePHYReg(PHLCON, 0x3472);
 8016166:	f243 4172 	movw	r1, #13426	@ 0x3472
  status |= MIOS32_ENC28J60_WritePHYReg(PHCON2, PHCON2_HDLDIS);
 801616a:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WritePHYReg(PHLCON, 0x3472);
 801616c:	2014      	movs	r0, #20
 801616e:	f7ff fecf 	bl	8015f10 <MIOS32_ENC28J60_WritePHYReg>
  status |= MIOS32_ENC28J60_WritePHYReg(PHCON1, PHCON1_PDPXMD);
 8016172:	f44f 7180 	mov.w	r1, #256	@ 0x100
  status |= MIOS32_ENC28J60_WritePHYReg(PHLCON, 0x3472);
 8016176:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_WritePHYReg(PHCON1, PHCON1_PDPXMD);
 8016178:	4628      	mov	r0, r5
 801617a:	f7ff fec9 	bl	8015f10 <MIOS32_ENC28J60_WritePHYReg>
 801617e:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_BankSel(ERDPTL);                // Return to default Bank 0
 8016180:	4628      	mov	r0, r5
 8016182:	f7ff fe16 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_RXEN);
 8016186:	2104      	movs	r1, #4
  status |= MIOS32_ENC28J60_BankSel(ERDPTL);                // Return to default Bank 0
 8016188:	4304      	orrs	r4, r0
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_RXEN);
 801618a:	201f      	movs	r0, #31
 801618c:	f7ff fdf7 	bl	8015d7e <MIOS32_ENC28J60_BFSReg>
 8016190:	ea44 0600 	orr.w	r6, r4, r0
  return (status < 0) ? status : 0;
 8016194:	ea06 76e6 	and.w	r6, r6, r6, asr #31
}
 8016198:	4630      	mov	r0, r6
 801619a:	bd70      	pop	{r4, r5, r6, pc}
    return -16; // no access to chip
 801619c:	f06f 060f 	mvn.w	r6, #15
 80161a0:	e7fa      	b.n	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
    return -17; // unsupported revision ID
 80161a2:	f06f 0610 	mvn.w	r6, #16
 80161a6:	e7f7      	b.n	8016198 <MIOS32_ENC28J60_PowerOn+0x1a0>
 80161a8:	200031d2 	.word	0x200031d2
 80161ac:	200031d6 	.word	0x200031d6
 80161b0:	200031d4 	.word	0x200031d4
 80161b4:	200031cc 	.word	0x200031cc

080161b8 <MIOS32_ENC28J60_Init>:
{
 80161b8:	b082      	sub	sp, #8
  if( mode != 0 )
 80161ba:	b960      	cbnz	r0, 80161d6 <MIOS32_ENC28J60_Init+0x1e>
  u8 default_mac_addr[6] = {
 80161bc:	4b08      	ldr	r3, [pc, #32]	@ (80161e0 <MIOS32_ENC28J60_Init+0x28>)
 80161be:	6818      	ldr	r0, [r3, #0]
 80161c0:	889b      	ldrh	r3, [r3, #4]
 80161c2:	f8ad 3004 	strh.w	r3, [sp, #4]
  memcpy(mac_addr, default_mac_addr, 6);
 80161c6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 80161ca:	4b06      	ldr	r3, [pc, #24]	@ (80161e4 <MIOS32_ENC28J60_Init+0x2c>)
 80161cc:	6018      	str	r0, [r3, #0]
 80161ce:	809a      	strh	r2, [r3, #4]
}
 80161d0:	b002      	add	sp, #8
  ret=MIOS32_ENC28J60_PowerOn();
 80161d2:	f7ff bf11 	b.w	8015ff8 <MIOS32_ENC28J60_PowerOn>
}
 80161d6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80161da:	b002      	add	sp, #8
 80161dc:	4770      	bx	lr
 80161de:	bf00      	nop
 80161e0:	08026e51 	.word	0x08026e51
 80161e4:	200031cc 	.word	0x200031cc

080161e8 <MIOS32_ENC28J60_PackageReceive>:
{
 80161e8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80161ec:	460f      	mov	r7, r1
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 80161ee:	2100      	movs	r1, #0
{
 80161f0:	4606      	mov	r6, r0
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 80161f2:	2201      	movs	r2, #1
 80161f4:	4608      	mov	r0, r1
 80161f6:	f000 fc47 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
 80161fa:	1e04      	subs	r4, r0, #0
 80161fc:	db59      	blt.n	80162b2 <MIOS32_ENC28J60_PackageReceive+0xca>
  status |= MIOS32_ENC28J60_BankSel(EPKTCNT);
 80161fe:	f240 1019 	movw	r0, #281	@ 0x119
 8016202:	f7ff fdd6 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
 8016206:	4605      	mov	r5, r0
  package_count = MIOS32_ENC28J60_ReadETHReg((u8)EPKTCNT);
 8016208:	2019      	movs	r0, #25
 801620a:	f7ff fd4d 	bl	8015ca8 <MIOS32_ENC28J60_ReadETHReg>
 801620e:	4680      	mov	r8, r0
  status |= MIOS32_ENC28J60_BankSel(ERDPTL);
 8016210:	2000      	movs	r0, #0
 8016212:	f7ff fdce 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
 8016216:	ea45 0300 	orr.w	r3, r5, r0
  if( status < 0 ) 
 801621a:	431c      	orrs	r4, r3
 801621c:	d449      	bmi.n	80162b2 <MIOS32_ENC28J60_PackageReceive+0xca>
  if( package_count <= 0 ) {
 801621e:	f1b8 0f00 	cmp.w	r8, #0
 8016222:	dd63      	ble.n	80162ec <MIOS32_ENC28J60_PackageReceive+0x104>
  if( !WasDiscarded ) {
 8016224:	f8df 80cc 	ldr.w	r8, [pc, #204]	@ 80162f4 <MIOS32_ENC28J60_PackageReceive+0x10c>
 8016228:	f898 5000 	ldrb.w	r5, [r8]
 801622c:	b945      	cbnz	r5, 8016240 <MIOS32_ENC28J60_PackageReceive+0x58>
    status = MIOS32_ENC28J60_MACDiscardRx(); // discard package immediately
 801622e:	f7ff fe43 	bl	8015eb8 <MIOS32_ENC28J60_MACDiscardRx>
    status = (status < 0) ? status : 0;
 8016232:	ea00 74e0 	and.w	r4, r0, r0, asr #31
  return packet_len; // no error: return packet length
 8016236:	ea14 0424 	ands.w	r4, r4, r4, asr #32
 801623a:	bf38      	it	cc
 801623c:	462c      	movcc	r4, r5
 801623e:	e038      	b.n	80162b2 <MIOS32_ENC28J60_PackageReceive+0xca>
  u16 CurrentPacketLocation = NextPacketLocation;
 8016240:	f8df 90b4 	ldr.w	r9, [pc, #180]	@ 80162f8 <MIOS32_ENC28J60_PackageReceive+0x110>
  status |= MIOS32_ENC28J60_WriteReg(ERDPTL, CurrentPacketLocation & 0xff);
 8016244:	2000      	movs	r0, #0
 8016246:	f899 1000 	ldrb.w	r1, [r9]
  u16 CurrentPacketLocation = NextPacketLocation;
 801624a:	f8b9 a000 	ldrh.w	sl, [r9]
  status |= MIOS32_ENC28J60_WriteReg(ERDPTL, CurrentPacketLocation & 0xff);
 801624e:	f7ff fd62 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ERDPTH, (CurrentPacketLocation >> 8) & 0xff);
 8016252:	ea4f 211a 	mov.w	r1, sl, lsr #8
  status |= MIOS32_ENC28J60_WriteReg(ERDPTL, CurrentPacketLocation & 0xff);
 8016256:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_WriteReg(ERDPTH, (CurrentPacketLocation >> 8) & 0xff);
 8016258:	2001      	movs	r0, #1
 801625a:	f7ff fd5c 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 801625e:	ea45 0300 	orr.w	r3, r5, r0
  if( status < 0 )
 8016262:	431c      	orrs	r4, r3
 8016264:	d425      	bmi.n	80162b2 <MIOS32_ENC28J60_PackageReceive+0xca>
  status |= MIOS32_ENC28J60_MACGetArray((u8 *)&header, sizeof(header));
 8016266:	2106      	movs	r1, #6
 8016268:	a802      	add	r0, sp, #8
 801626a:	f7ff fe8f 	bl	8015f8c <MIOS32_ENC28J60_MACGetArray>
  if( header.NextPacketPointer > RXSTOP ||
 801626e:	f8bd 1008 	ldrh.w	r1, [sp, #8]
 8016272:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 8016276:	f5b1 5f80 	cmp.w	r1, #4096	@ 0x1000
 801627a:	d20b      	bcs.n	8016294 <MIOS32_ENC28J60_PackageReceive+0xac>
 801627c:	f011 0301 	ands.w	r3, r1, #1
 8016280:	d108      	bne.n	8016294 <MIOS32_ENC28J60_PackageReceive+0xac>
      (header.NextPacketPointer & 1) ||
 8016282:	f99d 000d 	ldrsb.w	r0, [sp, #13]
 8016286:	2800      	cmp	r0, #0
 8016288:	db04      	blt.n	8016294 <MIOS32_ENC28J60_PackageReceive+0xac>
      header.StatusVector.bits.Zero ||
 801628a:	f240 50ee 	movw	r0, #1518	@ 0x5ee
 801628e:	4282      	cmp	r2, r0
      header.StatusVector.bits.ByteCount > MIOS32_ENC28J60_MAX_FRAME_SIZE ) {
 8016290:	4615      	mov	r5, r2
      header.StatusVector.bits.Zero ||
 8016292:	d912      	bls.n	80162ba <MIOS32_ENC28J60_PackageReceive+0xd2>
    MIOS32_MIDI_SendDebugMessage("[MIOS32_ENC28J60_PackageReceive] glitch detected - Ptr: %04x, Status: %04x (max: %04x) %02x%02x\n",
 8016294:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8016298:	9301      	str	r3, [sp, #4]
 801629a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 801629e:	9300      	str	r3, [sp, #0]
 80162a0:	4816      	ldr	r0, [pc, #88]	@ (80162fc <MIOS32_ENC28J60_PackageReceive+0x114>)
 80162a2:	f240 53ee 	movw	r3, #1518	@ 0x5ee
 80162a6:	f7fe fc9f 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
    MIOS32_ENC28J60_PowerOn();
 80162aa:	f7ff fea5 	bl	8015ff8 <MIOS32_ENC28J60_PowerOn>
    status=-16;
 80162ae:	f06f 040f 	mvn.w	r4, #15
}
 80162b2:	4620      	mov	r0, r4
 80162b4:	b004      	add	sp, #16
 80162b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  NextPacketLocation = header.NextPacketPointer;
 80162ba:	f8a9 1000 	strh.w	r1, [r9]
  WasDiscarded = 0;
 80162be:	f888 3000 	strb.w	r3, [r8]
  if( !packet_len || header.StatusVector.bits.CRCError || !header.StatusVector.bits.ReceiveOk ) {
 80162c2:	2a00      	cmp	r2, #0
 80162c4:	d0b3      	beq.n	801622e <MIOS32_ENC28J60_PackageReceive+0x46>
 80162c6:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80162ca:	f003 0390 	and.w	r3, r3, #144	@ 0x90
 80162ce:	2b80      	cmp	r3, #128	@ 0x80
 80162d0:	d1ad      	bne.n	801622e <MIOS32_ENC28J60_PackageReceive+0x46>
  if( packet_len > buffer_size )
 80162d2:	4297      	cmp	r7, r2
 80162d4:	463d      	mov	r5, r7
 80162d6:	bf28      	it	cs
 80162d8:	4615      	movcs	r5, r2
  status = MIOS32_ENC28J60_MACGetArray(buffer, packet_len);
 80162da:	4629      	mov	r1, r5
 80162dc:	4630      	mov	r0, r6
 80162de:	f7ff fe55 	bl	8015f8c <MIOS32_ENC28J60_MACGetArray>
 80162e2:	4604      	mov	r4, r0
  status |= MIOS32_ENC28J60_MACDiscardRx();
 80162e4:	f7ff fde8 	bl	8015eb8 <MIOS32_ENC28J60_MACDiscardRx>
 80162e8:	4304      	orrs	r4, r0
 80162ea:	e7a4      	b.n	8016236 <MIOS32_ENC28J60_PackageReceive+0x4e>
 80162ec:	4644      	mov	r4, r8
  u16 packet_len = 0;
 80162ee:	2500      	movs	r5, #0
 80162f0:	e7a1      	b.n	8016236 <MIOS32_ENC28J60_PackageReceive+0x4e>
 80162f2:	bf00      	nop
 80162f4:	200031d6 	.word	0x200031d6
 80162f8:	200031d4 	.word	0x200031d4
 80162fc:	08026df0 	.word	0x08026df0

08016300 <MIOS32_ENC28J60_MACPutArray>:
//! \param[in] buffer source buffer
//! \param[in] len number of bytes which should be written
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_ENC28J60_MACPutArray(u8 *buffer, u16 len)
{
 8016300:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  s32 status = 0;

  CSN_0;
 8016302:	2200      	movs	r2, #0
{
 8016304:	4606      	mov	r6, r0
 8016306:	460f      	mov	r7, r1
  CSN_0;
 8016308:	4610      	mov	r0, r2
 801630a:	2101      	movs	r1, #1
 801630c:	f000 fb6c 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WBM);
 8016310:	217a      	movs	r1, #122	@ 0x7a
 8016312:	2000      	movs	r0, #0
 8016314:	f000 fb9e 	bl	8016a54 <MIOS32_SPI_TransferByte>
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, buffer, NULL, len, NULL);
 8016318:	2500      	movs	r5, #0
 801631a:	463b      	mov	r3, r7
 801631c:	462a      	mov	r2, r5
 801631e:	4631      	mov	r1, r6
  status |= MIOS32_SPI_TransferByte(MIOS32_ENC28J60_SPI, WBM);
 8016320:	4604      	mov	r4, r0
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, buffer, NULL, len, NULL);
 8016322:	9500      	str	r5, [sp, #0]
 8016324:	4628      	mov	r0, r5
 8016326:	f000 fd4f 	bl	8016dc8 <MIOS32_SPI_TransferBlock>
  CSN_1;
 801632a:	2201      	movs	r2, #1
  status |= MIOS32_SPI_TransferBlock(MIOS32_ENC28J60_SPI, buffer, NULL, len, NULL);
 801632c:	4304      	orrs	r4, r0
  CSN_1;
 801632e:	4611      	mov	r1, r2
 8016330:	4628      	mov	r0, r5
 8016332:	f000 fb59 	bl	80169e8 <MIOS32_SPI_RC_PinSet>

  return status;
}
 8016336:	4620      	mov	r0, r4
 8016338:	b003      	add	sp, #12
 801633a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0801633c <MIOS32_ENC28J60_PackageSend>:
{
 801633c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016340:	4688      	mov	r8, r1
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 8016342:	2100      	movs	r1, #0
{
 8016344:	4681      	mov	r9, r0
 8016346:	4617      	mov	r7, r2
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 8016348:	4608      	mov	r0, r1
 801634a:	2201      	movs	r2, #1
{
 801634c:	461e      	mov	r6, r3
  if( (status=MIOS32_SPI_TransferModeInit(MIOS32_ENC28J60_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_4)) < 0 ) 
 801634e:	f000 fb9b 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
 8016352:	1e04      	subs	r4, r0, #0
 8016354:	db05      	blt.n	8016362 <MIOS32_ENC28J60_PackageSend+0x26>
  int timeout_ctr = 1000;
 8016356:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
  while( --timeout_ctr > 0 ) {
 801635a:	3d01      	subs	r5, #1
 801635c:	d104      	bne.n	8016368 <MIOS32_ENC28J60_PackageSend+0x2c>
    status=-16;
 801635e:	f06f 040f 	mvn.w	r4, #15
}
 8016362:	4620      	mov	r0, r4
 8016364:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    status = MIOS32_ENC28J60_ReadETHReg(ECON1);
 8016368:	201f      	movs	r0, #31
 801636a:	f7ff fc9d 	bl	8015ca8 <MIOS32_ENC28J60_ReadETHReg>
    if( status < 0 ) 
 801636e:	1e04      	subs	r4, r0, #0
 8016370:	dbf7      	blt.n	8016362 <MIOS32_ENC28J60_PackageSend+0x26>
    if( !(status & ECON1_TXRTS) )
 8016372:	f014 0a08 	ands.w	sl, r4, #8
 8016376:	d1f0      	bne.n	801635a <MIOS32_ENC28J60_PackageSend+0x1e>
  status |= MIOS32_ENC28J60_BankSel(EWRPTL);
 8016378:	2002      	movs	r0, #2
 801637a:	f7ff fd1a 	bl	8015db2 <MIOS32_ENC28J60_BankSel>
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL, TXSTART & 0xff);
 801637e:	4651      	mov	r1, sl
  status |= MIOS32_ENC28J60_BankSel(EWRPTL);
 8016380:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL, TXSTART & 0xff);
 8016382:	2002      	movs	r0, #2
 8016384:	f7ff fcc7 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(EWRPTH, (TXSTART >> 8) & 0xff);
 8016388:	2110      	movs	r1, #16
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL, TXSTART & 0xff);
 801638a:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_WriteReg(EWRPTH, (TXSTART >> 8) & 0xff);
 801638c:	2003      	movs	r0, #3
 801638e:	f7ff fcc2 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(EWRPTL, TXSTART & 0xff);
 8016392:	432c      	orrs	r4, r5
  if( status < 0 ) 
 8016394:	4304      	orrs	r4, r0
 8016396:	d4e4      	bmi.n	8016362 <MIOS32_ENC28J60_PackageSend+0x26>
  u16 end_addr = TXSTART + len + len2; // package control byte has already been considered in this calculation (+1 .. -1)
 8016398:	f506 5180 	add.w	r1, r6, #4096	@ 0x1000
 801639c:	4441      	add	r1, r8
 801639e:	fa1f fa81 	uxth.w	sl, r1
  status |= MIOS32_ENC28J60_WriteReg(ETXNDL, end_addr & 0xff);
 80163a2:	2006      	movs	r0, #6
 80163a4:	b2c9      	uxtb	r1, r1
 80163a6:	f7ff fcb6 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
  status |= MIOS32_ENC28J60_WriteReg(ETXNDH, (end_addr >> 8) & 0xff);
 80163aa:	ea4f 211a 	mov.w	r1, sl, lsr #8
  status |= MIOS32_ENC28J60_WriteReg(ETXNDL, end_addr & 0xff);
 80163ae:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_WriteReg(ETXNDH, (end_addr >> 8) & 0xff);
 80163b0:	2007      	movs	r0, #7
 80163b2:	f7ff fcb0 	bl	8015d16 <MIOS32_ENC28J60_WriteReg>
 80163b6:	4328      	orrs	r0, r5
  if( status < 0 ) 
 80163b8:	4304      	orrs	r4, r0
 80163ba:	d4d2      	bmi.n	8016362 <MIOS32_ENC28J60_PackageSend+0x26>
  status |= MIOS32_ENC28J60_MACPut(0x07); // enable CRC calculation and padding to 60 bytes
 80163bc:	2007      	movs	r0, #7
 80163be:	f7ff fe03 	bl	8015fc8 <MIOS32_ENC28J60_MACPut>
  status |= MIOS32_ENC28J60_MACPutArray(buffer, len);
 80163c2:	4641      	mov	r1, r8
  status |= MIOS32_ENC28J60_MACPut(0x07); // enable CRC calculation and padding to 60 bytes
 80163c4:	4605      	mov	r5, r0
  status |= MIOS32_ENC28J60_MACPutArray(buffer, len);
 80163c6:	4648      	mov	r0, r9
 80163c8:	f7ff ff9a 	bl	8016300 <MIOS32_ENC28J60_MACPutArray>
 80163cc:	4305      	orrs	r5, r0
 80163ce:	4325      	orrs	r5, r4
  if( buffer2 != NULL && len2 ) {
 80163d0:	b12f      	cbz	r7, 80163de <MIOS32_ENC28J60_PackageSend+0xa2>
 80163d2:	b126      	cbz	r6, 80163de <MIOS32_ENC28J60_PackageSend+0xa2>
    status |= MIOS32_ENC28J60_MACPutArray(buffer2, len2);
 80163d4:	4631      	mov	r1, r6
 80163d6:	4638      	mov	r0, r7
 80163d8:	f7ff ff92 	bl	8016300 <MIOS32_ENC28J60_MACPutArray>
 80163dc:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_TXRST);
 80163de:	2180      	movs	r1, #128	@ 0x80
 80163e0:	201f      	movs	r0, #31
 80163e2:	f7ff fccc 	bl	8015d7e <MIOS32_ENC28J60_BFSReg>
  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_TXRST);
 80163e6:	2180      	movs	r1, #128	@ 0x80
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_TXRST);
 80163e8:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_TXRST);
 80163ea:	201f      	movs	r0, #31
 80163ec:	f7ff fcad 	bl	8015d4a <MIOS32_ENC28J60_BFCReg>
  status |= MIOS32_ENC28J60_BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
 80163f0:	210a      	movs	r1, #10
  status |= MIOS32_ENC28J60_BFCReg(ECON1, ECON1_TXRST);
 80163f2:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
 80163f4:	201c      	movs	r0, #28
 80163f6:	f7ff fca8 	bl	8015d4a <MIOS32_ENC28J60_BFCReg>
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_TXRTS);
 80163fa:	2108      	movs	r1, #8
  status |= MIOS32_ENC28J60_BFCReg(EIR, EIR_TXERIF | EIR_TXIF);
 80163fc:	4305      	orrs	r5, r0
  status |= MIOS32_ENC28J60_BFSReg(ECON1, ECON1_TXRTS);
 80163fe:	201f      	movs	r0, #31
 8016400:	f7ff fcbd 	bl	8015d7e <MIOS32_ENC28J60_BFSReg>
 8016404:	ea45 0400 	orr.w	r4, r5, r0
  return status;
 8016408:	e7ab      	b.n	8016362 <MIOS32_ENC28J60_PackageSend+0x26>
	...

0801640c <MIOS32_TIMESTAMP_Init>:
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_TIMESTAMP_Init(u32 mode)
{
  // currently only mode 0 supported
  if( mode != 0 )
 801640c:	b910      	cbnz	r0, 8016414 <MIOS32_TIMESTAMP_Init+0x8>
    return -1; // unsupported mode

  timestamp = 0;
 801640e:	4b03      	ldr	r3, [pc, #12]	@ (801641c <MIOS32_TIMESTAMP_Init+0x10>)
 8016410:	6018      	str	r0, [r3, #0]

  return 0;
 8016412:	4770      	bx	lr
    return -1; // unsupported mode
 8016414:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8016418:	4770      	bx	lr
 801641a:	bf00      	nop
 801641c:	200031d8 	.word	0x200031d8

08016420 <MIOS32_TIMESTAMP_Inc>:
//!
//! \return number of SRs
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_TIMESTAMP_Inc(void)
{
  ++timestamp;
 8016420:	4a02      	ldr	r2, [pc, #8]	@ (801642c <MIOS32_TIMESTAMP_Inc+0xc>)
 8016422:	6813      	ldr	r3, [r2, #0]
 8016424:	3301      	adds	r3, #1
 8016426:	6013      	str	r3, [r2, #0]

  return 0; // no error
}
 8016428:	2000      	movs	r0, #0
 801642a:	4770      	bx	lr
 801642c:	200031d8 	.word	0x200031d8

08016430 <MIOS32_TIMESTAMP_Get>:
//! \return the current timestamp
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_TIMESTAMP_Get(void)
{
  return timestamp;
}
 8016430:	4b01      	ldr	r3, [pc, #4]	@ (8016438 <MIOS32_TIMESTAMP_Get+0x8>)
 8016432:	6818      	ldr	r0, [r3, #0]
 8016434:	4770      	bx	lr
 8016436:	bf00      	nop
 8016438:	200031d8 	.word	0x200031d8

0801643c <MIOS32_SYS_Reset>:
//!   <LI>reset STM32
//! </UL>
//! \return < 0 if reset failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_Reset(void)
{
 801643c:	b510      	push	{r4, lr}
  // disable all RTOS tasks
#ifndef MIOS32_DONT_USE_FREERTOS
  portENTER_CRITICAL(); // port specific FreeRTOS function to disable tasks (nested)
 801643e:	f7fd fd81 	bl	8013f44 <vPortEnterCritical>

  // print reboot message if LCD enabled
#ifndef MIOS32_DONT_USE_LCD
  // TODO: here we should select the normal font - but only if available!
  // MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
  MIOS32_LCD_BColourSet(0xffffff);
 8016442:	f06f 407f 	mvn.w	r0, #4278190080	@ 0xff000000
 8016446:	f7fe f9eb 	bl	8014820 <MIOS32_LCD_BColourSet>
  MIOS32_LCD_FColourSet(0x000000);
 801644a:	2000      	movs	r0, #0
 801644c:	f7fe f9ea 	bl	8014824 <MIOS32_LCD_FColourSet>

  MIOS32_LCD_DeviceSet(0);
 8016450:	2000      	movs	r0, #0
 8016452:	f7fe f8fb 	bl	801464c <MIOS32_LCD_DeviceSet>
  MIOS32_LCD_Clear();
 8016456:	f7fe f94b 	bl	80146f0 <MIOS32_LCD_Clear>
  MIOS32_LCD_CursorSet(0, 0);
 801645a:	2100      	movs	r1, #0
 801645c:	4608      	mov	r0, r1
 801645e:	f7fe f8fb 	bl	8014658 <MIOS32_LCD_CursorSet>
  MIOS32_LCD_PrintString("Bootloader Mode "); // 16 chars
 8016462:	481e      	ldr	r0, [pc, #120]	@ (80164dc <MIOS32_SYS_Reset+0xa0>)
 8016464:	f7fe f9a0 	bl	80147a8 <MIOS32_LCD_PrintString>
#endif

  // disable all interrupts
  MIOS32_IRQ_Disable();
 8016468:	f000 f940 	bl	80166ec <MIOS32_IRQ_Disable>

#if !defined(MIOS32_DONT_USE_BOARD_LED)
  // turn off all board LEDs
  MIOS32_BOARD_LED_Set(0xffffffff, 0x00000000);
 801646c:	2100      	movs	r1, #0
 801646e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8016472:	f000 fd9d 	bl	8016fb0 <MIOS32_BOARD_LED_Set>
 8016476:	2432      	movs	r4, #50	@ 0x32

  // wait for 50 mS to ensure that all ongoing operations (e.g. DMA driver SPI transfers) are finished
  {
    int i;
    for(i=0; i<50; ++i)
      MIOS32_DELAY_Wait_uS(1000);
 8016478:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 801647c:	f000 ffa2 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
    for(i=0; i<50; ++i)
 8016480:	3c01      	subs	r4, #1
 8016482:	d1f9      	bne.n	8016478 <MIOS32_SYS_Reset+0x3c>
  }

  // reset peripherals
  RCC_AHB1PeriphResetCmd(0xfffffffe, ENABLE); // don't reset GPIOA due to USB pins
 8016484:	2101      	movs	r1, #1
 8016486:	f06f 0001 	mvn.w	r0, #1
 801648a:	f002 ffa9 	bl	80193e0 <RCC_AHB1PeriphResetCmd>
  RCC_AHB2PeriphResetCmd(0xffffff7f, ENABLE); // don't reset OTG_FS, so that the connectuion can survive
 801648e:	2101      	movs	r1, #1
 8016490:	f06f 0080 	mvn.w	r0, #128	@ 0x80
 8016494:	f002 ffb0 	bl	80193f8 <RCC_AHB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, ENABLE);
 8016498:	2101      	movs	r1, #1
 801649a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801649e:	f002 ffb7 	bl	8019410 <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, ENABLE);
 80164a2:	2101      	movs	r1, #1
 80164a4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80164a8:	f002 ffbe 	bl	8019428 <RCC_APB2PeriphResetCmd>
  RCC_AHB1PeriphResetCmd(0xffffffff, DISABLE);
 80164ac:	4621      	mov	r1, r4
 80164ae:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80164b2:	f002 ff95 	bl	80193e0 <RCC_AHB1PeriphResetCmd>
  RCC_AHB2PeriphResetCmd(0xffffffff, DISABLE);
 80164b6:	4621      	mov	r1, r4
 80164b8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80164bc:	f002 ff9c 	bl	80193f8 <RCC_AHB2PeriphResetCmd>
  RCC_APB1PeriphResetCmd(0xffffffff, DISABLE);
 80164c0:	4621      	mov	r1, r4
 80164c2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80164c6:	f002 ffa3 	bl	8019410 <RCC_APB1PeriphResetCmd>
  RCC_APB2PeriphResetCmd(0xffffffff, DISABLE);
 80164ca:	4621      	mov	r1, r4
 80164cc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80164d0:	f002 ffaa 	bl	8019428 <RCC_APB2PeriphResetCmd>
  // not available in v3.0.0 library anymore? - copy from v2.0.1
  SCB->AIRCR = NVIC_AIRCR_VECTKEY | (1 << NVIC_VECTRESET);
#endif
#if 1
  // and this is the code for v3.3.0
  SCB->AIRCR = (0x5fa << SCB_AIRCR_VECTKEY_Pos) | (1 << SCB_AIRCR_VECTRESET_Pos);
 80164d4:	4b02      	ldr	r3, [pc, #8]	@ (80164e0 <MIOS32_SYS_Reset+0xa4>)
 80164d6:	4a03      	ldr	r2, [pc, #12]	@ (80164e4 <MIOS32_SYS_Reset+0xa8>)
 80164d8:	60da      	str	r2, [r3, #12]
#endif

  while( 1 );
 80164da:	e7fe      	b.n	80164da <MIOS32_SYS_Reset+0x9e>
 80164dc:	08026e57 	.word	0x08026e57
 80164e0:	e000ed00 	.word	0xe000ed00
 80164e4:	05fa0001 	.word	0x05fa0001

080164e8 <MIOS32_SYS_ChipIDGet>:
//! \return the chip ID
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_ChipIDGet(void)
{
  // stored in DBGMCU_IDCODE register
  return MEM32(0xe0042000);
 80164e8:	4b01      	ldr	r3, [pc, #4]	@ (80164f0 <MIOS32_SYS_ChipIDGet+0x8>)
 80164ea:	6818      	ldr	r0, [r3, #0]
}
 80164ec:	4770      	bx	lr
 80164ee:	bf00      	nop
 80164f0:	e0042000 	.word	0xe0042000

080164f4 <MIOS32_SYS_FlashSizeGet>:
//! \return the Flash size in bytes
/////////////////////////////////////////////////////////////////////////////
u32 MIOS32_SYS_FlashSizeGet(void)
{
  // stored in the so called "electronic signature"
  return (u32)MEM16(0x1fff7a22) * 0x400;
 80164f4:	4b02      	ldr	r3, [pc, #8]	@ (8016500 <MIOS32_SYS_FlashSizeGet+0xc>)
 80164f6:	8c58      	ldrh	r0, [r3, #34]	@ 0x22
 80164f8:	b280      	uxth	r0, r0
}
 80164fa:	0280      	lsls	r0, r0, #10
 80164fc:	4770      	bx	lr
 80164fe:	bf00      	nop
 8016500:	1fff7a00 	.word	0x1fff7a00

08016504 <MIOS32_SYS_RAMSizeGet>:
#if defined(MIOS32_PROCESSOR_STM32F407VG)
  return 192*1024; // unfortunately not stored in signature...
#else
# error "Please define RAM size here"
#endif
}
 8016504:	f44f 3040 	mov.w	r0, #196608	@ 0x30000
 8016508:	4770      	bx	lr
	...

0801650c <MIOS32_SYS_SerialNumberGet>:
//! \param[out] str pointer to a string which can store at least 32 digits + zero terminator!
//! (24 digits returned for STM32)
//! \return < 0 if feature not supported
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_SerialNumberGet(char *str)
{
 801650c:	b510      	push	{r4, lr}
  int i;

  // stored in the so called "electronic signature"
  for(i=0; i<24; ++i) {
    u8 b = MEM8(0x1fff7a10 + (i/2));
 801650e:	4c0c      	ldr	r4, [pc, #48]	@ (8016540 <MIOS32_SYS_SerialNumberGet+0x34>)
{
 8016510:	4601      	mov	r1, r0
  for(i=0; i<24; ++i) {
 8016512:	2200      	movs	r2, #0
    u8 b = MEM8(0x1fff7a10 + (i/2));
 8016514:	1053      	asrs	r3, r2, #1
    if( !(i & 1) )
 8016516:	f012 0f01 	tst.w	r2, #1
    u8 b = MEM8(0x1fff7a10 + (i/2));
 801651a:	5d1b      	ldrb	r3, [r3, r4]
 801651c:	b2db      	uxtb	r3, r3
      b >>= 4;
 801651e:	bf08      	it	eq
 8016520:	091b      	lsreq	r3, r3, #4
    b &= 0x0f;
 8016522:	f003 030f 	and.w	r3, r3, #15

    str[i] = ((b > 9) ? ('A'-10) : '0') + b;
 8016526:	2b09      	cmp	r3, #9
 8016528:	bf8c      	ite	hi
 801652a:	2037      	movhi	r0, #55	@ 0x37
 801652c:	2030      	movls	r0, #48	@ 0x30
 801652e:	4403      	add	r3, r0
 8016530:	548b      	strb	r3, [r1, r2]
  for(i=0; i<24; ++i) {
 8016532:	3201      	adds	r2, #1
 8016534:	2a18      	cmp	r2, #24
 8016536:	d1ed      	bne.n	8016514 <MIOS32_SYS_SerialNumberGet+0x8>
  }
  str[i] = 0;
 8016538:	2000      	movs	r0, #0
 801653a:	7608      	strb	r0, [r1, #24]

  return 0; // no error
}
 801653c:	bd10      	pop	{r4, pc}
 801653e:	bf00      	nop
 8016540:	1fff7a10 	.word	0x1fff7a10

08016544 <MIOS32_SYS_TimeSet>:
//! Note that this format isn't completely compatible to the NTP timestamp format,
//! as the fraction has only mS accuracy
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SYS_TimeSet(mios32_sys_time_t t)
{
 8016544:	b510      	push	{r4, lr}
 8016546:	b086      	sub	sp, #24
 8016548:	466b      	mov	r3, sp
 801654a:	e883 0003 	stmia.w	r3, {r0, r1}
 801654e:	4604      	mov	r4, r0
  // taken from STM32 example "RTC/Calendar"
  // adapted to clock RTC via HSE  oscillator

  // Enable PWR and BKP clocks
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
 8016550:	2101      	movs	r1, #1
 8016552:	f04f 5080 	mov.w	r0, #268435456	@ 0x10000000
 8016556:	f002 ff2b 	bl	80193b0 <RCC_APB1PeriphClockCmd>

  // Allow access to BKP Domain
  PWR_BackupAccessCmd(ENABLE);
 801655a:	2001      	movs	r0, #1
 801655c:	f002 feaa 	bl	80192b4 <PWR_BackupAccessCmd>

  // Select HSE (divided by 16) as RTC Clock Source
#if EXT_CRYSTAL_FRQ != 8000000
# error "Please configure alternative clock divider here"
#endif
  RCC_RTCCLKConfig(RCC_RTCCLKSource_HSE_Div16); // -> each 1/(8 MHz / 16) = 2 uS
 8016560:	4816      	ldr	r0, [pc, #88]	@ (80165bc <MIOS32_SYS_TimeSet+0x78>)
 8016562:	f002 feef 	bl	8019344 <RCC_RTCCLKConfig>

  // Enable RTC Clock
  RCC_RTCCLKCmd(ENABLE);
 8016566:	2001      	movs	r0, #1
 8016568:	f002 ff04 	bl	8019374 <RCC_RTCCLKCmd>

  // initialize RTC
  RTC_InitTypeDef RTC_InitStruct;
  RTC_StructInit(&RTC_InitStruct);
 801656c:	a803      	add	r0, sp, #12
 801656e:	f002 ff74 	bl	801945a <RTC_StructInit>

  // Set RTC prescaler: set RTC period from 2 uS to 1 S
  RTC_InitStruct.RTC_AsynchPrediv = 100 - 1; // 7bit maximum
  RTC_InitStruct.RTC_SynchPrediv = 5000 - 1; // 13 bit maximum
 8016572:	2263      	movs	r2, #99	@ 0x63
 8016574:	f241 3387 	movw	r3, #4999	@ 0x1387
  RTC_Init(&RTC_InitStruct);
 8016578:	a803      	add	r0, sp, #12
  RTC_InitStruct.RTC_SynchPrediv = 5000 - 1; // 13 bit maximum
 801657a:	e9cd 2304 	strd	r2, r3, [sp, #16]
  RTC_Init(&RTC_InitStruct);
 801657e:	f002 ff9b 	bl	80194b8 <RTC_Init>

  // Change the current time
  RTC_TimeTypeDef RTC_TimeStruct;
  RTC_TimeStructInit(&RTC_TimeStruct);
 8016582:	a802      	add	r0, sp, #8
 8016584:	f003 f820 	bl	80195c8 <RTC_TimeStructInit>
  RTC_TimeStruct.RTC_Hours = t.seconds / 3600;
 8016588:	f44f 6261 	mov.w	r2, #3600	@ 0xe10
 801658c:	fbb4 f3f2 	udiv	r3, r4, r2
 8016590:	f88d 3008 	strb.w	r3, [sp, #8]
  RTC_TimeStruct.RTC_Minutes = (t.seconds % 3600) / 60;
 8016594:	fb02 4313 	mls	r3, r2, r3, r4
 8016598:	223c      	movs	r2, #60	@ 0x3c
  RTC_TimeStruct.RTC_Seconds = t.seconds % 60; 
  RTC_SetTime(RTC_Format_BIN, &RTC_TimeStruct);
 801659a:	a902      	add	r1, sp, #8
  RTC_TimeStruct.RTC_Minutes = (t.seconds % 3600) / 60;
 801659c:	fbb3 f3f2 	udiv	r3, r3, r2
  RTC_SetTime(RTC_Format_BIN, &RTC_TimeStruct);
 80165a0:	2000      	movs	r0, #0
  RTC_TimeStruct.RTC_Minutes = (t.seconds % 3600) / 60;
 80165a2:	f88d 3009 	strb.w	r3, [sp, #9]
  RTC_TimeStruct.RTC_Seconds = t.seconds % 60; 
 80165a6:	fbb4 f3f2 	udiv	r3, r4, r2
 80165aa:	fb02 4413 	mls	r4, r2, r3, r4
 80165ae:	f88d 400a 	strb.w	r4, [sp, #10]
  RTC_SetTime(RTC_Format_BIN, &RTC_TimeStruct);
 80165b2:	f002 ffc5 	bl	8019540 <RTC_SetTime>
  // (fraction not taken into account here)

  return 0; // no error
}
 80165b6:	2000      	movs	r0, #0
 80165b8:	b006      	add	sp, #24
 80165ba:	bd10      	pop	{r4, pc}
 80165bc:	00100300 	.word	0x00100300

080165c0 <MIOS32_SYS_Init>:
{
 80165c0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if( mode != 0 )
 80165c2:	4604      	mov	r4, r0
 80165c4:	2800      	cmp	r0, #0
 80165c6:	f040 8081 	bne.w	80166cc <MIOS32_SYS_Init+0x10c>
  RCC_AHB1PeriphClockCmd(
 80165ca:	2101      	movs	r1, #1
 80165cc:	201f      	movs	r0, #31
 80165ce:	f002 fed7 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  if( (RCC->CFGR & (uint32_t)RCC_CFGR_SWS) == RCC_CFGR_SWS_PLL ) {
 80165d2:	4b40      	ldr	r3, [pc, #256]	@ (80166d4 <MIOS32_SYS_Init+0x114>)
  __IO uint32_t HSEStatus = 0;
 80165d4:	9400      	str	r4, [sp, #0]
  if( (RCC->CFGR & (uint32_t)RCC_CFGR_SWS) == RCC_CFGR_SWS_PLL ) {
 80165d6:	689a      	ldr	r2, [r3, #8]
 80165d8:	f002 020c 	and.w	r2, r2, #12
 80165dc:	2a08      	cmp	r2, #8
 80165de:	d118      	bne.n	8016612 <MIOS32_SYS_Init+0x52>
    HSEStatus = SUCCESS;
 80165e0:	2301      	movs	r3, #1
 80165e2:	9300      	str	r3, [sp, #0]
  NVIC_SetVectorTable((u32)&mios32_sys_isr_vector, 0x0);
 80165e4:	2100      	movs	r1, #0
 80165e6:	483c      	ldr	r0, [pc, #240]	@ (80166d8 <MIOS32_SYS_Init+0x118>)
 80165e8:	f002 fc0e 	bl	8018e08 <NVIC_SetVectorTable>
  NVIC_PriorityGroupConfig(MIOS32_IRQ_PRIGROUP);
 80165ec:	f44f 7040 	mov.w	r0, #768	@ 0x300
 80165f0:	f002 fc00 	bl	8018df4 <NVIC_PriorityGroupConfig>
  mios32_sys_time_t t = { .seconds=0, .fraction_ms=0 };
 80165f4:	2300      	movs	r3, #0
 80165f6:	e9cd 3302 	strd	r3, r3, [sp, #8]
  MIOS32_SYS_TimeSet(t);
 80165fa:	ab04      	add	r3, sp, #16
 80165fc:	e913 0003 	ldmdb	r3, {r0, r1}
 8016600:	f7ff ffa0 	bl	8016544 <MIOS32_SYS_TimeSet>
  return HSEStatus == SUCCESS ? 0 : -1;
 8016604:	9800      	ldr	r0, [sp, #0]
 8016606:	3801      	subs	r0, #1
 8016608:	bf18      	it	ne
 801660a:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
}
 801660e:	b004      	add	sp, #16
 8016610:	bd10      	pop	{r4, pc}
    RCC->CR |= (uint32_t)0x00000001;
 8016612:	681a      	ldr	r2, [r3, #0]
 8016614:	f042 0201 	orr.w	r2, r2, #1
 8016618:	601a      	str	r2, [r3, #0]
    RCC->CFGR = 0x00000000;
 801661a:	609c      	str	r4, [r3, #8]
    RCC->CR &= (uint32_t)0xFEF6FFFF;
 801661c:	681a      	ldr	r2, [r3, #0]
 801661e:	f022 7284 	bic.w	r2, r2, #17301504	@ 0x1080000
 8016622:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8016626:	601a      	str	r2, [r3, #0]
    RCC->PLLCFGR = 0x24003010;
 8016628:	4a2c      	ldr	r2, [pc, #176]	@ (80166dc <MIOS32_SYS_Init+0x11c>)
 801662a:	605a      	str	r2, [r3, #4]
    RCC->CR &= (uint32_t)0xFFFBFFFF;
 801662c:	681a      	ldr	r2, [r3, #0]
 801662e:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8016632:	601a      	str	r2, [r3, #0]
    RCC->CIR = 0x00000000;
 8016634:	60dc      	str	r4, [r3, #12]
    __IO uint32_t StartUpCounter = 0;
 8016636:	9401      	str	r4, [sp, #4]
    RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8016638:	681a      	ldr	r2, [r3, #0]
 801663a:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 801663e:	601a      	str	r2, [r3, #0]
      HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8016640:	681a      	ldr	r2, [r3, #0]
 8016642:	f402 3200 	and.w	r2, r2, #131072	@ 0x20000
 8016646:	9200      	str	r2, [sp, #0]
      StartUpCounter++;
 8016648:	9a01      	ldr	r2, [sp, #4]
 801664a:	3201      	adds	r2, #1
 801664c:	9201      	str	r2, [sp, #4]
    } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 801664e:	9a00      	ldr	r2, [sp, #0]
 8016650:	b91a      	cbnz	r2, 801665a <MIOS32_SYS_Init+0x9a>
 8016652:	9a01      	ldr	r2, [sp, #4]
 8016654:	f5b2 6fa0 	cmp.w	r2, #1280	@ 0x500
 8016658:	d1f2      	bne.n	8016640 <MIOS32_SYS_Init+0x80>
    if ((RCC->CR & RCC_CR_HSERDY) != RESET) {
 801665a:	681b      	ldr	r3, [r3, #0]
 801665c:	f413 3300 	ands.w	r3, r3, #131072	@ 0x20000
      HSEStatus = (uint32_t)0x01;
 8016660:	bf18      	it	ne
 8016662:	2301      	movne	r3, #1
      HSEStatus = (uint32_t)0x00;
 8016664:	9300      	str	r3, [sp, #0]
    if (HSEStatus == (uint32_t)0x01) {
 8016666:	9b00      	ldr	r3, [sp, #0]
 8016668:	2b01      	cmp	r3, #1
 801666a:	d1bb      	bne.n	80165e4 <MIOS32_SYS_Init+0x24>
      RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 801666c:	4b19      	ldr	r3, [pc, #100]	@ (80166d4 <MIOS32_SYS_Init+0x114>)
      PWR->CR |= PWR_CR_VOS;
 801666e:	491c      	ldr	r1, [pc, #112]	@ (80166e0 <MIOS32_SYS_Init+0x120>)
      RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 8016670:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 8016672:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8016676:	641a      	str	r2, [r3, #64]	@ 0x40
      PWR->CR |= PWR_CR_VOS;
 8016678:	680a      	ldr	r2, [r1, #0]
 801667a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 801667e:	600a      	str	r2, [r1, #0]
      RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8016680:	689a      	ldr	r2, [r3, #8]
 8016682:	609a      	str	r2, [r3, #8]
      RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8016684:	689a      	ldr	r2, [r3, #8]
 8016686:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 801668a:	609a      	str	r2, [r3, #8]
      RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 801668c:	689a      	ldr	r2, [r3, #8]
 801668e:	f442 52a0 	orr.w	r2, r2, #5120	@ 0x1400
 8016692:	609a      	str	r2, [r3, #8]
      RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8016694:	4a13      	ldr	r2, [pc, #76]	@ (80166e4 <MIOS32_SYS_Init+0x124>)
 8016696:	605a      	str	r2, [r3, #4]
      RCC->CR |= RCC_CR_PLLON;
 8016698:	681a      	ldr	r2, [r3, #0]
 801669a:	f042 7280 	orr.w	r2, r2, #16777216	@ 0x1000000
 801669e:	601a      	str	r2, [r3, #0]
      while((RCC->CR & RCC_CR_PLLRDY) == 0);
 80166a0:	681a      	ldr	r2, [r3, #0]
 80166a2:	0192      	lsls	r2, r2, #6
 80166a4:	d5fc      	bpl.n	80166a0 <MIOS32_SYS_Init+0xe0>
      FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 80166a6:	4a10      	ldr	r2, [pc, #64]	@ (80166e8 <MIOS32_SYS_Init+0x128>)
 80166a8:	f240 6105 	movw	r1, #1541	@ 0x605
 80166ac:	6011      	str	r1, [r2, #0]
      RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 80166ae:	689a      	ldr	r2, [r3, #8]
 80166b0:	f022 0203 	bic.w	r2, r2, #3
 80166b4:	609a      	str	r2, [r3, #8]
      RCC->CFGR |= RCC_CFGR_SW_PLL;
 80166b6:	689a      	ldr	r2, [r3, #8]
 80166b8:	f042 0202 	orr.w	r2, r2, #2
 80166bc:	609a      	str	r2, [r3, #8]
      while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
 80166be:	4a05      	ldr	r2, [pc, #20]	@ (80166d4 <MIOS32_SYS_Init+0x114>)
 80166c0:	6893      	ldr	r3, [r2, #8]
 80166c2:	f003 030c 	and.w	r3, r3, #12
 80166c6:	2b08      	cmp	r3, #8
 80166c8:	d1fa      	bne.n	80166c0 <MIOS32_SYS_Init+0x100>
 80166ca:	e78b      	b.n	80165e4 <MIOS32_SYS_Init+0x24>
    return -1; // unsupported mode
 80166cc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80166d0:	e79d      	b.n	801660e <MIOS32_SYS_Init+0x4e>
 80166d2:	bf00      	nop
 80166d4:	40023800 	.word	0x40023800
 80166d8:	08004000 	.word	0x08004000
 80166dc:	24003010 	.word	0x24003010
 80166e0:	40007000 	.word	0x40007000
 80166e4:	07405408 	.word	0x07405408
 80166e8:	40023c00 	.word	0x40023c00

080166ec <MIOS32_IRQ_Disable>:
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Disable(void)
{
  // get current priority if nested level == 0
  if( !nested_ctr ) {
 80166ec:	4b07      	ldr	r3, [pc, #28]	@ (801670c <MIOS32_IRQ_Disable+0x20>)
 80166ee:	681a      	ldr	r2, [r3, #0]
 80166f0:	b91a      	cbnz	r2, 80166fa <MIOS32_IRQ_Disable+0xe>
    __asm volatile (			   \
 80166f2:	f3ef 8110 	mrs	r1, PRIMASK
 80166f6:	4a06      	ldr	r2, [pc, #24]	@ (8016710 <MIOS32_IRQ_Disable+0x24>)
 80166f8:	6011      	str	r1, [r2, #0]
		    : "=r" (prev_primask)  \
		    );
  }

  // disable interrupts
  __asm volatile ( \
 80166fa:	f04f 0001 	mov.w	r0, #1
 80166fe:	f380 8810 	msr	PRIMASK, r0
		  "	mov r0, #1     \n" \
		  "	msr primask, r0\n" \
		  :::"r0"	 \
		  );

  ++nested_ctr;
 8016702:	681a      	ldr	r2, [r3, #0]
 8016704:	3201      	adds	r2, #1
 8016706:	601a      	str	r2, [r3, #0]

  return 0; // no error
}
 8016708:	2000      	movs	r0, #0
 801670a:	4770      	bx	lr
 801670c:	200031e0 	.word	0x200031e0
 8016710:	200031dc 	.word	0x200031dc

08016714 <MIOS32_IRQ_Enable>:
//! \return -1 on nesting errors (MIOS32_IRQ_Disable() hasn't been called before)
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Enable(void)
{
  // check for nesting error
  if( nested_ctr == 0 )
 8016714:	4b07      	ldr	r3, [pc, #28]	@ (8016734 <MIOS32_IRQ_Enable+0x20>)
 8016716:	6818      	ldr	r0, [r3, #0]
 8016718:	b138      	cbz	r0, 801672a <MIOS32_IRQ_Enable+0x16>
    return -1; // nesting error

  // decrease nesting level
  --nested_ctr;
 801671a:	3801      	subs	r0, #1
 801671c:	6018      	str	r0, [r3, #0]

  // set back previous priority once nested level reached 0 again
  if( nested_ctr == 0 ) {
 801671e:	b938      	cbnz	r0, 8016730 <MIOS32_IRQ_Enable+0x1c>
    __asm volatile ( \
 8016720:	4b05      	ldr	r3, [pc, #20]	@ (8016738 <MIOS32_IRQ_Enable+0x24>)
 8016722:	681b      	ldr	r3, [r3, #0]
 8016724:	f383 8810 	msr	PRIMASK, r3
 8016728:	4770      	bx	lr
    return -1; // nesting error
 801672a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801672e:	4770      	bx	lr
		    "	msr primask, %0\n" \
		    :: "r" (prev_primask)  \
		    );
  }

  return 0; // no error
 8016730:	2000      	movs	r0, #0
}
 8016732:	4770      	bx	lr
 8016734:	200031e0 	.word	0x200031e0
 8016738:	200031dc 	.word	0x200031dc

0801673c <MIOS32_IRQ_Install>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_IRQ_Install(u8 IRQn, u8 priority)
{
  // no check for IRQn as it's device dependent

  if( priority >= 16 )
 801673c:	290f      	cmp	r1, #15
{
 801673e:	b510      	push	{r4, lr}
  if( priority >= 16 )
 8016740:	d817      	bhi.n	8016772 <MIOS32_IRQ_Install+0x36>
    return -1; // invalid priority

  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 8016742:	4b0d      	ldr	r3, [pc, #52]	@ (8016778 <MIOS32_IRQ_Install+0x3c>)
  u32 tmppre = (4 - tmppriority);
  tmppriority = priority << tmppre;
  tmppriority = tmppriority << 4;
  NVIC->IP[IRQn] = tmppriority;
 8016744:	4c0d      	ldr	r4, [pc, #52]	@ (801677c <MIOS32_IRQ_Install+0x40>)
  u32 tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700)) >> 8;
 8016746:	68db      	ldr	r3, [r3, #12]
 8016748:	43db      	mvns	r3, r3
 801674a:	f3c3 2302 	ubfx	r3, r3, #8, #3
  u32 tmppre = (4 - tmppriority);
 801674e:	f1c3 0304 	rsb	r3, r3, #4
  tmppriority = priority << tmppre;
 8016752:	4099      	lsls	r1, r3
  tmppriority = tmppriority << 4;
 8016754:	0109      	lsls	r1, r1, #4
  NVIC->IP[IRQn] = tmppriority;
 8016756:	1823      	adds	r3, r4, r0
 8016758:	b2c9      	uxtb	r1, r1
 801675a:	f883 1300 	strb.w	r1, [r3, #768]	@ 0x300
    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 801675e:	b243      	sxtb	r3, r0
 8016760:	095b      	lsrs	r3, r3, #5
 8016762:	f000 001f 	and.w	r0, r0, #31
 8016766:	2201      	movs	r2, #1
 8016768:	4082      	lsls	r2, r0
 801676a:	f844 2023 	str.w	r2, [r4, r3, lsl #2]

  NVIC_EnableIRQ(IRQn);

  return 0; // no error
 801676e:	2000      	movs	r0, #0
}
 8016770:	bd10      	pop	{r4, pc}
    return -1; // invalid priority
 8016772:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8016776:	e7fb      	b.n	8016770 <MIOS32_IRQ_Install+0x34>
 8016778:	e000ed00 	.word	0xe000ed00
 801677c:	e000e100 	.word	0xe000e100

08016780 <MIOS32_SPI_IO_Init>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported pin driver mode
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_IO_Init(u8 spi, mios32_spi_pin_driver_t spi_pin_driver)
{
 8016780:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8016782:	4605      	mov	r5, r0
 8016784:	460c      	mov	r4, r1
  // init GPIO structure
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8016786:	4668      	mov	r0, sp
 8016788:	f002 fd56 	bl	8019238 <GPIO_StructInit>

  // select pin driver and output mode
  u8 slave = 0;
  switch( spi_pin_driver ) {
 801678c:	2c07      	cmp	r4, #7
 801678e:	f200 811c 	bhi.w	80169ca <MIOS32_SPI_IO_Init+0x24a>
 8016792:	e8df f004 	tbb	[pc, r4]
 8016796:	0a0f      	.short	0x0a0f
 8016798:	630e0407 	.word	0x630e0407
 801679c:	6765      	.short	0x6765
  u8 slave = 0;
 801679e:	2400      	movs	r4, #0
    case MIOS32_SPI_PIN_SLAVE_DRIVER_WEAK_OD:
      slave = 1;
    case MIOS32_SPI_PIN_DRIVER_WEAK_OD:
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
      break;
 80167a0:	2300      	movs	r3, #0
 80167a2:	e004      	b.n	80167ae <MIOS32_SPI_IO_Init+0x2e>
  u8 slave = 0;
 80167a4:	2400      	movs	r4, #0
      break;
 80167a6:	2300      	movs	r3, #0
 80167a8:	e005      	b.n	80167b6 <MIOS32_SPI_IO_Init+0x36>
  u8 slave = 0;
 80167aa:	2400      	movs	r4, #0
      break;
 80167ac:	2302      	movs	r3, #2
      break;
 80167ae:	2201      	movs	r2, #1
 80167b0:	e002      	b.n	80167b8 <MIOS32_SPI_IO_Init+0x38>
  switch( spi_pin_driver ) {
 80167b2:	2401      	movs	r4, #1
      break;
 80167b4:	2302      	movs	r3, #2
 80167b6:	2200      	movs	r2, #0

    default:
      return -3; // unsupported pin driver mode
  }

  switch( spi ) {
 80167b8:	2d01      	cmp	r5, #1
      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80167ba:	f88d 3005 	strb.w	r3, [sp, #5]
      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80167be:	f88d 2006 	strb.w	r2, [sp, #6]
  switch( spi ) {
 80167c2:	d051      	beq.n	8016868 <MIOS32_SPI_IO_Init+0xe8>
 80167c4:	2d02      	cmp	r5, #2
 80167c6:	f000 80ab 	beq.w	8016920 <MIOS32_SPI_IO_Init+0x1a0>
 80167ca:	2d00      	cmp	r5, #0
 80167cc:	f040 8100 	bne.w	80169d0 <MIOS32_SPI_IO_Init+0x250>
#ifdef MIOS32_DONT_USE_SPI0
      return -1; // disabled SPI port
#else
      MIOS32_SPI0_RCLK1_AF;
      MIOS32_SPI0_RCLK2_AF;
      MIOS32_SPI0_SCLK_AF;
 80167d0:	2205      	movs	r2, #5
 80167d2:	4611      	mov	r1, r2
 80167d4:	4880      	ldr	r0, [pc, #512]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
 80167d6:	f002 fd39 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI0_MISO_AF;
 80167da:	487f      	ldr	r0, [pc, #508]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
 80167dc:	2205      	movs	r2, #5
 80167de:	2106      	movs	r1, #6
 80167e0:	f002 fd34 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI0_MOSI_AF;
 80167e4:	487c      	ldr	r0, [pc, #496]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
 80167e6:	2205      	movs	r2, #5
 80167e8:	2107      	movs	r1, #7
 80167ea:	f002 fd2f 	bl	801924c <GPIO_PinAFConfig>

      if( slave ) {
 80167ee:	2c00      	cmp	r4, #0
 80167f0:	f040 80eb 	bne.w	80169ca <MIOS32_SPI_IO_Init+0x24a>
	GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
#endif
      } else {
	// SCLK and DOUT are outputs assigned to alternate functions
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 80167f4:	2320      	movs	r3, #32
	GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 80167f6:	4878      	ldr	r0, [pc, #480]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_SCLK_PIN;
 80167f8:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80167fa:	2502      	movs	r5, #2
	GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 80167fc:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80167fe:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_Init(MIOS32_SPI0_SCLK_PORT, &GPIO_InitStructure);
 8016802:	f002 fcd1 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 8016806:	2380      	movs	r3, #128	@ 0x80
	GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 8016808:	4873      	ldr	r0, [pc, #460]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
	GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);

#if defined(MIOS32_BOARD_STM32F4DISCOVERY) || defined(MIOS32_BOARD_MBHP_CORE_STM32F4)
	// set RE3=1 to ensure that the on-board MEMs is disabled
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
	GPIO_Init(GPIOE, &GPIO_InitStructure);	
 801680a:	4e74      	ldr	r6, [pc, #464]	@ (80169dc <MIOS32_SPI_IO_Init+0x25c>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MOSI_PIN;
 801680c:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI0_MOSI_PORT, &GPIO_InitStructure);
 801680e:	4669      	mov	r1, sp
 8016810:	f002 fcca 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8016814:	2401      	movs	r4, #1
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 8016816:	2304      	movs	r3, #4
	GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 8016818:	4871      	ldr	r0, [pc, #452]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK1_PIN;
 801681a:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 801681c:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 801681e:	f88d 4004 	strb.w	r4, [sp, #4]
	GPIO_Init(MIOS32_SPI0_RCLK1_PORT, &GPIO_InitStructure);
 8016822:	f002 fcc1 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 8016826:	f44f 6300 	mov.w	r3, #2048	@ 0x800
	GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 801682a:	486e      	ldr	r0, [pc, #440]	@ (80169e4 <MIOS32_SPI_IO_Init+0x264>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_RCLK2_PIN;
 801682c:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI0_RCLK2_PORT, &GPIO_InitStructure);
 801682e:	4669      	mov	r1, sp
 8016830:	f002 fcba 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
 8016834:	2708      	movs	r7, #8
	GPIO_Init(GPIOE, &GPIO_InitStructure);	
 8016836:	4669      	mov	r1, sp
 8016838:	4630      	mov	r0, r6
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
 801683a:	9700      	str	r7, [sp, #0]
	GPIO_Init(GPIOE, &GPIO_InitStructure);	
 801683c:	f002 fcb4 	bl	80191a8 <GPIO_Init>
#endif
    
	// DIN is input with pull-up
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 8016840:	2340      	movs	r3, #64	@ 0x40
	GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 8016842:	4865      	ldr	r0, [pc, #404]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
	MIOS32_SYS_STM_PINSET_1(GPIOE, GPIO_Pin_3);
 8016844:	8337      	strh	r7, [r6, #24]
	GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 8016846:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8016848:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 801684c:	f88d 4007 	strb.w	r4, [sp, #7]
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI0_MISO_PIN;
 8016850:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI0_MISO_PORT, &GPIO_InitStructure);
 8016852:	f002 fca9 	bl	80191a8 <GPIO_Init>

    default:
      return -2; // unsupported SPI port
  }

  return 0; // no error
 8016856:	2000      	movs	r0, #0
}
 8016858:	b003      	add	sp, #12
 801685a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch( spi_pin_driver ) {
 801685c:	2401      	movs	r4, #1
 801685e:	e7a5      	b.n	80167ac <MIOS32_SPI_IO_Init+0x2c>
 8016860:	2401      	movs	r4, #1
 8016862:	e7a0      	b.n	80167a6 <MIOS32_SPI_IO_Init+0x26>
 8016864:	2401      	movs	r4, #1
 8016866:	e79b      	b.n	80167a0 <MIOS32_SPI_IO_Init+0x20>
      MIOS32_SPI1_RCLK1_AF;
 8016868:	485d      	ldr	r0, [pc, #372]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 801686a:	2205      	movs	r2, #5
 801686c:	210c      	movs	r1, #12
 801686e:	f002 fced 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI1_SCLK_AF;
 8016872:	485b      	ldr	r0, [pc, #364]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 8016874:	2205      	movs	r2, #5
 8016876:	210d      	movs	r1, #13
 8016878:	f002 fce8 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI1_MISO_AF;
 801687c:	4858      	ldr	r0, [pc, #352]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 801687e:	2205      	movs	r2, #5
 8016880:	210e      	movs	r1, #14
 8016882:	f002 fce3 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI1_MOSI_AF;
 8016886:	4856      	ldr	r0, [pc, #344]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 8016888:	210f      	movs	r1, #15
 801688a:	2205      	movs	r2, #5
 801688c:	f002 fcde 	bl	801924c <GPIO_PinAFConfig>
      if( slave ) {
 8016890:	2602      	movs	r6, #2
 8016892:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
	GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 8016896:	4852      	ldr	r0, [pc, #328]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8016898:	f88d 6004 	strb.w	r6, [sp, #4]
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_SCLK_PIN;
 801689c:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 801689e:	4669      	mov	r1, sp
      if( slave ) {
 80168a0:	b304      	cbz	r4, 80168e4 <MIOS32_SPI_IO_Init+0x164>
	GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 80168a2:	f002 fc81 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80168a6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
	GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80168aa:	484d      	ldr	r0, [pc, #308]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80168ac:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80168ae:	4669      	mov	r1, sp
 80168b0:	f002 fc7a 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80168b4:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80168b8:	4849      	ldr	r0, [pc, #292]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80168ba:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80168bc:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80168be:	f88d 6004 	strb.w	r6, [sp, #4]
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80168c2:	f002 fc71 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
 80168c6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
	GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
 80168ca:	4846      	ldr	r0, [pc, #280]	@ (80169e4 <MIOS32_SPI_IO_Init+0x264>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
 80168cc:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
 80168ce:	4669      	mov	r1, sp
 80168d0:	f002 fc6a 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80168d4:	f88d 6004 	strb.w	r6, [sp, #4]
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MISO_PIN;
 80168d8:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
	GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 80168dc:	4840      	ldr	r0, [pc, #256]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 80168de:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_MISO_PORT, &GPIO_InitStructure);
 80168e0:	4669      	mov	r1, sp
 80168e2:	e7b6      	b.n	8016852 <MIOS32_SPI_IO_Init+0xd2>
	GPIO_Init(MIOS32_SPI1_SCLK_PORT, &GPIO_InitStructure);
 80168e4:	f002 fc60 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80168e8:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
	GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80168ec:	483c      	ldr	r0, [pc, #240]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_MOSI_PIN;
 80168ee:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_MOSI_PORT, &GPIO_InitStructure);
 80168f0:	4669      	mov	r1, sp
 80168f2:	f002 fc59 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80168f6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80168fa:	4839      	ldr	r0, [pc, #228]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK1_PIN;
 80168fc:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 80168fe:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8016900:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_Init(MIOS32_SPI1_RCLK1_PORT, &GPIO_InitStructure);
 8016904:	f002 fc50 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
 8016908:	f44f 6380 	mov.w	r3, #1024	@ 0x400
	GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
 801690c:	4835      	ldr	r0, [pc, #212]	@ (80169e4 <MIOS32_SPI_IO_Init+0x264>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI1_RCLK2_PIN;
 801690e:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI1_RCLK2_PORT, &GPIO_InitStructure);
 8016910:	4669      	mov	r1, sp
 8016912:	f002 fc49 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8016916:	f88d 6004 	strb.w	r6, [sp, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 801691a:	f88d 5007 	strb.w	r5, [sp, #7]
 801691e:	e7db      	b.n	80168d8 <MIOS32_SPI_IO_Init+0x158>
      MIOS32_SPI2_RCLK1_AF;
 8016920:	482d      	ldr	r0, [pc, #180]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
 8016922:	2206      	movs	r2, #6
 8016924:	210f      	movs	r1, #15
 8016926:	f002 fc91 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI2_SCLK_AF;
 801692a:	482d      	ldr	r0, [pc, #180]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 801692c:	2206      	movs	r2, #6
 801692e:	2103      	movs	r1, #3
 8016930:	f002 fc8c 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI2_MISO_AF;
 8016934:	482a      	ldr	r0, [pc, #168]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 8016936:	2206      	movs	r2, #6
 8016938:	2104      	movs	r1, #4
 801693a:	f002 fc87 	bl	801924c <GPIO_PinAFConfig>
      MIOS32_SPI2_MOSI_AF;
 801693e:	4828      	ldr	r0, [pc, #160]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
 8016940:	2105      	movs	r1, #5
 8016942:	2206      	movs	r2, #6
 8016944:	f002 fc82 	bl	801924c <GPIO_PinAFConfig>
      if( slave ) {
 8016948:	2308      	movs	r3, #8
	GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 801694a:	4825      	ldr	r0, [pc, #148]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 801694c:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_SCLK_PIN;
 8016950:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8016952:	4669      	mov	r1, sp
      if( slave ) {
 8016954:	b1dc      	cbz	r4, 801698e <MIOS32_SPI_IO_Init+0x20e>
	GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 8016956:	f002 fc27 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 801695a:	2320      	movs	r3, #32
	GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 801695c:	4820      	ldr	r0, [pc, #128]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 801695e:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8016960:	4669      	mov	r1, sp
 8016962:	f002 fc21 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 8016966:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 801696a:	481b      	ldr	r0, [pc, #108]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 801696c:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 801696e:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8016970:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 8016974:	f002 fc18 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 8016978:	f44f 7380 	mov.w	r3, #256	@ 0x100
	GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 801697c:	4818      	ldr	r0, [pc, #96]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 801697e:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 8016980:	4669      	mov	r1, sp
 8016982:	f002 fc11 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8016986:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MISO_PIN;
 801698a:	2310      	movs	r3, #16
 801698c:	e7a6      	b.n	80168dc <MIOS32_SPI_IO_Init+0x15c>
	GPIO_Init(MIOS32_SPI2_SCLK_PORT, &GPIO_InitStructure);
 801698e:	f002 fc0b 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8016992:	2320      	movs	r3, #32
	GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8016994:	4812      	ldr	r0, [pc, #72]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_MOSI_PIN;
 8016996:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_MOSI_PORT, &GPIO_InitStructure);
 8016998:	4669      	mov	r1, sp
 801699a:	f002 fc05 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 801699e:	2401      	movs	r4, #1
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 80169a0:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 80169a4:	480c      	ldr	r0, [pc, #48]	@ (80169d8 <MIOS32_SPI_IO_Init+0x258>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK1_PIN;
 80169a6:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 80169a8:	4669      	mov	r1, sp
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80169aa:	f88d 4004 	strb.w	r4, [sp, #4]
	GPIO_Init(MIOS32_SPI2_RCLK1_PORT, &GPIO_InitStructure);
 80169ae:	f002 fbfb 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80169b2:	f44f 7380 	mov.w	r3, #256	@ 0x100
	GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80169b6:	480a      	ldr	r0, [pc, #40]	@ (80169e0 <MIOS32_SPI_IO_Init+0x260>)
	GPIO_InitStructure.GPIO_Pin  = MIOS32_SPI2_RCLK2_PIN;
 80169b8:	9300      	str	r3, [sp, #0]
	GPIO_Init(MIOS32_SPI2_RCLK2_PORT, &GPIO_InitStructure);
 80169ba:	4669      	mov	r1, sp
 80169bc:	f002 fbf4 	bl	80191a8 <GPIO_Init>
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80169c0:	f88d 5004 	strb.w	r5, [sp, #4]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 80169c4:	f88d 4007 	strb.w	r4, [sp, #7]
 80169c8:	e7df      	b.n	801698a <MIOS32_SPI_IO_Init+0x20a>
      return -3; // unsupported pin driver mode
 80169ca:	f06f 0002 	mvn.w	r0, #2
 80169ce:	e743      	b.n	8016858 <MIOS32_SPI_IO_Init+0xd8>
  switch( spi ) {
 80169d0:	f06f 0001 	mvn.w	r0, #1
 80169d4:	e740      	b.n	8016858 <MIOS32_SPI_IO_Init+0xd8>
 80169d6:	bf00      	nop
 80169d8:	40020000 	.word	0x40020000
 80169dc:	40021000 	.word	0x40021000
 80169e0:	40020400 	.word	0x40020400
 80169e4:	40020c00 	.word	0x40020c00

080169e8 <MIOS32_SPI_RC_PinSet>:
//! \return -2 if unsupported SPI port selected
//! \return -3 if unsupported RCx pin selected
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_RC_PinSet(u8 spi, u8 rc_pin, u8 pin_value)
{
  switch( spi ) {
 80169e8:	2801      	cmp	r0, #1
 80169ea:	d012      	beq.n	8016a12 <MIOS32_SPI_RC_PinSet+0x2a>
 80169ec:	2802      	cmp	r0, #2
 80169ee:	d01b      	beq.n	8016a28 <MIOS32_SPI_RC_PinSet+0x40>
 80169f0:	bb38      	cbnz	r0, 8016a42 <MIOS32_SPI_RC_PinSet+0x5a>
  case 0:
#ifdef MIOS32_DONT_USE_SPI0
    return -1; // disabled SPI port
#else
    switch( rc_pin ) {
 80169f2:	b121      	cbz	r1, 80169fe <MIOS32_SPI_RC_PinSet+0x16>
 80169f4:	2901      	cmp	r1, #1
 80169f6:	d008      	beq.n	8016a0a <MIOS32_SPI_RC_PinSet+0x22>
 80169f8:	f06f 0002 	mvn.w	r0, #2
 80169fc:	4770      	bx	lr
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK1_PORT, MIOS32_SPI0_RCLK1_PIN, pin_value); break;
 80169fe:	4b12      	ldr	r3, [pc, #72]	@ (8016a48 <MIOS32_SPI_RC_PinSet+0x60>)
 8016a00:	2104      	movs	r1, #4
  case 2:
#ifdef MIOS32_DONT_USE_SPI2
    return -1; // disabled SPI port
#else
    switch( rc_pin ) {
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK1_PORT, MIOS32_SPI2_RCLK1_PIN, pin_value); break;
 8016a02:	b1e2      	cbz	r2, 8016a3e <MIOS32_SPI_RC_PinSet+0x56>
 8016a04:	8319      	strh	r1, [r3, #24]

  default:
    return -2; // unsupported SPI port
  }

  return 0; // no error
 8016a06:	2000      	movs	r0, #0
 8016a08:	4770      	bx	lr
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK2_PORT, MIOS32_SPI0_RCLK2_PIN, pin_value); break;
 8016a0a:	4b10      	ldr	r3, [pc, #64]	@ (8016a4c <MIOS32_SPI_RC_PinSet+0x64>)
 8016a0c:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 8016a10:	e7f7      	b.n	8016a02 <MIOS32_SPI_RC_PinSet+0x1a>
    switch( rc_pin ) {
 8016a12:	b129      	cbz	r1, 8016a20 <MIOS32_SPI_RC_PinSet+0x38>
 8016a14:	2901      	cmp	r1, #1
 8016a16:	d1ef      	bne.n	80169f8 <MIOS32_SPI_RC_PinSet+0x10>
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI1_RCLK2_PORT, MIOS32_SPI1_RCLK2_PIN, pin_value); break;
 8016a18:	4b0c      	ldr	r3, [pc, #48]	@ (8016a4c <MIOS32_SPI_RC_PinSet+0x64>)
 8016a1a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8016a1e:	e7f0      	b.n	8016a02 <MIOS32_SPI_RC_PinSet+0x1a>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI1_RCLK1_PORT, MIOS32_SPI1_RCLK1_PIN, pin_value); break;
 8016a20:	4b09      	ldr	r3, [pc, #36]	@ (8016a48 <MIOS32_SPI_RC_PinSet+0x60>)
 8016a22:	f44f 5180 	mov.w	r1, #4096	@ 0x1000
 8016a26:	e7ec      	b.n	8016a02 <MIOS32_SPI_RC_PinSet+0x1a>
    switch( rc_pin ) {
 8016a28:	b129      	cbz	r1, 8016a36 <MIOS32_SPI_RC_PinSet+0x4e>
 8016a2a:	2901      	cmp	r1, #1
 8016a2c:	d1e4      	bne.n	80169f8 <MIOS32_SPI_RC_PinSet+0x10>
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK2_PORT, MIOS32_SPI2_RCLK2_PIN, pin_value); break;
 8016a2e:	4b06      	ldr	r3, [pc, #24]	@ (8016a48 <MIOS32_SPI_RC_PinSet+0x60>)
 8016a30:	f44f 7180 	mov.w	r1, #256	@ 0x100
 8016a34:	e7e5      	b.n	8016a02 <MIOS32_SPI_RC_PinSet+0x1a>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK1_PORT, MIOS32_SPI2_RCLK1_PIN, pin_value); break;
 8016a36:	4b06      	ldr	r3, [pc, #24]	@ (8016a50 <MIOS32_SPI_RC_PinSet+0x68>)
 8016a38:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8016a3c:	e7e1      	b.n	8016a02 <MIOS32_SPI_RC_PinSet+0x1a>
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK2_PORT, MIOS32_SPI2_RCLK2_PIN, pin_value); break;
 8016a3e:	8359      	strh	r1, [r3, #26]
 8016a40:	e7e1      	b.n	8016a06 <MIOS32_SPI_RC_PinSet+0x1e>
  switch( spi ) {
 8016a42:	f06f 0001 	mvn.w	r0, #1
}
 8016a46:	4770      	bx	lr
 8016a48:	40020400 	.word	0x40020400
 8016a4c:	40020c00 	.word	0x40020c00
 8016a50:	40020000 	.word	0x40020000

08016a54 <MIOS32_SPI_TransferByte>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferByte(u8 spi, u8 b)
{
  SPI_TypeDef *spi_ptr;

  switch( spi ) {
 8016a54:	2802      	cmp	r0, #2
 8016a56:	d811      	bhi.n	8016a7c <MIOS32_SPI_TransferByte+0x28>
 8016a58:	4b0a      	ldr	r3, [pc, #40]	@ (8016a84 <MIOS32_SPI_TransferByte+0x30>)
 8016a5a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    default:
      return -2; // unsupported SPI port
  }

  // send byte
  spi_ptr->DR = b;
 8016a5e:	8199      	strh	r1, [r3, #12]

  // TK update: the dummy read above becomes obsolete since we are checking for SPI Master mode now
  // which requires a read operation as well

  // wait until SPI transfer finished
  if( spi_ptr->CR1 & SPI_Mode_Master ) {
 8016a60:	881a      	ldrh	r2, [r3, #0]
 8016a62:	f402 7282 	and.w	r2, r2, #260	@ 0x104
 8016a66:	b12a      	cbz	r2, 8016a74 <MIOS32_SPI_TransferByte+0x20>
    while( spi_ptr->SR & SPI_I2S_FLAG_BSY );
 8016a68:	891a      	ldrh	r2, [r3, #8]
 8016a6a:	0611      	lsls	r1, r2, #24
 8016a6c:	d4fc      	bmi.n	8016a68 <MIOS32_SPI_TransferByte+0x14>
  } else {
    while( !(spi_ptr->SR & SPI_I2S_FLAG_RXNE) );
  }

  // return received byte
  return spi_ptr->DR;
 8016a6e:	8998      	ldrh	r0, [r3, #12]
 8016a70:	b280      	uxth	r0, r0
 8016a72:	4770      	bx	lr
    while( !(spi_ptr->SR & SPI_I2S_FLAG_RXNE) );
 8016a74:	891a      	ldrh	r2, [r3, #8]
 8016a76:	07d2      	lsls	r2, r2, #31
 8016a78:	d5fc      	bpl.n	8016a74 <MIOS32_SPI_TransferByte+0x20>
 8016a7a:	e7f8      	b.n	8016a6e <MIOS32_SPI_TransferByte+0x1a>
      return -2; // unsupported SPI port
 8016a7c:	f06f 0001 	mvn.w	r0, #1
}
 8016a80:	4770      	bx	lr
 8016a82:	bf00      	nop
 8016a84:	08026e98 	.word	0x08026e98

08016a88 <MIOS32_SPI_TransferModeInit>:
{
 8016a88:	b570      	push	{r4, r5, r6, lr}
 8016a8a:	b086      	sub	sp, #24
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8016a8c:	f04f 7382 	mov.w	r3, #17039360	@ 0x1040000
{
 8016a90:	4604      	mov	r4, r0
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8016a92:	f44f 7000 	mov.w	r0, #512	@ 0x200
  SPI_InitStructure.SPI_Direction     = SPI_Direction_2Lines_FullDuplex;
 8016a96:	9301      	str	r3, [sp, #4]
  SPI_InitStructure.SPI_NSS           = SPI_NSS_Soft;
 8016a98:	f8ad 000e 	strh.w	r0, [sp, #14]
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8016a9c:	2300      	movs	r3, #0
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8016a9e:	2007      	movs	r0, #7
  SPI_InitStructure.SPI_DataSize      = SPI_DataSize_8b;
 8016aa0:	f8ad 3008 	strh.w	r3, [sp, #8]
  SPI_InitStructure.SPI_FirstBit      = SPI_FirstBit_MSB;
 8016aa4:	f8ad 3012 	strh.w	r3, [sp, #18]
  SPI_InitStructure.SPI_CRCPolynomial = 7;
 8016aa8:	f8ad 0014 	strh.w	r0, [sp, #20]
  switch( spi_mode ) {
 8016aac:	2907      	cmp	r1, #7
 8016aae:	d84f      	bhi.n	8016b50 <MIOS32_SPI_TransferModeInit+0xc8>
 8016ab0:	e8df f001 	tbb	[pc, r1]
 8016ab4:	453f3808 	.word	0x453f3808
 8016ab8:	413b3404 	.word	0x413b3404
      SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
 8016abc:	f8ad 3006 	strh.w	r3, [sp, #6]
      SPI_InitStructure.SPI_NSS  = SPI_NSS_Hard;
 8016ac0:	f8ad 300e 	strh.w	r3, [sp, #14]
      break;
 8016ac4:	2300      	movs	r3, #0
      break;
 8016ac6:	2100      	movs	r1, #0
  if( spi_prescaler >= 8 )
 8016ac8:	2a07      	cmp	r2, #7
      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8016aca:	f8ad 300a 	strh.w	r3, [sp, #10]
      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 8016ace:	f8ad 100c 	strh.w	r1, [sp, #12]
  if( spi_prescaler >= 8 )
 8016ad2:	d843      	bhi.n	8016b5c <MIOS32_SPI_TransferModeInit+0xd4>
  switch( spi ) {
 8016ad4:	2c01      	cmp	r4, #1
 8016ad6:	d034      	beq.n	8016b42 <MIOS32_SPI_TransferModeInit+0xba>
 8016ad8:	2c02      	cmp	r4, #2
 8016ada:	d037      	beq.n	8016b4c <MIOS32_SPI_TransferModeInit+0xc4>
 8016adc:	2c00      	cmp	r4, #0
 8016ade:	d13a      	bne.n	8016b56 <MIOS32_SPI_TransferModeInit+0xce>
      if( SPI_InitStructure.SPI_Mode == SPI_Mode_Slave ) {
 8016ae0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8016ae4:	2b00      	cmp	r3, #0
 8016ae6:	d039      	beq.n	8016b5c <MIOS32_SPI_TransferModeInit+0xd4>
      u16 prev_cr1 = MIOS32_SPI0_PTR->CR1;
 8016ae8:	4e1e      	ldr	r6, [pc, #120]	@ (8016b64 <MIOS32_SPI_TransferModeInit+0xdc>)
 8016aea:	8835      	ldrh	r5, [r6, #0]
 8016aec:	b2ad      	uxth	r5, r5
      SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8016aee:	00d2      	lsls	r2, r2, #3
      SPI_Init(MIOS32_SPI2_PTR, &SPI_InitStructure);
 8016af0:	a901      	add	r1, sp, #4
 8016af2:	4630      	mov	r0, r6
      SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8016af4:	f8ad 2010 	strh.w	r2, [sp, #16]
      SPI_Init(MIOS32_SPI2_PTR, &SPI_InitStructure);
 8016af8:	f002 fd6c 	bl	80195d4 <SPI_Init>
      if( SPI_InitStructure.SPI_Mode == SPI_Mode_Master ) {
 8016afc:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8016b00:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8016b04:	d107      	bne.n	8016b16 <MIOS32_SPI_TransferModeInit+0x8e>
	if( (prev_cr1 ^ MIOS32_SPI2_PTR->CR1) & 3 ) { // CPOL and CPHA located at bit #1 and #0
 8016b06:	8833      	ldrh	r3, [r6, #0]
 8016b08:	405d      	eors	r5, r3
 8016b0a:	07ab      	lsls	r3, r5, #30
 8016b0c:	d003      	beq.n	8016b16 <MIOS32_SPI_TransferModeInit+0x8e>
	  MIOS32_SPI_TransferByte(spi, 0xff);
 8016b0e:	21ff      	movs	r1, #255	@ 0xff
 8016b10:	4620      	mov	r0, r4
 8016b12:	f7ff ff9f 	bl	8016a54 <MIOS32_SPI_TransferByte>
  return 0; // no error
 8016b16:	2000      	movs	r0, #0
}
 8016b18:	b006      	add	sp, #24
 8016b1a:	bd70      	pop	{r4, r5, r6, pc}
      SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
 8016b1c:	f8ad 3006 	strh.w	r3, [sp, #6]
      SPI_InitStructure.SPI_NSS  = SPI_NSS_Hard;
 8016b20:	f8ad 300e 	strh.w	r3, [sp, #14]
      break;
 8016b24:	2300      	movs	r3, #0
      break;
 8016b26:	2101      	movs	r1, #1
 8016b28:	e7ce      	b.n	8016ac8 <MIOS32_SPI_TransferModeInit+0x40>
      SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
 8016b2a:	f8ad 3006 	strh.w	r3, [sp, #6]
      SPI_InitStructure.SPI_NSS  = SPI_NSS_Hard;
 8016b2e:	f8ad 300e 	strh.w	r3, [sp, #14]
      break;
 8016b32:	2302      	movs	r3, #2
 8016b34:	e7c7      	b.n	8016ac6 <MIOS32_SPI_TransferModeInit+0x3e>
      SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
 8016b36:	f8ad 3006 	strh.w	r3, [sp, #6]
      SPI_InitStructure.SPI_NSS  = SPI_NSS_Hard;
 8016b3a:	f8ad 300e 	strh.w	r3, [sp, #14]
      break;
 8016b3e:	2302      	movs	r3, #2
 8016b40:	e7f1      	b.n	8016b26 <MIOS32_SPI_TransferModeInit+0x9e>
      u16 prev_cr1 = MIOS32_SPI1_PTR->CR1;
 8016b42:	4e09      	ldr	r6, [pc, #36]	@ (8016b68 <MIOS32_SPI_TransferModeInit+0xe0>)
      u16 prev_cr1 = MIOS32_SPI2_PTR->CR1;
 8016b44:	8835      	ldrh	r5, [r6, #0]
      SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8016b46:	3a01      	subs	r2, #1
      u16 prev_cr1 = MIOS32_SPI2_PTR->CR1;
 8016b48:	b2ad      	uxth	r5, r5
      SPI_InitStructure.SPI_BaudRatePrescaler = (((u16)spi_prescaler&7)-1) << 3;
 8016b4a:	e7d0      	b.n	8016aee <MIOS32_SPI_TransferModeInit+0x66>
      u16 prev_cr1 = MIOS32_SPI2_PTR->CR1;
 8016b4c:	4e07      	ldr	r6, [pc, #28]	@ (8016b6c <MIOS32_SPI_TransferModeInit+0xe4>)
 8016b4e:	e7f9      	b.n	8016b44 <MIOS32_SPI_TransferModeInit+0xbc>
  switch( spi_mode ) {
 8016b50:	f06f 0003 	mvn.w	r0, #3
 8016b54:	e7e0      	b.n	8016b18 <MIOS32_SPI_TransferModeInit+0x90>
  switch( spi ) {
 8016b56:	f06f 0001 	mvn.w	r0, #1
 8016b5a:	e7dd      	b.n	8016b18 <MIOS32_SPI_TransferModeInit+0x90>
    return -3; // invalid prescaler selected
 8016b5c:	f06f 0002 	mvn.w	r0, #2
 8016b60:	e7da      	b.n	8016b18 <MIOS32_SPI_TransferModeInit+0x90>
 8016b62:	bf00      	nop
 8016b64:	40013000 	.word	0x40013000
 8016b68:	40003800 	.word	0x40003800
 8016b6c:	40003c00 	.word	0x40003c00

08016b70 <MIOS32_SPI_Init>:
{
 8016b70:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if( mode != 0 )
 8016b74:	4604      	mov	r4, r0
{
 8016b76:	b090      	sub	sp, #64	@ 0x40
  if( mode != 0 )
 8016b78:	2800      	cmp	r0, #0
 8016b7a:	f040 8101 	bne.w	8016d80 <MIOS32_SPI_Init+0x210>
  spi_callback[0] = NULL;
 8016b7e:	f8df 9208 	ldr.w	r9, [pc, #520]	@ 8016d88 <MIOS32_SPI_Init+0x218>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK1_PORT, MIOS32_SPI0_RCLK1_PIN, pin_value); break;
 8016b82:	f8df 8208 	ldr.w	r8, [pc, #520]	@ 8016d8c <MIOS32_SPI_Init+0x21c>
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK2_PORT, MIOS32_SPI0_RCLK2_PIN, pin_value); break;
 8016b86:	f8df a208 	ldr.w	sl, [pc, #520]	@ 8016d90 <MIOS32_SPI_Init+0x220>
  DMA_StructInit(&DMA_InitStructure);
 8016b8a:	a801      	add	r0, sp, #4
 8016b8c:	f002 fa22 	bl	8018fd4 <DMA_StructInit>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK1_PORT, MIOS32_SPI0_RCLK1_PIN, pin_value); break;
 8016b90:	2304      	movs	r3, #4
  spi_callback[0] = NULL;
 8016b92:	f8c9 4000 	str.w	r4, [r9]
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK1_PORT, MIOS32_SPI0_RCLK1_PIN, pin_value); break;
 8016b96:	f8a8 3018 	strh.w	r3, [r8, #24]
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI0_RCLK2_PORT, MIOS32_SPI0_RCLK2_PIN, pin_value); break;
 8016b9a:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8016b9e:	f8aa 3018 	strh.w	r3, [sl, #24]
  MIOS32_SPI_IO_Init(0, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016ba2:	2102      	movs	r1, #2
 8016ba4:	4620      	mov	r0, r4
 8016ba6:	f7ff fdeb 	bl	8016780 <MIOS32_SPI_IO_Init>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
 8016baa:	2101      	movs	r1, #1
 8016bac:	f44f 5080 	mov.w	r0, #4096	@ 0x1000
 8016bb0:	f002 fc0a 	bl	80193c8 <RCC_APB2PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
 8016bb4:	2101      	movs	r1, #1
 8016bb6:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 8016bba:	f002 fbe1 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 8016bbe:	2101      	movs	r1, #1
 8016bc0:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 8016bc4:	f002 fbdc 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  DMA_Cmd(MIOS32_SPI0_DMA_RX_PTR, DISABLE);
 8016bc8:	4872      	ldr	r0, [pc, #456]	@ (8016d94 <MIOS32_SPI_Init+0x224>)
 8016bca:	4621      	mov	r1, r4
 8016bcc:	f002 fa13 	bl	8018ff6 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8016bd0:	4b71      	ldr	r3, [pc, #452]	@ (8016d98 <MIOS32_SPI_Init+0x228>)
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8016bd2:	4870      	ldr	r0, [pc, #448]	@ (8016d94 <MIOS32_SPI_Init+0x224>)
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016bd4:	f44f 6580 	mov.w	r5, #1024	@ 0x400
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8016bd8:	f04f 66c0 	mov.w	r6, #100663296	@ 0x6000000
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8016bdc:	f44f 3780 	mov.w	r7, #65536	@ 0x10000
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8016be0:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI0_PTR->DR;
 8016be2:	e9cd 6301 	strd	r6, r3, [sp, #4]
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 8016be6:	e9cd 4403 	strd	r4, r4, [sp, #12]
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8016bea:	e9cd 4405 	strd	r4, r4, [sp, #20]
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8016bee:	e9cd 5407 	strd	r5, r4, [sp, #28]
  DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 8016bf2:	e9cd 4409 	strd	r4, r4, [sp, #36]	@ 0x24
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8016bf6:	970b      	str	r7, [sp, #44]	@ 0x2c
  DMA_Init(MIOS32_SPI0_DMA_RX_PTR, &DMA_InitStructure);
 8016bf8:	f002 f9c2 	bl	8018f80 <DMA_Init>
  DMA_Cmd(MIOS32_SPI0_DMA_TX_PTR, DISABLE);
 8016bfc:	4867      	ldr	r0, [pc, #412]	@ (8016d9c <MIOS32_SPI_Init+0x22c>)
 8016bfe:	4621      	mov	r1, r4
 8016c00:	f002 f9f9 	bl	8018ff6 <DMA_Cmd>
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8016c04:	4865      	ldr	r0, [pc, #404]	@ (8016d9c <MIOS32_SPI_Init+0x22c>)
  DMA_InitStructure.DMA_Channel = MIOS32_SPI0_DMA_TX_CHN;
 8016c06:	9601      	str	r6, [sp, #4]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8016c08:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 8016c0a:	2640      	movs	r6, #64	@ 0x40
  DMA_InitStructure.DMA_Memory0BaseAddr = 0; // will be configured later
 8016c0c:	9403      	str	r4, [sp, #12]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8016c0e:	9405      	str	r4, [sp, #20]
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 8016c10:	9604      	str	r6, [sp, #16]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016c12:	9507      	str	r5, [sp, #28]
  DMA_Init(MIOS32_SPI0_DMA_TX_PTR, &DMA_InitStructure);
 8016c14:	f002 f9b4 	bl	8018f80 <DMA_Init>
  SPI_Cmd(MIOS32_SPI0_PTR, ENABLE);
 8016c18:	4861      	ldr	r0, [pc, #388]	@ (8016da0 <MIOS32_SPI_Init+0x230>)
 8016c1a:	2101      	movs	r1, #1
 8016c1c:	f002 fcf9 	bl	8019612 <SPI_Cmd>
  SPI_I2S_DMACmd(MIOS32_SPI0_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8016c20:	2201      	movs	r2, #1
 8016c22:	485f      	ldr	r0, [pc, #380]	@ (8016da0 <MIOS32_SPI_Init+0x230>)
 8016c24:	2103      	movs	r1, #3
 8016c26:	f002 fd00 	bl	801962a <SPI_I2S_DMACmd>
  MIOS32_IRQ_Install(MIOS32_SPI0_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8016c2a:	2105      	movs	r1, #5
 8016c2c:	203a      	movs	r0, #58	@ 0x3a
 8016c2e:	f7ff fd85 	bl	801673c <MIOS32_IRQ_Install>
  MIOS32_SPI_TransferModeInit(0, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8016c32:	2206      	movs	r2, #6
 8016c34:	2103      	movs	r1, #3
 8016c36:	4620      	mov	r0, r4
 8016c38:	f7ff ff26 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI1_RCLK1_PORT, MIOS32_SPI1_RCLK1_PIN, pin_value); break;
 8016c3c:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
  spi_callback[1] = NULL;
 8016c40:	f8c9 4004 	str.w	r4, [r9, #4]
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016c44:	2102      	movs	r1, #2
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI1_RCLK1_PORT, MIOS32_SPI1_RCLK1_PIN, pin_value); break;
 8016c46:	f8a8 3018 	strh.w	r3, [r8, #24]
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016c4a:	2001      	movs	r0, #1
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI1_RCLK2_PORT, MIOS32_SPI1_RCLK2_PIN, pin_value); break;
 8016c4c:	f8aa 5018 	strh.w	r5, [sl, #24]
  MIOS32_SPI_IO_Init(1, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016c50:	f7ff fd96 	bl	8016780 <MIOS32_SPI_IO_Init>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 8016c54:	2101      	movs	r1, #1
 8016c56:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 8016c5a:	f002 fba9 	bl	80193b0 <RCC_APB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
 8016c5e:	2101      	movs	r1, #1
 8016c60:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 8016c64:	f002 fb8c 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 8016c68:	2101      	movs	r1, #1
 8016c6a:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 8016c6e:	f002 fb87 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  DMA_Cmd(MIOS32_SPI1_DMA_RX_PTR, DISABLE);
 8016c72:	484c      	ldr	r0, [pc, #304]	@ (8016da4 <MIOS32_SPI_Init+0x234>)
 8016c74:	4621      	mov	r1, r4
 8016c76:	f002 f9be 	bl	8018ff6 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI1_PTR->DR;
 8016c7a:	4b4b      	ldr	r3, [pc, #300]	@ (8016da8 <MIOS32_SPI_Init+0x238>)
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8016c7c:	4849      	ldr	r0, [pc, #292]	@ (8016da4 <MIOS32_SPI_Init+0x234>)
  DMA_InitStructure.DMA_Channel = MIOS32_SPI1_DMA_RX_CHN;
 8016c7e:	9401      	str	r4, [sp, #4]
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8016c80:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_Memory0BaseAddr = 0; // will be configured later
 8016c82:	e9cd 3402 	strd	r3, r4, [sp, #8]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8016c86:	e9cd 4404 	strd	r4, r4, [sp, #16]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016c8a:	e9cd 4506 	strd	r4, r5, [sp, #24]
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8016c8e:	e9cd 4408 	strd	r4, r4, [sp, #32]
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8016c92:	e9cd 470a 	strd	r4, r7, [sp, #40]	@ 0x28
  DMA_Init(MIOS32_SPI1_DMA_RX_PTR, &DMA_InitStructure);
 8016c96:	f002 f973 	bl	8018f80 <DMA_Init>
  DMA_Cmd(MIOS32_SPI1_DMA_TX_PTR, DISABLE);
 8016c9a:	4844      	ldr	r0, [pc, #272]	@ (8016dac <MIOS32_SPI_Init+0x23c>)
 8016c9c:	4621      	mov	r1, r4
 8016c9e:	f002 f9aa 	bl	8018ff6 <DMA_Cmd>
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8016ca2:	4842      	ldr	r0, [pc, #264]	@ (8016dac <MIOS32_SPI_Init+0x23c>)
  DMA_InitStructure.DMA_Channel = MIOS32_SPI1_DMA_TX_CHN;
 8016ca4:	9401      	str	r4, [sp, #4]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8016ca6:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 8016ca8:	e9cd 6404 	strd	r6, r4, [sp, #16]
  DMA_InitStructure.DMA_Memory0BaseAddr = 0; // will be configured later
 8016cac:	9403      	str	r4, [sp, #12]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016cae:	9507      	str	r5, [sp, #28]
  DMA_Init(MIOS32_SPI1_DMA_TX_PTR, &DMA_InitStructure);
 8016cb0:	f002 f966 	bl	8018f80 <DMA_Init>
  SPI_Cmd(MIOS32_SPI1_PTR, ENABLE);
 8016cb4:	483e      	ldr	r0, [pc, #248]	@ (8016db0 <MIOS32_SPI_Init+0x240>)
 8016cb6:	2101      	movs	r1, #1
 8016cb8:	f002 fcab 	bl	8019612 <SPI_Cmd>
  SPI_I2S_DMACmd(MIOS32_SPI1_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8016cbc:	2201      	movs	r2, #1
 8016cbe:	483c      	ldr	r0, [pc, #240]	@ (8016db0 <MIOS32_SPI_Init+0x240>)
 8016cc0:	2103      	movs	r1, #3
 8016cc2:	f002 fcb2 	bl	801962a <SPI_I2S_DMACmd>
  MIOS32_IRQ_Install(MIOS32_SPI1_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8016cc6:	2105      	movs	r1, #5
 8016cc8:	200e      	movs	r0, #14
 8016cca:	f7ff fd37 	bl	801673c <MIOS32_IRQ_Install>
  MIOS32_SPI_TransferModeInit(1, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8016cce:	2206      	movs	r2, #6
 8016cd0:	2103      	movs	r1, #3
 8016cd2:	2001      	movs	r0, #1
 8016cd4:	f7ff fed8 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK1_PORT, MIOS32_SPI2_RCLK1_PIN, pin_value); break;
 8016cd8:	4b36      	ldr	r3, [pc, #216]	@ (8016db4 <MIOS32_SPI_Init+0x244>)
  spi_callback[2] = NULL;
 8016cda:	f8c9 4008 	str.w	r4, [r9, #8]
    case 0: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK1_PORT, MIOS32_SPI2_RCLK1_PIN, pin_value); break;
 8016cde:	f44f 4900 	mov.w	r9, #32768	@ 0x8000
 8016ce2:	f8a3 9018 	strh.w	r9, [r3, #24]
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016ce6:	2102      	movs	r1, #2
    case 1: MIOS32_SYS_STM_PINSET(MIOS32_SPI2_RCLK2_PORT, MIOS32_SPI2_RCLK2_PIN, pin_value); break;
 8016ce8:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8016cec:	f8a8 3018 	strh.w	r3, [r8, #24]
  MIOS32_SPI_IO_Init(2, MIOS32_SPI_PIN_DRIVER_WEAK);
 8016cf0:	4608      	mov	r0, r1
 8016cf2:	f7ff fd45 	bl	8016780 <MIOS32_SPI_IO_Init>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);
 8016cf6:	2101      	movs	r1, #1
 8016cf8:	4648      	mov	r0, r9
 8016cfa:	f002 fb59 	bl	80193b0 <RCC_APB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);
 8016cfe:	2101      	movs	r1, #1
 8016d00:	f44f 1000 	mov.w	r0, #2097152	@ 0x200000
 8016d04:	f002 fb3c 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 8016d08:	2101      	movs	r1, #1
 8016d0a:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 8016d0e:	f002 fb37 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  DMA_Cmd(MIOS32_SPI2_DMA_RX_PTR, DISABLE);
 8016d12:	4829      	ldr	r0, [pc, #164]	@ (8016db8 <MIOS32_SPI_Init+0x248>)
 8016d14:	4621      	mov	r1, r4
 8016d16:	f002 f96e 	bl	8018ff6 <DMA_Cmd>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&MIOS32_SPI2_PTR->DR;
 8016d1a:	4b28      	ldr	r3, [pc, #160]	@ (8016dbc <MIOS32_SPI_Init+0x24c>)
  DMA_Init(MIOS32_SPI2_DMA_RX_PTR, &DMA_InitStructure);
 8016d1c:	4826      	ldr	r0, [pc, #152]	@ (8016db8 <MIOS32_SPI_Init+0x248>)
  DMA_InitStructure.DMA_Channel = MIOS32_SPI2_DMA_RX_CHN;
 8016d1e:	9401      	str	r4, [sp, #4]
  DMA_Init(MIOS32_SPI2_DMA_RX_PTR, &DMA_InitStructure);
 8016d20:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_Memory0BaseAddr = 0; // will be configured later
 8016d22:	e9cd 3402 	strd	r3, r4, [sp, #8]
  DMA_InitStructure.DMA_BufferSize = 0; // will be configured later
 8016d26:	e9cd 4404 	strd	r4, r4, [sp, #16]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016d2a:	e9cd 4506 	strd	r4, r5, [sp, #24]
  DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8016d2e:	e9cd 4408 	strd	r4, r4, [sp, #32]
  DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
 8016d32:	e9cd 470a 	strd	r4, r7, [sp, #40]	@ 0x28
  DMA_Init(MIOS32_SPI2_DMA_RX_PTR, &DMA_InitStructure);
 8016d36:	f002 f923 	bl	8018f80 <DMA_Init>
  DMA_Cmd(MIOS32_SPI2_DMA_TX_PTR, DISABLE);
 8016d3a:	4821      	ldr	r0, [pc, #132]	@ (8016dc0 <MIOS32_SPI_Init+0x250>)
 8016d3c:	4621      	mov	r1, r4
 8016d3e:	f002 f95a 	bl	8018ff6 <DMA_Cmd>
  DMA_Init(MIOS32_SPI2_DMA_TX_PTR, &DMA_InitStructure);
 8016d42:	481f      	ldr	r0, [pc, #124]	@ (8016dc0 <MIOS32_SPI_Init+0x250>)
  DMA_InitStructure.DMA_Channel = MIOS32_SPI2_DMA_TX_CHN;
 8016d44:	9401      	str	r4, [sp, #4]
  DMA_Init(MIOS32_SPI2_DMA_TX_PTR, &DMA_InitStructure);
 8016d46:	a901      	add	r1, sp, #4
  DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
 8016d48:	e9cd 6404 	strd	r6, r4, [sp, #16]
  DMA_InitStructure.DMA_Memory0BaseAddr = 0; // will be configured later
 8016d4c:	9403      	str	r4, [sp, #12]
  DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 8016d4e:	9507      	str	r5, [sp, #28]
  DMA_Init(MIOS32_SPI2_DMA_TX_PTR, &DMA_InitStructure);
 8016d50:	f002 f916 	bl	8018f80 <DMA_Init>
  SPI_Cmd(MIOS32_SPI2_PTR, ENABLE);
 8016d54:	481b      	ldr	r0, [pc, #108]	@ (8016dc4 <MIOS32_SPI_Init+0x254>)
 8016d56:	2101      	movs	r1, #1
 8016d58:	f002 fc5b 	bl	8019612 <SPI_Cmd>
  SPI_I2S_DMACmd(MIOS32_SPI2_PTR, SPI_I2S_DMAReq_Tx | SPI_I2S_DMAReq_Rx, ENABLE);
 8016d5c:	2201      	movs	r2, #1
 8016d5e:	4819      	ldr	r0, [pc, #100]	@ (8016dc4 <MIOS32_SPI_Init+0x254>)
 8016d60:	2103      	movs	r1, #3
 8016d62:	f002 fc62 	bl	801962a <SPI_I2S_DMACmd>
  MIOS32_IRQ_Install(MIOS32_SPI2_DMA_IRQ_CHANNEL, MIOS32_IRQ_SPI_DMA_PRIORITY);
 8016d66:	2105      	movs	r1, #5
 8016d68:	200d      	movs	r0, #13
 8016d6a:	f7ff fce7 	bl	801673c <MIOS32_IRQ_Install>
  MIOS32_SPI_TransferModeInit(2, MIOS32_SPI_MODE_CLK1_PHASE1, MIOS32_SPI_PRESCALER_128);
 8016d6e:	2206      	movs	r2, #6
 8016d70:	2103      	movs	r1, #3
 8016d72:	2002      	movs	r0, #2
 8016d74:	f7ff fe88 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
  return 0; // no error
 8016d78:	4620      	mov	r0, r4
}
 8016d7a:	b010      	add	sp, #64	@ 0x40
 8016d7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return -1; // unsupported mode
 8016d80:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8016d84:	e7f9      	b.n	8016d7a <MIOS32_SPI_Init+0x20a>
 8016d86:	bf00      	nop
 8016d88:	200031e8 	.word	0x200031e8
 8016d8c:	40020400 	.word	0x40020400
 8016d90:	40020c00 	.word	0x40020c00
 8016d94:	40026440 	.word	0x40026440
 8016d98:	4001300c 	.word	0x4001300c
 8016d9c:	40026458 	.word	0x40026458
 8016da0:	40013000 	.word	0x40013000
 8016da4:	40026058 	.word	0x40026058
 8016da8:	4000380c 	.word	0x4000380c
 8016dac:	40026070 	.word	0x40026070
 8016db0:	40003800 	.word	0x40003800
 8016db4:	40020000 	.word	0x40020000
 8016db8:	40026040 	.word	0x40026040
 8016dbc:	40003c0c 	.word	0x40003c0c
 8016dc0:	40026088 	.word	0x40026088
 8016dc4:	40003c00 	.word	0x40003c00

08016dc8 <MIOS32_SPI_TransferBlock>:
//! \return -1 if disabled SPI port selected
//! \return -2 if unsupported SPI port selected
//! \return -3 if function has been called during an ongoing DMA transfer
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_SPI_TransferBlock(u8 spi, u8 *send_buffer, u8 *receive_buffer, u16 len, void *callback)
{
 8016dc8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016dcc:	2802      	cmp	r0, #2
 8016dce:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8016dd2:	d857      	bhi.n	8016e84 <MIOS32_SPI_TransferBlock+0xbc>
 8016dd4:	4d2e      	ldr	r5, [pc, #184]	@ (8016e90 <MIOS32_SPI_TransferBlock+0xc8>)
 8016dd6:	4c2f      	ldr	r4, [pc, #188]	@ (8016e94 <MIOS32_SPI_TransferBlock+0xcc>)
 8016dd8:	f855 7020 	ldr.w	r7, [r5, r0, lsl #2]
 8016ddc:	4d2e      	ldr	r5, [pc, #184]	@ (8016e98 <MIOS32_SPI_TransferBlock+0xd0>)
 8016dde:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
 8016de2:	f855 6020 	ldr.w	r6, [r5, r0, lsl #2]
 8016de6:	4d2d      	ldr	r5, [pc, #180]	@ (8016e9c <MIOS32_SPI_TransferBlock+0xd4>)
 8016de8:	f855 9020 	ldr.w	r9, [r5, r0, lsl #2]
 8016dec:	4d2c      	ldr	r5, [pc, #176]	@ (8016ea0 <MIOS32_SPI_TransferBlock+0xd8>)
 8016dee:	f855 c020 	ldr.w	ip, [r5, r0, lsl #2]
    default:
      return -2; // unsupported SPI port
  }

  // exit if ongoing transfer
  if( dma_rx_ptr->NDTR )
 8016df2:	6875      	ldr	r5, [r6, #4]
 8016df4:	2d00      	cmp	r5, #0
 8016df6:	d148      	bne.n	8016e8a <MIOS32_SPI_TransferBlock+0xc2>
    return -3;

  // set callback function
  spi_callback[spi] = callback;
 8016df8:	4d2a      	ldr	r5, [pc, #168]	@ (8016ea4 <MIOS32_SPI_TransferBlock+0xdc>)
 8016dfa:	f845 8020 	str.w	r8, [r5, r0, lsl #2]

  // ensure that previously received value doesn't cause DMA access
  if( spi_ptr->DR );
 8016dfe:	89a0      	ldrh	r0, [r4, #12]

  // configure Rx channel
  // TK: optimization method: read rx_CCR once, write back only when required
  // the channel must be disabled to configure new values
  u32 rx_CCR = dma_rx_ptr->CR & ~CCR_ENABLE;
 8016e00:	6834      	ldr	r4, [r6, #0]
 8016e02:	f024 0001 	bic.w	r0, r4, #1
  dma_rx_ptr->CR = rx_CCR;
 8016e06:	6030      	str	r0, [r6, #0]
  if( receive_buffer != NULL ) {
 8016e08:	b302      	cbz	r2, 8016e4c <MIOS32_SPI_TransferBlock+0x84>
    // enable memory addr. increment - bytes written into receive buffer
    dma_rx_ptr->M0AR = (u32)receive_buffer;
 8016e0a:	60f2      	str	r2, [r6, #12]
    rx_CCR |= DMA_MemoryInc_Enable;
 8016e0c:	f440 6480 	orr.w	r4, r0, #1024	@ 0x400
    // disable memory addr. increment - bytes written into dummy buffer
    rx_dummy_byte = 0xff;
    dma_rx_ptr->M0AR = (u32)&rx_dummy_byte;
    rx_CCR &= ~DMA_MemoryInc_Enable;
  }
  dma_rx_ptr->NDTR = len;
 8016e10:	6073      	str	r3, [r6, #4]


  // configure Tx channel
  // TK: optimization method: read tx_CCR once, write back only when required
  // the channel must be disabled to configure new values
  u32 tx_CCR = dma_tx_ptr->CR & ~CCR_ENABLE;
 8016e12:	683d      	ldr	r5, [r7, #0]
 8016e14:	f025 0201 	bic.w	r2, r5, #1
  dma_tx_ptr->CR = tx_CCR;
 8016e18:	603a      	str	r2, [r7, #0]
  if( send_buffer != NULL ) {
 8016e1a:	b301      	cbz	r1, 8016e5e <MIOS32_SPI_TransferBlock+0x96>
    // enable memory addr. increment - bytes read from send buffer
    dma_tx_ptr->M0AR = (u32)send_buffer;
 8016e1c:	60f9      	str	r1, [r7, #12]
    tx_CCR |= DMA_MemoryInc_Enable;
 8016e1e:	f442 6580 	orr.w	r5, r2, #1024	@ 0x400
    tx_CCR &= ~DMA_MemoryInc_Enable;
  }
  dma_tx_ptr->NDTR = len;

  // new for STM32F4 DMA: it's required to clear interrupt flags before DMA channel is enabled again
  DMA_ClearFlag(dma_rx_ptr, dma_rx_irq_flags);
 8016e22:	4661      	mov	r1, ip
  dma_tx_ptr->NDTR = len;
 8016e24:	607b      	str	r3, [r7, #4]
  DMA_ClearFlag(dma_rx_ptr, dma_rx_irq_flags);
 8016e26:	4630      	mov	r0, r6
 8016e28:	f002 f8ee 	bl	8019008 <DMA_ClearFlag>
  DMA_ClearFlag(dma_tx_ptr, dma_tx_irq_flags);
 8016e2c:	4649      	mov	r1, r9
 8016e2e:	4638      	mov	r0, r7
 8016e30:	f002 f8ea 	bl	8019008 <DMA_ClearFlag>
  if( callback != NULL ) {
    rx_CCR |= DMA_IT_TC;
    dma_rx_ptr->CR = rx_CCR;

    // start DMA transfer
    dma_tx_ptr->CR = tx_CCR | CCR_ENABLE;
 8016e34:	f045 0501 	orr.w	r5, r5, #1
  if( callback != NULL ) {
 8016e38:	f1b8 0f00 	cmp.w	r8, #0
 8016e3c:	d018      	beq.n	8016e70 <MIOS32_SPI_TransferBlock+0xa8>
    rx_CCR |= DMA_IT_TC;
 8016e3e:	f044 0411 	orr.w	r4, r4, #17
    dma_rx_ptr->CR = rx_CCR;
 8016e42:	6034      	str	r4, [r6, #0]
    dma_tx_ptr->CR = tx_CCR | CCR_ENABLE;
 8016e44:	603d      	str	r5, [r7, #0]

    // if no callback: wait until all bytes have been transmitted/received
    while( dma_rx_ptr->NDTR );
  }

  return 0; // no error;
 8016e46:	2000      	movs	r0, #0
}
 8016e48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    rx_dummy_byte = 0xff;
 8016e4c:	4a16      	ldr	r2, [pc, #88]	@ (8016ea8 <MIOS32_SPI_TransferBlock+0xe0>)
    dma_rx_ptr->M0AR = (u32)&rx_dummy_byte;
 8016e4e:	60f2      	str	r2, [r6, #12]
    rx_dummy_byte = 0xff;
 8016e50:	20ff      	movs	r0, #255	@ 0xff
    rx_CCR &= ~DMA_MemoryInc_Enable;
 8016e52:	f424 6480 	bic.w	r4, r4, #1024	@ 0x400
    rx_dummy_byte = 0xff;
 8016e56:	7010      	strb	r0, [r2, #0]
    rx_CCR &= ~DMA_MemoryInc_Enable;
 8016e58:	f024 0401 	bic.w	r4, r4, #1
 8016e5c:	e7d8      	b.n	8016e10 <MIOS32_SPI_TransferBlock+0x48>
    tx_dummy_byte = 0xff;
 8016e5e:	4a13      	ldr	r2, [pc, #76]	@ (8016eac <MIOS32_SPI_TransferBlock+0xe4>)
    dma_tx_ptr->M0AR = (u32)&tx_dummy_byte;
 8016e60:	60fa      	str	r2, [r7, #12]
    tx_dummy_byte = 0xff;
 8016e62:	21ff      	movs	r1, #255	@ 0xff
    tx_CCR &= ~DMA_MemoryInc_Enable;
 8016e64:	f425 6580 	bic.w	r5, r5, #1024	@ 0x400
    tx_dummy_byte = 0xff;
 8016e68:	7011      	strb	r1, [r2, #0]
    tx_CCR &= ~DMA_MemoryInc_Enable;
 8016e6a:	f025 0501 	bic.w	r5, r5, #1
 8016e6e:	e7d8      	b.n	8016e22 <MIOS32_SPI_TransferBlock+0x5a>
    rx_CCR &= ~DMA_IT_TC;
 8016e70:	f024 0410 	bic.w	r4, r4, #16
 8016e74:	f044 0401 	orr.w	r4, r4, #1
    dma_rx_ptr->CR = rx_CCR;
 8016e78:	6034      	str	r4, [r6, #0]
    dma_tx_ptr->CR = tx_CCR | CCR_ENABLE;
 8016e7a:	603d      	str	r5, [r7, #0]
    while( dma_rx_ptr->NDTR );
 8016e7c:	6873      	ldr	r3, [r6, #4]
 8016e7e:	2b00      	cmp	r3, #0
 8016e80:	d1fc      	bne.n	8016e7c <MIOS32_SPI_TransferBlock+0xb4>
 8016e82:	e7e0      	b.n	8016e46 <MIOS32_SPI_TransferBlock+0x7e>
      return -2; // unsupported SPI port
 8016e84:	f06f 0001 	mvn.w	r0, #1
 8016e88:	e7de      	b.n	8016e48 <MIOS32_SPI_TransferBlock+0x80>
    return -3;
 8016e8a:	f06f 0002 	mvn.w	r0, #2
 8016e8e:	e7db      	b.n	8016e48 <MIOS32_SPI_TransferBlock+0x80>
 8016e90:	08026e8c 	.word	0x08026e8c
 8016e94:	08026e98 	.word	0x08026e98
 8016e98:	08026e80 	.word	0x08026e80
 8016e9c:	08026e74 	.word	0x08026e74
 8016ea0:	08026e68 	.word	0x08026e68
 8016ea4:	200031e8 	.word	0x200031e8
 8016ea8:	200031e4 	.word	0x200031e4
 8016eac:	200031e5 	.word	0x200031e5

08016eb0 <DMA2_Stream2_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Called when callback function has been defined and SPI transfer has finished
/////////////////////////////////////////////////////////////////////////////
MIOS32_SPI0_DMA_IRQHANDLER_FUNC
{
 8016eb0:	b510      	push	{r4, lr}
  DMA_ClearFlag(MIOS32_SPI0_DMA_RX_PTR, MIOS32_SPI0_DMA_RX_IRQ_FLAGS);
 8016eb2:	4905      	ldr	r1, [pc, #20]	@ (8016ec8 <DMA2_Stream2_IRQHandler+0x18>)
 8016eb4:	4805      	ldr	r0, [pc, #20]	@ (8016ecc <DMA2_Stream2_IRQHandler+0x1c>)
 8016eb6:	f002 f8a7 	bl	8019008 <DMA_ClearFlag>

  if( spi_callback[0] != NULL )
 8016eba:	4b05      	ldr	r3, [pc, #20]	@ (8016ed0 <DMA2_Stream2_IRQHandler+0x20>)
 8016ebc:	681b      	ldr	r3, [r3, #0]
 8016ebe:	b113      	cbz	r3, 8016ec6 <DMA2_Stream2_IRQHandler+0x16>
    spi_callback[0]();
}
 8016ec0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    spi_callback[0]();
 8016ec4:	4718      	bx	r3
}
 8016ec6:	bd10      	pop	{r4, pc}
 8016ec8:	10390000 	.word	0x10390000
 8016ecc:	40026440 	.word	0x40026440
 8016ed0:	200031e8 	.word	0x200031e8

08016ed4 <DMA1_Stream3_IRQHandler>:

MIOS32_SPI1_DMA_IRQHANDLER_FUNC
{
 8016ed4:	b510      	push	{r4, lr}
  DMA_ClearFlag(MIOS32_SPI1_DMA_RX_PTR, MIOS32_SPI1_DMA_RX_IRQ_FLAGS);
 8016ed6:	4806      	ldr	r0, [pc, #24]	@ (8016ef0 <DMA1_Stream3_IRQHandler+0x1c>)
 8016ed8:	f04f 51f2 	mov.w	r1, #507510784	@ 0x1e400000
 8016edc:	f002 f894 	bl	8019008 <DMA_ClearFlag>

  if( spi_callback[1] != NULL )
 8016ee0:	4b04      	ldr	r3, [pc, #16]	@ (8016ef4 <DMA1_Stream3_IRQHandler+0x20>)
 8016ee2:	685b      	ldr	r3, [r3, #4]
 8016ee4:	b113      	cbz	r3, 8016eec <DMA1_Stream3_IRQHandler+0x18>
    spi_callback[1]();
}
 8016ee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    spi_callback[1]();
 8016eea:	4718      	bx	r3
}
 8016eec:	bd10      	pop	{r4, pc}
 8016eee:	bf00      	nop
 8016ef0:	40026058 	.word	0x40026058
 8016ef4:	200031e8 	.word	0x200031e8

08016ef8 <DMA1_Stream2_IRQHandler>:

MIOS32_SPI2_DMA_IRQHANDLER_FUNC
{
 8016ef8:	b510      	push	{r4, lr}
  DMA_ClearFlag(MIOS32_SPI2_DMA_RX_PTR, MIOS32_SPI2_DMA_RX_IRQ_FLAGS);
 8016efa:	4905      	ldr	r1, [pc, #20]	@ (8016f10 <DMA1_Stream2_IRQHandler+0x18>)
 8016efc:	4805      	ldr	r0, [pc, #20]	@ (8016f14 <DMA1_Stream2_IRQHandler+0x1c>)
 8016efe:	f002 f883 	bl	8019008 <DMA_ClearFlag>

  if( spi_callback[2] != NULL )
 8016f02:	4b05      	ldr	r3, [pc, #20]	@ (8016f18 <DMA1_Stream2_IRQHandler+0x20>)
 8016f04:	689b      	ldr	r3, [r3, #8]
 8016f06:	b113      	cbz	r3, 8016f0e <DMA1_Stream2_IRQHandler+0x16>
    spi_callback[2]();
}
 8016f08:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    spi_callback[2]();
 8016f0c:	4718      	bx	r3
}
 8016f0e:	bd10      	pop	{r4, pc}
 8016f10:	10390000 	.word	0x10390000
 8016f14:	40026040 	.word	0x40026040
 8016f18:	200031e8 	.word	0x200031e8

08016f1c <MIOS32_BOARD_PinInitHlp>:

/////////////////////////////////////////////////////////////////////////////
//! Internally used help function to initialize a pin
/////////////////////////////////////////////////////////////////////////////
static s32 MIOS32_BOARD_PinInitHlp(GPIO_TypeDef *port, u16 pin_mask, mios32_board_pin_mode_t mode)
{
 8016f1c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8016f1e:	4605      	mov	r5, r0
  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 8016f20:	4668      	mov	r0, sp
{
 8016f22:	460e      	mov	r6, r1
 8016f24:	4614      	mov	r4, r2
  GPIO_StructInit(&GPIO_InitStructure);
 8016f26:	f002 f987 	bl	8019238 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8016f2a:	2302      	movs	r3, #2
 8016f2c:	f88d 3005 	strb.w	r3, [sp, #5]
  GPIO_InitStructure.GPIO_Pin = pin_mask;
 8016f30:	9600      	str	r6, [sp, #0]

  switch( mode ) {
 8016f32:	2c06      	cmp	r4, #6
 8016f34:	d82a      	bhi.n	8016f8c <MIOS32_BOARD_PinInitHlp+0x70>
 8016f36:	e8df f004 	tbb	[pc, r4]
 8016f3a:	040e      	.short	0x040e
 8016f3c:	1e191511 	.word	0x1e191511
 8016f40:	25          	.byte	0x25
 8016f41:	00          	.byte	0x00
  case MIOS32_BOARD_PIN_MODE_IGNORE:
    return 0; // don't touch
  case MIOS32_BOARD_PIN_MODE_ANALOG:
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8016f42:	2303      	movs	r3, #3
 8016f44:	f88d 3004 	strb.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8016f48:	2300      	movs	r3, #0
    break;
  case MIOS32_BOARD_PIN_MODE_INPUT:
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8016f4a:	f88d 3007 	strb.w	r3, [sp, #7]
  default:
    return -2; // invalid pin mode
  }

  // init IO mode
  GPIO_Init(port, &GPIO_InitStructure);
 8016f4e:	4669      	mov	r1, sp
 8016f50:	4628      	mov	r0, r5
 8016f52:	f002 f929 	bl	80191a8 <GPIO_Init>
    return 0; // don't touch
 8016f56:	2000      	movs	r0, #0

  return 0; // no error
}
 8016f58:	b002      	add	sp, #8
 8016f5a:	bd70      	pop	{r4, r5, r6, pc}
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8016f5c:	2300      	movs	r3, #0
 8016f5e:	f88d 3004 	strb.w	r3, [sp, #4]
 8016f62:	e7f2      	b.n	8016f4a <MIOS32_BOARD_PinInitHlp+0x2e>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8016f64:	2200      	movs	r2, #0
 8016f66:	f88d 2004 	strb.w	r2, [sp, #4]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN;
 8016f6a:	e7ee      	b.n	8016f4a <MIOS32_BOARD_PinInitHlp+0x2e>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8016f6c:	2300      	movs	r3, #0
 8016f6e:	f88d 3004 	strb.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8016f72:	2301      	movs	r3, #1
 8016f74:	e7e9      	b.n	8016f4a <MIOS32_BOARD_PinInitHlp+0x2e>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8016f76:	2301      	movs	r3, #1
 8016f78:	f88d 3004 	strb.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8016f7c:	2300      	movs	r3, #0
    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 8016f7e:	f88d 3006 	strb.w	r3, [sp, #6]
    break;
 8016f82:	e7e4      	b.n	8016f4e <MIOS32_BOARD_PinInitHlp+0x32>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8016f84:	2301      	movs	r3, #1
 8016f86:	f88d 3004 	strb.w	r3, [sp, #4]
 8016f8a:	e7f8      	b.n	8016f7e <MIOS32_BOARD_PinInitHlp+0x62>
    return -2; // invalid pin mode
 8016f8c:	f06f 0001 	mvn.w	r0, #1
 8016f90:	e7e2      	b.n	8016f58 <MIOS32_BOARD_PinInitHlp+0x3c>
	...

08016f94 <MIOS32_BOARD_Init>:
  if( mode != 0 )
 8016f94:	b920      	cbnz	r0, 8016fa0 <MIOS32_BOARD_Init+0xc>
  j5_enable_mask = 0;
 8016f96:	4b04      	ldr	r3, [pc, #16]	@ (8016fa8 <MIOS32_BOARD_Init+0x14>)
 8016f98:	8018      	strh	r0, [r3, #0]
  j10_enable_mask = 0;
 8016f9a:	4b04      	ldr	r3, [pc, #16]	@ (8016fac <MIOS32_BOARD_Init+0x18>)
 8016f9c:	8018      	strh	r0, [r3, #0]
  return 0; // no error
 8016f9e:	4770      	bx	lr
    return -1; // unsupported mode
 8016fa0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8016fa4:	4770      	bx	lr
 8016fa6:	bf00      	nop
 8016fa8:	200031f6 	.word	0x200031f6
 8016fac:	200031f4 	.word	0x200031f4

08016fb0 <MIOS32_BOARD_LED_Set>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_LED_Set(u32 leds, u32 value)
{
#if defined(MIOS32_BOARD_STM32F4DISCOVERY) || defined(MIOS32_BOARD_MBHP_CORE_STM32F4)
#if MIOS32_BOARD_J15_LED_NUM >= 1
  if( leds & 1 ) { // LED4 (Green)
 8016fb0:	07c2      	lsls	r2, r0, #31
 8016fb2:	d507      	bpl.n	8016fc4 <MIOS32_BOARD_LED_Set+0x14>
    MIOS32_SYS_STM_PINSET(GPIOD, GPIO_Pin_12, value & 1);
 8016fb4:	4b15      	ldr	r3, [pc, #84]	@ (801700c <MIOS32_BOARD_LED_Set+0x5c>)
 8016fb6:	f011 0f01 	tst.w	r1, #1
 8016fba:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8016fbe:	bf14      	ite	ne
 8016fc0:	831a      	strhne	r2, [r3, #24]
 8016fc2:	835a      	strheq	r2, [r3, #26]
  }
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 2
  if( leds & 2 ) { // LED3 (Orange)
 8016fc4:	0783      	lsls	r3, r0, #30
 8016fc6:	d507      	bpl.n	8016fd8 <MIOS32_BOARD_LED_Set+0x28>
    MIOS32_SYS_STM_PINSET(GPIOD, GPIO_Pin_13, value & 2);
 8016fc8:	4b10      	ldr	r3, [pc, #64]	@ (801700c <MIOS32_BOARD_LED_Set+0x5c>)
 8016fca:	f011 0f02 	tst.w	r1, #2
 8016fce:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 8016fd2:	bf14      	ite	ne
 8016fd4:	831a      	strhne	r2, [r3, #24]
 8016fd6:	835a      	strheq	r2, [r3, #26]
  }
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 3
  if( leds & 4 ) { // LED5 (Red)
 8016fd8:	0742      	lsls	r2, r0, #29
 8016fda:	d507      	bpl.n	8016fec <MIOS32_BOARD_LED_Set+0x3c>
    MIOS32_SYS_STM_PINSET(GPIOD, GPIO_Pin_14, value & 4);
 8016fdc:	4b0b      	ldr	r3, [pc, #44]	@ (801700c <MIOS32_BOARD_LED_Set+0x5c>)
 8016fde:	f011 0f04 	tst.w	r1, #4
 8016fe2:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
 8016fe6:	bf14      	ite	ne
 8016fe8:	831a      	strhne	r2, [r3, #24]
 8016fea:	835a      	strheq	r2, [r3, #26]
  }
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 4
  if( leds & 8 ) { // LED6 (Blue)
 8016fec:	0703      	lsls	r3, r0, #28
 8016fee:	d507      	bpl.n	8017000 <MIOS32_BOARD_LED_Set+0x50>
    MIOS32_SYS_STM_PINSET(GPIOD, GPIO_Pin_15, value & 8);
 8016ff0:	4b06      	ldr	r3, [pc, #24]	@ (801700c <MIOS32_BOARD_LED_Set+0x5c>)
 8016ff2:	f011 0f08 	tst.w	r1, #8
 8016ff6:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 8016ffa:	bf14      	ite	ne
 8016ffc:	831a      	strhne	r2, [r3, #24]
 8016ffe:	835a      	strheq	r2, [r3, #26]
#endif

  if( leds & 0xfffffff0)
    return -2; // LED doesn't exist

  return 0; // no error
 8017000:	280f      	cmp	r0, #15
#else
  return -1; // no LED specified for board
#endif
}
 8017002:	bf8c      	ite	hi
 8017004:	f06f 0001 	mvnhi.w	r0, #1
 8017008:	2000      	movls	r0, #0
 801700a:	4770      	bx	lr
 801700c:	40020c00 	.word	0x40020c00

08017010 <MIOS32_BOARD_LED_Get>:
{
  u32 values = 0;

#if defined(MIOS32_BOARD_STM32F4DISCOVERY) || defined(MIOS32_BOARD_MBHP_CORE_STM32F4)
#if MIOS32_BOARD_J15_LED_NUM >= 1
  if( GPIOD->ODR & GPIO_Pin_12 ) // LED4 (Green)
 8017010:	4b09      	ldr	r3, [pc, #36]	@ (8017038 <MIOS32_BOARD_LED_Get+0x28>)
 8017012:	6958      	ldr	r0, [r3, #20]
    values |= (1 << 0);
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 2
  if( GPIOD->ODR & GPIO_Pin_13 ) // LED3 (Orange)
 8017014:	695a      	ldr	r2, [r3, #20]
 8017016:	0491      	lsls	r1, r2, #18
    values |= (1 << 1);
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 3
  if( GPIOD->ODR & GPIO_Pin_14 ) // LED4 (Red)
 8017018:	695a      	ldr	r2, [r3, #20]
    values |= (1 << 2);
#endif
#if MIOS32_BOARD_J15_LED_NUM >= 4
  if( GPIOD->ODR & GPIO_Pin_15 ) // LED6 (Blue)
 801701a:	695b      	ldr	r3, [r3, #20]
  if( GPIOD->ODR & GPIO_Pin_12 ) // LED4 (Green)
 801701c:	f3c0 3000 	ubfx	r0, r0, #12, #1
    values |= (1 << 1);
 8017020:	bf48      	it	mi
 8017022:	f040 0002 	orrmi.w	r0, r0, #2
  if( GPIOD->ODR & GPIO_Pin_14 ) // LED4 (Red)
 8017026:	0452      	lsls	r2, r2, #17
    values |= (1 << 2);
 8017028:	bf48      	it	mi
 801702a:	f040 0004 	orrmi.w	r0, r0, #4
  if( GPIOD->ODR & GPIO_Pin_15 ) // LED6 (Blue)
 801702e:	041b      	lsls	r3, r3, #16
    values |= (1 << 3);
 8017030:	bf48      	it	mi
 8017032:	f040 0008 	orrmi.w	r0, r0, #8
#endif
#endif

  return values;
}
 8017036:	4770      	bx	lr
 8017038:	40020c00 	.word	0x40020c00

0801703c <MIOS32_BOARD_J10_PinInit>:
{
#if J10_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J10 not supported
#else

  if( pin >= J10_NUM_PINS )
 801703c:	280f      	cmp	r0, #15
{
 801703e:	b510      	push	{r4, lr}
 8017040:	460a      	mov	r2, r1
  if( pin >= J10_NUM_PINS )
 8017042:	d816      	bhi.n	8017072 <MIOS32_BOARD_J10_PinInit+0x36>
    return -1; // pin not supported

  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
    // don't touch
    j10_enable_mask &= ~(1 << pin);
 8017044:	4c0c      	ldr	r4, [pc, #48]	@ (8017078 <MIOS32_BOARD_J10_PinInit+0x3c>)
 8017046:	2101      	movs	r1, #1
 8017048:	8823      	ldrh	r3, [r4, #0]
 801704a:	4081      	lsls	r1, r0
  if( mode == MIOS32_BOARD_PIN_MODE_IGNORE ) {
 801704c:	b922      	cbnz	r2, 8017058 <MIOS32_BOARD_J10_PinInit+0x1c>
    j10_enable_mask &= ~(1 << pin);
 801704e:	ea23 0301 	bic.w	r3, r3, r1
 8017052:	8023      	strh	r3, [r4, #0]

    if( status < 0 )
      return status;
  }

  return 0; // no error
 8017054:	4610      	mov	r0, r2
#endif
}
 8017056:	bd10      	pop	{r4, pc}
    j10_enable_mask |= (1 << pin);
 8017058:	430b      	orrs	r3, r1
 801705a:	8023      	strh	r3, [r4, #0]
    s32 status = MIOS32_BOARD_PinInitHlp(j10_pin[pin].port, j10_pin[pin].pin_mask, mode);
 801705c:	4b07      	ldr	r3, [pc, #28]	@ (801707c <MIOS32_BOARD_J10_PinInit+0x40>)
 801705e:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
 8017062:	f853 0030 	ldr.w	r0, [r3, r0, lsl #3]
 8017066:	8889      	ldrh	r1, [r1, #4]
 8017068:	f7ff ff58 	bl	8016f1c <MIOS32_BOARD_PinInitHlp>
    if( status < 0 )
 801706c:	ea00 70e0 	and.w	r0, r0, r0, asr #31
 8017070:	e7f1      	b.n	8017056 <MIOS32_BOARD_J10_PinInit+0x1a>
    return -1; // pin not supported
 8017072:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8017076:	e7ee      	b.n	8017056 <MIOS32_BOARD_J10_PinInit+0x1a>
 8017078:	200031f4 	.word	0x200031f4
 801707c:	08026ea4 	.word	0x08026ea4

08017080 <MIOS32_BOARD_J10_PinSet>:
s32 MIOS32_BOARD_J10_PinSet(u8 pin, u8 value)
{
#if J10_NUM_PINS == 0
  return -1; // MIOS32_BOARD_J10 not supported
#else
  if( pin >= J10_NUM_PINS )
 8017080:	280f      	cmp	r0, #15
 8017082:	d810      	bhi.n	80170a6 <MIOS32_BOARD_J10_PinSet+0x26>
    return -1; // pin not supported

  if( !(j10_enable_mask & (1 << pin)) )
 8017084:	4b0b      	ldr	r3, [pc, #44]	@ (80170b4 <MIOS32_BOARD_J10_PinSet+0x34>)
 8017086:	881b      	ldrh	r3, [r3, #0]
 8017088:	4103      	asrs	r3, r0
 801708a:	07db      	lsls	r3, r3, #31
 801708c:	d50e      	bpl.n	80170ac <MIOS32_BOARD_J10_PinSet+0x2c>
    return -2; // pin disabled

  MIOS32_SYS_STM_PINSET(j10_pin[pin].port, j10_pin[pin].pin_mask, value);
 801708e:	4b0a      	ldr	r3, [pc, #40]	@ (80170b8 <MIOS32_BOARD_J10_PinSet+0x38>)
 8017090:	f853 2030 	ldr.w	r2, [r3, r0, lsl #3]
 8017094:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 8017098:	889b      	ldrh	r3, [r3, #4]
 801709a:	b111      	cbz	r1, 80170a2 <MIOS32_BOARD_J10_PinSet+0x22>
 801709c:	8313      	strh	r3, [r2, #24]

  return 0; // no error
 801709e:	2000      	movs	r0, #0
 80170a0:	4770      	bx	lr
  MIOS32_SYS_STM_PINSET(j10_pin[pin].port, j10_pin[pin].pin_mask, value);
 80170a2:	8353      	strh	r3, [r2, #26]
 80170a4:	e7fb      	b.n	801709e <MIOS32_BOARD_J10_PinSet+0x1e>
    return -1; // pin not supported
 80170a6:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80170aa:	4770      	bx	lr
    return -2; // pin disabled
 80170ac:	f06f 0001 	mvn.w	r0, #1
#endif
}
 80170b0:	4770      	bx	lr
 80170b2:	bf00      	nop
 80170b4:	200031f4 	.word	0x200031f4
 80170b8:	08026ea4 	.word	0x08026ea4

080170bc <MIOS32_BOARD_J15_PortInit>:
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  // currently only mode 0 and 1 supported
  if( mode != 0 && mode != 1 )
 80170bc:	2801      	cmp	r0, #1
{
 80170be:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80170c0:	4604      	mov	r4, r0
  if( mode != 0 && mode != 1 )
 80170c2:	d84d      	bhi.n	8017160 <MIOS32_BOARD_J15_PortInit+0xa4>
    return -1; // unsupported mode

  GPIO_InitTypeDef GPIO_InitStructure;
  GPIO_StructInit(&GPIO_InitStructure);
 80170c4:	4668      	mov	r0, sp
 80170c6:	f002 f8b7 	bl	8019238 <GPIO_StructInit>

  J15_PIN_SCLK_0;
 80170ca:	4d27      	ldr	r5, [pc, #156]	@ (8017168 <MIOS32_BOARD_J15_PortInit+0xac>)
  J15_PIN_RCLK_0;
  J15_PIN_RW(0);
 80170cc:	4b27      	ldr	r3, [pc, #156]	@ (801716c <MIOS32_BOARD_J15_PortInit+0xb0>)
  J15_PIN_SCLK_0;
 80170ce:	2240      	movs	r2, #64	@ 0x40
  J15_PIN_RCLK_0;
 80170d0:	2708      	movs	r7, #8
  J15_PIN_RW(0);
 80170d2:	f44f 6100 	mov.w	r1, #2048	@ 0x800
  J15_PIN_SCLK_0;
 80170d6:	836a      	strh	r2, [r5, #26]
  J15_PIN_E1(0);
 80170d8:	f44f 7680 	mov.w	r6, #256	@ 0x100
  J15_PIN_RCLK_0;
 80170dc:	836f      	strh	r7, [r5, #26]
  J15_PIN_RW(0);
 80170de:	8359      	strh	r1, [r3, #26]
  J15_PIN_E2(0);
 80170e0:	f44f 7100 	mov.w	r1, #512	@ 0x200
  J15_PIN_E1(0);
 80170e4:	835e      	strh	r6, [r3, #26]
  J15_PIN_E2(0);
 80170e6:	8359      	strh	r1, [r3, #26]
#ifdef MIOS32_BOARD_LCD_E4_PORT
  LCD_PIN_E4(0);
#endif

  // configure push-pull pins
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80170e8:	f240 1301 	movw	r3, #257	@ 0x101
 80170ec:	f8ad 3004 	strh.w	r3, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_25MHz; // weak driver to reduce transients

  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80170f0:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80170f2:	2300      	movs	r3, #0
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80170f4:	4628      	mov	r0, r5
  GPIO_InitStructure.GPIO_Pin = J15_SCLK_PIN;
 80170f6:	9200      	str	r2, [sp, #0]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80170f8:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_Init(J15_SCLK_PORT, &GPIO_InitStructure);
 80170fc:	f002 f854 	bl	80191a8 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 8017100:	4669      	mov	r1, sp
 8017102:	4628      	mov	r0, r5
  GPIO_InitStructure.GPIO_Pin = J15_RCLK_PIN;
 8017104:	9700      	str	r7, [sp, #0]
  GPIO_Init(J15_RCLK_PORT, &GPIO_InitStructure);
 8017106:	f002 f84f 	bl	80191a8 <GPIO_Init>

  // configure open-drain pins (if OD option enabled)
  if( mode )
 801710a:	b114      	cbz	r4, 8017112 <MIOS32_BOARD_J15_PortInit+0x56>
    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
 801710c:	2301      	movs	r3, #1
 801710e:	f88d 3006 	strb.w	r3, [sp, #6]

  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 8017112:	4817      	ldr	r0, [pc, #92]	@ (8017170 <MIOS32_BOARD_J15_PortInit+0xb4>)
  GPIO_InitStructure.GPIO_Pin = J15_SER_PIN;
 8017114:	9600      	str	r6, [sp, #0]
  GPIO_Init(J15_SER_PORT, &GPIO_InitStructure);
 8017116:	4669      	mov	r1, sp
 8017118:	f002 f846 	bl	80191a8 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 801711c:	4813      	ldr	r0, [pc, #76]	@ (801716c <MIOS32_BOARD_J15_PortInit+0xb0>)
  GPIO_InitStructure.GPIO_Pin = J15_E1_PIN;
 801711e:	9600      	str	r6, [sp, #0]
  GPIO_Init(J15_E1_PORT, &GPIO_InitStructure);
 8017120:	4669      	mov	r1, sp
 8017122:	f002 f841 	bl	80191a8 <GPIO_Init>

  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 8017126:	f44f 7300 	mov.w	r3, #512	@ 0x200
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 801712a:	4810      	ldr	r0, [pc, #64]	@ (801716c <MIOS32_BOARD_J15_PortInit+0xb0>)
  GPIO_InitStructure.GPIO_Pin = J15_E2_PIN;
 801712c:	9300      	str	r3, [sp, #0]
  GPIO_Init(J15_E2_PORT, &GPIO_InitStructure);
 801712e:	4669      	mov	r1, sp
 8017130:	f002 f83a 	bl	80191a8 <GPIO_Init>
#ifdef MIOS32_BOARD_LCD_E4_PORT
  GPIO_InitStructure.GPIO_Pin = LCD_E4_PIN;
  GPIO_Init(LCD_E4_PORT, &GPIO_InitStructure);
#endif

  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 8017134:	f44f 6300 	mov.w	r3, #2048	@ 0x800
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 8017138:	480c      	ldr	r0, [pc, #48]	@ (801716c <MIOS32_BOARD_J15_PortInit+0xb0>)
  GPIO_InitStructure.GPIO_Pin = J15_RW_PIN;
 801713a:	9300      	str	r3, [sp, #0]
  GPIO_Init(J15_RW_PORT, &GPIO_InitStructure);
 801713c:	4669      	mov	r1, sp
 801713e:	f002 f833 	bl	80191a8 <GPIO_Init>

  // configure "busy" input with pull-up
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8017142:	2301      	movs	r3, #1
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8017144:	4808      	ldr	r0, [pc, #32]	@ (8017168 <MIOS32_BOARD_J15_PortInit+0xac>)
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8017146:	f88d 3007 	strb.w	r3, [sp, #7]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 801714a:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 801714c:	2380      	movs	r3, #128	@ 0x80
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 801714e:	4669      	mov	r1, sp
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 8017150:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_Pin = J15_D7_PIN;
 8017154:	9300      	str	r3, [sp, #0]
  GPIO_Init(J15_D7_PORT, &GPIO_InitStructure);
 8017156:	f002 f827 	bl	80191a8 <GPIO_Init>

  return 0; // no error
 801715a:	4620      	mov	r0, r4
#endif
}
 801715c:	b003      	add	sp, #12
 801715e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1; // unsupported mode
 8017160:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8017164:	e7fa      	b.n	801715c <MIOS32_BOARD_J15_PortInit+0xa0>
 8017166:	bf00      	nop
 8017168:	40020c00 	.word	0x40020c00
 801716c:	40020800 	.word	0x40020800
 8017170:	40020000 	.word	0x40020000

08017174 <MIOS32_BOARD_J15_DataSet>:
//! to output an 8bit value on the data lines
//! \param[in] data the 8bit value
//! \return < 0 if access to data port not supported by board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_DataSet(u8 data)
{
 8017174:	b530      	push	{r4, r5, lr}
  return -1; // LCD port not available
#else
  int i;
  for(i=0; i<8; ++i, data <<= 1) {
    J15_PIN_SER(data & 0x80);
    J15_PIN_SCLK_0; // setup delay
 8017176:	4b0f      	ldr	r3, [pc, #60]	@ (80171b4 <MIOS32_BOARD_J15_DataSet+0x40>)
 8017178:	4c0f      	ldr	r4, [pc, #60]	@ (80171b8 <MIOS32_BOARD_J15_DataSet+0x44>)
{
 801717a:	4601      	mov	r1, r0
  for(i=0; i<8; ++i, data <<= 1) {
 801717c:	f44f 7580 	mov.w	r5, #256	@ 0x100
{
 8017180:	2008      	movs	r0, #8
    J15_PIN_SCLK_0; // setup delay
 8017182:	f04f 0240 	mov.w	r2, #64	@ 0x40
    J15_PIN_SER(data & 0x80);
 8017186:	f011 0f80 	tst.w	r1, #128	@ 0x80
 801718a:	bf14      	ite	ne
 801718c:	8325      	strhne	r5, [r4, #24]
 801718e:	8365      	strheq	r5, [r4, #26]
  for(i=0; i<8; ++i, data <<= 1) {
 8017190:	0049      	lsls	r1, r1, #1
 8017192:	3801      	subs	r0, #1
    J15_PIN_SCLK_0; // setup delay
 8017194:	835a      	strh	r2, [r3, #26]
  for(i=0; i<8; ++i, data <<= 1) {
 8017196:	b2c9      	uxtb	r1, r1
    J15_PIN_SCLK_0; // stretch...
 8017198:	835a      	strh	r2, [r3, #26]
    J15_PIN_SCLK_0; // stretch...
 801719a:	835a      	strh	r2, [r3, #26]
    J15_PIN_SCLK_0; // stretch...
 801719c:	835a      	strh	r2, [r3, #26]
    J15_PIN_SCLK_0; // stretch...
 801719e:	835a      	strh	r2, [r3, #26]
    J15_PIN_SCLK_1;
 80171a0:	831a      	strh	r2, [r3, #24]
    J15_PIN_SCLK_1;
 80171a2:	831a      	strh	r2, [r3, #24]
    J15_PIN_SCLK_1;
 80171a4:	831a      	strh	r2, [r3, #24]
  for(i=0; i<8; ++i, data <<= 1) {
 80171a6:	d1ee      	bne.n	8017186 <MIOS32_BOARD_J15_DataSet+0x12>
  }

  // transfer to output register
  J15_PIN_RCLK_1;
 80171a8:	2208      	movs	r2, #8
 80171aa:	831a      	strh	r2, [r3, #24]
  J15_PIN_RCLK_1;
 80171ac:	831a      	strh	r2, [r3, #24]
  J15_PIN_RCLK_1;
 80171ae:	831a      	strh	r2, [r3, #24]
  J15_PIN_RCLK_0;
 80171b0:	835a      	strh	r2, [r3, #26]

  return 0; // no error
#endif
}
 80171b2:	bd30      	pop	{r4, r5, pc}
 80171b4:	40020c00 	.word	0x40020c00
 80171b8:	40020000 	.word	0x40020000

080171bc <MIOS32_BOARD_J15_SerDataShift>:
//! (SCLK connected to J15A:E, Data line connected to J15A:RW)
//! \param[in] data the 8bit value
//! \return < 0 if access to data port not supported by board
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_SerDataShift(u8 data)
{
 80171bc:	b570      	push	{r4, r5, r6, lr}
 80171be:	4604      	mov	r4, r0
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  MIOS32_IRQ_Disable();
 80171c0:	f7ff fa94 	bl	80166ec <MIOS32_IRQ_Disable>

  int i;
  for(i=0; i<8; ++i, data <<= 1) {
    J15_PIN_SERLCD_DATAOUT(data & 0x80);
    J15_PIN_SERLCD_SCLK_0; // setup delay
 80171c4:	f44f 7080 	mov.w	r0, #256	@ 0x100
 80171c8:	4b15      	ldr	r3, [pc, #84]	@ (8017220 <MIOS32_BOARD_J15_SerDataShift+0x64>)
  MIOS32_IRQ_Disable();
 80171ca:	2508      	movs	r5, #8
 80171cc:	f44f 6600 	mov.w	r6, #2048	@ 0x800
    J15_PIN_SERLCD_SCLK_0; // setup delay
 80171d0:	4601      	mov	r1, r0
 80171d2:	f44f 7200 	mov.w	r2, #512	@ 0x200
    J15_PIN_SERLCD_DATAOUT(data & 0x80);
 80171d6:	f014 0f80 	tst.w	r4, #128	@ 0x80
 80171da:	bf14      	ite	ne
 80171dc:	831e      	strhne	r6, [r3, #24]
 80171de:	835e      	strheq	r6, [r3, #26]
  for(i=0; i<8; ++i, data <<= 1) {
 80171e0:	0064      	lsls	r4, r4, #1
 80171e2:	3d01      	subs	r5, #1
    J15_PIN_SERLCD_SCLK_0; // setup delay
 80171e4:	8359      	strh	r1, [r3, #26]
  for(i=0; i<8; ++i, data <<= 1) {
 80171e6:	b2e4      	uxtb	r4, r4
    J15_PIN_SERLCD_SCLK_0; // setup delay
 80171e8:	835a      	strh	r2, [r3, #26]
    J15_PIN_SERLCD_SCLK_0; // stretch...
 80171ea:	8359      	strh	r1, [r3, #26]
 80171ec:	835a      	strh	r2, [r3, #26]
    J15_PIN_SERLCD_SCLK_0; // stretch...
 80171ee:	8359      	strh	r1, [r3, #26]
 80171f0:	835a      	strh	r2, [r3, #26]
    J15_PIN_SERLCD_SCLK_0; // stretch...
 80171f2:	8359      	strh	r1, [r3, #26]
 80171f4:	835a      	strh	r2, [r3, #26]
    J15_PIN_SERLCD_SCLK_0; // stretch...
 80171f6:	8359      	strh	r1, [r3, #26]
 80171f8:	835a      	strh	r2, [r3, #26]
    J15_PIN_SERLCD_SCLK_1;
 80171fa:	8319      	strh	r1, [r3, #24]
 80171fc:	831a      	strh	r2, [r3, #24]
    J15_PIN_SERLCD_SCLK_1;
 80171fe:	8319      	strh	r1, [r3, #24]
 8017200:	831a      	strh	r2, [r3, #24]
    J15_PIN_SERLCD_SCLK_1;
 8017202:	8319      	strh	r1, [r3, #24]
 8017204:	831a      	strh	r2, [r3, #24]
  for(i=0; i<8; ++i, data <<= 1) {
 8017206:	d1e6      	bne.n	80171d6 <MIOS32_BOARD_J15_SerDataShift+0x1a>
  // With RW=1 the CS lines will go into high impedance state, and after 100..200 uS we will
  // see on the scope how CS line levels are changing, e.g. from high to mid level.
  // Although I assume that this can't cause an issue (because CS is only relevant when
  // the display gets a SCLK_0->SCLK_1 clock), I feel better when we ensure a proper CS state
  // after each MIOS32_BOARD_J15_SerDataShift call.
  J15_PIN_SERLCD_SCLK_0;
 8017208:	8358      	strh	r0, [r3, #26]
 801720a:	835a      	strh	r2, [r3, #26]
  J15_PIN_SERLCD_SCLK_0;
 801720c:	8358      	strh	r0, [r3, #26]
 801720e:	835a      	strh	r2, [r3, #26]
  J15_PIN_SERLCD_DATAOUT(0); 
 8017210:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8017214:	835a      	strh	r2, [r3, #26]

  MIOS32_IRQ_Enable();
 8017216:	f7ff fa7d 	bl	8016714 <MIOS32_IRQ_Enable>

  return 0; // no error
#endif
}
 801721a:	4628      	mov	r0, r5
 801721c:	bd70      	pop	{r4, r5, r6, pc}
 801721e:	bf00      	nop
 8017220:	40020800 	.word	0x40020800

08017224 <MIOS32_BOARD_J15_RS_Set>:
s32 MIOS32_BOARD_J15_RS_Set(u8 rs)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_SER(rs);
 8017224:	4b04      	ldr	r3, [pc, #16]	@ (8017238 <MIOS32_BOARD_J15_RS_Set+0x14>)
 8017226:	f44f 7280 	mov.w	r2, #256	@ 0x100
 801722a:	b110      	cbz	r0, 8017232 <MIOS32_BOARD_J15_RS_Set+0xe>
 801722c:	831a      	strh	r2, [r3, #24]

  return 0; // no error
#endif
}
 801722e:	2000      	movs	r0, #0
 8017230:	4770      	bx	lr
  J15_PIN_SER(rs);
 8017232:	835a      	strh	r2, [r3, #26]
 8017234:	e7fb      	b.n	801722e <MIOS32_BOARD_J15_RS_Set+0xa>
 8017236:	bf00      	nop
 8017238:	40020000 	.word	0x40020000

0801723c <MIOS32_BOARD_J15_RW_Set>:
s32 MIOS32_BOARD_J15_RW_Set(u8 rw)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  J15_PIN_RW(rw);
 801723c:	4b04      	ldr	r3, [pc, #16]	@ (8017250 <MIOS32_BOARD_J15_RW_Set+0x14>)
 801723e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8017242:	b110      	cbz	r0, 801724a <MIOS32_BOARD_J15_RW_Set+0xe>
 8017244:	831a      	strh	r2, [r3, #24]

  return 0; // no error
#endif
}
 8017246:	2000      	movs	r0, #0
 8017248:	4770      	bx	lr
  J15_PIN_RW(rw);
 801724a:	835a      	strh	r2, [r3, #26]
 801724c:	e7fb      	b.n	8017246 <MIOS32_BOARD_J15_RW_Set+0xa>
 801724e:	bf00      	nop
 8017250:	40020800 	.word	0x40020800

08017254 <MIOS32_BOARD_J15_E_Set>:
s32 MIOS32_BOARD_J15_E_Set(u8 lcd, u8 e)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  switch( lcd ) {
 8017254:	b120      	cbz	r0, 8017260 <MIOS32_BOARD_J15_E_Set+0xc>
 8017256:	2801      	cmp	r0, #1
 8017258:	d009      	beq.n	801726e <MIOS32_BOARD_J15_E_Set+0x1a>
 801725a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801725e:	4770      	bx	lr
    case 0: 
      J15_PIN_E1(e);
 8017260:	4b06      	ldr	r3, [pc, #24]	@ (801727c <MIOS32_BOARD_J15_E_Set+0x28>)
 8017262:	f44f 7280 	mov.w	r2, #256	@ 0x100
      return 0; // no error

    case 1: 
      J15_PIN_E2(e);
 8017266:	b131      	cbz	r1, 8017276 <MIOS32_BOARD_J15_E_Set+0x22>
 8017268:	831a      	strh	r2, [r3, #24]
      return 0; // no error
 801726a:	2000      	movs	r0, #0

  }

  return -1; // pin not available
#endif
}
 801726c:	4770      	bx	lr
      J15_PIN_E2(e);
 801726e:	4b03      	ldr	r3, [pc, #12]	@ (801727c <MIOS32_BOARD_J15_E_Set+0x28>)
 8017270:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8017274:	e7f7      	b.n	8017266 <MIOS32_BOARD_J15_E_Set+0x12>
 8017276:	835a      	strh	r2, [r3, #26]
 8017278:	e7f7      	b.n	801726a <MIOS32_BOARD_J15_E_Set+0x16>
 801727a:	bf00      	nop
 801727c:	40020800 	.word	0x40020800

08017280 <MIOS32_BOARD_J15_GetD7In>:
s32 MIOS32_BOARD_J15_GetD7In(void)
{
#if J15_AVAILABLE == 0
  return -1; // LCD port not available
#else
  return J15_PIN_D7_IN ? 1 : 0;
 8017280:	4b02      	ldr	r3, [pc, #8]	@ (801728c <MIOS32_BOARD_J15_GetD7In+0xc>)
 8017282:	6918      	ldr	r0, [r3, #16]
#endif
}
 8017284:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 8017288:	4770      	bx	lr
 801728a:	bf00      	nop
 801728c:	40020c00 	.word	0x40020c00

08017290 <MIOS32_BOARD_J15_D7InPullUpEnable>:
  return -1; // LCD port not available
#else
  return 0; // not relevant for MBHP_CORE_STM32 board
  // TODO: check if this is true 
#endif
}
 8017290:	2000      	movs	r0, #0
 8017292:	4770      	bx	lr

08017294 <MIOS32_BOARD_J15_PollUnbusy>:
//! \return -1 if LCD not available
//! \return -2 on timeout
//! return >= 0 on success
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_BOARD_J15_PollUnbusy(u8 lcd, u32 time_out)
{
 8017294:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  J15_PIN_SER(rs);
 8017298:	4b1b      	ldr	r3, [pc, #108]	@ (8017308 <MIOS32_BOARD_J15_PollUnbusy+0x74>)
  J15_PIN_RW(rw);
 801729a:	4e1c      	ldr	r6, [pc, #112]	@ (801730c <MIOS32_BOARD_J15_PollUnbusy+0x78>)
  J15_PIN_SER(rs);
 801729c:	f44f 7280 	mov.w	r2, #256	@ 0x100
  J15_PIN_RW(rw);
 80172a0:	f44f 6900 	mov.w	r9, #2048	@ 0x800
  J15_PIN_SER(rs);
 80172a4:	835a      	strh	r2, [r3, #26]
{
 80172a6:	460c      	mov	r4, r1
  J15_PIN_RW(rw);
 80172a8:	f8a6 9018 	strh.w	r9, [r6, #24]

  // select read (will also disable output buffer of 74HC595)
  MIOS32_BOARD_J15_RW_Set(1);

  // check if E pin is available
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 80172ac:	2101      	movs	r1, #1
{
 80172ae:	4605      	mov	r5, r0
  if( MIOS32_BOARD_J15_E_Set(lcd, 1) < 0 )
 80172b0:	f7ff ffd0 	bl	8017254 <MIOS32_BOARD_J15_E_Set>
 80172b4:	2800      	cmp	r0, #0
 80172b6:	db23      	blt.n	8017300 <MIOS32_BOARD_J15_PollUnbusy+0x6c>
    return -1; // LCD port not available

  // poll busy flag, timeout after 10 mS
  // each loop takes ca. 4 uS @ 72MHz, this has to be considered when defining the time_out value
  u32 repeat_ctr = 0;
 80172b8:	f04f 0800 	mov.w	r8, #0
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 80172bc:	b94c      	cbnz	r4, 80172d2 <MIOS32_BOARD_J15_PollUnbusy+0x3e>

  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
 80172be:	2c00      	cmp	r4, #0
  J15_PIN_RW(rw);
 80172c0:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 80172c4:	8373      	strh	r3, [r6, #26]
  return 0; // no error
 80172c6:	bf0c      	ite	eq
 80172c8:	f06f 0001 	mvneq.w	r0, #1
 80172cc:	2000      	movne	r0, #0
#endif
}
 80172ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    MIOS32_BOARD_J15_E_Set(lcd, 1);
 80172d2:	2101      	movs	r1, #1
 80172d4:	4628      	mov	r0, r5
 80172d6:	f7ff ffbd 	bl	8017254 <MIOS32_BOARD_J15_E_Set>
 80172da:	210a      	movs	r1, #10
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80172dc:	3901      	subs	r1, #1
  J15_PIN_RW(rw);
 80172de:	f8a6 9018 	strh.w	r9, [r6, #24]
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 80172e2:	d1fb      	bne.n	80172dc <MIOS32_BOARD_J15_PollUnbusy+0x48>
    u32 busy = MIOS32_BOARD_J15_GetD7In();
 80172e4:	f7ff ffcc 	bl	8017280 <MIOS32_BOARD_J15_GetD7In>
 80172e8:	4607      	mov	r7, r0
    MIOS32_BOARD_J15_E_Set(lcd, 0);
 80172ea:	4628      	mov	r0, r5
 80172ec:	f7ff ffb2 	bl	8017254 <MIOS32_BOARD_J15_E_Set>
    if( !busy && ++repeat_ctr >= 2)
 80172f0:	b927      	cbnz	r7, 80172fc <MIOS32_BOARD_J15_PollUnbusy+0x68>
 80172f2:	f1b8 0f00 	cmp.w	r8, #0
 80172f6:	d1e2      	bne.n	80172be <MIOS32_BOARD_J15_PollUnbusy+0x2a>
 80172f8:	f04f 0801 	mov.w	r8, #1
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 80172fc:	3c01      	subs	r4, #1
 80172fe:	e7dd      	b.n	80172bc <MIOS32_BOARD_J15_PollUnbusy+0x28>
    return -1; // LCD port not available
 8017300:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8017304:	e7e3      	b.n	80172ce <MIOS32_BOARD_J15_PollUnbusy+0x3a>
 8017306:	bf00      	nop
 8017308:	40020000 	.word	0x40020000
 801730c:	40020800 	.word	0x40020800

08017310 <TIM2_IRQHandler>:
//! Interrupt handlers
//! \note don't call them directly from application
/////////////////////////////////////////////////////////////////////////////
#ifndef MIOS32_DONT_ALLOCATE_TIM2_IRQn
TIMER0_IRQ_HANDLER
{
 8017310:	b510      	push	{r4, lr}
  if( TIM_GetITStatus(TIMER0_BASE, TIM_IT_Update) != RESET ) {
 8017312:	2101      	movs	r1, #1
 8017314:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8017318:	f002 f9da 	bl	80196d0 <TIM_GetITStatus>
 801731c:	b148      	cbz	r0, 8017332 <TIM2_IRQHandler+0x22>
    TIM_ClearITPendingBit(TIMER0_BASE, TIM_IT_Update);
 801731e:	2101      	movs	r1, #1
 8017320:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8017324:	f002 f9df 	bl	80196e6 <TIM_ClearITPendingBit>
    timer_callback[0]();
 8017328:	4b02      	ldr	r3, [pc, #8]	@ (8017334 <TIM2_IRQHandler+0x24>)
  }
}
 801732a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    timer_callback[0]();
 801732e:	681b      	ldr	r3, [r3, #0]
 8017330:	4718      	bx	r3
}
 8017332:	bd10      	pop	{r4, pc}
 8017334:	200031f8 	.word	0x200031f8

08017338 <TIM3_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM3_IRQn
TIMER1_IRQ_HANDLER
{
 8017338:	b510      	push	{r4, lr}
  if( TIM_GetITStatus(TIMER1_BASE, TIM_IT_Update) != RESET ) {
 801733a:	4807      	ldr	r0, [pc, #28]	@ (8017358 <TIM3_IRQHandler+0x20>)
 801733c:	2101      	movs	r1, #1
 801733e:	f002 f9c7 	bl	80196d0 <TIM_GetITStatus>
 8017342:	b140      	cbz	r0, 8017356 <TIM3_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER1_BASE, TIM_IT_Update);
 8017344:	4804      	ldr	r0, [pc, #16]	@ (8017358 <TIM3_IRQHandler+0x20>)
 8017346:	2101      	movs	r1, #1
 8017348:	f002 f9cd 	bl	80196e6 <TIM_ClearITPendingBit>
    timer_callback[1]();
 801734c:	4b03      	ldr	r3, [pc, #12]	@ (801735c <TIM3_IRQHandler+0x24>)
  }
}
 801734e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    timer_callback[1]();
 8017352:	685b      	ldr	r3, [r3, #4]
 8017354:	4718      	bx	r3
}
 8017356:	bd10      	pop	{r4, pc}
 8017358:	40000400 	.word	0x40000400
 801735c:	200031f8 	.word	0x200031f8

08017360 <TIM5_IRQHandler>:
#endif

#ifndef MIOS32_DONT_ALLOCATE_TIM5_IRQn
TIMER2_IRQ_HANDLER
{
 8017360:	b510      	push	{r4, lr}
  if( TIM_GetITStatus(TIMER2_BASE, TIM_IT_Update) != RESET ) {
 8017362:	4807      	ldr	r0, [pc, #28]	@ (8017380 <TIM5_IRQHandler+0x20>)
 8017364:	2101      	movs	r1, #1
 8017366:	f002 f9b3 	bl	80196d0 <TIM_GetITStatus>
 801736a:	b140      	cbz	r0, 801737e <TIM5_IRQHandler+0x1e>
    TIM_ClearITPendingBit(TIMER2_BASE, TIM_IT_Update);
 801736c:	4804      	ldr	r0, [pc, #16]	@ (8017380 <TIM5_IRQHandler+0x20>)
 801736e:	2101      	movs	r1, #1
 8017370:	f002 f9b9 	bl	80196e6 <TIM_ClearITPendingBit>
    timer_callback[2]();
 8017374:	4b03      	ldr	r3, [pc, #12]	@ (8017384 <TIM5_IRQHandler+0x24>)
  }
}
 8017376:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    timer_callback[2]();
 801737a:	689b      	ldr	r3, [r3, #8]
 801737c:	4718      	bx	r3
}
 801737e:	bd10      	pop	{r4, pc}
 8017380:	40000c00 	.word	0x40000c00
 8017384:	200031f8 	.word	0x200031f8

08017388 <MIOS32_DELAY_Init>:
//!
//! \param[in] mode currently only mode 0 supported
//! \return < 0 if initialisation failed
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Init(u32 mode)
{
 8017388:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  // currently only mode 0 supported
  if( mode != 0 )
 801738a:	4604      	mov	r4, r0
 801738c:	b9a8      	cbnz	r0, 80173ba <MIOS32_DELAY_Init+0x32>
    return -1; // unsupported mode

  // enable timer clock
  if( MIOS32_DELAY_TIMER == TIM1 || MIOS32_DELAY_TIMER == TIM8 )
    RCC_APB2PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);
 801738e:	2101      	movs	r1, #1
 8017390:	4608      	mov	r0, r1
 8017392:	f002 f819 	bl	80193c8 <RCC_APB2PeriphClockCmd>
  else
    RCC_APB1PeriphClockCmd(MIOS32_DELAY_TIMER_RCC, ENABLE);

  // time base configuration
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 8017396:	22a7      	movs	r2, #167	@ 0xa7
 8017398:	f64f 73ff 	movw	r3, #65535	@ 0xffff
  TIM_TimeBaseStructure.TIM_Prescaler = (TIM_PERIPHERAL_FRQ/1000000)-1; // for 1 uS accuracy
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 801739c:	4808      	ldr	r0, [pc, #32]	@ (80173c0 <MIOS32_DELAY_Init+0x38>)
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 801739e:	f8ad 400c 	strh.w	r4, [sp, #12]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 80173a2:	a901      	add	r1, sp, #4
  TIM_TimeBaseStructure.TIM_Period = 65535; // maximum value
 80173a4:	e9cd 2301 	strd	r2, r3, [sp, #4]
  TIM_TimeBaseInit(MIOS32_DELAY_TIMER, &TIM_TimeBaseStructure);
 80173a8:	f002 f948 	bl	801963c <TIM_TimeBaseInit>

  // enable counter
  TIM_Cmd(MIOS32_DELAY_TIMER, ENABLE);
 80173ac:	4804      	ldr	r0, [pc, #16]	@ (80173c0 <MIOS32_DELAY_Init+0x38>)
 80173ae:	2101      	movs	r1, #1
 80173b0:	f002 f982 	bl	80196b8 <TIM_Cmd>

  return 0; // no error
 80173b4:	4620      	mov	r0, r4
}
 80173b6:	b004      	add	sp, #16
 80173b8:	bd10      	pop	{r4, pc}
    return -1; // unsupported mode
 80173ba:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80173be:	e7fa      	b.n	80173b6 <MIOS32_DELAY_Init+0x2e>
 80173c0:	40010000 	.word	0x40010000

080173c4 <MIOS32_DELAY_Wait_uS>:
//! \param[in] uS delay (1..65535 microseconds)
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_DELAY_Wait_uS(u16 uS)
{
  u16 start = MIOS32_DELAY_TIMER->CNT;
 80173c4:	4904      	ldr	r1, [pc, #16]	@ (80173d8 <MIOS32_DELAY_Wait_uS+0x14>)
 80173c6:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
 80173c8:	b292      	uxth	r2, r2

  // note that this even works on 16bit counter wrap-arounds
  while( (u16)(MIOS32_DELAY_TIMER->CNT - start) <= uS );
 80173ca:	6a4b      	ldr	r3, [r1, #36]	@ 0x24
 80173cc:	1a9b      	subs	r3, r3, r2
 80173ce:	b29b      	uxth	r3, r3
 80173d0:	4283      	cmp	r3, r0
 80173d2:	d9fa      	bls.n	80173ca <MIOS32_DELAY_Wait_uS+0x6>

  return 0; // no error
}
 80173d4:	2000      	movs	r0, #0
 80173d6:	4770      	bx	lr
 80173d8:	40010000 	.word	0x40010000

080173dc <MIOS32_AIN_PinGet>:
{
#if !MIOS32_AIN_CHANNEL_MASK
  return -1; // no analog input selected
#else
  // check if pin exists
  if( pin >= NUM_AIN_PINS )
 80173dc:	2807      	cmp	r0, #7
    return -1;

  // return last conversion result which was outside the deadband
  return ain_pin_values[pin];
 80173de:	bf9a      	itte	ls
 80173e0:	4b02      	ldrls	r3, [pc, #8]	@ (80173ec <MIOS32_AIN_PinGet+0x10>)
 80173e2:	f833 0010 	ldrhls.w	r0, [r3, r0, lsl #1]
    return -1;
 80173e6:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
#endif
}
 80173ea:	4770      	bx	lr
 80173ec:	2000321c 	.word	0x2000321c

080173f0 <MIOS32_AIN_StartConversions>:
//! periodically from the application (e.g. from a timer), and conversion values
//! can be retrieved with MIOS32_AIN_PinGet()
//! \return < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_AIN_StartConversions(void)
{
 80173f0:	b508      	push	{r3, lr}
#if !MIOS32_AIN_CHANNEL_MASK
  return -1; // no analog input selected
#else
  ADC_SoftwareStartConv(ADC1);
 80173f2:	4802      	ldr	r0, [pc, #8]	@ (80173fc <MIOS32_AIN_StartConversions+0xc>)
 80173f4:	f001 fdaa 	bl	8018f4c <ADC_SoftwareStartConv>
  return 0; // no error
#endif
}
 80173f8:	2000      	movs	r0, #0
 80173fa:	bd08      	pop	{r3, pc}
 80173fc:	40012000 	.word	0x40012000

08017400 <MIOS32_AIN_Init>:
{
 8017400:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if( mode != 0 )
 8017404:	4604      	mov	r4, r0
{
 8017406:	b09d      	sub	sp, #116	@ 0x74
  if( mode != 0 )
 8017408:	2800      	cmp	r0, #0
 801740a:	f040 80d3 	bne.w	80175b4 <MIOS32_AIN_Init+0x1b4>
  ain_deadband = MIOS32_AIN_DEADBAND;
 801740e:	4b6b      	ldr	r3, [pc, #428]	@ (80175bc <MIOS32_AIN_Init+0x1bc>)
 8017410:	4d6b      	ldr	r5, [pc, #428]	@ (80175c0 <MIOS32_AIN_Init+0x1c0>)
 8017412:	260f      	movs	r6, #15
 8017414:	801e      	strh	r6, [r3, #0]
  service_prepare_callback = NULL;
 8017416:	4b6b      	ldr	r3, [pc, #428]	@ (80175c4 <MIOS32_AIN_Init+0x1c4>)
    adc_conversion_values[i] = 0;
 8017418:	4601      	mov	r1, r0
  service_prepare_callback = NULL;
 801741a:	6018      	str	r0, [r3, #0]
    adc_conversion_values[i] = 0;
 801741c:	2210      	movs	r2, #16
 801741e:	486a      	ldr	r0, [pc, #424]	@ (80175c8 <MIOS32_AIN_Init+0x1c8>)
 8017420:	f00c f897 	bl	8023552 <memset>
    ain_pin_values[i] = 0;
 8017424:	2210      	movs	r2, #16
 8017426:	4621      	mov	r1, r4
 8017428:	4868      	ldr	r0, [pc, #416]	@ (80175cc <MIOS32_AIN_Init+0x1cc>)
 801742a:	f00c f892 	bl	8023552 <memset>
    ain_pin_idle_ctr[i] = 0;
 801742e:	2210      	movs	r2, #16
 8017430:	4621      	mov	r1, r4
 8017432:	4867      	ldr	r0, [pc, #412]	@ (80175d0 <MIOS32_AIN_Init+0x1d0>)
 8017434:	f00c f88d 	bl	8023552 <memset>
    ain_pin_changed[i] = 0;
 8017438:	4b66      	ldr	r3, [pc, #408]	@ (80175d4 <MIOS32_AIN_Init+0x1d4>)
 801743a:	601c      	str	r4, [r3, #0]
  oversampling_ctr = mux_ctr = 0;
 801743c:	4b66      	ldr	r3, [pc, #408]	@ (80175d8 <MIOS32_AIN_Init+0x1d8>)
 801743e:	701c      	strb	r4, [r3, #0]
 8017440:	4b66      	ldr	r3, [pc, #408]	@ (80175dc <MIOS32_AIN_Init+0x1dc>)
  GPIO_StructInit(&GPIO_InitStructure);
 8017442:	a801      	add	r0, sp, #4
  oversampling_ctr = mux_ctr = 0;
 8017444:	701c      	strb	r4, [r3, #0]
  GPIO_StructInit(&GPIO_InitStructure);
 8017446:	f001 fef7 	bl	8019238 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;
 801744a:	2303      	movs	r3, #3
 801744c:	f88d 3008 	strb.w	r3, [sp, #8]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8017450:	f88d 400b 	strb.w	r4, [sp, #11]
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 8017454:	462f      	mov	r7, r5
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {      
 8017456:	fa46 f304 	asr.w	r3, r6, r4
 801745a:	07da      	lsls	r2, r3, #31
 801745c:	d505      	bpl.n	801746a <MIOS32_AIN_Init+0x6a>
      GPIO_InitStructure.GPIO_Pin = adc_chn_map[i].pin_mask;
 801745e:	892b      	ldrh	r3, [r5, #8]
      GPIO_Init(adc_chn_map[i].port, &GPIO_InitStructure);
 8017460:	6868      	ldr	r0, [r5, #4]
      GPIO_InitStructure.GPIO_Pin = adc_chn_map[i].pin_mask;
 8017462:	9301      	str	r3, [sp, #4]
      GPIO_Init(adc_chn_map[i].port, &GPIO_InitStructure);
 8017464:	a901      	add	r1, sp, #4
 8017466:	f001 fe9f 	bl	80191a8 <GPIO_Init>
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 801746a:	3401      	adds	r4, #1
 801746c:	2c08      	cmp	r4, #8
 801746e:	f105 050c 	add.w	r5, r5, #12
 8017472:	d1f0      	bne.n	8017456 <MIOS32_AIN_Init+0x56>
  num_channels = 0;
 8017474:	4d5a      	ldr	r5, [pc, #360]	@ (80175e0 <MIOS32_AIN_Init+0x1e0>)
      ADC_RegularChannelConfig(
 8017476:	f8df 816c 	ldr.w	r8, [pc, #364]	@ 80175e4 <MIOS32_AIN_Init+0x1e4>
 801747a:	f8df 916c 	ldr.w	r9, [pc, #364]	@ 80175e8 <MIOS32_AIN_Init+0x1e8>
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 801747e:	2101      	movs	r1, #1
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8017480:	2400      	movs	r4, #0
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8017482:	f44f 7040 	mov.w	r0, #768	@ 0x300
  GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8017486:	f88d 1008 	strb.w	r1, [sp, #8]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 801748a:	f88d 400a 	strb.w	r4, [sp, #10]
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 801748e:	260f      	movs	r6, #15
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_ADC2, ENABLE);
 8017490:	f001 ff9a 	bl	80193c8 <RCC_APB2PeriphClockCmd>
  num_channels = 0;
 8017494:	702c      	strb	r4, [r5, #0]
    if( MIOS32_AIN_CHANNEL_MASK & (1 << i) ) {
 8017496:	fa46 f304 	asr.w	r3, r6, r4
 801749a:	07db      	lsls	r3, r3, #31
 801749c:	d513      	bpl.n	80174c6 <MIOS32_AIN_Init+0xc6>
        (num_channels & 1) ? ADC2 : ADC1, 
 801749e:	782a      	ldrb	r2, [r5, #0]
	adc_chn_map[i].chn, 
 80174a0:	210c      	movs	r1, #12
 80174a2:	4361      	muls	r1, r4
      ADC_RegularChannelConfig(
 80174a4:	f012 0f01 	tst.w	r2, #1
 80174a8:	ea4f 0252 	mov.w	r2, r2, lsr #1
 80174ac:	f04f 0306 	mov.w	r3, #6
 80174b0:	5c79      	ldrb	r1, [r7, r1]
 80174b2:	f102 0201 	add.w	r2, r2, #1
 80174b6:	bf14      	ite	ne
 80174b8:	4640      	movne	r0, r8
 80174ba:	4648      	moveq	r0, r9
 80174bc:	f001 fd01 	bl	8018ec2 <ADC_RegularChannelConfig>
      ++num_channels;
 80174c0:	782b      	ldrb	r3, [r5, #0]
 80174c2:	3301      	adds	r3, #1
 80174c4:	702b      	strb	r3, [r5, #0]
  for(i=0; i<NUM_CHANNELS_MAX; ++i) {
 80174c6:	3401      	adds	r4, #1
 80174c8:	2c08      	cmp	r4, #8
 80174ca:	d1e4      	bne.n	8017496 <MIOS32_AIN_Init+0x96>
  num_used_channels = num_channels;
 80174cc:	782b      	ldrb	r3, [r5, #0]
 80174ce:	4e47      	ldr	r6, [pc, #284]	@ (80175ec <MIOS32_AIN_Init+0x1ec>)
  if( num_used_channels & 1 )
 80174d0:	07d8      	lsls	r0, r3, #31
      ++num_used_channels;
 80174d2:	bf44      	itt	mi
 80174d4:	3301      	addmi	r3, #1
 80174d6:	b2db      	uxtbmi	r3, r3
  ADC_CommonStructInit(&ADC_CommonInitStructure);
 80174d8:	a803      	add	r0, sp, #12
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 80174da:	2400      	movs	r4, #0
  num_used_channels = num_channels;
 80174dc:	7033      	strb	r3, [r6, #0]
  ADC_CommonStructInit(&ADC_CommonInitStructure);
 80174de:	f001 fce1 	bl	8018ea4 <ADC_CommonStructInit>
  ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
 80174e2:	2306      	movs	r3, #6
 80174e4:	e9cd 3403 	strd	r3, r4, [sp, #12]
  ADC_CommonInit(&ADC_CommonInitStructure);
 80174e8:	a803      	add	r0, sp, #12
  ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_2;
 80174ea:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
  ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 80174ee:	e9cd 3405 	strd	r3, r4, [sp, #20]
  ADC_CommonInit(&ADC_CommonInitStructure);
 80174f2:	f001 fcc3 	bl	8018e7c <ADC_CommonInit>
  ADC_StructInit(&ADC_InitStructure);
 80174f6:	a807      	add	r0, sp, #28
 80174f8:	f001 fcb6 	bl	8018e68 <ADC_StructInit>
  ADC_InitStructure.ADC_NbrOfConversion = num_used_channels >> 1;
 80174fc:	7833      	ldrb	r3, [r6, #0]
  ADC_Init(ADC1, &ADC_InitStructure);
 80174fe:	483a      	ldr	r0, [pc, #232]	@ (80175e8 <MIOS32_AIN_Init+0x1e8>)
  ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 8017500:	9409      	str	r4, [sp, #36]	@ 0x24
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 8017502:	2501      	movs	r5, #1
  ADC_InitStructure.ADC_NbrOfConversion = num_used_channels >> 1;
 8017504:	40eb      	lsrs	r3, r5
  ADC_Init(ADC1, &ADC_InitStructure);
 8017506:	a907      	add	r1, sp, #28
  ADC_InitStructure.ADC_NbrOfConversion = num_used_channels >> 1;
 8017508:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
  ADC_InitStructure.ADC_ScanConvMode = ENABLE;
 801750c:	f8ad 5020 	strh.w	r5, [sp, #32]
  ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8017510:	940b      	str	r4, [sp, #44]	@ 0x2c
  ADC_Init(ADC1, &ADC_InitStructure);
 8017512:	f001 fc83 	bl	8018e1c <ADC_Init>
  ADC_Init(ADC2, &ADC_InitStructure);
 8017516:	4833      	ldr	r0, [pc, #204]	@ (80175e4 <MIOS32_AIN_Init+0x1e4>)
 8017518:	a907      	add	r1, sp, #28
 801751a:	f001 fc7f 	bl	8018e1c <ADC_Init>
  ADC_DMACmd(ADC1, ENABLE);
 801751e:	4629      	mov	r1, r5
 8017520:	4831      	ldr	r0, [pc, #196]	@ (80175e8 <MIOS32_AIN_Init+0x1e8>)
 8017522:	f001 fd18 	bl	8018f56 <ADC_DMACmd>
  ADC_MultiModeDMARequestAfterLastTransferCmd(ENABLE);
 8017526:	4628      	mov	r0, r5
 8017528:	f001 fd1e 	bl	8018f68 <ADC_MultiModeDMARequestAfterLastTransferCmd>
  ADC_Cmd(ADC1, ENABLE);
 801752c:	482e      	ldr	r0, [pc, #184]	@ (80175e8 <MIOS32_AIN_Init+0x1e8>)
 801752e:	4629      	mov	r1, r5
 8017530:	f001 fcbe 	bl	8018eb0 <ADC_Cmd>
  ADC_Cmd(ADC2, ENABLE);
 8017534:	482b      	ldr	r0, [pc, #172]	@ (80175e4 <MIOS32_AIN_Init+0x1e4>)
 8017536:	4629      	mov	r1, r5
 8017538:	f001 fcba 	bl	8018eb0 <ADC_Cmd>
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
 801753c:	4629      	mov	r1, r5
 801753e:	f44f 0080 	mov.w	r0, #4194304	@ 0x400000
 8017542:	f001 ff1d 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  DMA_Cmd(DMA2_Stream0, DISABLE);
 8017546:	4621      	mov	r1, r4
 8017548:	4829      	ldr	r0, [pc, #164]	@ (80175f0 <MIOS32_AIN_Init+0x1f0>)
 801754a:	f001 fd54 	bl	8018ff6 <DMA_Cmd>
  DMA_StructInit(&DMA_InitStructure);
 801754e:	a80d      	add	r0, sp, #52	@ 0x34
 8017550:	f001 fd40 	bl	8018fd4 <DMA_StructInit>
  DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&ADC->CDR;
 8017554:	4b27      	ldr	r3, [pc, #156]	@ (80175f4 <MIOS32_AIN_Init+0x1f4>)
 8017556:	930e      	str	r3, [sp, #56]	@ 0x38
  DMA_InitStructure.DMA_Memory0BaseAddr = (u32)&adc_conversion_values;
 8017558:	4b1b      	ldr	r3, [pc, #108]	@ (80175c8 <MIOS32_AIN_Init+0x1c8>)
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 801755a:	4825      	ldr	r0, [pc, #148]	@ (80175f0 <MIOS32_AIN_Init+0x1f0>)
  DMA_InitStructure.DMA_Channel = DMA_Channel_0;
 801755c:	940d      	str	r4, [sp, #52]	@ 0x34
  DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
 801755e:	e9cd 340f 	strd	r3, r4, [sp, #60]	@ 0x3c
  DMA_InitStructure.DMA_BufferSize = num_used_channels >> 1; // number of conversions depends on number of used channels
 8017562:	7833      	ldrb	r3, [r6, #0]
 8017564:	40eb      	lsrs	r3, r5
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
 8017566:	f44f 6280 	mov.w	r2, #1024	@ 0x400
  DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 801756a:	e9cd 3411 	strd	r3, r4, [sp, #68]	@ 0x44
  DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
 801756e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8017572:	e9cd 2313 	strd	r2, r3, [sp, #76]	@ 0x4c
  DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 8017576:	f44f 4180 	mov.w	r1, #16384	@ 0x4000
 801757a:	f44f 7380 	mov.w	r3, #256	@ 0x100
 801757e:	e9cd 1315 	strd	r1, r3, [sp, #84]	@ 0x54
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8017582:	f44f 3300 	mov.w	r3, #131072	@ 0x20000
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 8017586:	a90d      	add	r1, sp, #52	@ 0x34
  DMA_InitStructure.DMA_Priority = DMA_Priority_High;
 8017588:	9317      	str	r3, [sp, #92]	@ 0x5c
  DMA_Init(DMA2_Stream0, &DMA_InitStructure);
 801758a:	f001 fcf9 	bl	8018f80 <DMA_Init>
  DMA_Cmd(DMA2_Stream0, ENABLE);
 801758e:	4818      	ldr	r0, [pc, #96]	@ (80175f0 <MIOS32_AIN_Init+0x1f0>)
 8017590:	4629      	mov	r1, r5
 8017592:	f001 fd30 	bl	8018ff6 <DMA_Cmd>
  DMA_ITConfig(DMA2_Stream0, DMA_IT_TC, ENABLE);
 8017596:	462a      	mov	r2, r5
 8017598:	4815      	ldr	r0, [pc, #84]	@ (80175f0 <MIOS32_AIN_Init+0x1f0>)
 801759a:	2110      	movs	r1, #16
 801759c:	f001 fd4a 	bl	8019034 <DMA_ITConfig>
  MIOS32_IRQ_Install(DMA2_Stream0_IRQn, MIOS32_IRQ_AIN_DMA_PRIORITY);
 80175a0:	2105      	movs	r1, #5
 80175a2:	2038      	movs	r0, #56	@ 0x38
 80175a4:	f7ff f8ca 	bl	801673c <MIOS32_IRQ_Install>
  MIOS32_AIN_StartConversions();
 80175a8:	f7ff ff22 	bl	80173f0 <MIOS32_AIN_StartConversions>
  return 0;
 80175ac:	4620      	mov	r0, r4
}
 80175ae:	b01d      	add	sp, #116	@ 0x74
 80175b0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return -1; // unsupported mode
 80175b4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80175b8:	e7f9      	b.n	80175ae <MIOS32_AIN_Init+0x1ae>
 80175ba:	bf00      	nop
 80175bc:	2000000a 	.word	0x2000000a
 80175c0:	08026f24 	.word	0x08026f24
 80175c4:	20003204 	.word	0x20003204
 80175c8:	20003230 	.word	0x20003230
 80175cc:	2000321c 	.word	0x2000321c
 80175d0:	20003208 	.word	0x20003208
 80175d4:	20003218 	.word	0x20003218
 80175d8:	2000322c 	.word	0x2000322c
 80175dc:	2000322d 	.word	0x2000322d
 80175e0:	2000322e 	.word	0x2000322e
 80175e4:	40012100 	.word	0x40012100
 80175e8:	40012000 	.word	0x40012000
 80175ec:	2000322f 	.word	0x2000322f
 80175f0:	40026410 	.word	0x40026410
 80175f4:	40012308 	.word	0x40012308

080175f8 <MIOS32_AIN_Handler>:
{
 80175f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if( _callback == NULL )
 80175fc:	4606      	mov	r6, r0
 80175fe:	2800      	cmp	r0, #0
 8017600:	d03b      	beq.n	801767a <MIOS32_AIN_Handler+0x82>
  if( mux_ctr || oversampling_ctr )
 8017602:	4b1f      	ldr	r3, [pc, #124]	@ (8017680 <MIOS32_AIN_Handler+0x88>)
 8017604:	781c      	ldrb	r4, [r3, #0]
 8017606:	4b1f      	ldr	r3, [pc, #124]	@ (8017684 <MIOS32_AIN_Handler+0x8c>)
 8017608:	781b      	ldrb	r3, [r3, #0]
 801760a:	431c      	orrs	r4, r3
 801760c:	d10d      	bne.n	801762a <MIOS32_AIN_Handler+0x32>
    for(chn=0; chn<num_channels; ++chn) {
 801760e:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 8017688 <MIOS32_AIN_Handler+0x90>
      if( ain_pin_changed[pin >> 5] & mask ) {
 8017612:	4f1e      	ldr	r7, [pc, #120]	@ (801768c <MIOS32_AIN_Handler+0x94>)
	u32 pin_value = ain_pin_values[pin];
 8017614:	f8df a078 	ldr.w	sl, [pc, #120]	@ 8017690 <MIOS32_AIN_Handler+0x98>
    for(chn=0; chn<num_channels; ++chn) {
 8017618:	f899 3000 	ldrb.w	r3, [r9]
 801761c:	42a3      	cmp	r3, r4
 801761e:	dc07      	bgt.n	8017630 <MIOS32_AIN_Handler+0x38>
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
 8017620:	4b1c      	ldr	r3, [pc, #112]	@ (8017694 <MIOS32_AIN_Handler+0x9c>)
 8017622:	681b      	ldr	r3, [r3, #0]
 8017624:	bb2b      	cbnz	r3, 8017672 <MIOS32_AIN_Handler+0x7a>
  MIOS32_AIN_StartConversions();
 8017626:	f7ff fee3 	bl	80173f0 <MIOS32_AIN_StartConversions>
    return 0;
 801762a:	2000      	movs	r0, #0
}
 801762c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if( ain_pin_changed[pin >> 5] & mask ) {
 8017630:	ea4f 1854 	mov.w	r8, r4, lsr #5
      u32 mask = 1 << (pin & 0x1f);
 8017634:	f004 031f 	and.w	r3, r4, #31
 8017638:	2501      	movs	r5, #1
 801763a:	409d      	lsls	r5, r3
      if( ain_pin_changed[pin >> 5] & mask ) {
 801763c:	f857 3028 	ldr.w	r3, [r7, r8, lsl #2]
 8017640:	421d      	tst	r5, r3
 8017642:	d014      	beq.n	801766e <MIOS32_AIN_Handler+0x76>
	MIOS32_IRQ_Disable();
 8017644:	f7ff f852 	bl	80166ec <MIOS32_IRQ_Disable>
	ain_pin_changed[pin>>5] &= ~mask;
 8017648:	f857 3028 	ldr.w	r3, [r7, r8, lsl #2]
	u32 pin_value = ain_pin_values[pin];
 801764c:	f83a b014 	ldrh.w	fp, [sl, r4, lsl #1]
	ain_pin_changed[pin>>5] &= ~mask;
 8017650:	ea23 0305 	bic.w	r3, r3, r5
 8017654:	f847 3028 	str.w	r3, [r7, r8, lsl #2]
	MIOS32_IRQ_Enable();
 8017658:	f7ff f85c 	bl	8016714 <MIOS32_IRQ_Enable>
	u8 app_pin = (num_channels & 1) ? (pin>>1) : pin;
 801765c:	f899 3000 	ldrb.w	r3, [r9]
 8017660:	07db      	lsls	r3, r3, #31
 8017662:	bf4c      	ite	mi
 8017664:	f3c4 0047 	ubfxmi	r0, r4, #1, #8
 8017668:	b2e0      	uxtbpl	r0, r4
	callback(app_pin, pin_value);
 801766a:	4659      	mov	r1, fp
 801766c:	47b0      	blx	r6
    for(chn=0; chn<num_channels; ++chn) {
 801766e:	3401      	adds	r4, #1
 8017670:	e7d2      	b.n	8017618 <MIOS32_AIN_Handler+0x20>
  if( service_prepare_callback != NULL && service_prepare_callback() >= 1 )
 8017672:	4798      	blx	r3
 8017674:	2800      	cmp	r0, #0
 8017676:	ddd6      	ble.n	8017626 <MIOS32_AIN_Handler+0x2e>
 8017678:	e7d7      	b.n	801762a <MIOS32_AIN_Handler+0x32>
    return -1;
 801767a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801767e:	e7d5      	b.n	801762c <MIOS32_AIN_Handler+0x34>
 8017680:	2000322c 	.word	0x2000322c
 8017684:	2000322d 	.word	0x2000322d
 8017688:	2000322e 	.word	0x2000322e
 801768c:	20003218 	.word	0x20003218
 8017690:	2000321c 	.word	0x2000321c
 8017694:	20003204 	.word	0x20003204

08017698 <DMA2_Stream0_IRQHandler>:
//! DMA channel interrupt is triggered when all ADC channels have been converted
//! \note shouldn't be called directly from application
/////////////////////////////////////////////////////////////////////////////
#if MIOS32_AIN_CHANNEL_MASK
void DMA2_Stream0_IRQHandler(void)
{
 8017698:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i;
  u16 *src_ptr, *dst_ptr;

  // clear the pending flag(s)
  DMA_ClearFlag(DMA2_Stream0, DMA_FLAG_TCIF0 | DMA_FLAG_TEIF0 | DMA_FLAG_HTIF0 | DMA_FLAG_FEIF0);
 801769c:	4931      	ldr	r1, [pc, #196]	@ (8017764 <DMA2_Stream0_IRQHandler+0xcc>)
 801769e:	4832      	ldr	r0, [pc, #200]	@ (8017768 <DMA2_Stream0_IRQHandler+0xd0>)
 80176a0:	f001 fcb2 	bl	8019008 <DMA_ClearFlag>
    oversampling_ctr = 0;
#endif

  // whenever we reached the last sample:
  // copy conversion values to ain_pin_values if difference > deadband
  if( oversampling_ctr == 0 ) {
 80176a4:	4b31      	ldr	r3, [pc, #196]	@ (801776c <DMA2_Stream0_IRQHandler+0xd4>)
 80176a6:	781b      	ldrb	r3, [r3, #0]
 80176a8:	b123      	cbz	r3, 80176b4 <DMA2_Stream0_IRQHandler+0x1c>

  // request next conversion as long as oversampling/mux counter haven't reached the end
  if( mux_ctr || oversampling_ctr ) {
    MIOS32_AIN_StartConversions();
  }
}
 80176aa:	b003      	add	sp, #12
 80176ac:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    MIOS32_AIN_StartConversions();
 80176b0:	f7ff be9e 	b.w	80173f0 <MIOS32_AIN_StartConversions>
    u8 pin_offset = num_used_channels * mux_ctr;
 80176b4:	4a2e      	ldr	r2, [pc, #184]	@ (8017770 <DMA2_Stream0_IRQHandler+0xd8>)
 80176b6:	4f2f      	ldr	r7, [pc, #188]	@ (8017774 <DMA2_Stream0_IRQHandler+0xdc>)
 80176b8:	7811      	ldrb	r1, [r2, #0]
 80176ba:	783a      	ldrb	r2, [r7, #0]
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 80176bc:	4c2e      	ldr	r4, [pc, #184]	@ (8017778 <DMA2_Stream0_IRQHandler+0xe0>)
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 80176be:	4e2f      	ldr	r6, [pc, #188]	@ (801777c <DMA2_Stream0_IRQHandler+0xe4>)
 80176c0:	f8df c0bc 	ldr.w	ip, [pc, #188]	@ 8017780 <DMA2_Stream0_IRQHandler+0xe8>
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 80176c4:	f8df e0bc 	ldr.w	lr, [pc, #188]	@ 8017784 <DMA2_Stream0_IRQHandler+0xec>
    u8 pin_offset = num_used_channels * mux_ctr;
 80176c8:	fb11 f102 	smulbb	r1, r1, r2
    u8 bit_offset = pin_offset & 0x1f;
 80176cc:	f001 021f 	and.w	r2, r1, #31
    u8 word_offset = pin_offset >> 5;
 80176d0:	f3c1 1042 	ubfx	r0, r1, #5, #3
    dst_ptr = (u16 *)&ain_pin_values[pin_offset];
 80176d4:	b2c9      	uxtb	r1, r1
 80176d6:	eb06 0641 	add.w	r6, r6, r1, lsl #1
    u16 *idle_ctr_ptr = (u16 *)&ain_pin_idle_ctr[pin_offset];
 80176da:	eb04 0141 	add.w	r1, r4, r1, lsl #1
    for(i=0; i<num_channels; ++i) {
 80176de:	4c2a      	ldr	r4, [pc, #168]	@ (8017788 <DMA2_Stream0_IRQHandler+0xf0>)
 80176e0:	7824      	ldrb	r4, [r4, #0]
 80176e2:	9400      	str	r4, [sp, #0]
      u16 deadband = *idle_ctr_ptr ? (ain_deadband) : (MIOS32_AIN_DEADBAND_IDLE);
 80176e4:	4c29      	ldr	r4, [pc, #164]	@ (801778c <DMA2_Stream0_IRQHandler+0xf4>)
 80176e6:	8824      	ldrh	r4, [r4, #0]
 80176e8:	9401      	str	r4, [sp, #4]
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 80176ea:	f04f 0901 	mov.w	r9, #1
	*idle_ctr_ptr = MIOS32_AIN_IDLE_CTR;
 80176ee:	f640 3ab8 	movw	sl, #3000	@ 0xbb8
    for(i=0; i<num_channels; ++i) {
 80176f2:	9c00      	ldr	r4, [sp, #0]
 80176f4:	429c      	cmp	r4, r3
 80176f6:	dc05      	bgt.n	8017704 <DMA2_Stream0_IRQHandler+0x6c>
  if( mux_ctr || oversampling_ctr ) {
 80176f8:	783b      	ldrb	r3, [r7, #0]
 80176fa:	2b00      	cmp	r3, #0
 80176fc:	d1d5      	bne.n	80176aa <DMA2_Stream0_IRQHandler+0x12>
}
 80176fe:	b003      	add	sp, #12
 8017700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      u16 deadband = *idle_ctr_ptr ? (ain_deadband) : (MIOS32_AIN_DEADBAND_IDLE);
 8017704:	880c      	ldrh	r4, [r1, #0]
 8017706:	9d01      	ldr	r5, [sp, #4]
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 8017708:	f83c 8b02 	ldrh.w	r8, [ip], #2
      u16 deadband = *idle_ctr_ptr ? (ain_deadband) : (MIOS32_AIN_DEADBAND_IDLE);
 801770c:	2c00      	cmp	r4, #0
 801770e:	bf18      	it	ne
 8017710:	46ab      	movne	fp, r5
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 8017712:	f836 5013 	ldrh.w	r5, [r6, r3, lsl #1]
 8017716:	eba8 0505 	sub.w	r5, r8, r5
      u16 deadband = *idle_ctr_ptr ? (ain_deadband) : (MIOS32_AIN_DEADBAND_IDLE);
 801771a:	bf08      	it	eq
 801771c:	f04f 0b7f 	moveq.w	fp, #127	@ 0x7f
      if( abs(*src_ptr - *dst_ptr) > deadband ) {
 8017720:	2d00      	cmp	r5, #0
 8017722:	bfb8      	it	lt
 8017724:	426d      	neglt	r5, r5
 8017726:	455d      	cmp	r5, fp
 8017728:	dd16      	ble.n	8017758 <DMA2_Stream0_IRQHandler+0xc0>
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 801772a:	f85e 4020 	ldr.w	r4, [lr, r0, lsl #2]
	*dst_ptr = *src_ptr;
 801772e:	f826 8013 	strh.w	r8, [r6, r3, lsl #1]
	ain_pin_changed[word_offset] |= (1 << bit_offset);
 8017732:	fa09 f502 	lsl.w	r5, r9, r2
 8017736:	432c      	orrs	r4, r5
 8017738:	f84e 4020 	str.w	r4, [lr, r0, lsl #2]
	*idle_ctr_ptr = MIOS32_AIN_IDLE_CTR;
 801773c:	f8a1 a000 	strh.w	sl, [r1]
      if( ++bit_offset >= 32 ) {
 8017740:	3201      	adds	r2, #1
 8017742:	b2d2      	uxtb	r2, r2
 8017744:	2a20      	cmp	r2, #32
	++word_offset;
 8017746:	bf08      	it	eq
 8017748:	3001      	addeq	r0, #1
      ++idle_ctr_ptr;
 801774a:	f101 0102 	add.w	r1, r1, #2
	++word_offset;
 801774e:	bf04      	itt	eq
 8017750:	b2c0      	uxtbeq	r0, r0
	bit_offset = 0;
 8017752:	2200      	moveq	r2, #0
    for(i=0; i<num_channels; ++i) {
 8017754:	3301      	adds	r3, #1
 8017756:	e7cc      	b.n	80176f2 <DMA2_Stream0_IRQHandler+0x5a>
	if( *idle_ctr_ptr )
 8017758:	2c00      	cmp	r4, #0
 801775a:	d0f1      	beq.n	8017740 <DMA2_Stream0_IRQHandler+0xa8>
	  *idle_ctr_ptr -= 1;
 801775c:	3c01      	subs	r4, #1
 801775e:	800c      	strh	r4, [r1, #0]
 8017760:	e7ee      	b.n	8017740 <DMA2_Stream0_IRQHandler+0xa8>
 8017762:	bf00      	nop
 8017764:	10800039 	.word	0x10800039
 8017768:	40026410 	.word	0x40026410
 801776c:	2000322d 	.word	0x2000322d
 8017770:	2000322f 	.word	0x2000322f
 8017774:	2000322c 	.word	0x2000322c
 8017778:	20003208 	.word	0x20003208
 801777c:	2000321c 	.word	0x2000321c
 8017780:	20003230 	.word	0x20003230
 8017784:	20003218 	.word	0x20003218
 8017788:	2000322e 	.word	0x2000322e
 801778c:	2000000a 	.word	0x2000000a

08017790 <USBD_USR_DeviceDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
static uint8_t *  USBD_USR_DeviceDescriptor( uint8_t speed , uint16_t *length)
{
  *length = sizeof(MIOS32_USB_DeviceDescriptor);
 8017790:	2312      	movs	r3, #18
  return (uint8_t *)MIOS32_USB_DeviceDescriptor;
}
 8017792:	4801      	ldr	r0, [pc, #4]	@ (8017798 <USBD_USR_DeviceDescriptor+0x8>)
  *length = sizeof(MIOS32_USB_DeviceDescriptor);
 8017794:	800b      	strh	r3, [r1, #0]
}
 8017796:	4770      	bx	lr
 8017798:	080270c5 	.word	0x080270c5

0801779c <USBD_USR_LangIDStrDescriptor>:
* @param  length : pointer to data length variable
* @retval pointer to descriptor buffer
*/
static uint8_t *  USBD_USR_LangIDStrDescriptor( uint8_t speed , uint16_t *length)
{
  *length =  sizeof(USBD_LangIDDesc);  
 801779c:	2304      	movs	r3, #4
  return (uint8_t *)USBD_LangIDDesc;
}
 801779e:	4801      	ldr	r0, [pc, #4]	@ (80177a4 <USBD_USR_LangIDStrDescriptor+0x8>)
  *length =  sizeof(USBD_LangIDDesc);  
 80177a0:	800b      	strh	r3, [r1, #0]
}
 80177a2:	4770      	bx	lr
 80177a4:	080270c1 	.word	0x080270c1

080177a8 <USBD_USR_Init>:
* @param  None
* @retval None
*/
static void USBD_USR_Init(void)
{   
}
 80177a8:	4770      	bx	lr

080177aa <USBD_USR_DeviceReset>:
* @param  speed : device speed
* @retval None
*/
static void USBD_USR_DeviceReset(uint8_t speed )
{
}
 80177aa:	4770      	bx	lr

080177ac <USBH_USR_Device_DescAvailable>:
 * @param  DeviceDesc : device descriptor
 * @retval None
 */
static void USBH_USR_Device_DescAvailable(void *DeviceDesc)
{
}
 80177ac:	4770      	bx	lr

080177ae <USBH_USR_Configuration_DescAvailable>:
 */
static void USBH_USR_Configuration_DescAvailable(USBH_CfgDesc_TypeDef * cfgDesc,
						 USBH_InterfaceDesc_TypeDef *itfDesc,
						 USBH_EpDesc_TypeDef *epDesc)
{
}
 80177ae:	4770      	bx	lr

080177b0 <USBH_USR_UserInput>:
 * @retval USBH_USR_Status : User response for key button
 */
static USBH_USR_Status USBH_USR_UserInput(void)
{
  return USBH_USR_RESP_OK;
}
 80177b0:	2001      	movs	r0, #1
 80177b2:	4770      	bx	lr

080177b4 <USBH_USR_Application>:
* @retval Staus
*/
static int USBH_USR_Application(void)
{
  return (0);
}
 80177b4:	2000      	movs	r0, #0
 80177b6:	4770      	bx	lr

080177b8 <MIOS32_USB_CLASS_Setup>:
					USB_SETUP_REQ *req)
{
  // not relevant for USB MIDI

  return USBD_OK;
}
 80177b8:	2000      	movs	r0, #0
 80177ba:	4770      	bx	lr

080177bc <MIOS32_USB_CLASS_EP0_RxReady>:
static uint8_t  MIOS32_USB_CLASS_EP0_RxReady (void  *pdev)
{ 
  // not relevant for USB MIDI
  
  return USBD_OK;
}
 80177bc:	2000      	movs	r0, #0
 80177be:	4770      	bx	lr

080177c0 <MIOS32_USB_CLASS_GetCfgDesc>:
  if( MIOS32_USB_ForceSingleUSB() ) {
    *length = sizeof (MIOS32_USB_ConfigDescriptor_SingleUSB);
    return (uint8_t *)MIOS32_USB_ConfigDescriptor_SingleUSB;
  }
#endif
  *length = sizeof (MIOS32_USB_ConfigDescriptor);
 80177c0:	2365      	movs	r3, #101	@ 0x65
  return (uint8_t *)MIOS32_USB_ConfigDescriptor;
}
 80177c2:	4801      	ldr	r0, [pc, #4]	@ (80177c8 <MIOS32_USB_CLASS_GetCfgDesc+0x8>)
  *length = sizeof (MIOS32_USB_ConfigDescriptor);
 80177c4:	800b      	strh	r3, [r1, #0]
}
 80177c6:	4770      	bx	lr
 80177c8:	0802705c 	.word	0x0802705c

080177cc <USBD_USR_SerialStrDescriptor>:
{
 80177cc:	b510      	push	{r4, lr}
  const u8 serial_number_dummy_str[] = "42";
 80177ce:	4b0b      	ldr	r3, [pc, #44]	@ (80177fc <USBD_USR_SerialStrDescriptor+0x30>)
{
 80177d0:	b08c      	sub	sp, #48	@ 0x30
  const u8 serial_number_dummy_str[] = "42";
 80177d2:	881a      	ldrh	r2, [r3, #0]
 80177d4:	789b      	ldrb	r3, [r3, #2]
 80177d6:	f8ad 2004 	strh.w	r2, [sp, #4]
  if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 80177da:	a802      	add	r0, sp, #8
{
 80177dc:	460c      	mov	r4, r1
  const u8 serial_number_dummy_str[] = "42";
 80177de:	f88d 3006 	strb.w	r3, [sp, #6]
  if( MIOS32_SYS_SerialNumberGet((char *)serial_number_str) >= 0 ) {
 80177e2:	f7fe fe93 	bl	801650c <MIOS32_SYS_SerialNumberGet>
 80177e6:	2800      	cmp	r0, #0
    USBD_GetString ((uint8_t*)serial_number_str, USBD_StrDesc, length);
 80177e8:	bfac      	ite	ge
 80177ea:	a802      	addge	r0, sp, #8
    USBD_GetString ((uint8_t*)serial_number_dummy_str, USBD_StrDesc, length);
 80177ec:	a801      	addlt	r0, sp, #4
    USBD_GetString ((uint8_t*)serial_number_str, USBD_StrDesc, length);
 80177ee:	4904      	ldr	r1, [pc, #16]	@ (8017800 <USBD_USR_SerialStrDescriptor+0x34>)
 80177f0:	4622      	mov	r2, r4
    USBD_GetString ((uint8_t*)serial_number_dummy_str, USBD_StrDesc, length);
 80177f2:	f002 fb3a 	bl	8019e6a <USBD_GetString>
}
 80177f6:	4802      	ldr	r0, [pc, #8]	@ (8017800 <USBD_USR_SerialStrDescriptor+0x34>)
 80177f8:	b00c      	add	sp, #48	@ 0x30
 80177fa:	bd10      	pop	{r4, pc}
 80177fc:	08026f84 	.word	0x08026f84
 8017800:	20004271 	.word	0x20004271

08017804 <USBD_USR_ProductStrDescriptor>:
{
 8017804:	b5f0      	push	{r4, r5, r6, r7, lr}
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 8017806:	4b1a      	ldr	r3, [pc, #104]	@ (8017870 <USBD_USR_ProductStrDescriptor+0x6c>)
{
 8017808:	b087      	sub	sp, #28
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 801780a:	466d      	mov	r5, sp
{
 801780c:	460a      	mov	r2, r1
  const u8 product_str[] = MIOS32_USB_PRODUCT_STR;
 801780e:	f103 0710 	add.w	r7, r3, #16
 8017812:	462c      	mov	r4, r5
 8017814:	6818      	ldr	r0, [r3, #0]
 8017816:	6859      	ldr	r1, [r3, #4]
 8017818:	462e      	mov	r6, r5
 801781a:	c603      	stmia	r6!, {r0, r1}
 801781c:	3308      	adds	r3, #8
 801781e:	42bb      	cmp	r3, r7
 8017820:	4635      	mov	r5, r6
 8017822:	d1f7      	bne.n	8017814 <USBD_USR_ProductStrDescriptor+0x10>
 8017824:	6818      	ldr	r0, [r3, #0]
 8017826:	8899      	ldrh	r1, [r3, #4]
 8017828:	799b      	ldrb	r3, [r3, #6]
 801782a:	6030      	str	r0, [r6, #0]
 801782c:	80b1      	strh	r1, [r6, #4]
 801782e:	71b3      	strb	r3, [r6, #6]
  for(j=0, len=0; j<MIOS32_SYS_USB_DEV_NAME_LEN && valid_str && product_str_user[j]; ++j, ++len) {
 8017830:	2500      	movs	r5, #0
 8017832:	f105 6300 	add.w	r3, r5, #134217728	@ 0x8000000
 8017836:	f503 5340 	add.w	r3, r3, #12288	@ 0x3000
 801783a:	f893 3fe0 	ldrb.w	r3, [r3, #4064]	@ 0xfe0
 801783e:	b923      	cbnz	r3, 801784a <USBD_USR_ProductStrDescriptor+0x46>
    product_str_ptr = product_str_user;
 8017840:	4b0c      	ldr	r3, [pc, #48]	@ (8017874 <USBD_USR_ProductStrDescriptor+0x70>)
 8017842:	2d00      	cmp	r5, #0
 8017844:	bf18      	it	ne
 8017846:	461c      	movne	r4, r3
 8017848:	e008      	b.n	801785c <USBD_USR_ProductStrDescriptor+0x58>
  for(j=0, len=0; j<MIOS32_SYS_USB_DEV_NAME_LEN && valid_str && product_str_user[j]; ++j, ++len) {
 801784a:	3501      	adds	r5, #1
    if( product_str_user[j] < 0x20 || product_str_user[j] >= 0x80 )
 801784c:	3b20      	subs	r3, #32
  for(j=0, len=0; j<MIOS32_SYS_USB_DEV_NAME_LEN && valid_str && product_str_user[j]; ++j, ++len) {
 801784e:	2d20      	cmp	r5, #32
    if( product_str_user[j] < 0x20 || product_str_user[j] >= 0x80 )
 8017850:	b2db      	uxtb	r3, r3
  for(j=0, len=0; j<MIOS32_SYS_USB_DEV_NAME_LEN && valid_str && product_str_user[j]; ++j, ++len) {
 8017852:	d10a      	bne.n	801786a <USBD_USR_ProductStrDescriptor+0x66>
    product_str_ptr = product_str_user;
 8017854:	4907      	ldr	r1, [pc, #28]	@ (8017874 <USBD_USR_ProductStrDescriptor+0x70>)
 8017856:	2b5f      	cmp	r3, #95	@ 0x5f
 8017858:	bf98      	it	ls
 801785a:	460c      	movls	r4, r1
  USBD_GetString ((uint8_t*)product_str_ptr, USBD_StrDesc, length);
 801785c:	4620      	mov	r0, r4
 801785e:	4906      	ldr	r1, [pc, #24]	@ (8017878 <USBD_USR_ProductStrDescriptor+0x74>)
 8017860:	f002 fb03 	bl	8019e6a <USBD_GetString>
}
 8017864:	4804      	ldr	r0, [pc, #16]	@ (8017878 <USBD_USR_ProductStrDescriptor+0x74>)
 8017866:	b007      	add	sp, #28
 8017868:	bdf0      	pop	{r4, r5, r6, r7, pc}
  for(j=0, len=0; j<MIOS32_SYS_USB_DEV_NAME_LEN && valid_str && product_str_user[j]; ++j, ++len) {
 801786a:	2b5f      	cmp	r3, #95	@ 0x5f
 801786c:	d9e1      	bls.n	8017832 <USBD_USR_ProductStrDescriptor+0x2e>
 801786e:	e7f5      	b.n	801785c <USBD_USR_ProductStrDescriptor+0x58>
 8017870:	08026f87 	.word	0x08026f87
 8017874:	08003fe0 	.word	0x08003fe0
 8017878:	20004271 	.word	0x20004271

0801787c <USBD_USR_ConfigStrDescriptor>:
  return USBD_USR_ProductStrDescriptor(speed, length);
 801787c:	f7ff bfc2 	b.w	8017804 <USBD_USR_ProductStrDescriptor>

08017880 <MIOS32_USB_CLASS_GetUsrStrDesc>:


static uint8_t *MIOS32_USB_CLASS_GetUsrStrDesc(uint8_t speed, uint8_t index, uint16_t *length)
{
  return USBD_USR_ProductStrDescriptor(speed, length);
 8017880:	4611      	mov	r1, r2
 8017882:	f7ff bfbf 	b.w	8017804 <USBD_USR_ProductStrDescriptor>
	...

08017888 <USBD_USR_ManufacturerStrDescriptor>:
{
 8017888:	b5f0      	push	{r4, r5, r6, r7, lr}
  const uint8_t vendor_str[] = MIOS32_USB_VENDOR_STR;
 801788a:	4b0d      	ldr	r3, [pc, #52]	@ (80178c0 <USBD_USR_ManufacturerStrDescriptor+0x38>)
{
 801788c:	b085      	sub	sp, #20
  const uint8_t vendor_str[] = MIOS32_USB_VENDOR_STR;
 801788e:	466c      	mov	r4, sp
{
 8017890:	460a      	mov	r2, r1
  const uint8_t vendor_str[] = MIOS32_USB_VENDOR_STR;
 8017892:	f103 0708 	add.w	r7, r3, #8
 8017896:	4626      	mov	r6, r4
 8017898:	6818      	ldr	r0, [r3, #0]
 801789a:	6859      	ldr	r1, [r3, #4]
 801789c:	4625      	mov	r5, r4
 801789e:	c503      	stmia	r5!, {r0, r1}
 80178a0:	3308      	adds	r3, #8
 80178a2:	42bb      	cmp	r3, r7
 80178a4:	462c      	mov	r4, r5
 80178a6:	d1f7      	bne.n	8017898 <USBD_USR_ManufacturerStrDescriptor+0x10>
 80178a8:	6818      	ldr	r0, [r3, #0]
 80178aa:	889b      	ldrh	r3, [r3, #4]
 80178ac:	6028      	str	r0, [r5, #0]
  USBD_GetString ((uint8_t*)vendor_str, USBD_StrDesc, length);
 80178ae:	4905      	ldr	r1, [pc, #20]	@ (80178c4 <USBD_USR_ManufacturerStrDescriptor+0x3c>)
  const uint8_t vendor_str[] = MIOS32_USB_VENDOR_STR;
 80178b0:	80ab      	strh	r3, [r5, #4]
  USBD_GetString ((uint8_t*)vendor_str, USBD_StrDesc, length);
 80178b2:	4630      	mov	r0, r6
 80178b4:	f002 fad9 	bl	8019e6a <USBD_GetString>
}
 80178b8:	4802      	ldr	r0, [pc, #8]	@ (80178c4 <USBD_USR_ManufacturerStrDescriptor+0x3c>)
 80178ba:	b005      	add	sp, #20
 80178bc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80178be:	bf00      	nop
 80178c0:	08026f9e 	.word	0x08026f9e
 80178c4:	20004271 	.word	0x20004271

080178c8 <MIOS32_USB_CLASS_DeInit>:
{
 80178c8:	b510      	push	{r4, lr}
  DCD_EP_Close(pdev, MIOS32_USB_MIDI_DATA_OUT_EP);
 80178ca:	2102      	movs	r1, #2
{
 80178cc:	4604      	mov	r4, r0
  DCD_EP_Close(pdev, MIOS32_USB_MIDI_DATA_OUT_EP);
 80178ce:	f003 fe4f 	bl	801b570 <DCD_EP_Close>
  DCD_EP_Close(pdev, MIOS32_USB_MIDI_DATA_IN_EP);
 80178d2:	2181      	movs	r1, #129	@ 0x81
 80178d4:	4620      	mov	r0, r4
 80178d6:	f003 fe4b 	bl	801b570 <DCD_EP_Close>
}
 80178da:	2000      	movs	r0, #0
 80178dc:	bd10      	pop	{r4, pc}

080178de <USBD_USR_DeviceDisconnected>:
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 80178de:	2000      	movs	r0, #0
 80178e0:	f000 bb40 	b.w	8017f64 <MIOS32_USB_MIDI_ChangeConnectionState>

080178e4 <USBH_USR_DeviceDisconnected>:
static void USBH_USR_DeviceDisconnected (void)
 80178e4:	f7ff bffb 	b.w	80178de <USBD_USR_DeviceDisconnected>

080178e8 <USBD_USR_DeviceConfigured>:
  MIOS32_USB_MIDI_ChangeConnectionState(1);
 80178e8:	2001      	movs	r0, #1
 80178ea:	f000 bb3b 	b.w	8017f64 <MIOS32_USB_MIDI_ChangeConnectionState>
	...

080178f0 <MIOS32_USB_CLASS_Init>:
{
 80178f0:	b510      	push	{r4, lr}
  DCD_EP_Open(pdev, MIOS32_USB_MIDI_DATA_OUT_EP, MIOS32_USB_MIDI_DATA_OUT_SIZE, USB_OTG_EP_BULK);
 80178f2:	2302      	movs	r3, #2
{
 80178f4:	4604      	mov	r4, r0
  DCD_EP_Open(pdev, MIOS32_USB_MIDI_DATA_OUT_EP, MIOS32_USB_MIDI_DATA_OUT_SIZE, USB_OTG_EP_BULK);
 80178f6:	4619      	mov	r1, r3
 80178f8:	2240      	movs	r2, #64	@ 0x40
 80178fa:	f003 fe17 	bl	801b52c <DCD_EP_Open>
  DCD_EP_Open(pdev, MIOS32_USB_MIDI_DATA_IN_EP, MIOS32_USB_MIDI_DATA_IN_SIZE, USB_OTG_EP_BULK);
 80178fe:	2302      	movs	r3, #2
 8017900:	2240      	movs	r2, #64	@ 0x40
 8017902:	2181      	movs	r1, #129	@ 0x81
 8017904:	4620      	mov	r0, r4
 8017906:	f003 fe11 	bl	801b52c <DCD_EP_Open>
  DCD_EP_PrepareRx(&USB_OTG_dev,
 801790a:	4a04      	ldr	r2, [pc, #16]	@ (801791c <MIOS32_USB_CLASS_Init+0x2c>)
 801790c:	4804      	ldr	r0, [pc, #16]	@ (8017920 <MIOS32_USB_CLASS_Init+0x30>)
 801790e:	2340      	movs	r3, #64	@ 0x40
 8017910:	2102      	movs	r1, #2
 8017912:	f003 fe44 	bl	801b59e <DCD_EP_PrepareRx>
}
 8017916:	2000      	movs	r0, #0
 8017918:	bd10      	pop	{r4, pc}
 801791a:	bf00      	nop
 801791c:	200032c4 	.word	0x200032c4
 8017920:	20003304 	.word	0x20003304

08017924 <MIOS32_USB_CLASS_DataOut>:
  if( epnum == MIOS32_USB_MIDI_DATA_OUT_EP )
 8017924:	2902      	cmp	r1, #2
{      
 8017926:	b508      	push	{r3, lr}
 8017928:	4608      	mov	r0, r1
  if( epnum == MIOS32_USB_MIDI_DATA_OUT_EP )
 801792a:	d102      	bne.n	8017932 <MIOS32_USB_CLASS_DataOut+0xe>
    MIOS32_USB_MIDI_EP2_OUT_Callback(epnum, 0); // parameters not relevant for STM32F4
 801792c:	2100      	movs	r1, #0
 801792e:	f000 fc87 	bl	8018240 <MIOS32_USB_MIDI_EP2_OUT_Callback>
}
 8017932:	2000      	movs	r0, #0
 8017934:	bd08      	pop	{r3, pc}

08017936 <MIOS32_USB_CLASS_DataIn>:
  if( epnum == (MIOS32_USB_MIDI_DATA_IN_EP & 0x7f) )
 8017936:	2901      	cmp	r1, #1
{
 8017938:	b508      	push	{r3, lr}
 801793a:	4608      	mov	r0, r1
  if( epnum == (MIOS32_USB_MIDI_DATA_IN_EP & 0x7f) )
 801793c:	d102      	bne.n	8017944 <MIOS32_USB_CLASS_DataIn+0xe>
    MIOS32_USB_MIDI_EP1_IN_Callback(epnum, 0); // parameters not relevant for STM32F4
 801793e:	2100      	movs	r1, #0
 8017940:	f000 fc76 	bl	8018230 <MIOS32_USB_MIDI_EP1_IN_Callback>
}
 8017944:	2000      	movs	r0, #0
 8017946:	bd08      	pop	{r3, pc}

08017948 <USBH_USR_Product_String>:
static void USBH_USR_Product_String(void *ProductString)
 8017948:	4770      	bx	lr

0801794a <USBH_USR_SerialNum_String>:
static void USBH_USR_SerialNum_String(void *SerialNumString)
 801794a:	4770      	bx	lr

0801794c <USBH_USR_DeviceSpeedDetected>:
static void USBH_USR_DeviceSpeedDetected(uint8_t DeviceSpeed)
 801794c:	4770      	bx	lr

0801794e <USBH_USR_Manufacturer_String>:
static void USBH_USR_Manufacturer_String(void *ManufacturerString)
 801794e:	4770      	bx	lr

08017950 <USBH_USR_DeviceNotSupported>:
static void USBH_USR_DeviceNotSupported(void)
 8017950:	4770      	bx	lr

08017952 <USBH_USR_OverCurrentDetected>:
static void USBH_USR_OverCurrentDetected (void)
 8017952:	4770      	bx	lr

08017954 <USBH_USR_EnumerationDone>:
static void USBH_USR_EnumerationDone(void)
 8017954:	4770      	bx	lr

08017956 <USBH_USR_DeviceAddressAssigned>:
static void USBH_USR_DeviceAddressAssigned(void)
 8017956:	4770      	bx	lr

08017958 <USBH_USR_Init>:
static void USBH_USR_Init(void)
 8017958:	4770      	bx	lr

0801795a <USBH_USR_DeviceAttached>:
static void USBH_USR_DeviceAttached(void)
 801795a:	4770      	bx	lr

0801795c <USBH_USR_UnrecoveredError>:
static void USBH_USR_UnrecoveredError (void)
 801795c:	4770      	bx	lr

0801795e <USBH_USR_ResetDevice>:
static void USBH_USR_ResetDevice(void)
 801795e:	4770      	bx	lr

08017960 <USBH_USR_DeInit>:
static void USBH_USR_DeInit(void)
 8017960:	4770      	bx	lr

08017962 <USBD_USR_DeviceConnected>:
static void USBD_USR_DeviceConnected (void)
 8017962:	4770      	bx	lr

08017964 <USBD_USR_DeviceSuspended>:
static void USBD_USR_DeviceSuspended(void)
 8017964:	4770      	bx	lr

08017966 <USBD_USR_DeviceResumed>:
static void USBD_USR_DeviceResumed(void)
 8017966:	4770      	bx	lr

08017968 <USBD_USR_InterfaceStrDescriptor>:
static uint8_t *  USBD_USR_InterfaceStrDescriptor( uint8_t speed , uint16_t *length)
 8017968:	f7ff bf4c 	b.w	8017804 <USBD_USR_ProductStrDescriptor>

0801796c <USB_OTG_BSP_Init>:
{
 801796c:	b573      	push	{r0, r1, r4, r5, r6, lr}
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 801796e:	4c21      	ldr	r4, [pc, #132]	@ (80179f4 <USB_OTG_BSP_Init+0x88>)
  RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);
 8017970:	2101      	movs	r1, #1
 8017972:	4608      	mov	r0, r1
 8017974:	f001 fd04 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8017978:	f240 3602 	movw	r6, #770	@ 0x302
 801797c:	f44f 53d8 	mov.w	r3, #6912	@ 0x1b00
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8017980:	4669      	mov	r1, sp
 8017982:	4620      	mov	r0, r4
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8017984:	e9cd 3600 	strd	r3, r6, [sp]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 8017988:	f001 fc0e 	bl	80191a8 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource8,GPIO_AF_OTG1_FS) ;
 801798c:	4620      	mov	r0, r4
 801798e:	220a      	movs	r2, #10
 8017990:	2108      	movs	r1, #8
 8017992:	f001 fc5b 	bl	801924c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ;
 8017996:	4620      	mov	r0, r4
 8017998:	220a      	movs	r2, #10
 801799a:	2109      	movs	r1, #9
 801799c:	f001 fc56 	bl	801924c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ;
 80179a0:	4620      	mov	r0, r4
 80179a2:	220a      	movs	r2, #10
 80179a4:	210b      	movs	r1, #11
 80179a6:	f001 fc51 	bl	801924c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
 80179aa:	220a      	movs	r2, #10
 80179ac:	4620      	mov	r0, r4
 80179ae:	210c      	movs	r1, #12
 80179b0:	f001 fc4c 	bl	801924c <GPIO_PinAFConfig>
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80179b4:	2501      	movs	r5, #1
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80179b6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80179ba:	4669      	mov	r1, sp
 80179bc:	4620      	mov	r0, r4
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
 80179be:	9300      	str	r3, [sp, #0]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80179c0:	f88d 5007 	strb.w	r5, [sp, #7]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80179c4:	f8ad 6004 	strh.w	r6, [sp, #4]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 80179c8:	f001 fbee 	bl	80191a8 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;
 80179cc:	220a      	movs	r2, #10
 80179ce:	4611      	mov	r1, r2
 80179d0:	4620      	mov	r0, r4
 80179d2:	f001 fc3b 	bl	801924c <GPIO_PinAFConfig>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 80179d6:	4629      	mov	r1, r5
 80179d8:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
 80179dc:	f001 fcf4 	bl	80193c8 <RCC_APB2PeriphClockCmd>
  RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ;
 80179e0:	4629      	mov	r1, r5
 80179e2:	2080      	movs	r0, #128	@ 0x80
 80179e4:	f001 fcd8 	bl	8019398 <RCC_AHB2PeriphClockCmd>
  EXTI_ClearITPendingBit(EXTI_Line0);
 80179e8:	4628      	mov	r0, r5
 80179ea:	f001 fb43 	bl	8019074 <EXTI_ClearITPendingBit>
}
 80179ee:	b002      	add	sp, #8
 80179f0:	bd70      	pop	{r4, r5, r6, pc}
 80179f2:	bf00      	nop
 80179f4:	40020000 	.word	0x40020000

080179f8 <USB_OTG_BSP_EnableInterrupt>:
  MIOS32_IRQ_Install(OTG_FS_IRQn, MIOS32_IRQ_USB_PRIORITY);
 80179f8:	2108      	movs	r1, #8
 80179fa:	2043      	movs	r0, #67	@ 0x43
 80179fc:	f7fe be9e 	b.w	801673c <MIOS32_IRQ_Install>

08017a00 <OTG_FS_IRQHandler>:
{
 8017a00:	b508      	push	{r3, lr}
  if( USB_OTG_IsHostMode(&USB_OTG_dev) ) {
 8017a02:	4808      	ldr	r0, [pc, #32]	@ (8017a24 <OTG_FS_IRQHandler+0x24>)
 8017a04:	f003 f920 	bl	801ac48 <USB_OTG_IsHostMode>
 8017a08:	b138      	cbz	r0, 8017a1a <OTG_FS_IRQHandler+0x1a>
    USBH_OTG_ISR_Handler(&USB_OTG_dev);
 8017a0a:	4806      	ldr	r0, [pc, #24]	@ (8017a24 <OTG_FS_IRQHandler+0x24>)
 8017a0c:	f004 f8c6 	bl	801bb9c <USBH_OTG_ISR_Handler>
}
 8017a10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  STM32_USBO_OTG_ISR_Handler(&USB_OTG_dev);
 8017a14:	4803      	ldr	r0, [pc, #12]	@ (8017a24 <OTG_FS_IRQHandler+0x24>)
 8017a16:	f005 bb05 	b.w	801d024 <STM32_USBO_OTG_ISR_Handler>
    USBD_OTG_ISR_Handler(&USB_OTG_dev);
 8017a1a:	4802      	ldr	r0, [pc, #8]	@ (8017a24 <OTG_FS_IRQHandler+0x24>)
 8017a1c:	f003 fe3a 	bl	801b694 <USBD_OTG_ISR_Handler>
 8017a20:	e7f6      	b.n	8017a10 <OTG_FS_IRQHandler+0x10>
 8017a22:	bf00      	nop
 8017a24:	20003304 	.word	0x20003304

08017a28 <USB_OTG_BSP_uDelay>:
  MIOS32_DELAY_Wait_uS(usec);
 8017a28:	b280      	uxth	r0, r0
 8017a2a:	f7ff bccb 	b.w	80173c4 <MIOS32_DELAY_Wait_uS>

08017a2e <USB_OTG_BSP_mDelay>:
  USB_OTG_BSP_uDelay(msec * 1000);
 8017a2e:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8017a32:	4358      	muls	r0, r3
  MIOS32_DELAY_Wait_uS(usec);
 8017a34:	b280      	uxth	r0, r0
 8017a36:	f7ff bcc5 	b.w	80173c4 <MIOS32_DELAY_Wait_uS>
	...

08017a3c <USB_OTG_BSP_ConfigVBUS>:
{
 8017a3c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8017a3e:	4c0c      	ldr	r4, [pc, #48]	@ (8017a70 <USB_OTG_BSP_ConfigVBUS+0x34>)
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);  
 8017a40:	2101      	movs	r1, #1
 8017a42:	2004      	movs	r0, #4
 8017a44:	f001 fc9c 	bl	8019380 <RCC_AHB1PeriphClockCmd>
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8017a48:	2501      	movs	r5, #1
 8017a4a:	f240 3301 	movw	r3, #769	@ 0x301
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8017a4e:	4669      	mov	r1, sp
 8017a50:	4620      	mov	r0, r4
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8017a52:	e9cd 5300 	strd	r5, r3, [sp]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 8017a56:	f001 fba7 	bl	80191a8 <GPIO_Init>
  GPIO_SetBits(GPIOC, GPIO_Pin_0);
 8017a5a:	4629      	mov	r1, r5
 8017a5c:	4620      	mov	r0, r4
 8017a5e:	f001 fbf1 	bl	8019244 <GPIO_SetBits>
  MIOS32_DELAY_Wait_uS(usec);
 8017a62:	f44f 6054 	mov.w	r0, #3392	@ 0xd40
 8017a66:	f7ff fcad 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
}
 8017a6a:	b003      	add	sp, #12
 8017a6c:	bd30      	pop	{r4, r5, pc}
 8017a6e:	bf00      	nop
 8017a70:	40020800 	.word	0x40020800

08017a74 <USB_OTG_BSP_DriveVBUS>:
  if (0 == state)
 8017a74:	b919      	cbnz	r1, 8017a7e <USB_OTG_BSP_DriveVBUS+0xa>
    GPIO_SetBits(GPIOC, GPIO_Pin_0);
 8017a76:	4804      	ldr	r0, [pc, #16]	@ (8017a88 <USB_OTG_BSP_DriveVBUS+0x14>)
 8017a78:	2101      	movs	r1, #1
 8017a7a:	f001 bbe3 	b.w	8019244 <GPIO_SetBits>
    GPIO_ResetBits(GPIOC, GPIO_Pin_0);
 8017a7e:	4802      	ldr	r0, [pc, #8]	@ (8017a88 <USB_OTG_BSP_DriveVBUS+0x14>)
 8017a80:	2101      	movs	r1, #1
 8017a82:	f001 bbe1 	b.w	8019248 <GPIO_ResetBits>
 8017a86:	bf00      	nop
 8017a88:	40020800 	.word	0x40020800

08017a8c <MIOS32_USB_IsInitialized>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_IsInitialized(void)
{
  // we assume that initialisation has been done when B-Session valid flag is set
  __IO USB_OTG_GREGS *GREGS = (USB_OTG_GREGS *)(USB_OTG_FS_BASE_ADDR + USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  return (GREGS->GOTGCTL & (1 << 19)) ? 1 : 0;
 8017a8c:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
 8017a90:	6818      	ldr	r0, [r3, #0]
}
 8017a92:	f3c0 40c0 	ubfx	r0, r0, #19, #1
 8017a96:	4770      	bx	lr

08017a98 <MIOS32_USB_ForceSingleUSB>:
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_USB_ForceSingleUSB(void)
{
  u8 *single_usb_confirm = (u8 *)MIOS32_SYS_ADDR_SINGLE_USB_CONFIRM;
  u8 *single_usb = (u8 *)MIOS32_SYS_ADDR_SINGLE_USB;
  if( *single_usb_confirm == 0x42 && *single_usb < 0x80 )
 8017a98:	4b07      	ldr	r3, [pc, #28]	@ (8017ab8 <MIOS32_USB_ForceSingleUSB+0x20>)
 8017a9a:	f893 20d4 	ldrb.w	r2, [r3, #212]	@ 0xd4
 8017a9e:	2a42      	cmp	r2, #66	@ 0x42
 8017aa0:	d107      	bne.n	8017ab2 <MIOS32_USB_ForceSingleUSB+0x1a>
 8017aa2:	f893 00d5 	ldrb.w	r0, [r3, #213]	@ 0xd5
 8017aa6:	f993 30d5 	ldrsb.w	r3, [r3, #213]	@ 0xd5
    return *single_usb;
 8017aaa:	2b00      	cmp	r3, #0
 8017aac:	bfb8      	it	lt
 8017aae:	2000      	movlt	r0, #0
 8017ab0:	4770      	bx	lr

  return 0;
 8017ab2:	2000      	movs	r0, #0
}
 8017ab4:	4770      	bx	lr
 8017ab6:	bf00      	nop
 8017ab8:	08003f00 	.word	0x08003f00

08017abc <MIOS32_USB_ForceDeviceMode>:
#ifdef MIOS32_DONT_USE_USB_HOST
  return 1;
#else
  u8 *enforce_usb_device_confirm = (u8 *)MIOS32_SYS_ADDR_ENFORCE_USB_DEVICE_CONFIRM;
  u8 *enforce_usb_device = (u8 *)MIOS32_SYS_ADDR_ENFORCE_USB_DEVICE;
  if( *enforce_usb_device_confirm == 0x42 && *enforce_usb_device < 0x80 )
 8017abc:	4b07      	ldr	r3, [pc, #28]	@ (8017adc <MIOS32_USB_ForceDeviceMode+0x20>)
 8017abe:	f893 20d6 	ldrb.w	r2, [r3, #214]	@ 0xd6
 8017ac2:	2a42      	cmp	r2, #66	@ 0x42
 8017ac4:	d107      	bne.n	8017ad6 <MIOS32_USB_ForceDeviceMode+0x1a>
 8017ac6:	f893 00d7 	ldrb.w	r0, [r3, #215]	@ 0xd7
 8017aca:	f993 30d7 	ldrsb.w	r3, [r3, #215]	@ 0xd7
    return *enforce_usb_device;
 8017ace:	2b00      	cmp	r3, #0
 8017ad0:	bfb8      	it	lt
 8017ad2:	2000      	movlt	r0, #0
 8017ad4:	4770      	bx	lr

  return 0;
 8017ad6:	2000      	movs	r0, #0
#endif
}
 8017ad8:	4770      	bx	lr
 8017ada:	bf00      	nop
 8017adc:	08003f00 	.word	0x08003f00

08017ae0 <MIOS32_USB_Init>:
  if( mode >= 3 )
 8017ae0:	2802      	cmp	r0, #2
{
 8017ae2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8017ae4:	4606      	mov	r6, r0
  if( mode >= 3 )
 8017ae6:	d85a      	bhi.n	8017b9e <MIOS32_USB_Init+0xbe>
  u8 usb_is_initialized = MIOS32_USB_IsInitialized();
 8017ae8:	f7ff ffd0 	bl	8017a8c <MIOS32_USB_IsInitialized>
  USBH_Init(&USB_OTG_dev, 
 8017aec:	4c2d      	ldr	r4, [pc, #180]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017aee:	4b2e      	ldr	r3, [pc, #184]	@ (8017ba8 <MIOS32_USB_Init+0xc8>)
 8017af0:	4a2e      	ldr	r2, [pc, #184]	@ (8017bac <MIOS32_USB_Init+0xcc>)
 8017af2:	9300      	str	r3, [sp, #0]
 8017af4:	2101      	movs	r1, #1
 8017af6:	4b2e      	ldr	r3, [pc, #184]	@ (8017bb0 <MIOS32_USB_Init+0xd0>)
 8017af8:	4f2e      	ldr	r7, [pc, #184]	@ (8017bb4 <MIOS32_USB_Init+0xd4>)
  u8 usb_is_initialized = MIOS32_USB_IsInitialized();
 8017afa:	4605      	mov	r5, r0
  USBH_Init(&USB_OTG_dev, 
 8017afc:	4620      	mov	r0, r4
 8017afe:	f002 f9f2 	bl	8019ee6 <USBH_Init>
  USBD_USR_DeviceDisconnected();
 8017b02:	f7ff feec 	bl	80178de <USBD_USR_DeviceDisconnected>
  if( mode == 0 && usb_is_initialized ) {
 8017b06:	bb96      	cbnz	r6, 8017b6e <MIOS32_USB_Init+0x8e>
 8017b08:	b2ed      	uxtb	r5, r5
 8017b0a:	b385      	cbz	r5, 8017b6e <MIOS32_USB_Init+0x8e>
    USB_OTG_BSP_Init(&USB_OTG_dev);
 8017b0c:	4620      	mov	r0, r4
 8017b0e:	f7ff ff2d 	bl	801796c <USB_OTG_BSP_Init>
    USB_OTG_dev.dev.class_cb = (USBD_Class_cb_TypeDef *)&MIOS32_USB_CLASS_cb;
 8017b12:	4b29      	ldr	r3, [pc, #164]	@ (8017bb8 <MIOS32_USB_Init+0xd8>)
 8017b14:	f8c4 35e4 	str.w	r3, [r4, #1508]	@ 0x5e4
    USB_OTG_SelectCore(&USB_OTG_dev, USB_OTG_FS_CORE_ID);
 8017b18:	2101      	movs	r1, #1
    USB_OTG_dev.dev.usr_device = (USBD_DEVICE *)&USR_desc;
 8017b1a:	4b28      	ldr	r3, [pc, #160]	@ (8017bbc <MIOS32_USB_Init+0xdc>)
 8017b1c:	f8c4 35ec 	str.w	r3, [r4, #1516]	@ 0x5ec
    USB_OTG_SelectCore(&USB_OTG_dev, USB_OTG_FS_CORE_ID);
 8017b20:	4620      	mov	r0, r4
    USB_OTG_dev.dev.usr_cb = (USBD_Usr_cb_TypeDef *)&USBD_USR_Callbacks;
 8017b22:	f8c4 75e8 	str.w	r7, [r4, #1512]	@ 0x5e8
    USB_OTG_SelectCore(&USB_OTG_dev, USB_OTG_FS_CORE_ID);
 8017b26:	f002 ff77 	bl	801aa18 <USB_OTG_SelectCore>
    USB_OTG_EnableGlobalInt(&USB_OTG_dev);
 8017b2a:	4620      	mov	r0, r4
 8017b2c:	f003 f824 	bl	801ab78 <USB_OTG_EnableGlobalInt>
    USB_OTG_EnableDevInt(&USB_OTG_dev);
 8017b30:	4620      	mov	r0, r4
 8017b32:	f003 fa77 	bl	801b024 <USB_OTG_EnableDevInt>
    USB_OTG_BSP_EnableInterrupt(&USB_OTG_dev);
 8017b36:	4620      	mov	r0, r4
 8017b38:	f7ff ff5e 	bl	80179f8 <USB_OTG_BSP_EnableInterrupt>
    USB_OTG_dev.dev.device_config = 1;
 8017b3c:	2101      	movs	r1, #1
    USB_OTG_dev.dev.device_status = USB_OTG_CONFIGURED;
 8017b3e:	2303      	movs	r3, #3
    MIOS32_USB_CLASS_Init(&USB_OTG_dev, 1);
 8017b40:	4620      	mov	r0, r4
    USB_OTG_dev.dev.device_config = 1;
 8017b42:	f884 1110 	strb.w	r1, [r4, #272]	@ 0x110
    USB_OTG_dev.dev.device_status = USB_OTG_CONFIGURED;
 8017b46:	f884 3112 	strb.w	r3, [r4, #274]	@ 0x112
    MIOS32_USB_CLASS_Init(&USB_OTG_dev, 1);
 8017b4a:	f7ff fed1 	bl	80178f0 <MIOS32_USB_CLASS_Init>
    USBD_USR_DeviceConfigured();
 8017b4e:	f7ff fecb 	bl	80178e8 <USBD_USR_DeviceConfigured>
  if( MIOS32_USB_ForceDeviceMode() || MIOS32_SYS_STM_PINGET(GPIOA, GPIO_Pin_10) ) {
 8017b52:	f7ff ffb3 	bl	8017abc <MIOS32_USB_ForceDeviceMode>
 8017b56:	b918      	cbnz	r0, 8017b60 <MIOS32_USB_Init+0x80>
 8017b58:	4b19      	ldr	r3, [pc, #100]	@ (8017bc0 <MIOS32_USB_Init+0xe0>)
 8017b5a:	691b      	ldr	r3, [r3, #16]
 8017b5c:	055b      	lsls	r3, r3, #21
 8017b5e:	d518      	bpl.n	8017b92 <MIOS32_USB_Init+0xb2>
    USB_OTG_SetCurrentMode(&USB_OTG_dev, DEVICE_MODE);
 8017b60:	2100      	movs	r1, #0
 8017b62:	4810      	ldr	r0, [pc, #64]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017b64:	f003 f852 	bl	801ac0c <USB_OTG_SetCurrentMode>
  return 0; // no error
 8017b68:	2000      	movs	r0, #0
}
 8017b6a:	b003      	add	sp, #12
 8017b6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    USBD_Init(&USB_OTG_dev,
 8017b6e:	4b12      	ldr	r3, [pc, #72]	@ (8017bb8 <MIOS32_USB_Init+0xd8>)
 8017b70:	4a12      	ldr	r2, [pc, #72]	@ (8017bbc <MIOS32_USB_Init+0xdc>)
 8017b72:	480c      	ldr	r0, [pc, #48]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017b74:	9700      	str	r7, [sp, #0]
 8017b76:	2101      	movs	r1, #1
 8017b78:	f001 ff38 	bl	80199ec <USBD_Init>
    DCD_DevDisconnect(&USB_OTG_dev);
 8017b7c:	4809      	ldr	r0, [pc, #36]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017b7e:	f003 fd87 	bl	801b690 <DCD_DevDisconnect>
  MIOS32_DELAY_Wait_uS(usec);
 8017b82:	f24c 3050 	movw	r0, #50000	@ 0xc350
 8017b86:	f7ff fc1d 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
    DCD_DevConnect(&USB_OTG_dev);
 8017b8a:	4806      	ldr	r0, [pc, #24]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017b8c:	f003 fd7f 	bl	801b68e <DCD_DevConnect>
 8017b90:	e7df      	b.n	8017b52 <MIOS32_USB_Init+0x72>
    USB_OTG_DriveVbus(&USB_OTG_dev, 1);
 8017b92:	2101      	movs	r1, #1
 8017b94:	4803      	ldr	r0, [pc, #12]	@ (8017ba4 <MIOS32_USB_Init+0xc4>)
 8017b96:	f003 f891 	bl	801acbc <USB_OTG_DriveVbus>
    USB_OTG_SetCurrentMode(&USB_OTG_dev, HOST_MODE);
 8017b9a:	2101      	movs	r1, #1
 8017b9c:	e7e1      	b.n	8017b62 <MIOS32_USB_Init+0x82>
    return -1; // unsupported mode
 8017b9e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8017ba2:	e7e2      	b.n	8017b6a <MIOS32_USB_Init+0x8a>
 8017ba4:	20003304 	.word	0x20003304
 8017ba8:	08026fdc 	.word	0x08026fdc
 8017bac:	20003240 	.word	0x20003240
 8017bb0:	080270d8 	.word	0x080270d8
 8017bb4:	08027024 	.word	0x08027024
 8017bb8:	08026fac 	.word	0x08026fac
 8017bbc:	08027040 	.word	0x08027040
 8017bc0:	40020000 	.word	0x40020000

08017bc4 <USBH_ClassRequest>:
 */
static USBH_Status USBH_ClassRequest(USB_OTG_CORE_HANDLE *pdev, void *phost)
{
  USBH_Status status = USBH_OK;
  return status;
}
 8017bc4:	2000      	movs	r0, #0
 8017bc6:	4770      	bx	lr

08017bc8 <USBH_InterfaceDeInit>:
{
 8017bc8:	b538      	push	{r3, r4, r5, lr}
  if( USBH_hc_num_out ) {
 8017bca:	4d0c      	ldr	r5, [pc, #48]	@ (8017bfc <USBH_InterfaceDeInit+0x34>)
 8017bcc:	7829      	ldrb	r1, [r5, #0]
{
 8017bce:	4604      	mov	r4, r0
  if( USBH_hc_num_out ) {
 8017bd0:	b139      	cbz	r1, 8017be2 <USBH_InterfaceDeInit+0x1a>
    USB_OTG_HC_Halt(pdev, USBH_hc_num_out);
 8017bd2:	f003 f9f2 	bl	801afba <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, USBH_hc_num_out);
 8017bd6:	7829      	ldrb	r1, [r5, #0]
 8017bd8:	4620      	mov	r0, r4
 8017bda:	f002 fc8c 	bl	801a4f6 <USBH_Free_Channel>
    USBH_hc_num_out = 0;     /* Reset the Channel as Free */
 8017bde:	2300      	movs	r3, #0
 8017be0:	702b      	strb	r3, [r5, #0]
  if( USBH_hc_num_in ) {
 8017be2:	4d07      	ldr	r5, [pc, #28]	@ (8017c00 <USBH_InterfaceDeInit+0x38>)
 8017be4:	7829      	ldrb	r1, [r5, #0]
 8017be6:	b141      	cbz	r1, 8017bfa <USBH_InterfaceDeInit+0x32>
    USB_OTG_HC_Halt(pdev, USBH_hc_num_in);
 8017be8:	4620      	mov	r0, r4
 8017bea:	f003 f9e6 	bl	801afba <USB_OTG_HC_Halt>
    USBH_Free_Channel  (pdev, USBH_hc_num_in);
 8017bee:	7829      	ldrb	r1, [r5, #0]
 8017bf0:	4620      	mov	r0, r4
 8017bf2:	f002 fc80 	bl	801a4f6 <USBH_Free_Channel>
    USBH_hc_num_in = 0;     /* Reset the Channel as Free */
 8017bf6:	2300      	movs	r3, #0
 8017bf8:	702b      	strb	r3, [r5, #0]
}
 8017bfa:	bd38      	pop	{r3, r4, r5, pc}
 8017bfc:	20003fb4 	.word	0x20003fb4
 8017c00:	20003fb5 	.word	0x20003fb5

08017c04 <MIOS32_USB_MIDI_TxBufferHandler>:
  if( USB_OTG_dev.dev.class_cb == NULL )
 8017c04:	4b20      	ldr	r3, [pc, #128]	@ (8017c88 <MIOS32_USB_MIDI_TxBufferHandler+0x84>)
 8017c06:	f8d3 35e4 	ldr.w	r3, [r3, #1508]	@ 0x5e4
{
 8017c0a:	b570      	push	{r4, r5, r6, lr}
  if( USB_OTG_dev.dev.class_cb == NULL )
 8017c0c:	2b00      	cmp	r3, #0
 8017c0e:	d03a      	beq.n	8017c86 <MIOS32_USB_MIDI_TxBufferHandler+0x82>
  MIOS32_IRQ_Disable();
 8017c10:	f7fe fd6c 	bl	80166ec <MIOS32_IRQ_Disable>
  if( !tx_buffer_busy && tx_buffer_size && transfer_possible ) {
 8017c14:	491d      	ldr	r1, [pc, #116]	@ (8017c8c <MIOS32_USB_MIDI_TxBufferHandler+0x88>)
 8017c16:	780b      	ldrb	r3, [r1, #0]
 8017c18:	bb13      	cbnz	r3, 8017c60 <MIOS32_USB_MIDI_TxBufferHandler+0x5c>
 8017c1a:	4a1d      	ldr	r2, [pc, #116]	@ (8017c90 <MIOS32_USB_MIDI_TxBufferHandler+0x8c>)
 8017c1c:	8813      	ldrh	r3, [r2, #0]
 8017c1e:	b29b      	uxth	r3, r3
 8017c20:	b1f3      	cbz	r3, 8017c60 <MIOS32_USB_MIDI_TxBufferHandler+0x5c>
 8017c22:	4b1c      	ldr	r3, [pc, #112]	@ (8017c94 <MIOS32_USB_MIDI_TxBufferHandler+0x90>)
 8017c24:	781b      	ldrb	r3, [r3, #0]
 8017c26:	b1db      	cbz	r3, 8017c60 <MIOS32_USB_MIDI_TxBufferHandler+0x5c>
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8017c28:	8813      	ldrh	r3, [r2, #0]
    u32 *buf_addr = (u32 *)USB_tx_buffer;
 8017c2a:	4c1b      	ldr	r4, [pc, #108]	@ (8017c98 <MIOS32_USB_MIDI_TxBufferHandler+0x94>)
      *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017c2c:	4d1b      	ldr	r5, [pc, #108]	@ (8017c9c <MIOS32_USB_MIDI_TxBufferHandler+0x98>)
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8017c2e:	b29b      	uxth	r3, r3
 8017c30:	2b10      	cmp	r3, #16
    tx_buffer_busy = 1;
 8017c32:	f04f 0001 	mov.w	r0, #1
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8017c36:	bf98      	it	ls
 8017c38:	8813      	ldrhls	r3, [r2, #0]
    tx_buffer_busy = 1;
 8017c3a:	7008      	strb	r0, [r1, #0]
    tx_buffer_size -= count;
 8017c3c:	8811      	ldrh	r1, [r2, #0]
      *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017c3e:	4818      	ldr	r0, [pc, #96]	@ (8017ca0 <MIOS32_USB_MIDI_TxBufferHandler+0x9c>)
    s16 count = (tx_buffer_size > (MIOS32_USB_MIDI_DATA_IN_SIZE/4)) ? (MIOS32_USB_MIDI_DATA_IN_SIZE/4) : tx_buffer_size;
 8017c40:	bf94      	ite	ls
 8017c42:	b21b      	sxthls	r3, r3
 8017c44:	2310      	movhi	r3, #16
    tx_buffer_size -= count;
 8017c46:	1ac9      	subs	r1, r1, r3
 8017c48:	b289      	uxth	r1, r1
 8017c4a:	8011      	strh	r1, [r2, #0]
    for(i=0; i<count; ++i) {
 8017c4c:	2100      	movs	r1, #0
	tx_buffer_tail = 0;
 8017c4e:	460e      	mov	r6, r1
    for(i=0; i<count; ++i) {
 8017c50:	4299      	cmp	r1, r3
 8017c52:	db09      	blt.n	8017c68 <MIOS32_USB_MIDI_TxBufferHandler+0x64>
    DCD_EP_Tx(&USB_OTG_dev, MIOS32_USB_MIDI_DATA_IN_EP, (uint8_t*)&USB_tx_buffer, count*4);
 8017c54:	4a10      	ldr	r2, [pc, #64]	@ (8017c98 <MIOS32_USB_MIDI_TxBufferHandler+0x94>)
 8017c56:	480c      	ldr	r0, [pc, #48]	@ (8017c88 <MIOS32_USB_MIDI_TxBufferHandler+0x84>)
 8017c58:	009b      	lsls	r3, r3, #2
 8017c5a:	2181      	movs	r1, #129	@ 0x81
 8017c5c:	f003 fcc1 	bl	801b5e2 <DCD_EP_Tx>
}
 8017c60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  MIOS32_IRQ_Enable();
 8017c64:	f7fe bd56 	b.w	8016714 <MIOS32_IRQ_Enable>
      *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017c68:	8802      	ldrh	r2, [r0, #0]
 8017c6a:	b292      	uxth	r2, r2
    for(i=0; i<count; ++i) {
 8017c6c:	3101      	adds	r1, #1
      *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017c6e:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8017c72:	f844 2b04 	str.w	r2, [r4], #4
      if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8017c76:	8802      	ldrh	r2, [r0, #0]
 8017c78:	3201      	adds	r2, #1
 8017c7a:	b292      	uxth	r2, r2
 8017c7c:	2a3f      	cmp	r2, #63	@ 0x3f
 8017c7e:	8002      	strh	r2, [r0, #0]
	tx_buffer_tail = 0;
 8017c80:	bf88      	it	hi
 8017c82:	8006      	strhhi	r6, [r0, #0]
    for(i=0; i<count; ++i) {
 8017c84:	e7e4      	b.n	8017c50 <MIOS32_USB_MIDI_TxBufferHandler+0x4c>
}
 8017c86:	bd70      	pop	{r4, r5, r6, pc}
 8017c88:	20003304 	.word	0x20003304
 8017c8c:	20003d9b 	.word	0x20003d9b
 8017c90:	20003d9c 	.word	0x20003d9c
 8017c94:	20003d9a 	.word	0x20003d9a
 8017c98:	20003fb8 	.word	0x20003fb8
 8017c9c:	20003da4 	.word	0x20003da4
 8017ca0:	20003da0 	.word	0x20003da0

08017ca4 <MIOS32_USB_MIDI_RxBufferHandler.part.0>:
static void MIOS32_USB_MIDI_RxBufferHandler(void)
 8017ca4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if( rx_buffer_new_data && (count=ep->xfer_count>>2) ) {
 8017ca8:	4f22      	ldr	r7, [pc, #136]	@ (8017d34 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x90>)
  MIOS32_IRQ_Disable();
 8017caa:	f7fe fd1f 	bl	80166ec <MIOS32_IRQ_Disable>
  if( rx_buffer_new_data && (count=ep->xfer_count>>2) ) {
 8017cae:	783b      	ldrb	r3, [r7, #0]
 8017cb0:	2b00      	cmp	r3, #0
 8017cb2:	d03a      	beq.n	8017d2a <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x86>
 8017cb4:	4b20      	ldr	r3, [pc, #128]	@ (8017d38 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x94>)
 8017cb6:	f8d3 23dc 	ldr.w	r2, [r3, #988]	@ 0x3dc
 8017cba:	0894      	lsrs	r4, r2, #2
 8017cbc:	f342 028f 	sbfx	r2, r2, #2, #16
 8017cc0:	2a00      	cmp	r2, #0
 8017cc2:	d032      	beq.n	8017d2a <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x86>
    if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8017cc4:	4e1d      	ldr	r6, [pc, #116]	@ (8017d3c <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x98>)
 8017cc6:	8833      	ldrh	r3, [r6, #0]
 8017cc8:	b29b      	uxth	r3, r3
 8017cca:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8017cce:	429a      	cmp	r2, r3
 8017cd0:	da2b      	bge.n	8017d2a <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x86>
      u32 *buf_addr = (u32 *)USB_rx_buffer;
 8017cd2:	f8df 806c 	ldr.w	r8, [pc, #108]	@ 8017d40 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x9c>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8017cd6:	4d1b      	ldr	r5, [pc, #108]	@ (8017d44 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0xa0>)
 8017cd8:	f8df 906c 	ldr.w	r9, [pc, #108]	@ 8017d48 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0xa4>
 8017cdc:	b2a4      	uxth	r4, r4
	package.ALL = *buf_addr++;
 8017cde:	f858 ab04 	ldr.w	sl, [r8], #4
	if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8017ce2:	f3ca 1003 	ubfx	r0, sl, #4, #4
 8017ce6:	3010      	adds	r0, #16
 8017ce8:	4651      	mov	r1, sl
 8017cea:	b2c0      	uxtb	r0, r0
 8017cec:	f7fd f848 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8017cf0:	b970      	cbnz	r0, 8017d10 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x6c>
	  rx_buffer[rx_buffer_head] = package.ALL;
 8017cf2:	882b      	ldrh	r3, [r5, #0]
 8017cf4:	b29b      	uxth	r3, r3
 8017cf6:	f849 a023 	str.w	sl, [r9, r3, lsl #2]
	  if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8017cfa:	882b      	ldrh	r3, [r5, #0]
 8017cfc:	3301      	adds	r3, #1
 8017cfe:	b29b      	uxth	r3, r3
 8017d00:	2b3f      	cmp	r3, #63	@ 0x3f
 8017d02:	802b      	strh	r3, [r5, #0]
	    rx_buffer_head = 0;
 8017d04:	bf88      	it	hi
 8017d06:	8028      	strhhi	r0, [r5, #0]
	  ++rx_buffer_size;
 8017d08:	8833      	ldrh	r3, [r6, #0]
 8017d0a:	3301      	adds	r3, #1
 8017d0c:	b29b      	uxth	r3, r3
 8017d0e:	8033      	strh	r3, [r6, #0]
      } while( --count > 0 );
 8017d10:	1e63      	subs	r3, r4, #1
 8017d12:	b29c      	uxth	r4, r3
 8017d14:	b21b      	sxth	r3, r3
 8017d16:	2b00      	cmp	r3, #0
 8017d18:	dce1      	bgt.n	8017cde <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x3a>
      rx_buffer_new_data = 0;
 8017d1a:	2300      	movs	r3, #0
 8017d1c:	703b      	strb	r3, [r7, #0]
      DCD_EP_PrepareRx(&USB_OTG_dev,
 8017d1e:	4a08      	ldr	r2, [pc, #32]	@ (8017d40 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x9c>)
 8017d20:	4805      	ldr	r0, [pc, #20]	@ (8017d38 <MIOS32_USB_MIDI_RxBufferHandler.part.0+0x94>)
 8017d22:	2340      	movs	r3, #64	@ 0x40
 8017d24:	2102      	movs	r1, #2
 8017d26:	f003 fc3a 	bl	801b59e <DCD_EP_PrepareRx>
}
 8017d2a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  MIOS32_IRQ_Enable();
 8017d2e:	f7fe bcf1 	b.w	8016714 <MIOS32_IRQ_Enable>
 8017d32:	bf00      	nop
 8017d34:	20003ea4 	.word	0x20003ea4
 8017d38:	20003304 	.word	0x20003304
 8017d3c:	20003ea6 	.word	0x20003ea6
 8017d40:	200032c4 	.word	0x200032c4
 8017d44:	20003ea8 	.word	0x20003ea8
 8017d48:	20003eac 	.word	0x20003eac

08017d4c <USBH_Handle>:
 * @param  pdev: Selected device
 * @param  hdev: Selected device property
 * @retval USBH_Status
 */
static USBH_Status USBH_Handle(USB_OTG_CORE_HANDLE *pdev, void *phost)
{
 8017d4c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if( transfer_possible ) {
 8017d50:	4d6f      	ldr	r5, [pc, #444]	@ (8017f10 <USBH_Handle+0x1c4>)
 8017d52:	782b      	ldrb	r3, [r5, #0]
{
 8017d54:	4606      	mov	r6, r0
 8017d56:	460f      	mov	r7, r1
  if( transfer_possible ) {
 8017d58:	2b00      	cmp	r3, #0
 8017d5a:	f000 80ae 	beq.w	8017eba <USBH_Handle+0x16e>
    USBH_HOST *pphost = phost;

    if( HCD_IsDeviceConnected(pdev) ) {
 8017d5e:	f003 ff06 	bl	801bb6e <HCD_IsDeviceConnected>
 8017d62:	2800      	cmp	r0, #0
 8017d64:	f000 80a9 	beq.w	8017eba <USBH_Handle+0x16e>

      u8 force_rx_req = 0;

      if( USBH_MIDI_transfer_state == USBH_MIDI_TX ) {
 8017d68:	4c6a      	ldr	r4, [pc, #424]	@ (8017f14 <USBH_Handle+0x1c8>)
 8017d6a:	f894 8000 	ldrb.w	r8, [r4]
 8017d6e:	f1b8 0f02 	cmp.w	r8, #2
 8017d72:	d125      	bne.n	8017dc0 <USBH_Handle+0x74>
	URB_STATE URB_State = HCD_GetURB_State(pdev, USBH_hc_num_out);
 8017d74:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 8017f18 <USBH_Handle+0x1cc>
 8017d78:	4630      	mov	r0, r6
 8017d7a:	f898 1000 	ldrb.w	r1, [r8]
 8017d7e:	f003 fefd 	bl	801bb7c <HCD_GetURB_State>

        if( URB_State == URB_IDLE ) {
 8017d82:	b188      	cbz	r0, 8017da8 <USBH_Handle+0x5c>
	  // wait...
	} else if( URB_State == URB_DONE ) {
 8017d84:	1e43      	subs	r3, r0, #1
 8017d86:	2b03      	cmp	r3, #3
 8017d88:	d80e      	bhi.n	8017da8 <USBH_Handle+0x5c>
 8017d8a:	e8df f003 	tbb	[pc, r3]
 8017d8e:	100b      	.short	0x100b
 8017d90:	020b      	.short	0x020b
	  USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
	} else if( URB_State == URB_STALL ) {
	  // Issue Clear Feature on OUT endpoint
	  if( USBH_ClrFeature(pdev, pphost, USBH_BulkOutEp, USBH_hc_num_out) == USBH_OK ) {
 8017d92:	f898 3000 	ldrb.w	r3, [r8]
 8017d96:	4a61      	ldr	r2, [pc, #388]	@ (8017f1c <USBH_Handle+0x1d0>)
 8017d98:	7812      	ldrb	r2, [r2, #0]
 8017d9a:	4639      	mov	r1, r7
 8017d9c:	4630      	mov	r0, r6
 8017d9e:	f002 fdd9 	bl	801a954 <USBH_ClrFeature>
 8017da2:	b908      	cbnz	r0, 8017da8 <USBH_Handle+0x5c>
	    USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
 8017da4:	2300      	movs	r3, #0
 8017da6:	7023      	strb	r3, [r4, #0]
      u8 force_rx_req = 0;
 8017da8:	f04f 0800 	mov.w	r8, #0
 8017dac:	e051      	b.n	8017e52 <USBH_Handle+0x106>
	  }
	} else if( URB_State == URB_NOTREADY ) {
	  // send again
	  USBH_BulkSendData(&USB_OTG_dev, (u8 *)USB_tx_buffer, USBH_tx_count, USBH_hc_num_out);
 8017dae:	4a5c      	ldr	r2, [pc, #368]	@ (8017f20 <USBH_Handle+0x1d4>)
 8017db0:	f898 3000 	ldrb.w	r3, [r8]
 8017db4:	7812      	ldrb	r2, [r2, #0]
 8017db6:	495b      	ldr	r1, [pc, #364]	@ (8017f24 <USBH_Handle+0x1d8>)
 8017db8:	485b      	ldr	r0, [pc, #364]	@ (8017f28 <USBH_Handle+0x1dc>)
 8017dba:	f002 fc27 	bl	801a60c <USBH_BulkSendData>
 8017dbe:	e7f3      	b.n	8017da8 <USBH_Handle+0x5c>
	} else if( URB_State == URB_ERROR ) {
	  USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
	}
      } else if( USBH_MIDI_transfer_state == USBH_MIDI_RX ) {
 8017dc0:	f1b8 0f01 	cmp.w	r8, #1
 8017dc4:	d1f0      	bne.n	8017da8 <USBH_Handle+0x5c>
	URB_STATE URB_State = HCD_GetURB_State(pdev, USBH_hc_num_in);
 8017dc6:	f8df 9164 	ldr.w	r9, [pc, #356]	@ 8017f2c <USBH_Handle+0x1e0>
 8017dca:	4630      	mov	r0, r6
 8017dcc:	f899 1000 	ldrb.w	r1, [r9]
 8017dd0:	f003 fed4 	bl	801bb7c <HCD_GetURB_State>
        if( URB_State == URB_IDLE || URB_State == URB_DONE ) {
 8017dd4:	2801      	cmp	r0, #1
 8017dd6:	d874      	bhi.n	8017ec2 <USBH_Handle+0x176>
	  // data received from receive
	  //u32 count = HCD_GetXferCnt(pdev, USBH_hc_num_in) / 4;
	  // Note: HCD_GetXferCnt returns a counter which isn't zeroed immediately on a USBH_BulkReceiveData() call
	  u32 count = USB_OTG_dev.host.hc[USBH_hc_num_in].xfer_count / 4;
 8017dd8:	f899 2000 	ldrb.w	r2, [r9]
 8017ddc:	4b52      	ldr	r3, [pc, #328]	@ (8017f28 <USBH_Handle+0x1dc>)
 8017dde:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8017de2:	f8d3 28a4 	ldr.w	r2, [r3, #2212]	@ 0x8a4

	  // push data into FIFO
	  if( !count ) {
 8017de6:	2a03      	cmp	r2, #3
 8017de8:	d9dc      	bls.n	8017da4 <USBH_Handle+0x58>
	    USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
	  } else if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8017dea:	f8df 9144 	ldr.w	r9, [pc, #324]	@ 8017f30 <USBH_Handle+0x1e4>
 8017dee:	f8b9 3000 	ldrh.w	r3, [r9]
 8017df2:	b29b      	uxth	r3, r3
 8017df4:	f1c3 0340 	rsb	r3, r3, #64	@ 0x40
 8017df8:	ebb3 0f92 	cmp.w	r3, r2, lsr #2
	  u32 count = USB_OTG_dev.host.hc[USBH_hc_num_in].xfer_count / 4;
 8017dfc:	ea4f 0692 	mov.w	r6, r2, lsr #2
	  } else if( count < (MIOS32_USB_MIDI_RX_BUFFER_SIZE-rx_buffer_size) ) {
 8017e00:	d9d2      	bls.n	8017da8 <USBH_Handle+0x5c>
	    u32 *buf_addr = (u32 *)USB_rx_buffer;

	    // copy received packages into receive buffer
	    // this operation should be atomic
	    MIOS32_IRQ_Disable();
 8017e02:	f7fe fc73 	bl	80166ec <MIOS32_IRQ_Disable>
	    u32 *buf_addr = (u32 *)USB_rx_buffer;
 8017e06:	f8df a12c 	ldr.w	sl, [pc, #300]	@ 8017f34 <USBH_Handle+0x1e8>
	    do {
	      mios32_midi_package_t package;
	      package.ALL = *buf_addr++;

	      if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
		rx_buffer[rx_buffer_head] = package.ALL;
 8017e0a:	4f4b      	ldr	r7, [pc, #300]	@ (8017f38 <USBH_Handle+0x1ec>)
 8017e0c:	f8df b12c 	ldr.w	fp, [pc, #300]	@ 8017f3c <USBH_Handle+0x1f0>
	      package.ALL = *buf_addr++;
 8017e10:	f85a 1b04 	ldr.w	r1, [sl], #4
	      if( MIOS32_MIDI_SendPackageToRxCallback(USB0 + package.cable, package) == 0 ) {
 8017e14:	9101      	str	r1, [sp, #4]
 8017e16:	f3c1 1003 	ubfx	r0, r1, #4, #4
 8017e1a:	3010      	adds	r0, #16
 8017e1c:	b2c0      	uxtb	r0, r0
 8017e1e:	f7fc ffaf 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8017e22:	b988      	cbnz	r0, 8017e48 <USBH_Handle+0xfc>
		rx_buffer[rx_buffer_head] = package.ALL;
 8017e24:	883b      	ldrh	r3, [r7, #0]
 8017e26:	9901      	ldr	r1, [sp, #4]
 8017e28:	b29b      	uxth	r3, r3
 8017e2a:	f84b 1023 	str.w	r1, [fp, r3, lsl #2]

		if( ++rx_buffer_head >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 8017e2e:	883b      	ldrh	r3, [r7, #0]
 8017e30:	3301      	adds	r3, #1
 8017e32:	b29b      	uxth	r3, r3
 8017e34:	2b3f      	cmp	r3, #63	@ 0x3f
 8017e36:	803b      	strh	r3, [r7, #0]
		  rx_buffer_head = 0;
 8017e38:	bf88      	it	hi
 8017e3a:	8038      	strhhi	r0, [r7, #0]
		++rx_buffer_size;
 8017e3c:	f8b9 3000 	ldrh.w	r3, [r9]
 8017e40:	3301      	adds	r3, #1
 8017e42:	b29b      	uxth	r3, r3
 8017e44:	f8a9 3000 	strh.w	r3, [r9]
	      }
	    } while( --count > 0 );
 8017e48:	3e01      	subs	r6, #1
 8017e4a:	d1e1      	bne.n	8017e10 <USBH_Handle+0xc4>
	    MIOS32_IRQ_Enable();
 8017e4c:	f7fe fc62 	bl	8016714 <MIOS32_IRQ_Enable>

	    USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
 8017e50:	7026      	strb	r6, [r4, #0]
	  USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
	}
      }


      if( USBH_MIDI_transfer_state == USBH_MIDI_IDLE ) {
 8017e52:	7823      	ldrb	r3, [r4, #0]
 8017e54:	2b00      	cmp	r3, #0
 8017e56:	d130      	bne.n	8017eba <USBH_Handle+0x16e>
	if( !force_rx_req && tx_buffer_size && transfer_possible ) {
 8017e58:	f1b8 0f00 	cmp.w	r8, #0
 8017e5c:	d14c      	bne.n	8017ef8 <USBH_Handle+0x1ac>
 8017e5e:	4e38      	ldr	r6, [pc, #224]	@ (8017f40 <USBH_Handle+0x1f4>)
 8017e60:	8833      	ldrh	r3, [r6, #0]
 8017e62:	b29b      	uxth	r3, r3
 8017e64:	2b00      	cmp	r3, #0
 8017e66:	d047      	beq.n	8017ef8 <USBH_Handle+0x1ac>
 8017e68:	782b      	ldrb	r3, [r5, #0]
 8017e6a:	2b00      	cmp	r3, #0
 8017e6c:	d044      	beq.n	8017ef8 <USBH_Handle+0x1ac>
	  // atomic operation to avoid conflict with other interrupts
	  MIOS32_IRQ_Disable();
 8017e6e:	f7fe fc3d 	bl	80166ec <MIOS32_IRQ_Disable>

	  s16 count = (tx_buffer_size > (USBH_BulkOutEpSize/4)) ? (USBH_BulkOutEpSize/4) : tx_buffer_size;
 8017e72:	4b34      	ldr	r3, [pc, #208]	@ (8017f44 <USBH_Handle+0x1f8>)

	  // send to IN pipe
	  tx_buffer_size -= count;

	  u32 *buf_addr = (u32 *)USB_tx_buffer;
 8017e74:	4d2b      	ldr	r5, [pc, #172]	@ (8017f24 <USBH_Handle+0x1d8>)
	  s16 count = (tx_buffer_size > (USBH_BulkOutEpSize/4)) ? (USBH_BulkOutEpSize/4) : tx_buffer_size;
 8017e76:	8819      	ldrh	r1, [r3, #0]
 8017e78:	8833      	ldrh	r3, [r6, #0]
	  int i;
	  for(i=0; i<count; ++i) {
	    *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017e7a:	4833      	ldr	r0, [pc, #204]	@ (8017f48 <USBH_Handle+0x1fc>)
	  s16 count = (tx_buffer_size > (USBH_BulkOutEpSize/4)) ? (USBH_BulkOutEpSize/4) : tx_buffer_size;
 8017e7c:	b29b      	uxth	r3, r3
 8017e7e:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8017e82:	ea4f 0291 	mov.w	r2, r1, lsr #2
 8017e86:	bf98      	it	ls
 8017e88:	8832      	ldrhls	r2, [r6, #0]
	  tx_buffer_size -= count;
 8017e8a:	8833      	ldrh	r3, [r6, #0]
	  s16 count = (tx_buffer_size > (USBH_BulkOutEpSize/4)) ? (USBH_BulkOutEpSize/4) : tx_buffer_size;
 8017e8c:	b212      	sxth	r2, r2
	  tx_buffer_size -= count;
 8017e8e:	1a9b      	subs	r3, r3, r2
 8017e90:	b29b      	uxth	r3, r3
 8017e92:	8033      	strh	r3, [r6, #0]
	  for(i=0; i<count; ++i) {
 8017e94:	2100      	movs	r1, #0
	    *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017e96:	4e2d      	ldr	r6, [pc, #180]	@ (8017f4c <USBH_Handle+0x200>)
	    if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
	      tx_buffer_tail = 0;
 8017e98:	460f      	mov	r7, r1
	  for(i=0; i<count; ++i) {
 8017e9a:	4291      	cmp	r1, r2
 8017e9c:	db1d      	blt.n	8017eda <USBH_Handle+0x18e>
	  }
	  
	  USBH_tx_count = count * 4;
 8017e9e:	4b20      	ldr	r3, [pc, #128]	@ (8017f20 <USBH_Handle+0x1d4>)
	  USBH_BulkSendData(&USB_OTG_dev, (u8 *)USB_tx_buffer, USBH_tx_count, USBH_hc_num_out);
 8017ea0:	4920      	ldr	r1, [pc, #128]	@ (8017f24 <USBH_Handle+0x1d8>)
 8017ea2:	4821      	ldr	r0, [pc, #132]	@ (8017f28 <USBH_Handle+0x1dc>)
	  USBH_tx_count = count * 4;
 8017ea4:	0092      	lsls	r2, r2, #2
 8017ea6:	b2d2      	uxtb	r2, r2
 8017ea8:	701a      	strb	r2, [r3, #0]
	  USBH_BulkSendData(&USB_OTG_dev, (u8 *)USB_tx_buffer, USBH_tx_count, USBH_hc_num_out);
 8017eaa:	4b1b      	ldr	r3, [pc, #108]	@ (8017f18 <USBH_Handle+0x1cc>)
 8017eac:	781b      	ldrb	r3, [r3, #0]
 8017eae:	f002 fbad 	bl	801a60c <USBH_BulkSendData>

	  USBH_MIDI_transfer_state = USBH_MIDI_TX;
 8017eb2:	2302      	movs	r3, #2
 8017eb4:	7023      	strb	r3, [r4, #0]

	  MIOS32_IRQ_Enable();
 8017eb6:	f7fe fc2d 	bl	8016714 <MIOS32_IRQ_Enable>
      }
    }
  }

  return USBH_OK;
}
 8017eba:	2000      	movs	r0, #0
 8017ebc:	b003      	add	sp, #12
 8017ebe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if( URB_State == URB_STALL ) {
 8017ec2:	2804      	cmp	r0, #4
 8017ec4:	d103      	bne.n	8017ece <USBH_Handle+0x182>
	  if( USBH_ClrFeature(pdev, pphost, USBH_BulkInEp, USBH_hc_num_in) == USBH_OK ) {
 8017ec6:	f899 3000 	ldrb.w	r3, [r9]
 8017eca:	4a21      	ldr	r2, [pc, #132]	@ (8017f50 <USBH_Handle+0x204>)
 8017ecc:	e764      	b.n	8017d98 <USBH_Handle+0x4c>
	} else if( URB_State == URB_ERROR || URB_State == URB_NOTREADY ) {
 8017ece:	3802      	subs	r0, #2
 8017ed0:	b2c0      	uxtb	r0, r0
 8017ed2:	2801      	cmp	r0, #1
 8017ed4:	f63f af68 	bhi.w	8017da8 <USBH_Handle+0x5c>
 8017ed8:	e764      	b.n	8017da4 <USBH_Handle+0x58>
	    *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017eda:	8803      	ldrh	r3, [r0, #0]
 8017edc:	b29b      	uxth	r3, r3
	  for(i=0; i<count; ++i) {
 8017ede:	3101      	adds	r1, #1
	    *(buf_addr++) = tx_buffer[tx_buffer_tail];
 8017ee0:	f856 3023 	ldr.w	r3, [r6, r3, lsl #2]
 8017ee4:	f845 3b04 	str.w	r3, [r5], #4
	    if( ++tx_buffer_tail >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 8017ee8:	8803      	ldrh	r3, [r0, #0]
 8017eea:	3301      	adds	r3, #1
 8017eec:	b29b      	uxth	r3, r3
 8017eee:	2b3f      	cmp	r3, #63	@ 0x3f
 8017ef0:	8003      	strh	r3, [r0, #0]
	      tx_buffer_tail = 0;
 8017ef2:	bf88      	it	hi
 8017ef4:	8007      	strhhi	r7, [r0, #0]
	  for(i=0; i<count; ++i) {
 8017ef6:	e7d0      	b.n	8017e9a <USBH_Handle+0x14e>
	  USBH_BulkReceiveData(&USB_OTG_dev, (u8 *)USB_rx_buffer, USBH_BulkInEpSize, USBH_hc_num_in);
 8017ef8:	4b0c      	ldr	r3, [pc, #48]	@ (8017f2c <USBH_Handle+0x1e0>)
 8017efa:	4a16      	ldr	r2, [pc, #88]	@ (8017f54 <USBH_Handle+0x208>)
 8017efc:	781b      	ldrb	r3, [r3, #0]
 8017efe:	7812      	ldrb	r2, [r2, #0]
 8017f00:	490c      	ldr	r1, [pc, #48]	@ (8017f34 <USBH_Handle+0x1e8>)
 8017f02:	4809      	ldr	r0, [pc, #36]	@ (8017f28 <USBH_Handle+0x1dc>)
 8017f04:	f002 fb9d 	bl	801a642 <USBH_BulkReceiveData>
	  USBH_MIDI_transfer_state = USBH_MIDI_RX;
 8017f08:	2301      	movs	r3, #1
 8017f0a:	7023      	strb	r3, [r4, #0]
 8017f0c:	e7d5      	b.n	8017eba <USBH_Handle+0x16e>
 8017f0e:	bf00      	nop
 8017f10:	20003d9a 	.word	0x20003d9a
 8017f14:	20003fac 	.word	0x20003fac
 8017f18:	20003fb4 	.word	0x20003fb4
 8017f1c:	20003fb3 	.word	0x20003fb3
 8017f20:	20003fb0 	.word	0x20003fb0
 8017f24:	20003fb8 	.word	0x20003fb8
 8017f28:	20003304 	.word	0x20003304
 8017f2c:	20003fb5 	.word	0x20003fb5
 8017f30:	20003ea6 	.word	0x20003ea6
 8017f34:	200032c4 	.word	0x200032c4
 8017f38:	20003ea8 	.word	0x20003ea8
 8017f3c:	20003eac 	.word	0x20003eac
 8017f40:	20003d9c 	.word	0x20003d9c
 8017f44:	20003fae 	.word	0x20003fae
 8017f48:	20003da0 	.word	0x20003da0
 8017f4c:	20003da4 	.word	0x20003da4
 8017f50:	20003fb2 	.word	0x20003fb2
 8017f54:	20003fb1 	.word	0x20003fb1

08017f58 <MIOS32_USB_MIDI_Init>:
  if( mode != 0 )
 8017f58:	3800      	subs	r0, #0
 8017f5a:	bf18      	it	ne
 8017f5c:	2001      	movne	r0, #1
}
 8017f5e:	4240      	negs	r0, r0
 8017f60:	4770      	bx	lr
	...

08017f64 <MIOS32_USB_MIDI_ChangeConnectionState>:
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8017f64:	4a0e      	ldr	r2, [pc, #56]	@ (8017fa0 <MIOS32_USB_MIDI_ChangeConnectionState+0x3c>)
 8017f66:	2300      	movs	r3, #0
{
 8017f68:	b510      	push	{r4, lr}
  rx_buffer_tail = rx_buffer_head = rx_buffer_size = 0;
 8017f6a:	8013      	strh	r3, [r2, #0]
 8017f6c:	4a0d      	ldr	r2, [pc, #52]	@ (8017fa4 <MIOS32_USB_MIDI_ChangeConnectionState+0x40>)
 8017f6e:	4c0e      	ldr	r4, [pc, #56]	@ (8017fa8 <MIOS32_USB_MIDI_ChangeConnectionState+0x44>)
 8017f70:	8013      	strh	r3, [r2, #0]
 8017f72:	4a0e      	ldr	r2, [pc, #56]	@ (8017fac <MIOS32_USB_MIDI_ChangeConnectionState+0x48>)
 8017f74:	8013      	strh	r3, [r2, #0]
  rx_buffer_new_data = 0; // no data received yet
 8017f76:	4a0e      	ldr	r2, [pc, #56]	@ (8017fb0 <MIOS32_USB_MIDI_ChangeConnectionState+0x4c>)
 8017f78:	7013      	strb	r3, [r2, #0]
  tx_buffer_tail = tx_buffer_head = tx_buffer_size = 0;
 8017f7a:	4a0e      	ldr	r2, [pc, #56]	@ (8017fb4 <MIOS32_USB_MIDI_ChangeConnectionState+0x50>)
 8017f7c:	8013      	strh	r3, [r2, #0]
 8017f7e:	4a0e      	ldr	r2, [pc, #56]	@ (8017fb8 <MIOS32_USB_MIDI_ChangeConnectionState+0x54>)
 8017f80:	8013      	strh	r3, [r2, #0]
 8017f82:	4a0e      	ldr	r2, [pc, #56]	@ (8017fbc <MIOS32_USB_MIDI_ChangeConnectionState+0x58>)
 8017f84:	2101      	movs	r1, #1
 8017f86:	8013      	strh	r3, [r2, #0]
  if( connected ) {
 8017f88:	4a0d      	ldr	r2, [pc, #52]	@ (8017fc0 <MIOS32_USB_MIDI_ChangeConnectionState+0x5c>)
 8017f8a:	b128      	cbz	r0, 8017f98 <MIOS32_USB_MIDI_ChangeConnectionState+0x34>
    tx_buffer_busy = 0; // buffer not busy anymore
 8017f8c:	7013      	strb	r3, [r2, #0]
    USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
 8017f8e:	4a0d      	ldr	r2, [pc, #52]	@ (8017fc4 <MIOS32_USB_MIDI_ChangeConnectionState+0x60>)
    transfer_possible = 1;
 8017f90:	7021      	strb	r1, [r4, #0]
    USBH_MIDI_transfer_state = USBH_MIDI_IDLE;
 8017f92:	7013      	strb	r3, [r2, #0]
}
 8017f94:	2000      	movs	r0, #0
 8017f96:	bd10      	pop	{r4, pc}
    transfer_possible = 0;
 8017f98:	7020      	strb	r0, [r4, #0]
    tx_buffer_busy = 1; // buffer busy
 8017f9a:	7011      	strb	r1, [r2, #0]
 8017f9c:	e7fa      	b.n	8017f94 <MIOS32_USB_MIDI_ChangeConnectionState+0x30>
 8017f9e:	bf00      	nop
 8017fa0:	20003ea6 	.word	0x20003ea6
 8017fa4:	20003ea8 	.word	0x20003ea8
 8017fa8:	20003d9a 	.word	0x20003d9a
 8017fac:	20003eaa 	.word	0x20003eaa
 8017fb0:	20003ea4 	.word	0x20003ea4
 8017fb4:	20003d9c 	.word	0x20003d9c
 8017fb8:	20003d9e 	.word	0x20003d9e
 8017fbc:	20003da0 	.word	0x20003da0
 8017fc0:	20003d9b 	.word	0x20003d9b
 8017fc4:	20003fac 	.word	0x20003fac

08017fc8 <MIOS32_USB_MIDI_CheckAvailable>:
{
 8017fc8:	b510      	push	{r4, lr}
 8017fca:	4604      	mov	r4, r0
  if( MIOS32_USB_ForceSingleUSB() && cable >= 1 )
 8017fcc:	f7ff fd64 	bl	8017a98 <MIOS32_USB_ForceSingleUSB>
 8017fd0:	b92c      	cbnz	r4, 8017fde <MIOS32_USB_MIDI_CheckAvailable+0x16>
  return transfer_possible ? 1 : 0;
 8017fd2:	4b04      	ldr	r3, [pc, #16]	@ (8017fe4 <MIOS32_USB_MIDI_CheckAvailable+0x1c>)
 8017fd4:	7818      	ldrb	r0, [r3, #0]
 8017fd6:	3800      	subs	r0, #0
 8017fd8:	bf18      	it	ne
 8017fda:	2001      	movne	r0, #1
}
 8017fdc:	bd10      	pop	{r4, pc}
    return 0;
 8017fde:	2000      	movs	r0, #0
 8017fe0:	e7fc      	b.n	8017fdc <MIOS32_USB_MIDI_CheckAvailable+0x14>
 8017fe2:	bf00      	nop
 8017fe4:	20003d9a 	.word	0x20003d9a

08017fe8 <USBH_InterfaceInit>:
{
 8017fe8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8017fec:	460c      	mov	r4, r1
 8017fee:	4605      	mov	r5, r0
  MIOS32_USB_MIDI_ChangeConnectionState(0);
 8017ff0:	2000      	movs	r0, #0
 8017ff2:	f7ff ffb7 	bl	8017f64 <MIOS32_USB_MIDI_ChangeConnectionState>
  for(i=0; i<pphost->device_prop.Cfg_Desc.bNumInterfaces && i < USBH_MAX_NUM_INTERFACES; ++i) {
 8017ff6:	f894 3038 	ldrb.w	r3, [r4, #56]	@ 0x38
 8017ffa:	2b00      	cmp	r3, #0
 8017ffc:	d067      	beq.n	80180ce <USBH_InterfaceInit+0xe6>
    if( (pphost->device_prop.Itf_Desc[i].bInterfaceClass == 1) &&
 8017ffe:	f894 2043 	ldrb.w	r2, [r4, #67]	@ 0x43
 8018002:	2a01      	cmp	r2, #1
 8018004:	d103      	bne.n	801800e <USBH_InterfaceInit+0x26>
 8018006:	f894 2044 	ldrb.w	r2, [r4, #68]	@ 0x44
 801800a:	2a03      	cmp	r2, #3
 801800c:	d06b      	beq.n	80180e6 <USBH_InterfaceInit+0xfe>
  for(i=0; i<pphost->device_prop.Cfg_Desc.bNumInterfaces && i < USBH_MAX_NUM_INTERFACES; ++i) {
 801800e:	2b01      	cmp	r3, #1
 8018010:	d05d      	beq.n	80180ce <USBH_InterfaceInit+0xe6>
    if( (pphost->device_prop.Itf_Desc[i].bInterfaceClass == 1) &&
 8018012:	f894 304c 	ldrb.w	r3, [r4, #76]	@ 0x4c
 8018016:	2b01      	cmp	r3, #1
 8018018:	d159      	bne.n	80180ce <USBH_InterfaceInit+0xe6>
 801801a:	f894 204d 	ldrb.w	r2, [r4, #77]	@ 0x4d
 801801e:	2a03      	cmp	r2, #3
 8018020:	d155      	bne.n	80180ce <USBH_InterfaceInit+0xe6>
      if( pphost->device_prop.Ep_Desc[i][0].bEndpointAddress & 0x80 ) {
 8018022:	011a      	lsls	r2, r3, #4
 8018024:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 8018028:	4f30      	ldr	r7, [pc, #192]	@ (80180ec <USBH_InterfaceInit+0x104>)
 801802a:	f893 c052 	ldrb.w	ip, [r3, #82]	@ 0x52
	USBH_BulkInEpSize  = pphost->device_prop.Ep_Desc[i][0].wMaxPacketSize;
 801802e:	f8b3 0054 	ldrh.w	r0, [r3, #84]	@ 0x54
      if( pphost->device_prop.Ep_Desc[i][0].bEndpointAddress & 0x80 ) {
 8018032:	f993 3052 	ldrsb.w	r3, [r3, #82]	@ 0x52
 8018036:	4e2e      	ldr	r6, [pc, #184]	@ (80180f0 <USBH_InterfaceInit+0x108>)
 8018038:	f8df 80b8 	ldr.w	r8, [pc, #184]	@ 80180f4 <USBH_InterfaceInit+0x10c>
 801803c:	492e      	ldr	r1, [pc, #184]	@ (80180f8 <USBH_InterfaceInit+0x110>)
      USBH_hc_num_out = USBH_Alloc_Channel(pdev, USBH_BulkOutEp);
 801803e:	f8df 90bc 	ldr.w	r9, [pc, #188]	@ 80180fc <USBH_InterfaceInit+0x114>
      if( pphost->device_prop.Ep_Desc[i][0].bEndpointAddress & 0x80 ) {
 8018042:	2b00      	cmp	r3, #0
      if( pphost->device_prop.Ep_Desc[i][1].bEndpointAddress & 0x80 ) {
 8018044:	eb04 0302 	add.w	r3, r4, r2
	USBH_BulkOutEpSize  = pphost->device_prop.Ep_Desc[i] [0].wMaxPacketSize;
 8018048:	bfa8      	it	ge
 801804a:	8038      	strhge	r0, [r7, #0]
	USBH_BulkInEpSize  = pphost->device_prop.Ep_Desc[i][1].wMaxPacketSize;
 801804c:	f8b3 205c 	ldrh.w	r2, [r3, #92]	@ 0x5c
	USBH_BulkInEpSize  = pphost->device_prop.Ep_Desc[i][0].wMaxPacketSize;
 8018050:	bfb8      	it	lt
 8018052:	7030      	strblt	r0, [r6, #0]
      if( pphost->device_prop.Ep_Desc[i][1].bEndpointAddress & 0x80 ) {
 8018054:	f893 005a 	ldrb.w	r0, [r3, #90]	@ 0x5a
 8018058:	f993 305a 	ldrsb.w	r3, [r3, #90]	@ 0x5a
	USBH_BulkInEp = (pphost->device_prop.Ep_Desc[i][0].bEndpointAddress);
 801805c:	bfb4      	ite	lt
 801805e:	f888 c000 	strblt.w	ip, [r8]
	USBH_BulkOutEp = (pphost->device_prop.Ep_Desc[i][0].bEndpointAddress);
 8018062:	f881 c000 	strbge.w	ip, [r1]
      if( pphost->device_prop.Ep_Desc[i][1].bEndpointAddress & 0x80 ) {
 8018066:	2b00      	cmp	r3, #0
	USBH_BulkOutEp = (pphost->device_prop.Ep_Desc[i][1].bEndpointAddress);
 8018068:	bfac      	ite	ge
 801806a:	7008      	strbge	r0, [r1, #0]
	USBH_BulkInEp = (pphost->device_prop.Ep_Desc[i][1].bEndpointAddress);
 801806c:	f888 0000 	strblt.w	r0, [r8]
      USBH_hc_num_out = USBH_Alloc_Channel(pdev, USBH_BulkOutEp);
 8018070:	7809      	ldrb	r1, [r1, #0]
	USBH_BulkOutEpSize  = pphost->device_prop.Ep_Desc[i][1].wMaxPacketSize;
 8018072:	bfa8      	it	ge
 8018074:	803a      	strhge	r2, [r7, #0]
      USBH_hc_num_out = USBH_Alloc_Channel(pdev, USBH_BulkOutEp);
 8018076:	4628      	mov	r0, r5
	USBH_BulkInEpSize  = pphost->device_prop.Ep_Desc[i][1].wMaxPacketSize;
 8018078:	bfb8      	it	lt
 801807a:	7032      	strblt	r2, [r6, #0]
      USBH_hc_num_out = USBH_Alloc_Channel(pdev, USBH_BulkOutEp);
 801807c:	f002 fa22 	bl	801a4c4 <USBH_Alloc_Channel>
      USBH_hc_num_in = USBH_Alloc_Channel(pdev, USBH_BulkInEp);
 8018080:	f898 1000 	ldrb.w	r1, [r8]
      USBH_hc_num_out = USBH_Alloc_Channel(pdev, USBH_BulkOutEp);
 8018084:	f889 0000 	strb.w	r0, [r9]
      USBH_hc_num_in = USBH_Alloc_Channel(pdev, USBH_BulkInEp);
 8018088:	4628      	mov	r0, r5
 801808a:	f002 fa1b 	bl	801a4c4 <USBH_Alloc_Channel>
 801808e:	f8df 8070 	ldr.w	r8, [pc, #112]	@ 8018100 <USBH_InterfaceInit+0x118>
      USBH_Open_Channel(pdev,
 8018092:	883b      	ldrh	r3, [r7, #0]
      USBH_hc_num_in = USBH_Alloc_Channel(pdev, USBH_BulkInEp);
 8018094:	f888 0000 	strb.w	r0, [r8]
      USBH_Open_Channel(pdev,
 8018098:	2702      	movs	r7, #2
 801809a:	9301      	str	r3, [sp, #4]
 801809c:	9700      	str	r7, [sp, #0]
 801809e:	f894 3021 	ldrb.w	r3, [r4, #33]	@ 0x21
 80180a2:	f894 2020 	ldrb.w	r2, [r4, #32]
 80180a6:	f899 1000 	ldrb.w	r1, [r9]
 80180aa:	4628      	mov	r0, r5
 80180ac:	f002 f9c8 	bl	801a440 <USBH_Open_Channel>
      USBH_Open_Channel(pdev,
 80180b0:	7833      	ldrb	r3, [r6, #0]
 80180b2:	e9cd 7300 	strd	r7, r3, [sp]
 80180b6:	4628      	mov	r0, r5
 80180b8:	f894 3021 	ldrb.w	r3, [r4, #33]	@ 0x21
 80180bc:	f894 2020 	ldrb.w	r2, [r4, #32]
 80180c0:	f898 1000 	ldrb.w	r1, [r8]
 80180c4:	f002 f9bc 	bl	801a440 <USBH_Open_Channel>
      MIOS32_USB_MIDI_ChangeConnectionState(1);
 80180c8:	2001      	movs	r0, #1
 80180ca:	f7ff ff4b 	bl	8017f64 <MIOS32_USB_MIDI_ChangeConnectionState>
  if( MIOS32_USB_MIDI_CheckAvailable(0) ) {
 80180ce:	2000      	movs	r0, #0
 80180d0:	f7ff ff7a 	bl	8017fc8 <MIOS32_USB_MIDI_CheckAvailable>
 80180d4:	b118      	cbz	r0, 80180de <USBH_InterfaceInit+0xf6>
    pphost->usr_cb->DeviceNotSupported();
 80180d6:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 80180da:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80180dc:	4798      	blx	r3
}
 80180de:	2000      	movs	r0, #0
 80180e0:	b003      	add	sp, #12
 80180e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  for(i=0; i<pphost->device_prop.Cfg_Desc.bNumInterfaces && i < USBH_MAX_NUM_INTERFACES; ++i) {
 80180e6:	2300      	movs	r3, #0
 80180e8:	e79b      	b.n	8018022 <USBH_InterfaceInit+0x3a>
 80180ea:	bf00      	nop
 80180ec:	20003fae 	.word	0x20003fae
 80180f0:	20003fb1 	.word	0x20003fb1
 80180f4:	20003fb2 	.word	0x20003fb2
 80180f8:	20003fb3 	.word	0x20003fb3
 80180fc:	20003fb4 	.word	0x20003fb4
 8018100:	20003fb5 	.word	0x20003fb5

08018104 <MIOS32_USB_MIDI_PackageSend_NonBlocking>:
{
 8018104:	b570      	push	{r4, r5, r6, lr}
  if( !transfer_possible )
 8018106:	4e18      	ldr	r6, [pc, #96]	@ (8018168 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x64>)
 8018108:	7833      	ldrb	r3, [r6, #0]
{
 801810a:	4605      	mov	r5, r0
  if( !transfer_possible )
 801810c:	b913      	cbnz	r3, 8018114 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x10>
    return -1;
 801810e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 8018112:	bd70      	pop	{r4, r5, r6, pc}
  if( tx_buffer_size >= (MIOS32_USB_MIDI_TX_BUFFER_SIZE-1) ) {
 8018114:	4c15      	ldr	r4, [pc, #84]	@ (801816c <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x68>)
 8018116:	8823      	ldrh	r3, [r4, #0]
 8018118:	b29b      	uxth	r3, r3
 801811a:	2b3e      	cmp	r3, #62	@ 0x3e
 801811c:	d90b      	bls.n	8018136 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x32>
    if( USB_OTG_IsDeviceMode(&USB_OTG_dev) ) {
 801811e:	4814      	ldr	r0, [pc, #80]	@ (8018170 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x6c>)
 8018120:	f002 fd8c 	bl	801ac3c <USB_OTG_IsDeviceMode>
 8018124:	b108      	cbz	r0, 801812a <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x26>
      MIOS32_USB_MIDI_TxBufferHandler();
 8018126:	f7ff fd6d 	bl	8017c04 <MIOS32_USB_MIDI_TxBufferHandler>
    if( !transfer_possible )
 801812a:	7833      	ldrb	r3, [r6, #0]
 801812c:	2b00      	cmp	r3, #0
 801812e:	d0ee      	beq.n	801810e <MIOS32_USB_MIDI_PackageSend_NonBlocking+0xa>
    return -2;
 8018130:	f06f 0001 	mvn.w	r0, #1
 8018134:	e7ed      	b.n	8018112 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0xe>
  MIOS32_IRQ_Disable();
 8018136:	f7fe fad9 	bl	80166ec <MIOS32_IRQ_Disable>
  tx_buffer[tx_buffer_head++] = package.ALL;
 801813a:	4b0e      	ldr	r3, [pc, #56]	@ (8018174 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x70>)
 801813c:	881a      	ldrh	r2, [r3, #0]
 801813e:	b292      	uxth	r2, r2
 8018140:	1c51      	adds	r1, r2, #1
 8018142:	b289      	uxth	r1, r1
 8018144:	8019      	strh	r1, [r3, #0]
 8018146:	490c      	ldr	r1, [pc, #48]	@ (8018178 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0x74>)
 8018148:	f841 5022 	str.w	r5, [r1, r2, lsl #2]
  if( tx_buffer_head >= MIOS32_USB_MIDI_TX_BUFFER_SIZE )
 801814c:	881a      	ldrh	r2, [r3, #0]
 801814e:	b292      	uxth	r2, r2
 8018150:	2a3f      	cmp	r2, #63	@ 0x3f
    tx_buffer_head = 0;
 8018152:	bf84      	itt	hi
 8018154:	2200      	movhi	r2, #0
 8018156:	801a      	strhhi	r2, [r3, #0]
  ++tx_buffer_size;
 8018158:	8823      	ldrh	r3, [r4, #0]
 801815a:	3301      	adds	r3, #1
 801815c:	b29b      	uxth	r3, r3
 801815e:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 8018160:	f7fe fad8 	bl	8016714 <MIOS32_IRQ_Enable>
  return 0;
 8018164:	2000      	movs	r0, #0
 8018166:	e7d4      	b.n	8018112 <MIOS32_USB_MIDI_PackageSend_NonBlocking+0xe>
 8018168:	20003d9a 	.word	0x20003d9a
 801816c:	20003d9c 	.word	0x20003d9c
 8018170:	20003304 	.word	0x20003304
 8018174:	20003d9e 	.word	0x20003d9e
 8018178:	20003da4 	.word	0x20003da4

0801817c <MIOS32_USB_MIDI_PackageSend>:
{
 801817c:	b570      	push	{r4, r5, r6, lr}
    if( timeout_ctr >= 10000 )
 801817e:	4d0a      	ldr	r5, [pc, #40]	@ (80181a8 <MIOS32_USB_MIDI_PackageSend+0x2c>)
{
 8018180:	4604      	mov	r4, r0
    if( timeout_ctr >= 10000 )
 8018182:	f242 760f 	movw	r6, #9999	@ 0x270f
  while( (error=MIOS32_USB_MIDI_PackageSend_NonBlocking(package)) == -2 ) {
 8018186:	4620      	mov	r0, r4
 8018188:	f7ff ffbc 	bl	8018104 <MIOS32_USB_MIDI_PackageSend_NonBlocking>
 801818c:	1c83      	adds	r3, r0, #2
 801818e:	d005      	beq.n	801819c <MIOS32_USB_MIDI_PackageSend+0x20>
  if( error >= 0 ) // no error: reset timeout counter
 8018190:	2800      	cmp	r0, #0
    timeout_ctr = 0;
 8018192:	bfa2      	ittt	ge
 8018194:	4b04      	ldrge	r3, [pc, #16]	@ (80181a8 <MIOS32_USB_MIDI_PackageSend+0x2c>)
 8018196:	2200      	movge	r2, #0
 8018198:	801a      	strhge	r2, [r3, #0]
}
 801819a:	bd70      	pop	{r4, r5, r6, pc}
    if( timeout_ctr >= 10000 )
 801819c:	882b      	ldrh	r3, [r5, #0]
 801819e:	42b3      	cmp	r3, r6
 80181a0:	d8fb      	bhi.n	801819a <MIOS32_USB_MIDI_PackageSend+0x1e>
    ++timeout_ctr;
 80181a2:	3301      	adds	r3, #1
 80181a4:	802b      	strh	r3, [r5, #0]
 80181a6:	e7ee      	b.n	8018186 <MIOS32_USB_MIDI_PackageSend+0xa>
 80181a8:	20003d98 	.word	0x20003d98

080181ac <MIOS32_USB_MIDI_PackageReceive>:
{
 80181ac:	b538      	push	{r3, r4, r5, lr}
  if( !rx_buffer_size )
 80181ae:	4c11      	ldr	r4, [pc, #68]	@ (80181f4 <MIOS32_USB_MIDI_PackageReceive+0x48>)
 80181b0:	8823      	ldrh	r3, [r4, #0]
 80181b2:	b29b      	uxth	r3, r3
{
 80181b4:	4605      	mov	r5, r0
  if( !rx_buffer_size )
 80181b6:	b1cb      	cbz	r3, 80181ec <MIOS32_USB_MIDI_PackageReceive+0x40>
  MIOS32_IRQ_Disable();
 80181b8:	f7fe fa98 	bl	80166ec <MIOS32_IRQ_Disable>
  package->ALL = rx_buffer[rx_buffer_tail];
 80181bc:	4a0e      	ldr	r2, [pc, #56]	@ (80181f8 <MIOS32_USB_MIDI_PackageReceive+0x4c>)
 80181be:	490f      	ldr	r1, [pc, #60]	@ (80181fc <MIOS32_USB_MIDI_PackageReceive+0x50>)
 80181c0:	8813      	ldrh	r3, [r2, #0]
 80181c2:	b29b      	uxth	r3, r3
 80181c4:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 80181c8:	602b      	str	r3, [r5, #0]
  if( ++rx_buffer_tail >= MIOS32_USB_MIDI_RX_BUFFER_SIZE )
 80181ca:	8813      	ldrh	r3, [r2, #0]
 80181cc:	3301      	adds	r3, #1
 80181ce:	b29b      	uxth	r3, r3
 80181d0:	2b3f      	cmp	r3, #63	@ 0x3f
 80181d2:	8013      	strh	r3, [r2, #0]
    rx_buffer_tail = 0;
 80181d4:	bf84      	itt	hi
 80181d6:	2300      	movhi	r3, #0
 80181d8:	8013      	strhhi	r3, [r2, #0]
  --rx_buffer_size;
 80181da:	8823      	ldrh	r3, [r4, #0]
 80181dc:	3b01      	subs	r3, #1
 80181de:	b29b      	uxth	r3, r3
 80181e0:	8023      	strh	r3, [r4, #0]
  MIOS32_IRQ_Enable();
 80181e2:	f7fe fa97 	bl	8016714 <MIOS32_IRQ_Enable>
  return rx_buffer_size;
 80181e6:	8820      	ldrh	r0, [r4, #0]
 80181e8:	b280      	uxth	r0, r0
}
 80181ea:	bd38      	pop	{r3, r4, r5, pc}
    return -1;
 80181ec:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80181f0:	e7fb      	b.n	80181ea <MIOS32_USB_MIDI_PackageReceive+0x3e>
 80181f2:	bf00      	nop
 80181f4:	20003ea6 	.word	0x20003ea6
 80181f8:	20003eaa 	.word	0x20003eaa
 80181fc:	20003eac 	.word	0x20003eac

08018200 <MIOS32_USB_MIDI_Periodic_mS>:
{
 8018200:	b510      	push	{r4, lr}
  if( USB_OTG_IsHostMode(&USB_OTG_dev) ) {
 8018202:	4c09      	ldr	r4, [pc, #36]	@ (8018228 <MIOS32_USB_MIDI_Periodic_mS+0x28>)
 8018204:	4620      	mov	r0, r4
 8018206:	f002 fd1f 	bl	801ac48 <USB_OTG_IsHostMode>
 801820a:	b128      	cbz	r0, 8018218 <MIOS32_USB_MIDI_Periodic_mS+0x18>
    USBH_Process(&USB_OTG_dev, &USB_Host);
 801820c:	4907      	ldr	r1, [pc, #28]	@ (801822c <MIOS32_USB_MIDI_Periodic_mS+0x2c>)
 801820e:	4620      	mov	r0, r4
 8018210:	f001 ff6c 	bl	801a0ec <USBH_Process>
}
 8018214:	2000      	movs	r0, #0
 8018216:	bd10      	pop	{r4, pc}
  if( USB_OTG_dev.dev.class_cb == NULL ) {
 8018218:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	@ 0x5e4
 801821c:	b10b      	cbz	r3, 8018222 <MIOS32_USB_MIDI_Periodic_mS+0x22>
 801821e:	f7ff fd41 	bl	8017ca4 <MIOS32_USB_MIDI_RxBufferHandler.part.0>
    MIOS32_USB_MIDI_TxBufferHandler();
 8018222:	f7ff fcef 	bl	8017c04 <MIOS32_USB_MIDI_TxBufferHandler>
 8018226:	e7f5      	b.n	8018214 <MIOS32_USB_MIDI_Periodic_mS+0x14>
 8018228:	20003304 	.word	0x20003304
 801822c:	20003240 	.word	0x20003240

08018230 <MIOS32_USB_MIDI_EP1_IN_Callback>:
  tx_buffer_busy = 0;
 8018230:	4b02      	ldr	r3, [pc, #8]	@ (801823c <MIOS32_USB_MIDI_EP1_IN_Callback+0xc>)
 8018232:	2200      	movs	r2, #0
 8018234:	701a      	strb	r2, [r3, #0]
  MIOS32_USB_MIDI_TxBufferHandler();
 8018236:	f7ff bce5 	b.w	8017c04 <MIOS32_USB_MIDI_TxBufferHandler>
 801823a:	bf00      	nop
 801823c:	20003d9b 	.word	0x20003d9b

08018240 <MIOS32_USB_MIDI_EP2_OUT_Callback>:
  rx_buffer_new_data = 1;
 8018240:	4b04      	ldr	r3, [pc, #16]	@ (8018254 <MIOS32_USB_MIDI_EP2_OUT_Callback+0x14>)
 8018242:	2201      	movs	r2, #1
 8018244:	701a      	strb	r2, [r3, #0]
  if( USB_OTG_dev.dev.class_cb == NULL ) {
 8018246:	4b04      	ldr	r3, [pc, #16]	@ (8018258 <MIOS32_USB_MIDI_EP2_OUT_Callback+0x18>)
 8018248:	f8d3 35e4 	ldr.w	r3, [r3, #1508]	@ 0x5e4
 801824c:	b10b      	cbz	r3, 8018252 <MIOS32_USB_MIDI_EP2_OUT_Callback+0x12>
 801824e:	f7ff bd29 	b.w	8017ca4 <MIOS32_USB_MIDI_RxBufferHandler.part.0>
}
 8018252:	4770      	bx	lr
 8018254:	20003ea4 	.word	0x20003ea4
 8018258:	20003304 	.word	0x20003304

0801825c <MIOS32_UART_IsAssignedToMIDI>:
s32 MIOS32_UART_IsAssignedToMIDI(u8 uart)
{
#if NUM_SUPPORTED_UARTS == 0
  return 0; // no UART available
#else
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 801825c:	4b03      	ldr	r3, [pc, #12]	@ (801826c <MIOS32_UART_IsAssignedToMIDI+0x10>)
 801825e:	781b      	ldrb	r3, [r3, #0]
 8018260:	fa43 f000 	asr.w	r0, r3, r0
#endif
}
 8018264:	f000 0001 	and.w	r0, r0, #1
 8018268:	4770      	bx	lr
 801826a:	bf00      	nop
 801826c:	20004220 	.word	0x20004220

08018270 <MIOS32_UART_BaudrateSet>:
//! \return 0: baudrate has been changed
//! \return -1: uart not available
//! \return -2: function not prepared for this UART
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_BaudrateSet(u8 uart, u32 baudrate)
{
 8018270:	b530      	push	{r4, r5, lr}
#if NUM_SUPPORTED_UARTS == 0
  return -1; // no UART available
#else
  if( uart >= NUM_SUPPORTED_UARTS )
 8018272:	2803      	cmp	r0, #3
{
 8018274:	b085      	sub	sp, #20
 8018276:	4604      	mov	r4, r0
 8018278:	460d      	mov	r5, r1
  if( uart >= NUM_SUPPORTED_UARTS )
 801827a:	d820      	bhi.n	80182be <MIOS32_UART_BaudrateSet+0x4e>

  // USART configuration
  USART_InitTypeDef USART_InitStructure;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
 801827c:	2300      	movs	r3, #0
 801827e:	f44f 2240 	mov.w	r2, #786432	@ 0xc0000
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_InitStructure.USART_BaudRate = baudrate;

  switch( uart ) {
 8018282:	2802      	cmp	r0, #2
  USART_InitStructure.USART_BaudRate = baudrate;
 8018284:	9100      	str	r1, [sp, #0]
  USART_InitStructure.USART_Parity = USART_Parity_No;
 8018286:	e9cd 3201 	strd	r3, r2, [sp, #4]
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 801828a:	f8ad 300c 	strh.w	r3, [sp, #12]
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 801828e:	4669      	mov	r1, sp
  switch( uart ) {
 8018290:	d00d      	beq.n	80182ae <MIOS32_UART_BaudrateSet+0x3e>
 8018292:	2803      	cmp	r0, #3
 8018294:	d011      	beq.n	80182ba <MIOS32_UART_BaudrateSet+0x4a>
 8018296:	2801      	cmp	r0, #1
  case 0: USART_Init(MIOS32_UART0, &USART_InitStructure); break;
 8018298:	bf14      	ite	ne
 801829a:	480a      	ldrne	r0, [pc, #40]	@ (80182c4 <MIOS32_UART_BaudrateSet+0x54>)
#if NUM_SUPPORTED_UARTS >= 2
  case 1: USART_Init(MIOS32_UART1, &USART_InitStructure); break;
 801829c:	480a      	ldreq	r0, [pc, #40]	@ (80182c8 <MIOS32_UART_BaudrateSet+0x58>)
#endif
#if NUM_SUPPORTED_UARTS >= 3
  case 2: USART_Init(MIOS32_UART2_TX, &USART_InitStructure); USART_Init(MIOS32_UART2_RX, &USART_InitStructure); break;
#endif
#if NUM_SUPPORTED_UARTS >= 4
  case 3: USART_Init(MIOS32_UART3, &USART_InitStructure); break;
 801829e:	f001 fa27 	bl	80196f0 <USART_Init>
  default:
    return -2; // not prepared
  }

  // store baudrate in array
  uart_baudrate[uart] = baudrate;
 80182a2:	4b0a      	ldr	r3, [pc, #40]	@ (80182cc <MIOS32_UART_BaudrateSet+0x5c>)
 80182a4:	f843 5024 	str.w	r5, [r3, r4, lsl #2]

  return 0;
 80182a8:	2000      	movs	r0, #0
#endif
}
 80182aa:	b005      	add	sp, #20
 80182ac:	bd30      	pop	{r4, r5, pc}
  case 2: USART_Init(MIOS32_UART2_TX, &USART_InitStructure); USART_Init(MIOS32_UART2_RX, &USART_InitStructure); break;
 80182ae:	4808      	ldr	r0, [pc, #32]	@ (80182d0 <MIOS32_UART_BaudrateSet+0x60>)
 80182b0:	f001 fa1e 	bl	80196f0 <USART_Init>
 80182b4:	4807      	ldr	r0, [pc, #28]	@ (80182d4 <MIOS32_UART_BaudrateSet+0x64>)
 80182b6:	4669      	mov	r1, sp
 80182b8:	e7f1      	b.n	801829e <MIOS32_UART_BaudrateSet+0x2e>
  case 3: USART_Init(MIOS32_UART3, &USART_InitStructure); break;
 80182ba:	4807      	ldr	r0, [pc, #28]	@ (80182d8 <MIOS32_UART_BaudrateSet+0x68>)
 80182bc:	e7ef      	b.n	801829e <MIOS32_UART_BaudrateSet+0x2e>
    return -1;
 80182be:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80182c2:	e7f2      	b.n	80182aa <MIOS32_UART_BaudrateSet+0x3a>
 80182c4:	40004400 	.word	0x40004400
 80182c8:	40004800 	.word	0x40004800
 80182cc:	20004210 	.word	0x20004210
 80182d0:	40011400 	.word	0x40011400
 80182d4:	40011000 	.word	0x40011000
 80182d8:	40005000 	.word	0x40005000

080182dc <MIOS32_UART_InitPort>:
{
 80182dc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80182de:	4604      	mov	r4, r0
  GPIO_StructInit(&GPIO_InitStructure);
 80182e0:	4668      	mov	r0, sp
{
 80182e2:	461f      	mov	r7, r3
 80182e4:	460e      	mov	r6, r1
 80182e6:	4615      	mov	r5, r2
  GPIO_StructInit(&GPIO_InitStructure);
 80182e8:	f000 ffa6 	bl	8019238 <GPIO_StructInit>
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80182ec:	2300      	movs	r3, #0
  if( uart >= NUM_SUPPORTED_UARTS )
 80182ee:	2c03      	cmp	r4, #3
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
 80182f0:	f88d 3005 	strb.w	r3, [sp, #5]
  if( uart >= NUM_SUPPORTED_UARTS )
 80182f4:	d872      	bhi.n	80183dc <MIOS32_UART_InitPort+0x100>
    uart_assigned_to_midi |= (1 << uart);
 80182f6:	493b      	ldr	r1, [pc, #236]	@ (80183e4 <MIOS32_UART_InitPort+0x108>)
 80182f8:	2201      	movs	r2, #1
 80182fa:	7808      	ldrb	r0, [r1, #0]
 80182fc:	40a2      	lsls	r2, r4
  if( is_midi ) {
 80182fe:	b357      	cbz	r7, 8018356 <MIOS32_UART_InitPort+0x7a>
    uart_assigned_to_midi |= (1 << uart);
 8018300:	ea40 0302 	orr.w	r3, r0, r2
 8018304:	b2db      	uxtb	r3, r3
    GPIO_InitStructure.GPIO_OType = (tx_pin_mode == MIOS32_BOARD_PIN_MODE_OUTPUT_PP) ? GPIO_OType_PP : GPIO_OType_OD;
 8018306:	1f6a      	subs	r2, r5, #5
 8018308:	bf18      	it	ne
 801830a:	2201      	movne	r2, #1
  switch( uart ) {
 801830c:	2c02      	cmp	r4, #2
 801830e:	700b      	strb	r3, [r1, #0]
 8018310:	d039      	beq.n	8018386 <MIOS32_UART_InitPort+0xaa>
 8018312:	2c03      	cmp	r4, #3
 8018314:	d04f      	beq.n	80183b6 <MIOS32_UART_InitPort+0xda>
 8018316:	2c01      	cmp	r4, #1
 8018318:	f04f 0502 	mov.w	r5, #2
 801831c:	d01e      	beq.n	801835c <MIOS32_UART_InitPort+0x80>
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 801831e:	2304      	movs	r3, #4
    GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8018320:	4831      	ldr	r0, [pc, #196]	@ (80183e8 <MIOS32_UART_InitPort+0x10c>)
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_TX_PIN;
 8018322:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 8018324:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_OType = (tx_pin_mode == MIOS32_BOARD_PIN_MODE_OUTPUT_PP) ? GPIO_OType_PP : GPIO_OType_OD;
 8018326:	f88d 2006 	strb.w	r2, [sp, #6]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 801832a:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_Init(MIOS32_UART0_TX_PORT, &GPIO_InitStructure);
 801832e:	f000 ff3b 	bl	80191a8 <GPIO_Init>
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8018332:	2301      	movs	r3, #1
    GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8018334:	482c      	ldr	r0, [pc, #176]	@ (80183e8 <MIOS32_UART_InitPort+0x10c>)
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8018336:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 801833a:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 801833c:	2308      	movs	r3, #8
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 801833e:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART0_RX_PIN;
 8018342:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART0_RX_PORT, &GPIO_InitStructure);
 8018344:	f000 ff30 	bl	80191a8 <GPIO_Init>
    MIOS32_UART_BaudrateSet(uart, baudrate);
 8018348:	4631      	mov	r1, r6
 801834a:	2000      	movs	r0, #0
 801834c:	f7ff ff90 	bl	8018270 <MIOS32_UART_BaudrateSet>
  return 0; // no error
 8018350:	2000      	movs	r0, #0
}
 8018352:	b003      	add	sp, #12
 8018354:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uart_assigned_to_midi &= ~(1 << uart);
 8018356:	ea20 0302 	bic.w	r3, r0, r2
 801835a:	e7d4      	b.n	8018306 <MIOS32_UART_InitPort+0x2a>
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 801835c:	f44f 7380 	mov.w	r3, #256	@ 0x100
    GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8018360:	4822      	ldr	r0, [pc, #136]	@ (80183ec <MIOS32_UART_InitPort+0x110>)
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_TX_PIN;
 8018362:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 8018364:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8018366:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_InitStructure.GPIO_OType = (tx_pin_mode == MIOS32_BOARD_PIN_MODE_OUTPUT_PP) ? GPIO_OType_PP : GPIO_OType_OD;
 801836a:	f88d 2006 	strb.w	r2, [sp, #6]
    GPIO_Init(MIOS32_UART1_TX_PORT, &GPIO_InitStructure);
 801836e:	f000 ff1b 	bl	80191a8 <GPIO_Init>
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8018372:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8018376:	f88d 4007 	strb.w	r4, [sp, #7]
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART1_RX_PIN;
 801837a:	f44f 7300 	mov.w	r3, #512	@ 0x200
    GPIO_Init(MIOS32_UART3_RX_PORT, &GPIO_InitStructure);
 801837e:	481b      	ldr	r0, [pc, #108]	@ (80183ec <MIOS32_UART_InitPort+0x110>)
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART3_RX_PIN;
 8018380:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART3_RX_PORT, &GPIO_InitStructure);
 8018382:	4669      	mov	r1, sp
 8018384:	e012      	b.n	80183ac <MIOS32_UART_InitPort+0xd0>
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART2_TX_PIN;
 8018386:	2340      	movs	r3, #64	@ 0x40
    GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
 8018388:	4819      	ldr	r0, [pc, #100]	@ (80183f0 <MIOS32_UART_InitPort+0x114>)
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART2_TX_PIN;
 801838a:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
 801838c:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 801838e:	f88d 4004 	strb.w	r4, [sp, #4]
    GPIO_InitStructure.GPIO_OType = (tx_pin_mode == MIOS32_BOARD_PIN_MODE_OUTPUT_PP) ? GPIO_OType_PP : GPIO_OType_OD;
 8018392:	f88d 2006 	strb.w	r2, [sp, #6]
    GPIO_Init(MIOS32_UART2_TX_PORT, &GPIO_InitStructure);
 8018396:	f000 ff07 	bl	80191a8 <GPIO_Init>
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 801839a:	2301      	movs	r3, #1
 801839c:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
 80183a0:	4814      	ldr	r0, [pc, #80]	@ (80183f4 <MIOS32_UART_InitPort+0x118>)
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80183a2:	f88d 4004 	strb.w	r4, [sp, #4]
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART2_RX_PIN;
 80183a6:	2380      	movs	r3, #128	@ 0x80
 80183a8:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART2_RX_PORT, &GPIO_InitStructure);
 80183aa:	4669      	mov	r1, sp
    GPIO_Init(MIOS32_UART3_RX_PORT, &GPIO_InitStructure);
 80183ac:	f000 fefc 	bl	80191a8 <GPIO_Init>
    MIOS32_UART_BaudrateSet(uart, baudrate);
 80183b0:	4631      	mov	r1, r6
 80183b2:	4620      	mov	r0, r4
 80183b4:	e7ca      	b.n	801834c <MIOS32_UART_InitPort+0x70>
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART3_TX_PIN;
 80183b6:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80183ba:	2502      	movs	r5, #2
    GPIO_Init(MIOS32_UART3_TX_PORT, &GPIO_InitStructure);
 80183bc:	480c      	ldr	r0, [pc, #48]	@ (80183f0 <MIOS32_UART_InitPort+0x114>)
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART3_TX_PIN;
 80183be:	9300      	str	r3, [sp, #0]
    GPIO_Init(MIOS32_UART3_TX_PORT, &GPIO_InitStructure);
 80183c0:	4669      	mov	r1, sp
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80183c2:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_InitStructure.GPIO_OType = (tx_pin_mode == MIOS32_BOARD_PIN_MODE_OUTPUT_PP) ? GPIO_OType_PP : GPIO_OType_OD;
 80183c6:	f88d 2006 	strb.w	r2, [sp, #6]
    GPIO_Init(MIOS32_UART3_TX_PORT, &GPIO_InitStructure);
 80183ca:	f000 feed 	bl	80191a8 <GPIO_Init>
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 80183ce:	2301      	movs	r3, #1
 80183d0:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80183d4:	f88d 5004 	strb.w	r5, [sp, #4]
    GPIO_InitStructure.GPIO_Pin = MIOS32_UART3_RX_PIN;
 80183d8:	2304      	movs	r3, #4
 80183da:	e7d0      	b.n	801837e <MIOS32_UART_InitPort+0xa2>
    return -1; // unsupported UART
 80183dc:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80183e0:	e7b7      	b.n	8018352 <MIOS32_UART_InitPort+0x76>
 80183e2:	bf00      	nop
 80183e4:	20004220 	.word	0x20004220
 80183e8:	40020000 	.word	0x40020000
 80183ec:	40020c00 	.word	0x40020c00
 80183f0:	40020800 	.word	0x40020800
 80183f4:	40020400 	.word	0x40020400

080183f8 <MIOS32_UART_InitPortDefault>:
{
 80183f8:	b508      	push	{r3, lr}
  switch( uart ) {
 80183fa:	2803      	cmp	r0, #3
 80183fc:	d81e      	bhi.n	801843c <MIOS32_UART_InitPortDefault+0x44>
 80183fe:	e8df f000 	tbb	[pc, r0]
 8018402:	0b02      	.short	0x0b02
 8018404:	1711      	.short	0x1711
    MIOS32_UART_InitPort(0, MIOS32_UART0_BAUDRATE, MIOS32_BOARD_PIN_MODE_OUTPUT_OD, MIOS32_UART0_ASSIGNMENT == 1);
 8018406:	2301      	movs	r3, #1
 8018408:	2206      	movs	r2, #6
 801840a:	f647 2112 	movw	r1, #31250	@ 0x7a12
 801840e:	2000      	movs	r0, #0
 8018410:	f7ff ff64 	bl	80182dc <MIOS32_UART_InitPort>
  return 0; // no error
 8018414:	2000      	movs	r0, #0
}
 8018416:	bd08      	pop	{r3, pc}
    MIOS32_UART_InitPort(1, MIOS32_UART1_BAUDRATE, MIOS32_BOARD_PIN_MODE_OUTPUT_OD, MIOS32_UART1_ASSIGNMENT == 1);
 8018418:	2301      	movs	r3, #1
 801841a:	2206      	movs	r2, #6
 801841c:	f647 2112 	movw	r1, #31250	@ 0x7a12
 8018420:	4618      	mov	r0, r3
 8018422:	e7f5      	b.n	8018410 <MIOS32_UART_InitPortDefault+0x18>
    MIOS32_UART_InitPort(2, MIOS32_UART2_BAUDRATE, MIOS32_BOARD_PIN_MODE_OUTPUT_OD, MIOS32_UART2_ASSIGNMENT == 1);
 8018424:	2301      	movs	r3, #1
 8018426:	2206      	movs	r2, #6
 8018428:	f647 2112 	movw	r1, #31250	@ 0x7a12
 801842c:	2002      	movs	r0, #2
 801842e:	e7ef      	b.n	8018410 <MIOS32_UART_InitPortDefault+0x18>
    MIOS32_UART_InitPort(3, MIOS32_UART3_BAUDRATE, MIOS32_BOARD_PIN_MODE_OUTPUT_OD, MIOS32_UART3_ASSIGNMENT == 1);
 8018430:	2301      	movs	r3, #1
 8018432:	2206      	movs	r2, #6
 8018434:	f647 2112 	movw	r1, #31250	@ 0x7a12
 8018438:	2003      	movs	r0, #3
 801843a:	e7e9      	b.n	8018410 <MIOS32_UART_InitPortDefault+0x18>
  switch( uart ) {
 801843c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8018440:	e7e9      	b.n	8018416 <MIOS32_UART_InitPortDefault+0x1e>
	...

08018444 <MIOS32_UART_Init>:
{
 8018444:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if( mode != 0 )
 8018448:	4604      	mov	r4, r0
 801844a:	2800      	cmp	r0, #0
 801844c:	f040 8089 	bne.w	8018562 <MIOS32_UART_Init+0x11e>
  MIOS32_UART0_REMAP_FUNC;
 8018450:	4845      	ldr	r0, [pc, #276]	@ (8018568 <MIOS32_UART_Init+0x124>)
      rx_buffer_tail[uart] = rx_buffer_head[uart] = rx_buffer_size[uart] = 0;
 8018452:	f8df 8118 	ldr.w	r8, [pc, #280]	@ 801856c <MIOS32_UART_Init+0x128>
 8018456:	4f46      	ldr	r7, [pc, #280]	@ (8018570 <MIOS32_UART_Init+0x12c>)
 8018458:	4e46      	ldr	r6, [pc, #280]	@ (8018574 <MIOS32_UART_Init+0x130>)
  MIOS32_UART0_REMAP_FUNC;
 801845a:	2207      	movs	r2, #7
 801845c:	2102      	movs	r1, #2
 801845e:	f000 fef5 	bl	801924c <GPIO_PinAFConfig>
 8018462:	4841      	ldr	r0, [pc, #260]	@ (8018568 <MIOS32_UART_Init+0x124>)
 8018464:	2207      	movs	r2, #7
 8018466:	2103      	movs	r1, #3
 8018468:	f000 fef0 	bl	801924c <GPIO_PinAFConfig>
  MIOS32_UART1_REMAP_FUNC;
 801846c:	4842      	ldr	r0, [pc, #264]	@ (8018578 <MIOS32_UART_Init+0x134>)
 801846e:	2207      	movs	r2, #7
 8018470:	2108      	movs	r1, #8
 8018472:	f000 feeb 	bl	801924c <GPIO_PinAFConfig>
 8018476:	4840      	ldr	r0, [pc, #256]	@ (8018578 <MIOS32_UART_Init+0x134>)
 8018478:	2207      	movs	r2, #7
 801847a:	2109      	movs	r1, #9
 801847c:	f000 fee6 	bl	801924c <GPIO_PinAFConfig>
  MIOS32_UART2_REMAP_FUNC;
 8018480:	483e      	ldr	r0, [pc, #248]	@ (801857c <MIOS32_UART_Init+0x138>)
 8018482:	2208      	movs	r2, #8
 8018484:	2106      	movs	r1, #6
 8018486:	f000 fee1 	bl	801924c <GPIO_PinAFConfig>
 801848a:	2207      	movs	r2, #7
 801848c:	4611      	mov	r1, r2
 801848e:	483c      	ldr	r0, [pc, #240]	@ (8018580 <MIOS32_UART_Init+0x13c>)
 8018490:	f000 fedc 	bl	801924c <GPIO_PinAFConfig>
  MIOS32_UART3_REMAP_FUNC;
 8018494:	4839      	ldr	r0, [pc, #228]	@ (801857c <MIOS32_UART_Init+0x138>)
 8018496:	2208      	movs	r2, #8
 8018498:	210c      	movs	r1, #12
 801849a:	f000 fed7 	bl	801924c <GPIO_PinAFConfig>
 801849e:	2208      	movs	r2, #8
 80184a0:	4835      	ldr	r0, [pc, #212]	@ (8018578 <MIOS32_UART_Init+0x134>)
 80184a2:	2102      	movs	r1, #2
 80184a4:	f000 fed2 	bl	801924c <GPIO_PinAFConfig>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_USART6, ENABLE);
 80184a8:	2101      	movs	r1, #1
 80184aa:	2030      	movs	r0, #48	@ 0x30
 80184ac:	f000 ff8c 	bl	80193c8 <RCC_APB2PeriphClockCmd>
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_USART3 | RCC_APB1Periph_UART4 | RCC_APB1Periph_UART5, ENABLE);
 80184b0:	2101      	movs	r1, #1
 80184b2:	f44f 10f0 	mov.w	r0, #1966080	@ 0x1e0000
 80184b6:	f000 ff7b 	bl	80193b0 <RCC_APB1PeriphClockCmd>
      tx_buffer_tail[uart] = tx_buffer_head[uart] = tx_buffer_size[uart] = 0;
 80184ba:	4b32      	ldr	r3, [pc, #200]	@ (8018584 <MIOS32_UART_Init+0x140>)
      rx_buffer_tail[uart] = rx_buffer_head[uart] = rx_buffer_size[uart] = 0;
 80184bc:	2500      	movs	r5, #0
 80184be:	f808 5004 	strb.w	r5, [r8, r4]
 80184c2:	553d      	strb	r5, [r7, r4]
 80184c4:	5535      	strb	r5, [r6, r4]
      tx_buffer_tail[uart] = tx_buffer_head[uart] = tx_buffer_size[uart] = 0;
 80184c6:	551d      	strb	r5, [r3, r4]
 80184c8:	4b2f      	ldr	r3, [pc, #188]	@ (8018588 <MIOS32_UART_Init+0x144>)
 80184ca:	551d      	strb	r5, [r3, r4]
 80184cc:	4b2f      	ldr	r3, [pc, #188]	@ (801858c <MIOS32_UART_Init+0x148>)
      MIOS32_UART_InitPortDefault(uart);
 80184ce:	b2e0      	uxtb	r0, r4
      tx_buffer_tail[uart] = tx_buffer_head[uart] = tx_buffer_size[uart] = 0;
 80184d0:	551d      	strb	r5, [r3, r4]
    for(uart=0; uart<NUM_SUPPORTED_UARTS; ++uart) {
 80184d2:	3401      	adds	r4, #1
      MIOS32_UART_InitPortDefault(uart);
 80184d4:	f7ff ff90 	bl	80183f8 <MIOS32_UART_InitPortDefault>
    for(uart=0; uart<NUM_SUPPORTED_UARTS; ++uart) {
 80184d8:	2c04      	cmp	r4, #4
 80184da:	d1ee      	bne.n	80184ba <MIOS32_UART_Init+0x76>
  MIOS32_IRQ_Install(MIOS32_UART0_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80184dc:	4621      	mov	r1, r4
 80184de:	2026      	movs	r0, #38	@ 0x26
 80184e0:	f7fe f92c 	bl	801673c <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART0, USART_IT_RXNE, ENABLE);
 80184e4:	2201      	movs	r2, #1
 80184e6:	482a      	ldr	r0, [pc, #168]	@ (8018590 <MIOS32_UART_Init+0x14c>)
 80184e8:	f240 5125 	movw	r1, #1317	@ 0x525
 80184ec:	f001 f962 	bl	80197b4 <USART_ITConfig>
  MIOS32_IRQ_Install(MIOS32_UART1_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 80184f0:	4621      	mov	r1, r4
 80184f2:	2027      	movs	r0, #39	@ 0x27
 80184f4:	f7fe f922 	bl	801673c <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART1, USART_IT_RXNE, ENABLE);
 80184f8:	2201      	movs	r2, #1
 80184fa:	4826      	ldr	r0, [pc, #152]	@ (8018594 <MIOS32_UART_Init+0x150>)
 80184fc:	f240 5125 	movw	r1, #1317	@ 0x525
 8018500:	f001 f958 	bl	80197b4 <USART_ITConfig>
  MIOS32_IRQ_Install(MIOS32_UART2_TX_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 8018504:	4621      	mov	r1, r4
 8018506:	2047      	movs	r0, #71	@ 0x47
 8018508:	f7fe f918 	bl	801673c <MIOS32_IRQ_Install>
  MIOS32_IRQ_Install(MIOS32_UART2_RX_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 801850c:	4621      	mov	r1, r4
 801850e:	2025      	movs	r0, #37	@ 0x25
 8018510:	f7fe f914 	bl	801673c <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART2_RX, USART_IT_RXNE, ENABLE);
 8018514:	2201      	movs	r2, #1
 8018516:	4820      	ldr	r0, [pc, #128]	@ (8018598 <MIOS32_UART_Init+0x154>)
 8018518:	f240 5125 	movw	r1, #1317	@ 0x525
 801851c:	f001 f94a 	bl	80197b4 <USART_ITConfig>
  MIOS32_IRQ_Install(MIOS32_UART3_IRQ_CHANNEL, MIOS32_IRQ_UART_PRIORITY);
 8018520:	4621      	mov	r1, r4
 8018522:	2035      	movs	r0, #53	@ 0x35
 8018524:	f7fe f90a 	bl	801673c <MIOS32_IRQ_Install>
  USART_ITConfig(MIOS32_UART3, USART_IT_RXNE, ENABLE);
 8018528:	2201      	movs	r2, #1
 801852a:	481c      	ldr	r0, [pc, #112]	@ (801859c <MIOS32_UART_Init+0x158>)
 801852c:	f240 5125 	movw	r1, #1317	@ 0x525
 8018530:	f001 f940 	bl	80197b4 <USART_ITConfig>
  USART_Cmd(MIOS32_UART0, ENABLE);
 8018534:	4816      	ldr	r0, [pc, #88]	@ (8018590 <MIOS32_UART_Init+0x14c>)
 8018536:	2101      	movs	r1, #1
 8018538:	f001 f930 	bl	801979c <USART_Cmd>
  USART_Cmd(MIOS32_UART1, ENABLE);
 801853c:	4815      	ldr	r0, [pc, #84]	@ (8018594 <MIOS32_UART_Init+0x150>)
 801853e:	2101      	movs	r1, #1
 8018540:	f001 f92c 	bl	801979c <USART_Cmd>
  USART_Cmd(MIOS32_UART2_RX, ENABLE);
 8018544:	4814      	ldr	r0, [pc, #80]	@ (8018598 <MIOS32_UART_Init+0x154>)
 8018546:	2101      	movs	r1, #1
 8018548:	f001 f928 	bl	801979c <USART_Cmd>
  USART_Cmd(MIOS32_UART2_TX, ENABLE);
 801854c:	4814      	ldr	r0, [pc, #80]	@ (80185a0 <MIOS32_UART_Init+0x15c>)
 801854e:	2101      	movs	r1, #1
 8018550:	f001 f924 	bl	801979c <USART_Cmd>
  USART_Cmd(MIOS32_UART3, ENABLE);
 8018554:	4811      	ldr	r0, [pc, #68]	@ (801859c <MIOS32_UART_Init+0x158>)
 8018556:	2101      	movs	r1, #1
 8018558:	f001 f920 	bl	801979c <USART_Cmd>
  return 0; // no error
 801855c:	4628      	mov	r0, r5
}
 801855e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return -1; // unsupported mode
 8018562:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8018566:	e7fa      	b.n	801855e <MIOS32_UART_Init+0x11a>
 8018568:	40020000 	.word	0x40020000
 801856c:	20004104 	.word	0x20004104
 8018570:	20004108 	.word	0x20004108
 8018574:	2000410c 	.word	0x2000410c
 8018578:	40020c00 	.word	0x40020c00
 801857c:	40020800 	.word	0x40020800
 8018580:	40020400 	.word	0x40020400
 8018584:	20003ff8 	.word	0x20003ff8
 8018588:	20003ffc 	.word	0x20003ffc
 801858c:	20004000 	.word	0x20004000
 8018590:	40004400 	.word	0x40004400
 8018594:	40004800 	.word	0x40004800
 8018598:	40011000 	.word	0x40011000
 801859c:	40005000 	.word	0x40005000
 80185a0:	40011400 	.word	0x40011400

080185a4 <MIOS32_UART_RxBufferGet>:
s32 MIOS32_UART_RxBufferGet(u8 uart)
{
#if NUM_SUPPORTED_UARTS == 0
  return -1; // no UART available
#else
  if( uart >= NUM_SUPPORTED_UARTS )
 80185a4:	2803      	cmp	r0, #3
{
 80185a6:	b570      	push	{r4, r5, r6, lr}
 80185a8:	4604      	mov	r4, r0
  if( uart >= NUM_SUPPORTED_UARTS )
 80185aa:	d81a      	bhi.n	80185e2 <MIOS32_UART_RxBufferGet+0x3e>
    return -1; // UART not available

  if( !rx_buffer_size[uart] )
 80185ac:	4e10      	ldr	r6, [pc, #64]	@ (80185f0 <MIOS32_UART_RxBufferGet+0x4c>)
 80185ae:	5c33      	ldrb	r3, [r6, r0]
 80185b0:	b1d3      	cbz	r3, 80185e8 <MIOS32_UART_RxBufferGet+0x44>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 80185b2:	f7fe f89b 	bl	80166ec <MIOS32_IRQ_Disable>
  u8 b = rx_buffer[uart][rx_buffer_tail[uart]];
 80185b6:	4a0f      	ldr	r2, [pc, #60]	@ (80185f4 <MIOS32_UART_RxBufferGet+0x50>)
 80185b8:	4b0f      	ldr	r3, [pc, #60]	@ (80185f8 <MIOS32_UART_RxBufferGet+0x54>)
 80185ba:	5d11      	ldrb	r1, [r2, r4]
 80185bc:	eb03 1384 	add.w	r3, r3, r4, lsl #6
 80185c0:	5c5d      	ldrb	r5, [r3, r1]
  if( ++rx_buffer_tail[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 80185c2:	5d13      	ldrb	r3, [r2, r4]
 80185c4:	3301      	adds	r3, #1
 80185c6:	b2db      	uxtb	r3, r3
 80185c8:	2b3f      	cmp	r3, #63	@ 0x3f
 80185ca:	5513      	strb	r3, [r2, r4]
    rx_buffer_tail[uart] = 0;
 80185cc:	bf84      	itt	hi
 80185ce:	2300      	movhi	r3, #0
 80185d0:	5513      	strbhi	r3, [r2, r4]
  --rx_buffer_size[uart];
 80185d2:	5d33      	ldrb	r3, [r6, r4]
 80185d4:	3b01      	subs	r3, #1
 80185d6:	b2db      	uxtb	r3, r3
 80185d8:	5533      	strb	r3, [r6, r4]
  MIOS32_IRQ_Enable();
 80185da:	f7fe f89b 	bl	8016714 <MIOS32_IRQ_Enable>

  return b; // return received byte
 80185de:	4628      	mov	r0, r5
#endif
}
 80185e0:	bd70      	pop	{r4, r5, r6, pc}
    return -1; // UART not available
 80185e2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80185e6:	e7fb      	b.n	80185e0 <MIOS32_UART_RxBufferGet+0x3c>
    return -2; // nothing new in buffer
 80185e8:	f06f 0001 	mvn.w	r0, #1
 80185ec:	e7f8      	b.n	80185e0 <MIOS32_UART_RxBufferGet+0x3c>
 80185ee:	bf00      	nop
 80185f0:	20004104 	.word	0x20004104
 80185f4:	2000410c 	.word	0x2000410c
 80185f8:	20004110 	.word	0x20004110

080185fc <MIOS32_UART_RxBufferPut>:
s32 MIOS32_UART_RxBufferPut(u8 uart, u8 b)
{
#if NUM_SUPPORTED_UARTS == 0
  return -1; // no UART available
#else
  if( uart >= NUM_SUPPORTED_UARTS )
 80185fc:	2803      	cmp	r0, #3
{
 80185fe:	b570      	push	{r4, r5, r6, lr}
 8018600:	4604      	mov	r4, r0
 8018602:	460e      	mov	r6, r1
  if( uart >= NUM_SUPPORTED_UARTS )
 8018604:	d81b      	bhi.n	801863e <MIOS32_UART_RxBufferPut+0x42>
    return -1; // UART not available

  if( rx_buffer_size[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 8018606:	4d11      	ldr	r5, [pc, #68]	@ (801864c <MIOS32_UART_RxBufferPut+0x50>)
 8018608:	5c2b      	ldrb	r3, [r5, r0]
 801860a:	2b3f      	cmp	r3, #63	@ 0x3f
 801860c:	d81a      	bhi.n	8018644 <MIOS32_UART_RxBufferPut+0x48>
    return -2; // buffer full (retry)

  // copy received byte into receive buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 801860e:	f7fe f86d 	bl	80166ec <MIOS32_IRQ_Disable>
  rx_buffer[uart][rx_buffer_head[uart]] = b;
 8018612:	4a0f      	ldr	r2, [pc, #60]	@ (8018650 <MIOS32_UART_RxBufferPut+0x54>)
 8018614:	4b0f      	ldr	r3, [pc, #60]	@ (8018654 <MIOS32_UART_RxBufferPut+0x58>)
 8018616:	5d11      	ldrb	r1, [r2, r4]
 8018618:	eb03 1384 	add.w	r3, r3, r4, lsl #6
 801861c:	545e      	strb	r6, [r3, r1]
  if( ++rx_buffer_head[uart] >= MIOS32_UART_RX_BUFFER_SIZE )
 801861e:	5d13      	ldrb	r3, [r2, r4]
 8018620:	3301      	adds	r3, #1
 8018622:	b2db      	uxtb	r3, r3
 8018624:	2b3f      	cmp	r3, #63	@ 0x3f
 8018626:	5513      	strb	r3, [r2, r4]
    rx_buffer_head[uart] = 0;
 8018628:	bf84      	itt	hi
 801862a:	2300      	movhi	r3, #0
 801862c:	5513      	strbhi	r3, [r2, r4]
  ++rx_buffer_size[uart];
 801862e:	5d2b      	ldrb	r3, [r5, r4]
 8018630:	3301      	adds	r3, #1
 8018632:	b2db      	uxtb	r3, r3
 8018634:	552b      	strb	r3, [r5, r4]
  MIOS32_IRQ_Enable();
 8018636:	f7fe f86d 	bl	8016714 <MIOS32_IRQ_Enable>

  return 0; // no error
 801863a:	2000      	movs	r0, #0
#endif
}
 801863c:	bd70      	pop	{r4, r5, r6, pc}
    return -1; // UART not available
 801863e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8018642:	e7fb      	b.n	801863c <MIOS32_UART_RxBufferPut+0x40>
    return -2; // buffer full (retry)
 8018644:	f06f 0001 	mvn.w	r0, #1
 8018648:	e7f8      	b.n	801863c <MIOS32_UART_RxBufferPut+0x40>
 801864a:	bf00      	nop
 801864c:	20004104 	.word	0x20004104
 8018650:	20004108 	.word	0x20004108
 8018654:	20004110 	.word	0x20004110

08018658 <MIOS32_UART_TxBufferGet>:
s32 MIOS32_UART_TxBufferGet(u8 uart)
{
#if NUM_SUPPORTED_UARTS == 0
  return -1; // no UART available
#else
  if( uart >= NUM_SUPPORTED_UARTS )
 8018658:	2803      	cmp	r0, #3
{
 801865a:	b570      	push	{r4, r5, r6, lr}
 801865c:	4604      	mov	r4, r0
  if( uart >= NUM_SUPPORTED_UARTS )
 801865e:	d81a      	bhi.n	8018696 <MIOS32_UART_TxBufferGet+0x3e>
    return -1; // UART not available

  if( !tx_buffer_size[uart] )
 8018660:	4e10      	ldr	r6, [pc, #64]	@ (80186a4 <MIOS32_UART_TxBufferGet+0x4c>)
 8018662:	5c33      	ldrb	r3, [r6, r0]
 8018664:	b1d3      	cbz	r3, 801869c <MIOS32_UART_TxBufferGet+0x44>
    return -2; // nothing new in buffer

  // get byte - this operation should be atomic!
  MIOS32_IRQ_Disable();
 8018666:	f7fe f841 	bl	80166ec <MIOS32_IRQ_Disable>
  u8 b = tx_buffer[uart][tx_buffer_tail[uart]];
 801866a:	4a0f      	ldr	r2, [pc, #60]	@ (80186a8 <MIOS32_UART_TxBufferGet+0x50>)
 801866c:	4b0f      	ldr	r3, [pc, #60]	@ (80186ac <MIOS32_UART_TxBufferGet+0x54>)
 801866e:	5d11      	ldrb	r1, [r2, r4]
 8018670:	eb03 1384 	add.w	r3, r3, r4, lsl #6
 8018674:	5c5d      	ldrb	r5, [r3, r1]
  if( ++tx_buffer_tail[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 8018676:	5d13      	ldrb	r3, [r2, r4]
 8018678:	3301      	adds	r3, #1
 801867a:	b2db      	uxtb	r3, r3
 801867c:	2b3f      	cmp	r3, #63	@ 0x3f
 801867e:	5513      	strb	r3, [r2, r4]
    tx_buffer_tail[uart] = 0;
 8018680:	bf84      	itt	hi
 8018682:	2300      	movhi	r3, #0
 8018684:	5513      	strbhi	r3, [r2, r4]
  --tx_buffer_size[uart];
 8018686:	5d33      	ldrb	r3, [r6, r4]
 8018688:	3b01      	subs	r3, #1
 801868a:	b2db      	uxtb	r3, r3
 801868c:	5533      	strb	r3, [r6, r4]
  MIOS32_IRQ_Enable();
 801868e:	f7fe f841 	bl	8016714 <MIOS32_IRQ_Enable>

  return b; // return transmitted byte
 8018692:	4628      	mov	r0, r5
#endif
}
 8018694:	bd70      	pop	{r4, r5, r6, pc}
    return -1; // UART not available
 8018696:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801869a:	e7fb      	b.n	8018694 <MIOS32_UART_TxBufferGet+0x3c>
    return -2; // nothing new in buffer
 801869c:	f06f 0001 	mvn.w	r0, #1
 80186a0:	e7f8      	b.n	8018694 <MIOS32_UART_TxBufferGet+0x3c>
 80186a2:	bf00      	nop
 80186a4:	20003ff8 	.word	0x20003ff8
 80186a8:	20004000 	.word	0x20004000
 80186ac:	20004004 	.word	0x20004004

080186b0 <MIOS32_UART_TxBufferPutMore_NonBlocking>:
s32 MIOS32_UART_TxBufferPutMore_NonBlocking(u8 uart, u8 *buffer, u16 len)
{
#if NUM_SUPPORTED_UARTS == 0
  return -1; // no UART available
#else
  if( uart >= NUM_SUPPORTED_UARTS )
 80186b0:	2803      	cmp	r0, #3
{
 80186b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80186b4:	4604      	mov	r4, r0
 80186b6:	460d      	mov	r5, r1
 80186b8:	4617      	mov	r7, r2
  if( uart >= NUM_SUPPORTED_UARTS )
 80186ba:	d83c      	bhi.n	8018736 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x86>
    return -1; // UART not available

  if( (tx_buffer_size[uart]+len) >= MIOS32_UART_TX_BUFFER_SIZE )
 80186bc:	4e21      	ldr	r6, [pc, #132]	@ (8018744 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x94>)
 80186be:	5c33      	ldrb	r3, [r6, r0]
 80186c0:	4413      	add	r3, r2
 80186c2:	2b3f      	cmp	r3, #63	@ 0x3f
 80186c4:	dc3a      	bgt.n	801873c <MIOS32_UART_TxBufferPutMore_NonBlocking+0x8c>
    return -2; // buffer full or cannot get all requested bytes (retry)

  // copy bytes to be transmitted into transmit buffer
  // this operation should be atomic!
  MIOS32_IRQ_Disable();
 80186c6:	f7fe f811 	bl	80166ec <MIOS32_IRQ_Disable>

  u16 i;
  for(i=0; i<len; ++i) {
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 80186ca:	481f      	ldr	r0, [pc, #124]	@ (8018748 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x98>)
 80186cc:	491f      	ldr	r1, [pc, #124]	@ (801874c <MIOS32_UART_TxBufferPutMore_NonBlocking+0x9c>)
 80186ce:	19ea      	adds	r2, r5, r7
 80186d0:	eb00 1084 	add.w	r0, r0, r4, lsl #6

    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
      tx_buffer_head[uart] = 0;
 80186d4:	2700      	movs	r7, #0
  for(i=0; i<len; ++i) {
 80186d6:	4295      	cmp	r5, r2
 80186d8:	d103      	bne.n	80186e2 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x32>
        default: MIOS32_IRQ_Enable(); return -3; // uart not supported by routine (yet)
      }
    }
  }

  MIOS32_IRQ_Enable();
 80186da:	f7fe f81b 	bl	8016714 <MIOS32_IRQ_Enable>

  return 0; // no error
 80186de:	2000      	movs	r0, #0
#endif
}
 80186e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tx_buffer[uart][tx_buffer_head[uart]] = *buffer++;
 80186e2:	5d0b      	ldrb	r3, [r1, r4]
 80186e4:	f815 cb01 	ldrb.w	ip, [r5], #1
 80186e8:	f800 c003 	strb.w	ip, [r0, r3]
    if( ++tx_buffer_head[uart] >= MIOS32_UART_TX_BUFFER_SIZE )
 80186ec:	5d0b      	ldrb	r3, [r1, r4]
 80186ee:	3301      	adds	r3, #1
 80186f0:	b2db      	uxtb	r3, r3
 80186f2:	2b3f      	cmp	r3, #63	@ 0x3f
 80186f4:	550b      	strb	r3, [r1, r4]
      tx_buffer_head[uart] = 0;
 80186f6:	bf88      	it	hi
 80186f8:	550f      	strbhi	r7, [r1, r4]
    if( ++tx_buffer_size[uart] == 1 ) {
 80186fa:	5d33      	ldrb	r3, [r6, r4]
 80186fc:	3301      	adds	r3, #1
 80186fe:	b2db      	uxtb	r3, r3
 8018700:	2b01      	cmp	r3, #1
 8018702:	5533      	strb	r3, [r6, r4]
 8018704:	d1e7      	bne.n	80186d6 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x26>
      switch( uart ) {
 8018706:	2c02      	cmp	r4, #2
 8018708:	d00f      	beq.n	801872a <MIOS32_UART_TxBufferPutMore_NonBlocking+0x7a>
 801870a:	2c03      	cmp	r4, #3
 801870c:	d010      	beq.n	8018730 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x80>
 801870e:	2c01      	cmp	r4, #1
        case 0: MIOS32_UART0->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8018710:	bf14      	ite	ne
 8018712:	f8df c03c 	ldrne.w	ip, [pc, #60]	@ 8018750 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xa0>
        case 1: MIOS32_UART1->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8018716:	f8df c03c 	ldreq.w	ip, [pc, #60]	@ 8018754 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xa4>
        case 3: MIOS32_UART3->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 801871a:	f8bc 300c 	ldrh.w	r3, [ip, #12]
 801871e:	b29b      	uxth	r3, r3
 8018720:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8018724:	f8ac 300c 	strh.w	r3, [ip, #12]
 8018728:	e7d5      	b.n	80186d6 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x26>
        case 2: MIOS32_UART2_TX->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 801872a:	f8df c02c 	ldr.w	ip, [pc, #44]	@ 8018758 <MIOS32_UART_TxBufferPutMore_NonBlocking+0xa8>
 801872e:	e7f4      	b.n	801871a <MIOS32_UART_TxBufferPutMore_NonBlocking+0x6a>
        case 3: MIOS32_UART3->CR1 |= (1 << 7); break; // enable TXE interrupt (TXEIE=1)
 8018730:	f8df c028 	ldr.w	ip, [pc, #40]	@ 801875c <MIOS32_UART_TxBufferPutMore_NonBlocking+0xac>
 8018734:	e7f1      	b.n	801871a <MIOS32_UART_TxBufferPutMore_NonBlocking+0x6a>
    return -1; // UART not available
 8018736:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801873a:	e7d1      	b.n	80186e0 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x30>
    return -2; // buffer full or cannot get all requested bytes (retry)
 801873c:	f06f 0001 	mvn.w	r0, #1
 8018740:	e7ce      	b.n	80186e0 <MIOS32_UART_TxBufferPutMore_NonBlocking+0x30>
 8018742:	bf00      	nop
 8018744:	20003ff8 	.word	0x20003ff8
 8018748:	20004004 	.word	0x20004004
 801874c:	20003ffc 	.word	0x20003ffc
 8018750:	40004400 	.word	0x40004400
 8018754:	40004800 	.word	0x40004800
 8018758:	40011400 	.word	0x40011400
 801875c:	40005000 	.word	0x40005000

08018760 <MIOS32_UART_TxBufferPutMore>:
//! \return -1 if UART not available
//! \return -3 if UART not supported by MIOS32_UART_TxBufferPut Routine
//! \note Applications shouldn't call these functions directly, instead please use \ref MIOS32_COM or \ref MIOS32_MIDI layer functions
/////////////////////////////////////////////////////////////////////////////
s32 MIOS32_UART_TxBufferPutMore(u8 uart, u8 *buffer, u16 len)
{
 8018760:	b570      	push	{r4, r5, r6, lr}
 8018762:	4604      	mov	r4, r0
 8018764:	460d      	mov	r5, r1
 8018766:	4616      	mov	r6, r2
  s32 error;

  while( (error=MIOS32_UART_TxBufferPutMore_NonBlocking(uart, buffer, len)) == -2 );
 8018768:	4632      	mov	r2, r6
 801876a:	4629      	mov	r1, r5
 801876c:	4620      	mov	r0, r4
 801876e:	f7ff ff9f 	bl	80186b0 <MIOS32_UART_TxBufferPutMore_NonBlocking>
 8018772:	1c83      	adds	r3, r0, #2
 8018774:	d0f8      	beq.n	8018768 <MIOS32_UART_TxBufferPutMore+0x8>

  return error;
}
 8018776:	bd70      	pop	{r4, r5, r6, pc}

08018778 <USART2_IRQHandler>:
// Interrupt handler for first UART
/////////////////////////////////////////////////////////////////////////////
#if NUM_SUPPORTED_UARTS >= 1
MIOS32_UART0_IRQHANDLER_FUNC
{
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8018778:	4b16      	ldr	r3, [pc, #88]	@ (80187d4 <USART2_IRQHandler+0x5c>)
 801877a:	881a      	ldrh	r2, [r3, #0]
 801877c:	0691      	lsls	r1, r2, #26
{
 801877e:	b510      	push	{r4, lr}
  if( MIOS32_UART0->SR & (1 << 5) ) { // check if RXNE flag is set
 8018780:	d509      	bpl.n	8018796 <USART2_IRQHandler+0x1e>
    u8 b = MIOS32_UART0->DR;
 8018782:	889c      	ldrh	r4, [r3, #4]
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 8018784:	4b14      	ldr	r3, [pc, #80]	@ (80187d8 <USART2_IRQHandler+0x60>)

    s32 status = MIOS32_UART_IsAssignedToMIDI(0) ? MIOS32_MIDI_SendByteToRxCallback(UART0, b) : 0;
 8018786:	781b      	ldrb	r3, [r3, #0]
 8018788:	07da      	lsls	r2, r3, #31
    u8 b = MIOS32_UART0->DR;
 801878a:	b2e4      	uxtb	r4, r4
    s32 status = MIOS32_UART_IsAssignedToMIDI(0) ? MIOS32_MIDI_SendByteToRxCallback(UART0, b) : 0;
 801878c:	d414      	bmi.n	80187b8 <USART2_IRQHandler+0x40>

    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 801878e:	4621      	mov	r1, r4
 8018790:	2000      	movs	r0, #0
 8018792:	f7ff ff33 	bl	80185fc <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }

  if( MIOS32_UART0->SR & (1 << 7) ) { // check if TXE flag is set
 8018796:	4c0f      	ldr	r4, [pc, #60]	@ (80187d4 <USART2_IRQHandler+0x5c>)
 8018798:	8823      	ldrh	r3, [r4, #0]
 801879a:	061b      	lsls	r3, r3, #24
 801879c:	d50b      	bpl.n	80187b6 <USART2_IRQHandler+0x3e>
    return tx_buffer_size[uart];
 801879e:	4b0f      	ldr	r3, [pc, #60]	@ (80187dc <USART2_IRQHandler+0x64>)
 80187a0:	781b      	ldrb	r3, [r3, #0]
    if( MIOS32_UART_TxBufferUsed(0) > 0 ) {
 80187a2:	b183      	cbz	r3, 80187c6 <USART2_IRQHandler+0x4e>
      s32 b = MIOS32_UART_TxBufferGet(0);
 80187a4:	2000      	movs	r0, #0
 80187a6:	f7ff ff57 	bl	8018658 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 80187aa:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART0->DR = 0xff;
 80187ac:	bfb5      	itete	lt
 80187ae:	23ff      	movlt	r3, #255	@ 0xff
      } else {
	MIOS32_UART0->DR = b;
 80187b0:	b280      	uxthge	r0, r0
	MIOS32_UART0->DR = 0xff;
 80187b2:	80a3      	strhlt	r3, [r4, #4]
	MIOS32_UART0->DR = b;
 80187b4:	80a0      	strhge	r0, [r4, #4]
      }
    } else {
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
    }
  }
}
 80187b6:	bd10      	pop	{r4, pc}
    s32 status = MIOS32_UART_IsAssignedToMIDI(0) ? MIOS32_MIDI_SendByteToRxCallback(UART0, b) : 0;
 80187b8:	4621      	mov	r1, r4
 80187ba:	2020      	movs	r0, #32
 80187bc:	f7fc fad8 	bl	8014d70 <MIOS32_MIDI_SendByteToRxCallback>
    if( status == 0 && MIOS32_UART_RxBufferPut(0, b) < 0 ) {
 80187c0:	2800      	cmp	r0, #0
 80187c2:	d0e4      	beq.n	801878e <USART2_IRQHandler+0x16>
 80187c4:	e7e7      	b.n	8018796 <USART2_IRQHandler+0x1e>
      MIOS32_UART0->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80187c6:	89a3      	ldrh	r3, [r4, #12]
 80187c8:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80187cc:	041b      	lsls	r3, r3, #16
 80187ce:	0c1b      	lsrs	r3, r3, #16
 80187d0:	81a3      	strh	r3, [r4, #12]
}
 80187d2:	e7f0      	b.n	80187b6 <USART2_IRQHandler+0x3e>
 80187d4:	40004400 	.word	0x40004400
 80187d8:	20004220 	.word	0x20004220
 80187dc:	20003ff8 	.word	0x20003ff8

080187e0 <USART3_IRQHandler>:
// Interrupt handler for second UART
/////////////////////////////////////////////////////////////////////////////
#if NUM_SUPPORTED_UARTS >= 2
MIOS32_UART1_IRQHANDLER_FUNC
{
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80187e0:	4b16      	ldr	r3, [pc, #88]	@ (801883c <USART3_IRQHandler+0x5c>)
 80187e2:	881a      	ldrh	r2, [r3, #0]
 80187e4:	0691      	lsls	r1, r2, #26
{
 80187e6:	b510      	push	{r4, lr}
  if( MIOS32_UART1->SR & (1 << 5) ) { // check if RXNE flag is set
 80187e8:	d509      	bpl.n	80187fe <USART3_IRQHandler+0x1e>
    u8 b = MIOS32_UART1->DR;
 80187ea:	889c      	ldrh	r4, [r3, #4]
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 80187ec:	4b14      	ldr	r3, [pc, #80]	@ (8018840 <USART3_IRQHandler+0x60>)
 80187ee:	781b      	ldrb	r3, [r3, #0]

    s32 status = MIOS32_UART_IsAssignedToMIDI(1) ? MIOS32_MIDI_SendByteToRxCallback(UART1, b) : 0;
 80187f0:	079a      	lsls	r2, r3, #30
    u8 b = MIOS32_UART1->DR;
 80187f2:	b2e4      	uxtb	r4, r4
    s32 status = MIOS32_UART_IsAssignedToMIDI(1) ? MIOS32_MIDI_SendByteToRxCallback(UART1, b) : 0;
 80187f4:	d414      	bmi.n	8018820 <USART3_IRQHandler+0x40>

    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 80187f6:	4621      	mov	r1, r4
 80187f8:	2001      	movs	r0, #1
 80187fa:	f7ff feff 	bl	80185fc <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART1->SR & (1 << 7) ) { // check if TXE flag is set
 80187fe:	4c0f      	ldr	r4, [pc, #60]	@ (801883c <USART3_IRQHandler+0x5c>)
 8018800:	8823      	ldrh	r3, [r4, #0]
 8018802:	061b      	lsls	r3, r3, #24
 8018804:	d50b      	bpl.n	801881e <USART3_IRQHandler+0x3e>
    return tx_buffer_size[uart];
 8018806:	4b0f      	ldr	r3, [pc, #60]	@ (8018844 <USART3_IRQHandler+0x64>)
 8018808:	785b      	ldrb	r3, [r3, #1]
    if( MIOS32_UART_TxBufferUsed(1) > 0 ) {
 801880a:	b183      	cbz	r3, 801882e <USART3_IRQHandler+0x4e>
      s32 b = MIOS32_UART_TxBufferGet(1);
 801880c:	2001      	movs	r0, #1
 801880e:	f7ff ff23 	bl	8018658 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 8018812:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART1->DR = 0xff;
 8018814:	bfb5      	itete	lt
 8018816:	23ff      	movlt	r3, #255	@ 0xff
      } else {
	MIOS32_UART1->DR = b;
 8018818:	b280      	uxthge	r0, r0
	MIOS32_UART1->DR = 0xff;
 801881a:	80a3      	strhlt	r3, [r4, #4]
	MIOS32_UART1->DR = b;
 801881c:	80a0      	strhge	r0, [r4, #4]
      }
    } else {
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
    }
  }
}
 801881e:	bd10      	pop	{r4, pc}
    s32 status = MIOS32_UART_IsAssignedToMIDI(1) ? MIOS32_MIDI_SendByteToRxCallback(UART1, b) : 0;
 8018820:	4621      	mov	r1, r4
 8018822:	2021      	movs	r0, #33	@ 0x21
 8018824:	f7fc faa4 	bl	8014d70 <MIOS32_MIDI_SendByteToRxCallback>
    if( status == 0 && MIOS32_UART_RxBufferPut(1, b) < 0 ) {
 8018828:	2800      	cmp	r0, #0
 801882a:	d0e4      	beq.n	80187f6 <USART3_IRQHandler+0x16>
 801882c:	e7e7      	b.n	80187fe <USART3_IRQHandler+0x1e>
      MIOS32_UART1->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 801882e:	89a3      	ldrh	r3, [r4, #12]
 8018830:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8018834:	041b      	lsls	r3, r3, #16
 8018836:	0c1b      	lsrs	r3, r3, #16
 8018838:	81a3      	strh	r3, [r4, #12]
}
 801883a:	e7f0      	b.n	801881e <USART3_IRQHandler+0x3e>
 801883c:	40004800 	.word	0x40004800
 8018840:	20004220 	.word	0x20004220
 8018844:	20003ff8 	.word	0x20003ff8

08018848 <USART6_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// Interrupt handler for third UART
/////////////////////////////////////////////////////////////////////////////
#if NUM_SUPPORTED_UARTS >= 3
MIOS32_UART2_TX_IRQHANDLER_FUNC
{
 8018848:	b510      	push	{r4, lr}
  if( MIOS32_UART2_TX->SR & (1 << 5) ) { // check if RXNE flag is set
 801884a:	4c0e      	ldr	r4, [pc, #56]	@ (8018884 <USART6_IRQHandler+0x3c>)
 801884c:	8823      	ldrh	r3, [r4, #0]
 801884e:	069a      	lsls	r2, r3, #26
    // dummy... this UART is only used for output transfers
    u8 b = MIOS32_UART2_TX->DR;
 8018850:	bf48      	it	mi
 8018852:	88a3      	ldrhmi	r3, [r4, #4]
    if( b ); // prevent "unused variable" warning
  }
  
  if( MIOS32_UART2_TX->SR & (1 << 7) ) { // check if TXE flag is set
 8018854:	8823      	ldrh	r3, [r4, #0]
 8018856:	061b      	lsls	r3, r3, #24
 8018858:	d50b      	bpl.n	8018872 <USART6_IRQHandler+0x2a>
    return tx_buffer_size[uart];
 801885a:	4b0b      	ldr	r3, [pc, #44]	@ (8018888 <USART6_IRQHandler+0x40>)
 801885c:	789b      	ldrb	r3, [r3, #2]
    if( MIOS32_UART_TxBufferUsed(2) > 0 ) {
 801885e:	b14b      	cbz	r3, 8018874 <USART6_IRQHandler+0x2c>
      s32 b = MIOS32_UART_TxBufferGet(2);
 8018860:	2002      	movs	r0, #2
 8018862:	f7ff fef9 	bl	8018658 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 8018866:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART2_TX->DR = 0xff;
 8018868:	bfb5      	itete	lt
 801886a:	23ff      	movlt	r3, #255	@ 0xff
      } else {
	MIOS32_UART2_TX->DR = b;
 801886c:	b280      	uxthge	r0, r0
	MIOS32_UART2_TX->DR = 0xff;
 801886e:	80a3      	strhlt	r3, [r4, #4]
	MIOS32_UART2_TX->DR = b;
 8018870:	80a0      	strhge	r0, [r4, #4]
      }
    } else {
      MIOS32_UART2_TX->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
    }
  }
}
 8018872:	bd10      	pop	{r4, pc}
      MIOS32_UART2_TX->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 8018874:	89a3      	ldrh	r3, [r4, #12]
 8018876:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 801887a:	041b      	lsls	r3, r3, #16
 801887c:	0c1b      	lsrs	r3, r3, #16
 801887e:	81a3      	strh	r3, [r4, #12]
}
 8018880:	e7f7      	b.n	8018872 <USART6_IRQHandler+0x2a>
 8018882:	bf00      	nop
 8018884:	40011400 	.word	0x40011400
 8018888:	20003ff8 	.word	0x20003ff8

0801888c <USART1_IRQHandler>:

MIOS32_UART2_RX_IRQHANDLER_FUNC
{
 801888c:	b538      	push	{r3, r4, r5, lr}
  if( MIOS32_UART2_RX->SR & (1 << 5) ) { // check if RXNE flag is set
 801888e:	4c0f      	ldr	r4, [pc, #60]	@ (80188cc <USART1_IRQHandler+0x40>)
 8018890:	8823      	ldrh	r3, [r4, #0]
 8018892:	0699      	lsls	r1, r3, #26
 8018894:	d509      	bpl.n	80188aa <USART1_IRQHandler+0x1e>
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 8018896:	4b0e      	ldr	r3, [pc, #56]	@ (80188d0 <USART1_IRQHandler+0x44>)
    u8 b = MIOS32_UART2_RX->DR;
 8018898:	88a5      	ldrh	r5, [r4, #4]
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 801889a:	781b      	ldrb	r3, [r3, #0]

    s32 status = MIOS32_UART_IsAssignedToMIDI(2) ? MIOS32_MIDI_SendByteToRxCallback(UART2, b) : 0;
 801889c:	075a      	lsls	r2, r3, #29
    u8 b = MIOS32_UART2_RX->DR;
 801889e:	b2ed      	uxtb	r5, r5
    s32 status = MIOS32_UART_IsAssignedToMIDI(2) ? MIOS32_MIDI_SendByteToRxCallback(UART2, b) : 0;
 80188a0:	d40d      	bmi.n	80188be <USART1_IRQHandler+0x32>

    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 80188a2:	4629      	mov	r1, r5
 80188a4:	2002      	movs	r0, #2
 80188a6:	f7ff fea9 	bl	80185fc <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART2_RX->SR & (1 << 7) ) { // check if TXE flag is set
 80188aa:	8823      	ldrh	r3, [r4, #0]
 80188ac:	061b      	lsls	r3, r3, #24
 80188ae:	d505      	bpl.n	80188bc <USART1_IRQHandler+0x30>
    // dummy... this UART is only used for output transfers
    MIOS32_UART2_RX->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 80188b0:	89a3      	ldrh	r3, [r4, #12]
 80188b2:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80188b6:	041b      	lsls	r3, r3, #16
 80188b8:	0c1b      	lsrs	r3, r3, #16
 80188ba:	81a3      	strh	r3, [r4, #12]
  }
}
 80188bc:	bd38      	pop	{r3, r4, r5, pc}
    s32 status = MIOS32_UART_IsAssignedToMIDI(2) ? MIOS32_MIDI_SendByteToRxCallback(UART2, b) : 0;
 80188be:	4629      	mov	r1, r5
 80188c0:	2022      	movs	r0, #34	@ 0x22
 80188c2:	f7fc fa55 	bl	8014d70 <MIOS32_MIDI_SendByteToRxCallback>
    if( status == 0 && MIOS32_UART_RxBufferPut(2, b) < 0 ) {
 80188c6:	2800      	cmp	r0, #0
 80188c8:	d0eb      	beq.n	80188a2 <USART1_IRQHandler+0x16>
 80188ca:	e7ee      	b.n	80188aa <USART1_IRQHandler+0x1e>
 80188cc:	40011000 	.word	0x40011000
 80188d0:	20004220 	.word	0x20004220

080188d4 <UART5_IRQHandler>:
// Interrupt handler for fourth UART
/////////////////////////////////////////////////////////////////////////////
#if NUM_SUPPORTED_UARTS >= 4
MIOS32_UART3_IRQHANDLER_FUNC
{
  if( MIOS32_UART3->SR & (1 << 5) ) { // check if RXNE flag is set
 80188d4:	4b16      	ldr	r3, [pc, #88]	@ (8018930 <UART5_IRQHandler+0x5c>)
 80188d6:	881a      	ldrh	r2, [r3, #0]
 80188d8:	0691      	lsls	r1, r2, #26
{
 80188da:	b510      	push	{r4, lr}
  if( MIOS32_UART3->SR & (1 << 5) ) { // check if RXNE flag is set
 80188dc:	d509      	bpl.n	80188f2 <UART5_IRQHandler+0x1e>
    u8 b = MIOS32_UART3->DR;
 80188de:	889c      	ldrh	r4, [r3, #4]
  return (uart_assigned_to_midi & (1 << uart)) ? 1 : 0;
 80188e0:	4b14      	ldr	r3, [pc, #80]	@ (8018934 <UART5_IRQHandler+0x60>)
 80188e2:	781b      	ldrb	r3, [r3, #0]

    s32 status = MIOS32_UART_IsAssignedToMIDI(3) ? MIOS32_MIDI_SendByteToRxCallback(UART3, b) : 0;
 80188e4:	071a      	lsls	r2, r3, #28
    u8 b = MIOS32_UART3->DR;
 80188e6:	b2e4      	uxtb	r4, r4
    s32 status = MIOS32_UART_IsAssignedToMIDI(3) ? MIOS32_MIDI_SendByteToRxCallback(UART3, b) : 0;
 80188e8:	d414      	bmi.n	8018914 <UART5_IRQHandler+0x40>

    if( status == 0 && MIOS32_UART_RxBufferPut(3, b) < 0 ) {
 80188ea:	4621      	mov	r1, r4
 80188ec:	2003      	movs	r0, #3
 80188ee:	f7ff fe85 	bl	80185fc <MIOS32_UART_RxBufferPut>
      // here we could add some error handling
    }
  }
  
  if( MIOS32_UART3->SR & (1 << 7) ) { // check if TXE flag is set
 80188f2:	4c0f      	ldr	r4, [pc, #60]	@ (8018930 <UART5_IRQHandler+0x5c>)
 80188f4:	8823      	ldrh	r3, [r4, #0]
 80188f6:	061b      	lsls	r3, r3, #24
 80188f8:	d50b      	bpl.n	8018912 <UART5_IRQHandler+0x3e>
    return tx_buffer_size[uart];
 80188fa:	4b0f      	ldr	r3, [pc, #60]	@ (8018938 <UART5_IRQHandler+0x64>)
 80188fc:	78db      	ldrb	r3, [r3, #3]
    if( MIOS32_UART_TxBufferUsed(3) > 0 ) {
 80188fe:	b183      	cbz	r3, 8018922 <UART5_IRQHandler+0x4e>
      s32 b = MIOS32_UART_TxBufferGet(3);
 8018900:	2003      	movs	r0, #3
 8018902:	f7ff fea9 	bl	8018658 <MIOS32_UART_TxBufferGet>
      if( b < 0 ) {
 8018906:	2800      	cmp	r0, #0
	// here we could add some error handling
	MIOS32_UART3->DR = 0xff;
 8018908:	bfb5      	itete	lt
 801890a:	23ff      	movlt	r3, #255	@ 0xff
      } else {
	MIOS32_UART3->DR = b;
 801890c:	b280      	uxthge	r0, r0
	MIOS32_UART3->DR = 0xff;
 801890e:	80a3      	strhlt	r3, [r4, #4]
	MIOS32_UART3->DR = b;
 8018910:	80a0      	strhge	r0, [r4, #4]
      }
    } else {
      MIOS32_UART3->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
    }
  }
}
 8018912:	bd10      	pop	{r4, pc}
    s32 status = MIOS32_UART_IsAssignedToMIDI(3) ? MIOS32_MIDI_SendByteToRxCallback(UART3, b) : 0;
 8018914:	4621      	mov	r1, r4
 8018916:	2023      	movs	r0, #35	@ 0x23
 8018918:	f7fc fa2a 	bl	8014d70 <MIOS32_MIDI_SendByteToRxCallback>
    if( status == 0 && MIOS32_UART_RxBufferPut(3, b) < 0 ) {
 801891c:	2800      	cmp	r0, #0
 801891e:	d0e4      	beq.n	80188ea <UART5_IRQHandler+0x16>
 8018920:	e7e7      	b.n	80188f2 <UART5_IRQHandler+0x1e>
      MIOS32_UART3->CR1 &= ~(1 << 7); // disable TXE interrupt (TXEIE=0)
 8018922:	89a3      	ldrh	r3, [r4, #12]
 8018924:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8018928:	041b      	lsls	r3, r3, #16
 801892a:	0c1b      	lsrs	r3, r3, #16
 801892c:	81a3      	strh	r3, [r4, #12]
}
 801892e:	e7f0      	b.n	8018912 <UART5_IRQHandler+0x3e>
 8018930:	40005000 	.word	0x40005000
 8018934:	20004220 	.word	0x20004220
 8018938:	20003ff8 	.word	0x20003ff8

0801893c <EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// Internal function for handling IIC event interrupts
/////////////////////////////////////////////////////////////////////////////
static void EV_IRQHandler(iic_rec_t *iicx)
{
  u32 SR1Register = iicx->base->SR1;
 801893c:	6803      	ldr	r3, [r0, #0]
 801893e:	8a9a      	ldrh	r2, [r3, #20]
 8018940:	b291      	uxth	r1, r2

  if( iicx->base->SR2 ); // SR2Register not used, but we've to read this SFR to clear the flags

  /* If SB = 1, I2C master sent a START on the bus: EV5) */
  if( (SR1Register & 0x0001) == 0x0001 ) {
 8018942:	f012 0201 	ands.w	r2, r2, #1
{
 8018946:	b530      	push	{r4, r5, lr}
  if( iicx->base->SR2 ); // SR2Register not used, but we've to read this SFR to clear the flags
 8018948:	8b1c      	ldrh	r4, [r3, #24]
  if( (SR1Register & 0x0001) == 0x0001 ) {
 801894a:	d010      	beq.n	801896e <EV_IRQHandler+0x32>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 801894c:	6942      	ldr	r2, [r0, #20]
 801894e:	0792      	lsls	r2, r2, #30
 8018950:	d50a      	bpl.n	8018968 <EV_IRQHandler+0x2c>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8018952:	7d02      	ldrb	r2, [r0, #20]
 8018954:	f36f 0200 	bfc	r2, #0, #1
 8018958:	7502      	strb	r2, [r0, #20]
      // disable all interrupts
      iicx->base->CR2 &= (u16)~(I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 801895a:	889a      	ldrh	r2, [r3, #4]
 801895c:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
	}

	/* If no further data to be sent, disable the I2C BUF IT
	   in order to not have a TxE interrupt */
	if( iicx->buffer_ix >= iicx->buffer_len ) {
	  iicx->base->CR2 &= (u16)~I2C_IT_BUF;
 8018960:	0412      	lsls	r2, r2, #16
 8018962:	0c12      	lsrs	r2, r2, #16
 8018964:	809a      	strh	r2, [r3, #4]
 8018966:	e001      	b.n	801896c <EV_IRQHandler+0x30>
    iicx->base->DR = iicx->iic_address;
 8018968:	7902      	ldrb	r2, [r0, #4]
 801896a:	821a      	strh	r2, [r3, #16]
      iicx->transfer_state.STOP_REQUESTED = 1;
    }

    return;
  }
}
 801896c:	bd30      	pop	{r4, r5, pc}
  if( (SR1Register & 0x0002) == 0x0002 ) {
 801896e:	f011 0402 	ands.w	r4, r1, #2
 8018972:	d045      	beq.n	8018a00 <EV_IRQHandler+0xc4>
    if( !(iicx->iic_address & 1) ) {
 8018974:	7901      	ldrb	r1, [r0, #4]
 8018976:	07cd      	lsls	r5, r1, #31
 8018978:	d42f      	bmi.n	80189da <EV_IRQHandler+0x9e>
      if( iicx->buffer_len == 0 ) { // no data transmitted (only address was sent)
 801897a:	8a01      	ldrh	r1, [r0, #16]
 801897c:	b289      	uxth	r1, r1
 801897e:	b999      	cbnz	r1, 80189a8 <EV_IRQHandler+0x6c>
	iicx->base->CR1 |= 0x0200; // CR1_STOP_Set
 8018980:	881a      	ldrh	r2, [r3, #0]
 8018982:	b292      	uxth	r2, r2
 8018984:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8018988:	801a      	strh	r2, [r3, #0]
	iicx->transfer_state.STOP_REQUESTED = 1;
 801898a:	7d02      	ldrb	r2, [r0, #20]
 801898c:	f042 0202 	orr.w	r2, r2, #2
 8018990:	7502      	strb	r2, [r0, #20]
	iicx->base->CR2 &= (u16)~(I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8018992:	889a      	ldrh	r2, [r3, #4]
 8018994:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8018998:	0412      	lsls	r2, r2, #16
 801899a:	0c12      	lsrs	r2, r2, #16
 801899c:	809a      	strh	r2, [r3, #4]
	iicx->transfer_state.BUSY = 0;	
 801899e:	7d03      	ldrb	r3, [r0, #20]
 80189a0:	f361 0300 	bfi	r3, r1, #0, #1
      iicx->transfer_state.STOP_REQUESTED = 1;
 80189a4:	7503      	strb	r3, [r0, #20]
 80189a6:	e7e1      	b.n	801896c <EV_IRQHandler+0x30>
	if( iicx->buffer_ix < iicx->buffer_len ) {
 80189a8:	8a44      	ldrh	r4, [r0, #18]
 80189aa:	8a01      	ldrh	r1, [r0, #16]
 80189ac:	b2a4      	uxth	r4, r4
 80189ae:	b289      	uxth	r1, r1
 80189b0:	428c      	cmp	r4, r1
 80189b2:	d208      	bcs.n	80189c6 <EV_IRQHandler+0x8a>
	  iicx->base->DR = (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++];
 80189b4:	6884      	ldr	r4, [r0, #8]
 80189b6:	b12c      	cbz	r4, 80189c4 <EV_IRQHandler+0x88>
 80189b8:	8a42      	ldrh	r2, [r0, #18]
 80189ba:	b292      	uxth	r2, r2
 80189bc:	1c51      	adds	r1, r2, #1
 80189be:	b289      	uxth	r1, r1
 80189c0:	8241      	strh	r1, [r0, #18]
 80189c2:	5ca2      	ldrb	r2, [r4, r2]
 80189c4:	821a      	strh	r2, [r3, #16]
	if( iicx->buffer_ix >= iicx->buffer_len ) {
 80189c6:	8a41      	ldrh	r1, [r0, #18]
 80189c8:	8a02      	ldrh	r2, [r0, #16]
 80189ca:	b289      	uxth	r1, r1
 80189cc:	b292      	uxth	r2, r2
 80189ce:	4291      	cmp	r1, r2
 80189d0:	d3cc      	bcc.n	801896c <EV_IRQHandler+0x30>
	  iicx->base->CR2 &= (u16)~I2C_IT_BUF;
 80189d2:	889a      	ldrh	r2, [r3, #4]
 80189d4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80189d8:	e7c2      	b.n	8018960 <EV_IRQHandler+0x24>
      if( iicx->buffer_len == 1 ) {
 80189da:	8a02      	ldrh	r2, [r0, #16]
 80189dc:	b292      	uxth	r2, r2
 80189de:	2a01      	cmp	r2, #1
 80189e0:	d1c4      	bne.n	801896c <EV_IRQHandler+0x30>
	iicx->base->CR1 &= 0xFBFF; // CR1_ACK_Reset
 80189e2:	881a      	ldrh	r2, [r3, #0]
 80189e4:	f422 6280 	bic.w	r2, r2, #1024	@ 0x400
 80189e8:	0412      	lsls	r2, r2, #16
 80189ea:	0c12      	lsrs	r2, r2, #16
 80189ec:	801a      	strh	r2, [r3, #0]
	iicx->base->CR1 |= 0x0200; // CR1_STOP_Set
 80189ee:	881a      	ldrh	r2, [r3, #0]
 80189f0:	b292      	uxth	r2, r2
 80189f2:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80189f6:	801a      	strh	r2, [r3, #0]
      iicx->transfer_state.STOP_REQUESTED = 1;
 80189f8:	7d03      	ldrb	r3, [r0, #20]
 80189fa:	f043 0302 	orr.w	r3, r3, #2
 80189fe:	e7d1      	b.n	80189a4 <EV_IRQHandler+0x68>
  if( (SR1Register &0x0084) == 0x0080 ) {
 8018a00:	f001 0284 	and.w	r2, r1, #132	@ 0x84
 8018a04:	2a80      	cmp	r2, #128	@ 0x80
 8018a06:	d10f      	bne.n	8018a28 <EV_IRQHandler+0xec>
    if( iicx->buffer_ix < iicx->buffer_len ) {
 8018a08:	8a41      	ldrh	r1, [r0, #18]
 8018a0a:	8a02      	ldrh	r2, [r0, #16]
 8018a0c:	b289      	uxth	r1, r1
 8018a0e:	b292      	uxth	r2, r2
 8018a10:	4291      	cmp	r1, r2
 8018a12:	d2ab      	bcs.n	801896c <EV_IRQHandler+0x30>
      iicx->base->DR = (iicx->tx_buffer_ptr == NULL) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++];
 8018a14:	6885      	ldr	r5, [r0, #8]
 8018a16:	b12d      	cbz	r5, 8018a24 <EV_IRQHandler+0xe8>
 8018a18:	8a42      	ldrh	r2, [r0, #18]
 8018a1a:	b292      	uxth	r2, r2
 8018a1c:	1c51      	adds	r1, r2, #1
 8018a1e:	b289      	uxth	r1, r1
 8018a20:	8241      	strh	r1, [r0, #18]
 8018a22:	5cac      	ldrb	r4, [r5, r2]
 8018a24:	821c      	strh	r4, [r3, #16]
      if( iicx->buffer_ix >= iicx->buffer_len ) {
 8018a26:	e7ce      	b.n	80189c6 <EV_IRQHandler+0x8a>
  if( (SR1Register & 0x0084) == 0x0084 ) {
 8018a28:	2a84      	cmp	r2, #132	@ 0x84
 8018a2a:	d112      	bne.n	8018a52 <EV_IRQHandler+0x116>
    iicx->base->CR1 |= 0x0200; // CR1_STOP_Set
 8018a2c:	881a      	ldrh	r2, [r3, #0]
 8018a2e:	b292      	uxth	r2, r2
 8018a30:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8018a34:	801a      	strh	r2, [r3, #0]
    iicx->transfer_state.STOP_REQUESTED = 1;
 8018a36:	7d02      	ldrb	r2, [r0, #20]
 8018a38:	f042 0202 	orr.w	r2, r2, #2
 8018a3c:	7502      	strb	r2, [r0, #20]
    iicx->base->CR2 &= (u16)~(I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8018a3e:	889a      	ldrh	r2, [r3, #4]
 8018a40:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 8018a44:	0412      	lsls	r2, r2, #16
 8018a46:	0c12      	lsrs	r2, r2, #16
 8018a48:	809a      	strh	r2, [r3, #4]
    iicx->transfer_state.BUSY = 0;
 8018a4a:	7d03      	ldrb	r3, [r0, #20]
 8018a4c:	f364 0300 	bfi	r3, r4, #0, #1
 8018a50:	e7a8      	b.n	80189a4 <EV_IRQHandler+0x68>
  if( (SR1Register & 0x0040) == 0x0040 && iicx->rx_buffer_ptr != NULL ) {
 8018a52:	064c      	lsls	r4, r1, #25
 8018a54:	d58a      	bpl.n	801896c <EV_IRQHandler+0x30>
 8018a56:	68c4      	ldr	r4, [r0, #12]
 8018a58:	2c00      	cmp	r4, #0
 8018a5a:	d087      	beq.n	801896c <EV_IRQHandler+0x30>
    u8 b = iicx->base->DR;
 8018a5c:	8a1a      	ldrh	r2, [r3, #16]
    if( iicx->buffer_ix < iicx->buffer_len )
 8018a5e:	8a41      	ldrh	r1, [r0, #18]
 8018a60:	8a03      	ldrh	r3, [r0, #16]
 8018a62:	b289      	uxth	r1, r1
 8018a64:	b29b      	uxth	r3, r3
 8018a66:	4299      	cmp	r1, r3
    u8 b = iicx->base->DR;
 8018a68:	b2d2      	uxtb	r2, r2
    if( iicx->buffer_ix < iicx->buffer_len )
 8018a6a:	d205      	bcs.n	8018a78 <EV_IRQHandler+0x13c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 8018a6c:	8a43      	ldrh	r3, [r0, #18]
 8018a6e:	b29b      	uxth	r3, r3
 8018a70:	1c59      	adds	r1, r3, #1
 8018a72:	b289      	uxth	r1, r1
 8018a74:	8241      	strh	r1, [r0, #18]
 8018a76:	54e2      	strb	r2, [r4, r3]
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8018a78:	6943      	ldr	r3, [r0, #20]
 8018a7a:	0799      	lsls	r1, r3, #30
 8018a7c:	d50b      	bpl.n	8018a96 <EV_IRQHandler+0x15a>
      iicx->transfer_state.BUSY = 0;
 8018a7e:	7d03      	ldrb	r3, [r0, #20]
      iicx->base->CR2 &= (u16)~(I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8018a80:	6802      	ldr	r2, [r0, #0]
      iicx->transfer_state.BUSY = 0;
 8018a82:	f36f 0300 	bfc	r3, #0, #1
 8018a86:	7503      	strb	r3, [r0, #20]
      iicx->base->CR2 &= (u16)~(I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR);
 8018a88:	8893      	ldrh	r3, [r2, #4]
 8018a8a:	f423 63e0 	bic.w	r3, r3, #1792	@ 0x700
 8018a8e:	041b      	lsls	r3, r3, #16
 8018a90:	0c1b      	lsrs	r3, r3, #16
 8018a92:	8093      	strh	r3, [r2, #4]
      return;
 8018a94:	e76a      	b.n	801896c <EV_IRQHandler+0x30>
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 8018a96:	8a41      	ldrh	r1, [r0, #18]
 8018a98:	8a03      	ldrh	r3, [r0, #16]
 8018a9a:	b29b      	uxth	r3, r3
 8018a9c:	b289      	uxth	r1, r1
 8018a9e:	3b01      	subs	r3, #1
 8018aa0:	4299      	cmp	r1, r3
 8018aa2:	da0b      	bge.n	8018abc <EV_IRQHandler+0x180>
 8018aa4:	6943      	ldr	r3, [r0, #20]
 8018aa6:	075b      	lsls	r3, r3, #29
 8018aa8:	f57f af60 	bpl.w	801896c <EV_IRQHandler+0x30>
 8018aac:	8a43      	ldrh	r3, [r0, #18]
 8018aae:	b29b      	uxth	r3, r3
 8018ab0:	2b01      	cmp	r3, #1
 8018ab2:	f47f af5b 	bne.w	801896c <EV_IRQHandler+0x30>
 8018ab6:	2a00      	cmp	r2, #0
 8018ab8:	f47f af58 	bne.w	801896c <EV_IRQHandler+0x30>
      iicx->base->CR1 &= 0xFBFF; // CR1_ACK_Reset
 8018abc:	6802      	ldr	r2, [r0, #0]
 8018abe:	8813      	ldrh	r3, [r2, #0]
 8018ac0:	f423 6380 	bic.w	r3, r3, #1024	@ 0x400
 8018ac4:	041b      	lsls	r3, r3, #16
 8018ac6:	0c1b      	lsrs	r3, r3, #16
 8018ac8:	8013      	strh	r3, [r2, #0]
      iicx->base->CR1 |= 0x0200; // CR1_STOP_Set
 8018aca:	8813      	ldrh	r3, [r2, #0]
 8018acc:	b29b      	uxth	r3, r3
 8018ace:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8018ad2:	8013      	strh	r3, [r2, #0]
 8018ad4:	e790      	b.n	80189f8 <EV_IRQHandler+0xbc>
	...

08018ad8 <ER_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
 8018ad8:	b538      	push	{r3, r4, r5, lr}
 8018ada:	4604      	mov	r4, r0
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 8018adc:	6800      	ldr	r0, [r0, #0]
 8018ade:	f000 fbdc 	bl	801929a <I2C_GetLastEvent>
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 8018ae2:	4b17      	ldr	r3, [pc, #92]	@ (8018b40 <ER_IRQHandler+0x68>)
 8018ae4:	4003      	ands	r3, r0
  u32 event = I2C_GetLastEvent(iicx->base);
 8018ae6:	4605      	mov	r5, r0
  if( event & I2C_FLAG_BERR  ) {
 8018ae8:	b13b      	cbz	r3, 8018afa <ER_IRQHandler+0x22>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 8018aea:	6820      	ldr	r0, [r4, #0]
 8018aec:	f04f 2101 	mov.w	r1, #16777472	@ 0x1000100
 8018af0:	f000 fbdb 	bl	80192aa <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 8018af4:	f06f 0305 	mvn.w	r3, #5
 8018af8:	61a3      	str	r3, [r4, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 8018afa:	4b12      	ldr	r3, [pc, #72]	@ (8018b44 <ER_IRQHandler+0x6c>)
 8018afc:	402b      	ands	r3, r5
 8018afe:	b133      	cbz	r3, 8018b0e <ER_IRQHandler+0x36>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 8018b00:	4911      	ldr	r1, [pc, #68]	@ (8018b48 <ER_IRQHandler+0x70>)
 8018b02:	6820      	ldr	r0, [r4, #0]
 8018b04:	f000 fbd1 	bl	80192aa <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 8018b08:	f06f 0304 	mvn.w	r3, #4
 8018b0c:	61a3      	str	r3, [r4, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 8018b0e:	4b0f      	ldr	r3, [pc, #60]	@ (8018b4c <ER_IRQHandler+0x74>)
 8018b10:	402b      	ands	r3, r5
 8018b12:	b153      	cbz	r3, 8018b2a <ER_IRQHandler+0x52>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 8018b14:	490e      	ldr	r1, [pc, #56]	@ (8018b50 <ER_IRQHandler+0x78>)
 8018b16:	6820      	ldr	r0, [r4, #0]
 8018b18:	f000 fbc7 	bl	80192aa <I2C_ClearITPendingBit>
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 8018b1c:	f06f 0306 	mvn.w	r3, #6
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 8018b20:	6820      	ldr	r0, [r4, #0]
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 8018b22:	61a3      	str	r3, [r4, #24]
    I2C_GenerateSTOP(iicx->base, ENABLE);
 8018b24:	2101      	movs	r1, #1
 8018b26:	f000 fba3 	bl	8019270 <I2C_GenerateSTOP>
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8018b2a:	6820      	ldr	r0, [r4, #0]
 8018b2c:	2200      	movs	r2, #0
 8018b2e:	f44f 61e0 	mov.w	r1, #1792	@ 0x700
 8018b32:	f000 fba9 	bl	8019288 <I2C_ITConfig>

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8018b36:	7d23      	ldrb	r3, [r4, #20]
 8018b38:	f36f 0300 	bfc	r3, #0, #1
 8018b3c:	7523      	strb	r3, [r4, #20]
}
 8018b3e:	bd38      	pop	{r3, r4, r5, pc}
 8018b40:	10000100 	.word	0x10000100
 8018b44:	10000200 	.word	0x10000200
 8018b48:	01000200 	.word	0x01000200
 8018b4c:	10000400 	.word	0x10000400
 8018b50:	01000400 	.word	0x01000400

08018b54 <I2C2_EV_IRQHandler>:
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////
#if defined(MIOS32_IIC0_ENABLED) && MIOS32_IIC0_ENABLED > 0
void I2C2_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
 8018b54:	4801      	ldr	r0, [pc, #4]	@ (8018b5c <I2C2_EV_IRQHandler+0x8>)
 8018b56:	f7ff bef1 	b.w	801893c <EV_IRQHandler>
 8018b5a:	bf00      	nop
 8018b5c:	20004224 	.word	0x20004224

08018b60 <I2C2_ER_IRQHandler>:
}

void I2C2_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
 8018b60:	4801      	ldr	r0, [pc, #4]	@ (8018b68 <I2C2_ER_IRQHandler+0x8>)
 8018b62:	f7ff bfb9 	b.w	8018ad8 <ER_IRQHandler>
 8018b66:	bf00      	nop
 8018b68:	20004224 	.word	0x20004224

08018b6c <I2C1_EV_IRQHandler>:
#endif

#if defined(MIOS32_IIC1_ENABLED) && MIOS32_IIC1_ENABLED > 0
void I2C1_EV_IRQHandler(void)
{
  EV_IRQHandler((iic_rec_t *)&iic_rec[1]);
 8018b6c:	4801      	ldr	r0, [pc, #4]	@ (8018b74 <I2C1_EV_IRQHandler+0x8>)
 8018b6e:	f7ff bee5 	b.w	801893c <EV_IRQHandler>
 8018b72:	bf00      	nop
 8018b74:	20004248 	.word	0x20004248

08018b78 <I2C1_ER_IRQHandler>:
}

void I2C1_ER_IRQHandler(void)
{
  ER_IRQHandler((iic_rec_t *)&iic_rec[1]);
 8018b78:	4801      	ldr	r0, [pc, #4]	@ (8018b80 <I2C1_ER_IRQHandler+0x8>)
 8018b7a:	f7ff bfad 	b.w	8018ad8 <ER_IRQHandler>
 8018b7e:	bf00      	nop
 8018b80:	20004248 	.word	0x20004248

08018b84 <printchar>:
static void printchar(char **str, int c)
{
  //	extern int putchar(int c);
	
	if (str) {
		**str = c;
 8018b84:	b2c9      	uxtb	r1, r1
	if (str) {
 8018b86:	b128      	cbz	r0, 8018b94 <printchar+0x10>
		**str = c;
 8018b88:	6803      	ldr	r3, [r0, #0]
 8018b8a:	7019      	strb	r1, [r3, #0]
		++(*str);
 8018b8c:	6803      	ldr	r3, [r0, #0]
 8018b8e:	3301      	adds	r3, #1
 8018b90:	6003      	str	r3, [r0, #0]
	}
#ifndef MIOS32_DONT_USE_COM
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
#endif
}
 8018b92:	4770      	bx	lr
	else MIOS32_COM_SendChar(1, c); // (void)putchar(c);
 8018b94:	2001      	movs	r0, #1
 8018b96:	f7fc be4f 	b.w	8015838 <MIOS32_COM_SendChar>

08018b9a <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8018b9a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	register int pc = 0, padchar = ' ';

	if (width > 0) {
 8018b9e:	1e14      	subs	r4, r2, #0
{
 8018ba0:	4607      	mov	r7, r0
 8018ba2:	460e      	mov	r6, r1
 8018ba4:	461d      	mov	r5, r3
	if (width > 0) {
 8018ba6:	dd12      	ble.n	8018bce <prints+0x34>
		register int len = 0;
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
 8018ba8:	4608      	mov	r0, r1
 8018baa:	f00a fcaf 	bl	802350c <strlen>
		if (len >= width) width = 0;
 8018bae:	4284      	cmp	r4, r0
		else width -= len;
 8018bb0:	bfcc      	ite	gt
 8018bb2:	1a24      	subgt	r4, r4, r0
		if (len >= width) width = 0;
 8018bb4:	2400      	movle	r4, #0
		if (pad & PAD_ZERO) padchar = '0';
 8018bb6:	f015 0f02 	tst.w	r5, #2
 8018bba:	bf0c      	ite	eq
 8018bbc:	f04f 0a20 	moveq.w	sl, #32
 8018bc0:	f04f 0a30 	movne.w	sl, #48	@ 0x30
	}
	if (!(pad & PAD_RIGHT)) {
 8018bc4:	07eb      	lsls	r3, r5, #31
 8018bc6:	d510      	bpl.n	8018bea <prints+0x50>
	register int pc = 0, padchar = ' ';
 8018bc8:	2500      	movs	r5, #0
 8018bca:	46b0      	mov	r8, r6
 8018bcc:	e013      	b.n	8018bf6 <prints+0x5c>
 8018bce:	f04f 0a20 	mov.w	sl, #32
 8018bd2:	e7f7      	b.n	8018bc4 <prints+0x2a>
		for ( ; width > 0; --width) {
			printchar (out, padchar);
 8018bd4:	4651      	mov	r1, sl
 8018bd6:	4638      	mov	r0, r7
 8018bd8:	f7ff ffd4 	bl	8018b84 <printchar>
		for ( ; width > 0; --width) {
 8018bdc:	3d01      	subs	r5, #1
 8018bde:	2d00      	cmp	r5, #0
 8018be0:	dcf8      	bgt.n	8018bd4 <prints+0x3a>
 8018be2:	ea24 75e4 	bic.w	r5, r4, r4, asr #31
 8018be6:	1b64      	subs	r4, r4, r5
 8018be8:	e7ef      	b.n	8018bca <prints+0x30>
 8018bea:	4625      	mov	r5, r4
 8018bec:	e7f7      	b.n	8018bde <prints+0x44>
			++pc;
		}
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
 8018bee:	4638      	mov	r0, r7
 8018bf0:	f7ff ffc8 	bl	8018b84 <printchar>
 8018bf4:	46c8      	mov	r8, r9
	for ( ; *string ; ++string) {
 8018bf6:	46c1      	mov	r9, r8
 8018bf8:	f819 1b01 	ldrb.w	r1, [r9], #1
 8018bfc:	2900      	cmp	r1, #0
 8018bfe:	d1f6      	bne.n	8018bee <prints+0x54>
 8018c00:	46a1      	mov	r9, r4
		++pc;
	}
	for ( ; width > 0; --width) {
 8018c02:	f1b9 0f00 	cmp.w	r9, #0
 8018c06:	dc06      	bgt.n	8018c16 <prints+0x7c>
 8018c08:	1ba8      	subs	r0, r5, r6
 8018c0a:	4440      	add	r0, r8
		printchar (out, padchar);
		++pc;
	}

	return pc;
}
 8018c0c:	2c00      	cmp	r4, #0
 8018c0e:	bfa8      	it	ge
 8018c10:	1900      	addge	r0, r0, r4
 8018c12:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		printchar (out, padchar);
 8018c16:	4651      	mov	r1, sl
 8018c18:	4638      	mov	r0, r7
 8018c1a:	f7ff ffb3 	bl	8018b84 <printchar>
	for ( ; width > 0; --width) {
 8018c1e:	f109 39ff 	add.w	r9, r9, #4294967295	@ 0xffffffff
 8018c22:	e7ee      	b.n	8018c02 <prints+0x68>

08018c24 <printi>:
/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12
#endif

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8018c24:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8018c28:	4680      	mov	r8, r0
 8018c2a:	e9dd 7a0c 	ldrd	r7, sl, [sp, #48]	@ 0x30
 8018c2e:	4615      	mov	r5, r2
 8018c30:	461c      	mov	r4, r3
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
	register unsigned int u = i;

	if (i == 0) {
 8018c32:	b951      	cbnz	r1, 8018c4a <printi+0x26>
		print_buf[0] = '0';
 8018c34:	2330      	movs	r3, #48	@ 0x30
 8018c36:	f8ad 3004 	strh.w	r3, [sp, #4]
		print_buf[1] = '\0';
		return prints (out, print_buf, width, pad);
 8018c3a:	463a      	mov	r2, r7
 8018c3c:	4653      	mov	r3, sl
 8018c3e:	a901      	add	r1, sp, #4
 8018c40:	f7ff ffab 	bl	8018b9a <prints>
			*--s = '-';
		}
	}

	return pc + prints (out, s, width, pad);
}
 8018c44:	b004      	add	sp, #16
 8018c46:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (sg && b == 10 && i < 0) {
 8018c4a:	b123      	cbz	r3, 8018c56 <printi+0x32>
 8018c4c:	2a0a      	cmp	r2, #10
 8018c4e:	d129      	bne.n	8018ca4 <printi+0x80>
 8018c50:	2900      	cmp	r1, #0
 8018c52:	da27      	bge.n	8018ca4 <printi+0x80>
		u = -i;
 8018c54:	4249      	negs	r1, r1
			t += letbase - '0' - 10;
 8018c56:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
	*s = '\0';
 8018c58:	2300      	movs	r3, #0
 8018c5a:	f88d 300f 	strb.w	r3, [sp, #15]
			t += letbase - '0' - 10;
 8018c5e:	3a3a      	subs	r2, #58	@ 0x3a
	s = print_buf + PRINT_BUF_LEN-1;
 8018c60:	f10d 030f 	add.w	r3, sp, #15
		t = u % b;
 8018c64:	fbb1 f0f5 	udiv	r0, r1, r5
 8018c68:	fb05 1610 	mls	r6, r5, r0, r1
		if( t >= 10 )
 8018c6c:	2e09      	cmp	r6, #9
			t += letbase - '0' - 10;
 8018c6e:	bf88      	it	hi
 8018c70:	18b6      	addhi	r6, r6, r2
		*--s = t + '0';
 8018c72:	3630      	adds	r6, #48	@ 0x30
	while (u) {
 8018c74:	428d      	cmp	r5, r1
		*--s = t + '0';
 8018c76:	f103 39ff 	add.w	r9, r3, #4294967295	@ 0xffffffff
 8018c7a:	f803 6c01 	strb.w	r6, [r3, #-1]
	while (u) {
 8018c7e:	d913      	bls.n	8018ca8 <printi+0x84>
	if (neg) {
 8018c80:	b144      	cbz	r4, 8018c94 <printi+0x70>
		if( width && (pad & PAD_ZERO) ) {
 8018c82:	b1a7      	cbz	r7, 8018cae <printi+0x8a>
 8018c84:	f01a 0f02 	tst.w	sl, #2
 8018c88:	d011      	beq.n	8018cae <printi+0x8a>
			printchar (out, '-');
 8018c8a:	212d      	movs	r1, #45	@ 0x2d
 8018c8c:	4640      	mov	r0, r8
 8018c8e:	f7ff ff79 	bl	8018b84 <printchar>
			--width;
 8018c92:	3f01      	subs	r7, #1
	return pc + prints (out, s, width, pad);
 8018c94:	4653      	mov	r3, sl
 8018c96:	463a      	mov	r2, r7
 8018c98:	4649      	mov	r1, r9
 8018c9a:	4640      	mov	r0, r8
 8018c9c:	f7ff ff7d 	bl	8018b9a <prints>
 8018ca0:	4420      	add	r0, r4
 8018ca2:	e7cf      	b.n	8018c44 <printi+0x20>
	register int t, neg = 0, pc = 0;
 8018ca4:	2400      	movs	r4, #0
 8018ca6:	e7d6      	b.n	8018c56 <printi+0x32>
		u /= b;
 8018ca8:	4601      	mov	r1, r0
		*--s = t + '0';
 8018caa:	464b      	mov	r3, r9
 8018cac:	e7da      	b.n	8018c64 <printi+0x40>
			*--s = '-';
 8018cae:	222d      	movs	r2, #45	@ 0x2d
 8018cb0:	f809 2c01 	strb.w	r2, [r9, #-1]
	register int t, neg = 0, pc = 0;
 8018cb4:	2400      	movs	r4, #0
			*--s = '-';
 8018cb6:	f1a3 0902 	sub.w	r9, r3, #2
 8018cba:	e7eb      	b.n	8018c94 <printi+0x70>

08018cbc <print>:

static int print( char **out, const char *format, va_list args )
{
 8018cbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018cc0:	4607      	mov	r7, r0
 8018cc2:	b086      	sub	sp, #24
 8018cc4:	460e      	mov	r6, r1
 8018cc6:	4614      	mov	r4, r2
	register int width, pad;
	register int pc = 0;
 8018cc8:	2500      	movs	r5, #0
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
				width *= 10;
 8018cca:	f04f 080a 	mov.w	r8, #10
	for (; *format != 0; ++format) {
 8018cce:	7833      	ldrb	r3, [r6, #0]
 8018cd0:	b93b      	cbnz	r3, 8018ce2 <print+0x26>
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
 8018cd2:	b117      	cbz	r7, 8018cda <print+0x1e>
 8018cd4:	683b      	ldr	r3, [r7, #0]
 8018cd6:	2200      	movs	r2, #0
 8018cd8:	701a      	strb	r2, [r3, #0]
	va_end( args );
	return pc;
}
 8018cda:	4628      	mov	r0, r5
 8018cdc:	b006      	add	sp, #24
 8018cde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (*format == '%') {
 8018ce2:	2b25      	cmp	r3, #37	@ 0x25
 8018ce4:	d165      	bne.n	8018db2 <print+0xf6>
			if (*format == '\0') break;
 8018ce6:	7873      	ldrb	r3, [r6, #1]
 8018ce8:	2b00      	cmp	r3, #0
 8018cea:	d0f2      	beq.n	8018cd2 <print+0x16>
			if (*format == '%') goto out;
 8018cec:	2b25      	cmp	r3, #37	@ 0x25
			++format;
 8018cee:	f106 0201 	add.w	r2, r6, #1
			if (*format == '%') goto out;
 8018cf2:	d05d      	beq.n	8018db0 <print+0xf4>
			if (*format == '-') {
 8018cf4:	2b2d      	cmp	r3, #45	@ 0x2d
				++format;
 8018cf6:	bf06      	itte	eq
 8018cf8:	1cb2      	addeq	r2, r6, #2
				pad = PAD_RIGHT;
 8018cfa:	2301      	moveq	r3, #1
			width = pad = 0;
 8018cfc:	2300      	movne	r3, #0
				++format;
 8018cfe:	4616      	mov	r6, r2
			while (*format == '0') {
 8018d00:	f812 1b01 	ldrb.w	r1, [r2], #1
 8018d04:	2930      	cmp	r1, #48	@ 0x30
 8018d06:	d016      	beq.n	8018d36 <print+0x7a>
			width = pad = 0;
 8018d08:	2200      	movs	r2, #0
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8018d0a:	4630      	mov	r0, r6
 8018d0c:	f810 1b01 	ldrb.w	r1, [r0], #1
 8018d10:	f1a1 0c30 	sub.w	ip, r1, #48	@ 0x30
 8018d14:	fa5f fe8c 	uxtb.w	lr, ip
 8018d18:	f1be 0f09 	cmp.w	lr, #9
 8018d1c:	d90e      	bls.n	8018d3c <print+0x80>
			if( *format == 's' ) {
 8018d1e:	2973      	cmp	r1, #115	@ 0x73
 8018d20:	d110      	bne.n	8018d44 <print+0x88>
				register char *s = (char *)va_arg( args, int );
 8018d22:	6821      	ldr	r1, [r4, #0]
				pc += prints (out, s?s:"(null)", width, pad);
 8018d24:	4826      	ldr	r0, [pc, #152]	@ (8018dc0 <print+0x104>)
				register char *s = (char *)va_arg( args, int );
 8018d26:	3404      	adds	r4, #4
				pc += prints (out, s?s:"(null)", width, pad);
 8018d28:	2900      	cmp	r1, #0
 8018d2a:	bf08      	it	eq
 8018d2c:	4601      	moveq	r1, r0
				pc += prints (out, scr, width, pad);
 8018d2e:	4638      	mov	r0, r7
 8018d30:	f7ff ff33 	bl	8018b9a <prints>
 8018d34:	e01f      	b.n	8018d76 <print+0xba>
				pad |= PAD_ZERO;
 8018d36:	f043 0302 	orr.w	r3, r3, #2
 8018d3a:	e7e0      	b.n	8018cfe <print+0x42>
				width += *format - '0';
 8018d3c:	fb08 c202 	mla	r2, r8, r2, ip
			for ( ; *format >= '0' && *format <= '9'; ++format) {
 8018d40:	4606      	mov	r6, r0
 8018d42:	e7e2      	b.n	8018d0a <print+0x4e>
			if( *format == 'd' ) {
 8018d44:	2964      	cmp	r1, #100	@ 0x64
 8018d46:	d018      	beq.n	8018d7a <print+0xbe>
 8018d48:	d805      	bhi.n	8018d56 <print+0x9a>
 8018d4a:	2958      	cmp	r1, #88	@ 0x58
 8018d4c:	d01d      	beq.n	8018d8a <print+0xce>
 8018d4e:	2963      	cmp	r1, #99	@ 0x63
 8018d50:	d025      	beq.n	8018d9e <print+0xe2>
	for (; *format != 0; ++format) {
 8018d52:	3601      	adds	r6, #1
 8018d54:	e7bb      	b.n	8018cce <print+0x12>
 8018d56:	2975      	cmp	r1, #117	@ 0x75
 8018d58:	d01a      	beq.n	8018d90 <print+0xd4>
 8018d5a:	2978      	cmp	r1, #120	@ 0x78
 8018d5c:	d1f9      	bne.n	8018d52 <print+0x96>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 8018d5e:	4621      	mov	r1, r4
 8018d60:	2061      	movs	r0, #97	@ 0x61
 8018d62:	e9cd 3001 	strd	r3, r0, [sp, #4]
 8018d66:	9200      	str	r2, [sp, #0]
 8018d68:	2300      	movs	r3, #0
 8018d6a:	2210      	movs	r2, #16
 8018d6c:	6809      	ldr	r1, [r1, #0]
 8018d6e:	4638      	mov	r0, r7
 8018d70:	3404      	adds	r4, #4
 8018d72:	f7ff ff57 	bl	8018c24 <printi>
 8018d76:	4405      	add	r5, r0
				continue;
 8018d78:	e7eb      	b.n	8018d52 <print+0x96>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 8018d7a:	2061      	movs	r0, #97	@ 0x61
 8018d7c:	e9cd 3001 	strd	r3, r0, [sp, #4]
 8018d80:	4621      	mov	r1, r4
 8018d82:	9200      	str	r2, [sp, #0]
 8018d84:	2301      	movs	r3, #1
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 8018d86:	220a      	movs	r2, #10
 8018d88:	e7f0      	b.n	8018d6c <print+0xb0>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 8018d8a:	4621      	mov	r1, r4
 8018d8c:	2041      	movs	r0, #65	@ 0x41
 8018d8e:	e7e8      	b.n	8018d62 <print+0xa6>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 8018d90:	2061      	movs	r0, #97	@ 0x61
 8018d92:	e9cd 3001 	strd	r3, r0, [sp, #4]
 8018d96:	4621      	mov	r1, r4
 8018d98:	9200      	str	r2, [sp, #0]
 8018d9a:	2300      	movs	r3, #0
 8018d9c:	e7f3      	b.n	8018d86 <print+0xca>
				scr[0] = (char)va_arg( args, int );
 8018d9e:	6821      	ldr	r1, [r4, #0]
 8018da0:	f88d 1014 	strb.w	r1, [sp, #20]
				scr[1] = '\0';
 8018da4:	2100      	movs	r1, #0
 8018da6:	f88d 1015 	strb.w	r1, [sp, #21]
				scr[0] = (char)va_arg( args, int );
 8018daa:	3404      	adds	r4, #4
				pc += prints (out, scr, width, pad);
 8018dac:	a905      	add	r1, sp, #20
 8018dae:	e7be      	b.n	8018d2e <print+0x72>
			++format;
 8018db0:	4616      	mov	r6, r2
			printchar (out, *format);
 8018db2:	7831      	ldrb	r1, [r6, #0]
 8018db4:	4638      	mov	r0, r7
 8018db6:	f7ff fee5 	bl	8018b84 <printchar>
			++pc;
 8018dba:	3501      	adds	r5, #1
 8018dbc:	e7c9      	b.n	8018d52 <print+0x96>
 8018dbe:	bf00      	nop
 8018dc0:	080270e8 	.word	0x080270e8

08018dc4 <sprintf>:
{
  return print( 0, format, args );
}

int sprintf(char *out, const char *format, ...)
{
 8018dc4:	b40e      	push	{r1, r2, r3}
 8018dc6:	b50f      	push	{r0, r1, r2, r3, lr}
 8018dc8:	aa05      	add	r2, sp, #20
 8018dca:	9001      	str	r0, [sp, #4]
 8018dcc:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;
        
        va_start( args, format );
 8018dd0:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 8018dd2:	a801      	add	r0, sp, #4
 8018dd4:	f7ff ff72 	bl	8018cbc <print>
}
 8018dd8:	b004      	add	sp, #16
 8018dda:	f85d eb04 	ldr.w	lr, [sp], #4
 8018dde:	b003      	add	sp, #12
 8018de0:	4770      	bx	lr

08018de2 <vsprintf>:

// TK: added for alternative parameter passing
int vsprintf(char *out, const char *format, va_list args)
{
 8018de2:	b507      	push	{r0, r1, r2, lr}
  char *_out;
  _out = out;
 8018de4:	9001      	str	r0, [sp, #4]
  return print( &_out, format, args );
 8018de6:	a801      	add	r0, sp, #4
 8018de8:	f7ff ff68 	bl	8018cbc <print>
}
 8018dec:	b003      	add	sp, #12
 8018dee:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08018df4 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8018df4:	4b03      	ldr	r3, [pc, #12]	@ (8018e04 <NVIC_PriorityGroupConfig+0x10>)
 8018df6:	f040 60bf 	orr.w	r0, r0, #100139008	@ 0x5f80000
 8018dfa:	f440 3000 	orr.w	r0, r0, #131072	@ 0x20000
 8018dfe:	60d8      	str	r0, [r3, #12]
}
 8018e00:	4770      	bx	lr
 8018e02:	bf00      	nop
 8018e04:	e000ed00 	.word	0xe000ed00

08018e08 <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8018e08:	f021 4160 	bic.w	r1, r1, #3758096384	@ 0xe0000000
 8018e0c:	4b02      	ldr	r3, [pc, #8]	@ (8018e18 <NVIC_SetVectorTable+0x10>)
 8018e0e:	f021 017f 	bic.w	r1, r1, #127	@ 0x7f
 8018e12:	4301      	orrs	r1, r0
 8018e14:	6099      	str	r1, [r3, #8]
}
 8018e16:	4770      	bx	lr
 8018e18:	e000ed00 	.word	0xe000ed00

08018e1c <ADC_Init>:
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 8018e1c:	6843      	ldr	r3, [r0, #4]
  tmpreg1 &= CR1_CLEAR_MASK;
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8018e1e:	790a      	ldrb	r2, [r1, #4]
  tmpreg1 &= CR1_CLEAR_MASK;
 8018e20:	f023 7340 	bic.w	r3, r3, #50331648	@ 0x3000000
 8018e24:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8018e28:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 8018e2c:	680a      	ldr	r2, [r1, #0]
 8018e2e:	4313      	orrs	r3, r2
                                   ADC_InitStruct->ADC_Resolution);
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 8018e30:	6043      	str	r3, [r0, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 8018e32:	e9d1 2303 	ldrd	r2, r3, [r1, #12]
 8018e36:	4313      	orrs	r3, r2
 8018e38:	688a      	ldr	r2, [r1, #8]
{
 8018e3a:	b510      	push	{r4, lr}
 8018e3c:	4313      	orrs	r3, r2
  tmpreg1 = ADCx->CR2;
 8018e3e:	6884      	ldr	r4, [r0, #8]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 8018e40:	4a08      	ldr	r2, [pc, #32]	@ (8018e64 <ADC_Init+0x48>)
 8018e42:	4022      	ands	r2, r4
 8018e44:	4313      	orrs	r3, r2
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
                        ADC_InitStruct->ADC_ExternalTrigConv | 
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 8018e46:	794a      	ldrb	r2, [r1, #5]
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 8018e48:	ea43 0342 	orr.w	r3, r3, r2, lsl #1
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 8018e4c:	6083      	str	r3, [r0, #8]
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8018e4e:	7d0a      	ldrb	r2, [r1, #20]
  tmpreg1 = ADCx->SQR1;
 8018e50:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 8018e52:	3a01      	subs	r2, #1
  tmpreg1 &= SQR1_L_RESET;
 8018e54:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 8018e58:	b2d2      	uxtb	r2, r2
 8018e5a:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 8018e5e:	62c3      	str	r3, [r0, #44]	@ 0x2c
}
 8018e60:	bd10      	pop	{r4, pc}
 8018e62:	bf00      	nop
 8018e64:	c0fff7fd 	.word	0xc0fff7fd

08018e68 <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8018e68:	2300      	movs	r3, #0

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 8018e6a:	e9c0 3302 	strd	r3, r3, [r0, #8]
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8018e6e:	6003      	str	r3, [r0, #0]
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8018e70:	8083      	strh	r3, [r0, #4]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8018e72:	6103      	str	r3, [r0, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8018e74:	2301      	movs	r3, #1
 8018e76:	7503      	strb	r3, [r0, #20]
}
 8018e78:	4770      	bx	lr
	...

08018e7c <ADC_CommonInit>:
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8018e7c:	e9d0 3200 	ldrd	r3, r2, [r0]
  tmpreg1 = ADC->CCR;
 8018e80:	4906      	ldr	r1, [pc, #24]	@ (8018e9c <ADC_CommonInit+0x20>)
{
 8018e82:	b510      	push	{r4, lr}
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8018e84:	4313      	orrs	r3, r2
  tmpreg1 = ADC->CCR;
 8018e86:	684c      	ldr	r4, [r1, #4]
  tmpreg1 &= CR_CLEAR_MASK;
 8018e88:	4a05      	ldr	r2, [pc, #20]	@ (8018ea0 <ADC_CommonInit+0x24>)
 8018e8a:	4022      	ands	r2, r4
 8018e8c:	4313      	orrs	r3, r2
 8018e8e:	6882      	ldr	r2, [r0, #8]
 8018e90:	4313      	orrs	r3, r2
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8018e92:	68c2      	ldr	r2, [r0, #12]
 8018e94:	4313      	orrs	r3, r2
                        ADC_CommonInitStruct->ADC_Prescaler | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8018e96:	604b      	str	r3, [r1, #4]
}
 8018e98:	bd10      	pop	{r4, pc}
 8018e9a:	bf00      	nop
 8018e9c:	40012300 	.word	0x40012300
 8018ea0:	fffc30e0 	.word	0xfffc30e0

08018ea4 <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8018ea4:	2300      	movs	r3, #0

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 8018ea6:	e9c0 3300 	strd	r3, r3, [r0]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 8018eaa:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
 8018eae:	4770      	bx	lr

08018eb0 <ADC_Cmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Set the ADON bit to wake up the ADC from power down mode */
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8018eb0:	6883      	ldr	r3, [r0, #8]
  if (NewState != DISABLE)
 8018eb2:	b119      	cbz	r1, 8018ebc <ADC_Cmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 8018eb4:	f043 0301 	orr.w	r3, r3, #1
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8018eb8:	6083      	str	r3, [r0, #8]
  }
}
 8018eba:	4770      	bx	lr
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8018ebc:	f023 0301 	bic.w	r3, r3, #1
 8018ec0:	e7fa      	b.n	8018eb8 <ADC_Cmd+0x8>

08018ec2 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8018ec2:	2909      	cmp	r1, #9
{
 8018ec4:	b570      	push	{r4, r5, r6, lr}
  if (ADC_Channel > ADC_Channel_9)
 8018ec6:	d91b      	bls.n	8018f00 <ADC_RegularChannelConfig+0x3e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8018ec8:	f1a1 040a 	sub.w	r4, r1, #10
    tmpreg1 = ADCx->SMPR1;
 8018ecc:	68c5      	ldr	r5, [r0, #12]
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 8018ece:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 8018ed2:	2607      	movs	r6, #7
 8018ed4:	40a6      	lsls	r6, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8018ed6:	ea25 0506 	bic.w	r5, r5, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8018eda:	fa03 f404 	lsl.w	r4, r3, r4
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8018ede:	432c      	orrs	r4, r5
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 8018ee0:	60c4      	str	r4, [r0, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 8018ee2:	2a06      	cmp	r2, #6
 8018ee4:	d817      	bhi.n	8018f16 <ADC_RegularChannelConfig+0x54>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8018ee6:	3a01      	subs	r2, #1
    tmpreg1 = ADCx->SQR3;
 8018ee8:	6b43      	ldr	r3, [r0, #52]	@ 0x34
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8018eea:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8018eee:	241f      	movs	r4, #31
 8018ef0:	4094      	lsls	r4, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8018ef2:	ea23 0304 	bic.w	r3, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8018ef6:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8018efa:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8018efc:	6342      	str	r2, [r0, #52]	@ 0x34
    tmpreg1 |= tmpreg2;
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
  }
}
 8018efe:	bd70      	pop	{r4, r5, r6, pc}
    tmpreg1 = ADCx->SMPR2;
 8018f00:	6904      	ldr	r4, [r0, #16]
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8018f02:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 8018f06:	2507      	movs	r5, #7
 8018f08:	40b5      	lsls	r5, r6
    tmpreg1 &= ~tmpreg2;
 8018f0a:	ea24 0405 	bic.w	r4, r4, r5
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8018f0e:	40b3      	lsls	r3, r6
    tmpreg1 |= tmpreg2;
 8018f10:	4323      	orrs	r3, r4
    ADCx->SMPR2 = tmpreg1;
 8018f12:	6103      	str	r3, [r0, #16]
 8018f14:	e7e5      	b.n	8018ee2 <ADC_RegularChannelConfig+0x20>
  else if (Rank < 13)
 8018f16:	2a0c      	cmp	r2, #12
 8018f18:	d80c      	bhi.n	8018f34 <ADC_RegularChannelConfig+0x72>
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8018f1a:	3a07      	subs	r2, #7
    tmpreg1 = ADCx->SQR2;
 8018f1c:	6b03      	ldr	r3, [r0, #48]	@ 0x30
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8018f1e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8018f22:	241f      	movs	r4, #31
 8018f24:	4094      	lsls	r4, r2
    tmpreg1 &= ~tmpreg2;
 8018f26:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 8018f2a:	fa01 f202 	lsl.w	r2, r1, r2
    tmpreg1 |= tmpreg2;
 8018f2e:	431a      	orrs	r2, r3
    ADCx->SQR2 = tmpreg1;
 8018f30:	6302      	str	r2, [r0, #48]	@ 0x30
 8018f32:	e7e4      	b.n	8018efe <ADC_RegularChannelConfig+0x3c>
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8018f34:	3a0d      	subs	r2, #13
    tmpreg1 = ADCx->SQR1;
 8018f36:	6ac3      	ldr	r3, [r0, #44]	@ 0x2c
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 8018f38:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8018f3c:	241f      	movs	r4, #31
 8018f3e:	4094      	lsls	r4, r2
    tmpreg1 &= ~tmpreg2;
 8018f40:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8018f44:	4091      	lsls	r1, r2
    tmpreg1 |= tmpreg2;
 8018f46:	4319      	orrs	r1, r3
    ADCx->SQR1 = tmpreg1;
 8018f48:	62c1      	str	r1, [r0, #44]	@ 0x2c
}
 8018f4a:	e7d8      	b.n	8018efe <ADC_RegularChannelConfig+0x3c>

08018f4c <ADC_SoftwareStartConv>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8018f4c:	6883      	ldr	r3, [r0, #8]
 8018f4e:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8018f52:	6083      	str	r3, [r0, #8]
}
 8018f54:	4770      	bx	lr

08018f56 <ADC_DMACmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8018f56:	6883      	ldr	r3, [r0, #8]
  if (NewState != DISABLE)
 8018f58:	b119      	cbz	r1, 8018f62 <ADC_DMACmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 8018f5a:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8018f5e:	6083      	str	r3, [r0, #8]
  }
}
 8018f60:	4770      	bx	lr
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 8018f62:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8018f66:	e7fa      	b.n	8018f5e <ADC_DMACmd+0x8>

08018f68 <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8018f68:	4b04      	ldr	r3, [pc, #16]	@ (8018f7c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x14>)
  {
    /* Enable the selected ADC DMA request after last transfer */
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 8018f6a:	685a      	ldr	r2, [r3, #4]
  if (NewState != DISABLE)
 8018f6c:	b118      	cbz	r0, 8018f76 <ADC_MultiModeDMARequestAfterLastTransferCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 8018f6e:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8018f72:	605a      	str	r2, [r3, #4]
  }
}
 8018f74:	4770      	bx	lr
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8018f76:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8018f7a:	e7fa      	b.n	8018f72 <ADC_MultiModeDMARequestAfterLastTransferCmd+0xa>
 8018f7c:	40012300 	.word	0x40012300

08018f80 <DMA_Init>:
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 8018f80:	6803      	ldr	r3, [r0, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8018f82:	4a13      	ldr	r2, [pc, #76]	@ (8018fd0 <DMA_Init+0x50>)
{
 8018f84:	b510      	push	{r4, lr}
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8018f86:	401a      	ands	r2, r3
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8018f88:	68cc      	ldr	r4, [r1, #12]
 8018f8a:	680b      	ldr	r3, [r1, #0]
 8018f8c:	4323      	orrs	r3, r4
 8018f8e:	694c      	ldr	r4, [r1, #20]
 8018f90:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8018f92:	698c      	ldr	r4, [r1, #24]
 8018f94:	4323      	orrs	r3, r4
 8018f96:	69cc      	ldr	r4, [r1, #28]
 8018f98:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8018f9a:	6a0c      	ldr	r4, [r1, #32]
 8018f9c:	4323      	orrs	r3, r4
 8018f9e:	6a4c      	ldr	r4, [r1, #36]	@ 0x24
 8018fa0:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8018fa2:	6a8c      	ldr	r4, [r1, #40]	@ 0x28
 8018fa4:	4323      	orrs	r3, r4
 8018fa6:	6b4c      	ldr	r4, [r1, #52]	@ 0x34
 8018fa8:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8018faa:	6b8c      	ldr	r4, [r1, #56]	@ 0x38
 8018fac:	4323      	orrs	r3, r4
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8018fae:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 8018fb0:	6003      	str	r3, [r0, #0]
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8018fb2:	e9d1 340b 	ldrd	r3, r4, [r1, #44]	@ 0x2c
  tmpreg = DMAy_Streamx->FCR;
 8018fb6:	6942      	ldr	r2, [r0, #20]
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8018fb8:	4323      	orrs	r3, r4
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8018fba:	f022 0207 	bic.w	r2, r2, #7
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8018fbe:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 8018fc0:	6143      	str	r3, [r0, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8018fc2:	690b      	ldr	r3, [r1, #16]
 8018fc4:	6043      	str	r3, [r0, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8018fc6:	684b      	ldr	r3, [r1, #4]
 8018fc8:	6083      	str	r3, [r0, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 8018fca:	688b      	ldr	r3, [r1, #8]
 8018fcc:	60c3      	str	r3, [r0, #12]
}
 8018fce:	bd10      	pop	{r4, pc}
 8018fd0:	f01c803f 	.word	0xf01c803f

08018fd4 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8018fd4:	2300      	movs	r3, #0

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8018fd6:	e9c0 3300 	strd	r3, r3, [r0]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8018fda:	e9c0 3302 	strd	r3, r3, [r0, #8]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8018fde:	e9c0 3304 	strd	r3, r3, [r0, #16]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8018fe2:	e9c0 3306 	strd	r3, r3, [r0, #24]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8018fe6:	e9c0 3308 	strd	r3, r3, [r0, #32]

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8018fea:	e9c0 330a 	strd	r3, r3, [r0, #40]	@ 0x28

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8018fee:	e9c0 330c 	strd	r3, r3, [r0, #48]	@ 0x30

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8018ff2:	6383      	str	r3, [r0, #56]	@ 0x38
}
 8018ff4:	4770      	bx	lr

08018ff6 <DMA_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected DMAy Streamx by setting EN bit */
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8018ff6:	6803      	ldr	r3, [r0, #0]
  if (NewState != DISABLE)
 8018ff8:	b119      	cbz	r1, 8019002 <DMA_Cmd+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8018ffa:	f043 0301 	orr.w	r3, r3, #1
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8018ffe:	6003      	str	r3, [r0, #0]
  }
}
 8019000:	4770      	bx	lr
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8019002:	f023 0301 	bic.w	r3, r3, #1
 8019006:	e7fa      	b.n	8018ffe <DMA_Cmd+0x8>

08019008 <DMA_ClearFlag>:
  *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
  *         Where x can be 0 to 7 to select the DMA Stream.   
  * @retval None
  */
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
{
 8019008:	b510      	push	{r4, lr}

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 801900a:	4a07      	ldr	r2, [pc, #28]	@ (8019028 <DMA_ClearFlag+0x20>)
 801900c:	4c07      	ldr	r4, [pc, #28]	@ (801902c <DMA_ClearFlag+0x24>)
 801900e:	4b08      	ldr	r3, [pc, #32]	@ (8019030 <DMA_ClearFlag+0x28>)
 8019010:	42a0      	cmp	r0, r4
 8019012:	bf98      	it	ls
 8019014:	4613      	movls	r3, r2

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
  {
    /* Set DMAy HIFCR register clear flag bits */
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8019016:	f021 22f0 	bic.w	r2, r1, #4026593280	@ 0xf000f000
 801901a:	f022 1282 	bic.w	r2, r2, #8519810	@ 0x820082
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 801901e:	0089      	lsls	r1, r1, #2
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8019020:	bf4c      	ite	mi
 8019022:	60da      	strmi	r2, [r3, #12]
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8019024:	609a      	strpl	r2, [r3, #8]
  }    
}
 8019026:	bd10      	pop	{r4, pc}
 8019028:	40026000 	.word	0x40026000
 801902c:	4002640f 	.word	0x4002640f
 8019030:	40026400 	.word	0x40026400

08019034 <DMA_ITConfig>:
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 8019034:	060b      	lsls	r3, r1, #24
 8019036:	d512      	bpl.n	801905e <DMA_ITConfig+0x2a>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8019038:	6943      	ldr	r3, [r0, #20]
    if (NewState != DISABLE)
 801903a:	b152      	cbz	r2, 8019052 <DMA_ITConfig+0x1e>
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 801903c:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8019040:	2980      	cmp	r1, #128	@ 0x80
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8019042:	6143      	str	r3, [r0, #20]
  if (DMA_IT != DMA_IT_FE)
 8019044:	d015      	beq.n	8019072 <DMA_ITConfig+0x3e>
  {
    if (NewState != DISABLE)
    {
      /* Enable the selected DMA transfer interrupts */
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 8019046:	6803      	ldr	r3, [r0, #0]
 8019048:	f001 011e 	and.w	r1, r1, #30
 801904c:	4319      	orrs	r1, r3
 801904e:	6001      	str	r1, [r0, #0]
 8019050:	4770      	bx	lr
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8019052:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  if (DMA_IT != DMA_IT_FE)
 8019056:	2980      	cmp	r1, #128	@ 0x80
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8019058:	6143      	str	r3, [r0, #20]
  if (DMA_IT != DMA_IT_FE)
 801905a:	d104      	bne.n	8019066 <DMA_ITConfig+0x32>
 801905c:	4770      	bx	lr
 801905e:	2980      	cmp	r1, #128	@ 0x80
 8019060:	d007      	beq.n	8019072 <DMA_ITConfig+0x3e>
    if (NewState != DISABLE)
 8019062:	2a00      	cmp	r2, #0
 8019064:	d1ef      	bne.n	8019046 <DMA_ITConfig+0x12>
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8019066:	6803      	ldr	r3, [r0, #0]
 8019068:	f001 011e 	and.w	r1, r1, #30
 801906c:	ea23 0301 	bic.w	r3, r3, r1
 8019070:	6003      	str	r3, [r0, #0]
    }    
  }
}
 8019072:	4770      	bx	lr

08019074 <EXTI_ClearITPendingBit>:
  * @brief  Clears the EXTI's line pending bits.
  * @param  EXTI_Line: specifies the EXTI lines to clear.
  *          This parameter can be any combination of EXTI_Linex where x can be (0..22)
  * @retval None
  */
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
 8019074:	4b01      	ldr	r3, [pc, #4]	@ (801907c <EXTI_ClearITPendingBit+0x8>)
 8019076:	6158      	str	r0, [r3, #20]
 8019078:	4770      	bx	lr
 801907a:	bf00      	nop
 801907c:	40013c00 	.word	0x40013c00

08019080 <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8019080:	4b04      	ldr	r3, [pc, #16]	@ (8019094 <FLASH_Unlock+0x14>)
 8019082:	691a      	ldr	r2, [r3, #16]
 8019084:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8019086:	bfbf      	itttt	lt
 8019088:	4a03      	ldrlt	r2, [pc, #12]	@ (8019098 <FLASH_Unlock+0x18>)
 801908a:	605a      	strlt	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 801908c:	f102 3288 	addlt.w	r2, r2, #2290649224	@ 0x88888888
 8019090:	605a      	strlt	r2, [r3, #4]
  }  
}
 8019092:	4770      	bx	lr
 8019094:	40023c00 	.word	0x40023c00
 8019098:	45670123 	.word	0x45670123

0801909c <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 801909c:	4a02      	ldr	r2, [pc, #8]	@ (80190a8 <FLASH_Lock+0xc>)
 801909e:	6913      	ldr	r3, [r2, #16]
 80190a0:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
 80190a4:	6113      	str	r3, [r2, #16]
}
 80190a6:	4770      	bx	lr
 80190a8:	40023c00 	.word	0x40023c00

080190ac <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 80190ac:	4b01      	ldr	r3, [pc, #4]	@ (80190b4 <FLASH_ClearFlag+0x8>)
 80190ae:	60d8      	str	r0, [r3, #12]
}
 80190b0:	4770      	bx	lr
 80190b2:	bf00      	nop
 80190b4:	40023c00 	.word	0x40023c00

080190b8 <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 80190b8:	4b0b      	ldr	r3, [pc, #44]	@ (80190e8 <FLASH_GetStatus+0x30>)
 80190ba:	68da      	ldr	r2, [r3, #12]
 80190bc:	03d1      	lsls	r1, r2, #15
 80190be:	d40d      	bmi.n	80190dc <FLASH_GetStatus+0x24>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 80190c0:	68da      	ldr	r2, [r3, #12]
 80190c2:	06d2      	lsls	r2, r2, #27
 80190c4:	d40c      	bmi.n	80190e0 <FLASH_GetStatus+0x28>
    { 
      flashstatus = FLASH_ERROR_WRP;
    }
    else 
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 80190c6:	68da      	ldr	r2, [r3, #12]
 80190c8:	f012 0fef 	tst.w	r2, #239	@ 0xef
 80190cc:	d10a      	bne.n	80190e4 <FLASH_GetStatus+0x2c>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 80190ce:	68db      	ldr	r3, [r3, #12]
        {
          flashstatus = FLASH_ERROR_OPERATION;
 80190d0:	f013 0f02 	tst.w	r3, #2
 80190d4:	bf0c      	ite	eq
 80190d6:	2008      	moveq	r0, #8
 80190d8:	2007      	movne	r0, #7
 80190da:	4770      	bx	lr
    flashstatus = FLASH_BUSY;
 80190dc:	2001      	movs	r0, #1
 80190de:	4770      	bx	lr
      flashstatus = FLASH_ERROR_WRP;
 80190e0:	2005      	movs	r0, #5
 80190e2:	4770      	bx	lr
        flashstatus = FLASH_ERROR_PROGRAM; 
 80190e4:	2006      	movs	r0, #6
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
}
 80190e6:	4770      	bx	lr
 80190e8:	40023c00 	.word	0x40023c00

080190ec <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 80190ec:	b507      	push	{r0, r1, r2, lr}
  __IO FLASH_Status status = FLASH_COMPLETE;
 80190ee:	2308      	movs	r3, #8
 80190f0:	f88d 3007 	strb.w	r3, [sp, #7]
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
  {
    status = FLASH_GetStatus();
 80190f4:	f7ff ffe0 	bl	80190b8 <FLASH_GetStatus>
 80190f8:	f88d 0007 	strb.w	r0, [sp, #7]
  while(status == FLASH_BUSY)
 80190fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8019100:	2b01      	cmp	r3, #1
 8019102:	d0f7      	beq.n	80190f4 <FLASH_WaitForLastOperation+0x8>
  }
  /* Return the operation status */
  return status;
 8019104:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8019108:	b003      	add	sp, #12
 801910a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08019110 <FLASH_EraseSector>:
{
 8019110:	b570      	push	{r4, r5, r6, lr}
 8019112:	2902      	cmp	r1, #2
 8019114:	bf94      	ite	ls
 8019116:	020d      	lslls	r5, r1, #8
 8019118:	f44f 7540 	movhi.w	r5, #768	@ 0x300
 801911c:	4606      	mov	r6, r0
  status = FLASH_WaitForLastOperation();
 801911e:	f7ff ffe5 	bl	80190ec <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 8019122:	2808      	cmp	r0, #8
 8019124:	d11e      	bne.n	8019164 <FLASH_EraseSector+0x54>
    FLASH->CR &= CR_PSIZE_MASK;
 8019126:	4c10      	ldr	r4, [pc, #64]	@ (8019168 <FLASH_EraseSector+0x58>)
 8019128:	6923      	ldr	r3, [r4, #16]
 801912a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 801912e:	6123      	str	r3, [r4, #16]
    FLASH->CR |= tmp_psize;
 8019130:	6923      	ldr	r3, [r4, #16]
 8019132:	432b      	orrs	r3, r5
 8019134:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK;
 8019136:	6923      	ldr	r3, [r4, #16]
 8019138:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 801913c:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 801913e:	6920      	ldr	r0, [r4, #16]
 8019140:	4330      	orrs	r0, r6
 8019142:	f040 0002 	orr.w	r0, r0, #2
 8019146:	6120      	str	r0, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8019148:	6923      	ldr	r3, [r4, #16]
 801914a:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 801914e:	6123      	str	r3, [r4, #16]
    status = FLASH_WaitForLastOperation();
 8019150:	f7ff ffcc 	bl	80190ec <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_SER);
 8019154:	6923      	ldr	r3, [r4, #16]
 8019156:	f023 0302 	bic.w	r3, r3, #2
 801915a:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK; 
 801915c:	6923      	ldr	r3, [r4, #16]
 801915e:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8019162:	6123      	str	r3, [r4, #16]
}
 8019164:	bd70      	pop	{r4, r5, r6, pc}
 8019166:	bf00      	nop
 8019168:	40023c00 	.word	0x40023c00

0801916c <FLASH_ProgramHalfWord>:
{
 801916c:	b570      	push	{r4, r5, r6, lr}
 801916e:	4605      	mov	r5, r0
 8019170:	460e      	mov	r6, r1
  status = FLASH_WaitForLastOperation();
 8019172:	f7ff ffbb 	bl	80190ec <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 8019176:	2808      	cmp	r0, #8
 8019178:	d113      	bne.n	80191a2 <FLASH_ProgramHalfWord+0x36>
    FLASH->CR &= CR_PSIZE_MASK;
 801917a:	4c0a      	ldr	r4, [pc, #40]	@ (80191a4 <FLASH_ProgramHalfWord+0x38>)
 801917c:	6923      	ldr	r3, [r4, #16]
 801917e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8019182:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 8019184:	6923      	ldr	r3, [r4, #16]
 8019186:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801918a:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 801918c:	6923      	ldr	r3, [r4, #16]
 801918e:	f043 0301 	orr.w	r3, r3, #1
 8019192:	6123      	str	r3, [r4, #16]
    *(__IO uint16_t*)Address = Data;
 8019194:	802e      	strh	r6, [r5, #0]
    status = FLASH_WaitForLastOperation();
 8019196:	f7ff ffa9 	bl	80190ec <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 801919a:	6923      	ldr	r3, [r4, #16]
 801919c:	f023 0301 	bic.w	r3, r3, #1
 80191a0:	6123      	str	r3, [r4, #16]
}
 80191a2:	bd70      	pop	{r4, r5, r6, pc}
 80191a4:	40023c00 	.word	0x40023c00

080191a8 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 80191a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80191aa:	2300      	movs	r3, #0
  {
    pos = ((uint32_t)0x01) << pinpos;
 80191ac:	2601      	movs	r6, #1
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80191ae:	2503      	movs	r5, #3
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80191b0:	680c      	ldr	r4, [r1, #0]
    pos = ((uint32_t)0x01) << pinpos;
 80191b2:	fa06 f203 	lsl.w	r2, r6, r3
    if (currentpin == pos)
 80191b6:	43a2      	bics	r2, r4
 80191b8:	d13a      	bne.n	8019230 <GPIO_Init+0x88>
      if( ((GPIOx->MODER >> (2*pinpos)) & 3) != GPIO_InitStruct->GPIO_Mode ) {
 80191ba:	6807      	ldr	r7, [r0, #0]
 80191bc:	790c      	ldrb	r4, [r1, #4]
 80191be:	005a      	lsls	r2, r3, #1
 80191c0:	40d7      	lsrs	r7, r2
 80191c2:	f007 0703 	and.w	r7, r7, #3
 80191c6:	42a7      	cmp	r7, r4
 80191c8:	d00c      	beq.n	80191e4 <GPIO_Init+0x3c>
	GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80191ca:	6807      	ldr	r7, [r0, #0]
 80191cc:	fa05 fc02 	lsl.w	ip, r5, r2
 80191d0:	ea27 070c 	bic.w	r7, r7, ip
 80191d4:	6007      	str	r7, [r0, #0]
	GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80191d6:	f8d0 c000 	ldr.w	ip, [r0]
 80191da:	fa04 f702 	lsl.w	r7, r4, r2
 80191de:	ea47 070c 	orr.w	r7, r7, ip
 80191e2:	6007      	str	r7, [r0, #0]
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80191e4:	3c01      	subs	r4, #1
 80191e6:	2c01      	cmp	r4, #1
 80191e8:	d816      	bhi.n	8019218 <GPIO_Init+0x70>
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80191ea:	6884      	ldr	r4, [r0, #8]
 80191ec:	fa05 f702 	lsl.w	r7, r5, r2
 80191f0:	ea24 0407 	bic.w	r4, r4, r7
 80191f4:	6084      	str	r4, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 80191f6:	794c      	ldrb	r4, [r1, #5]
 80191f8:	6887      	ldr	r7, [r0, #8]
 80191fa:	4094      	lsls	r4, r2
 80191fc:	433c      	orrs	r4, r7
 80191fe:	6084      	str	r4, [r0, #8]
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8019200:	6844      	ldr	r4, [r0, #4]
 8019202:	fa06 f703 	lsl.w	r7, r6, r3
 8019206:	ea24 0407 	bic.w	r4, r4, r7
 801920a:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 801920c:	798c      	ldrb	r4, [r1, #6]
 801920e:	6847      	ldr	r7, [r0, #4]
 8019210:	409c      	lsls	r4, r3
 8019212:	b2a4      	uxth	r4, r4
 8019214:	433c      	orrs	r4, r7
 8019216:	6044      	str	r4, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8019218:	68c4      	ldr	r4, [r0, #12]
 801921a:	fa05 f702 	lsl.w	r7, r5, r2
 801921e:	ea24 0407 	bic.w	r4, r4, r7
 8019222:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8019224:	79cc      	ldrb	r4, [r1, #7]
 8019226:	68c7      	ldr	r7, [r0, #12]
 8019228:	fa04 f202 	lsl.w	r2, r4, r2
 801922c:	433a      	orrs	r2, r7
 801922e:	60c2      	str	r2, [r0, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8019230:	3301      	adds	r3, #1
 8019232:	2b10      	cmp	r3, #16
 8019234:	d1bc      	bne.n	80191b0 <GPIO_Init+0x8>
    }
  }
}
 8019236:	bdf0      	pop	{r4, r5, r6, r7, pc}

08019238 <GPIO_StructInit>:
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8019238:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801923c:	2300      	movs	r3, #0
 801923e:	e9c0 2300 	strd	r2, r3, [r0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
}
 8019242:	4770      	bx	lr

08019244 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8019244:	8301      	strh	r1, [r0, #24]
}
 8019246:	4770      	bx	lr

08019248 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8019248:	8341      	strh	r1, [r0, #26]
}
 801924a:	4770      	bx	lr

0801924c <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 801924c:	f001 0307 	and.w	r3, r1, #7
 8019250:	08c9      	lsrs	r1, r1, #3
 8019252:	eb00 0081 	add.w	r0, r0, r1, lsl #2
{
 8019256:	b510      	push	{r4, lr}
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8019258:	6a01      	ldr	r1, [r0, #32]
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 801925a:	009b      	lsls	r3, r3, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 801925c:	240f      	movs	r4, #15
 801925e:	409c      	lsls	r4, r3
 8019260:	ea21 0104 	bic.w	r1, r1, r4
 8019264:	6201      	str	r1, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8019266:	6a01      	ldr	r1, [r0, #32]
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8019268:	409a      	lsls	r2, r3
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 801926a:	430a      	orrs	r2, r1
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 801926c:	6202      	str	r2, [r0, #32]
}
 801926e:	bd10      	pop	{r4, pc}

08019270 <I2C_GenerateSTOP>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
 8019270:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8019272:	b121      	cbz	r1, 801927e <I2C_GenerateSTOP+0xe>
    I2Cx->CR1 |= I2C_CR1_STOP;
 8019274:	b29b      	uxth	r3, r3
 8019276:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 801927a:	8003      	strh	r3, [r0, #0]
  }
}
 801927c:	4770      	bx	lr
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 801927e:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 8019282:	041b      	lsls	r3, r3, #16
 8019284:	0c1b      	lsrs	r3, r3, #16
 8019286:	e7f8      	b.n	801927a <I2C_GenerateSTOP+0xa>

08019288 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8019288:	8883      	ldrh	r3, [r0, #4]
 801928a:	b29b      	uxth	r3, r3
  if (NewState != DISABLE)
 801928c:	b112      	cbz	r2, 8019294 <I2C_ITConfig+0xc>
    I2Cx->CR2 |= I2C_IT;
 801928e:	4319      	orrs	r1, r3
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8019290:	8081      	strh	r1, [r0, #4]
  }
}
 8019292:	4770      	bx	lr
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8019294:	ea23 0101 	bic.w	r1, r3, r1
 8019298:	e7fa      	b.n	8019290 <I2C_ITConfig+0x8>

0801929a <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 801929a:	8a83      	ldrh	r3, [r0, #20]
  flag2 = I2Cx->SR2;
 801929c:	8b02      	ldrh	r2, [r0, #24]
  flag1 = I2Cx->SR1;
 801929e:	b29b      	uxth	r3, r3
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 80192a0:	ea43 4002 	orr.w	r0, r3, r2, lsl #16

  /* Return status */
  return lastevent;
}
 80192a4:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 80192a8:	4770      	bx	lr

080192aa <I2C_ClearITPendingBit>:
  * @note   SB (Start Bit) is cleared by software sequence: a read operation to 
  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *          I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
 80192aa:	43c9      	mvns	r1, r1
 80192ac:	b289      	uxth	r1, r1
 80192ae:	8281      	strh	r1, [r0, #20]
 80192b0:	4770      	bx	lr
	...

080192b4 <PWR_BackupAccessCmd>:
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 80192b4:	4b01      	ldr	r3, [pc, #4]	@ (80192bc <PWR_BackupAccessCmd+0x8>)
 80192b6:	6218      	str	r0, [r3, #32]
}
 80192b8:	4770      	bx	lr
 80192ba:	bf00      	nop
 80192bc:	420e0000 	.word	0x420e0000

080192c0 <RCC_GetClocksFreq>:
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80192c0:	4b1c      	ldr	r3, [pc, #112]	@ (8019334 <RCC_GetClocksFreq+0x74>)
 80192c2:	689a      	ldr	r2, [r3, #8]
 80192c4:	f002 020c 	and.w	r2, r2, #12

  switch (tmp)
 80192c8:	2a04      	cmp	r2, #4
{
 80192ca:	b510      	push	{r4, lr}
  switch (tmp)
 80192cc:	d02e      	beq.n	801932c <RCC_GetClocksFreq+0x6c>
 80192ce:	2a08      	cmp	r2, #8
 80192d0:	d12e      	bne.n	8019330 <RCC_GetClocksFreq+0x70>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80192d2:	6859      	ldr	r1, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80192d4:	685a      	ldr	r2, [r3, #4]
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80192d6:	685b      	ldr	r3, [r3, #4]
      if (pllsource != 0)
 80192d8:	0249      	lsls	r1, r1, #9
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 80192da:	f3c3 1388 	ubfx	r3, r3, #6, #9
 80192de:	bf4c      	ite	mi
 80192e0:	4915      	ldrmi	r1, [pc, #84]	@ (8019338 <RCC_GetClocksFreq+0x78>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80192e2:	4916      	ldrpl	r1, [pc, #88]	@ (801933c <RCC_GetClocksFreq+0x7c>)
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80192e4:	f002 023f 	and.w	r2, r2, #63	@ 0x3f
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80192e8:	fbb1 f2f2 	udiv	r2, r1, r2
 80192ec:	4353      	muls	r3, r2
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 80192ee:	4a11      	ldr	r2, [pc, #68]	@ (8019334 <RCC_GetClocksFreq+0x74>)
 80192f0:	6852      	ldr	r2, [r2, #4]
 80192f2:	f3c2 4201 	ubfx	r2, r2, #16, #2
 80192f6:	3201      	adds	r2, #1
 80192f8:	0052      	lsls	r2, r2, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 80192fa:	fbb3 f3f2 	udiv	r3, r3, r2
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80192fe:	4a0d      	ldr	r2, [pc, #52]	@ (8019334 <RCC_GetClocksFreq+0x74>)
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8019300:	6003      	str	r3, [r0, #0]
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8019302:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8019304:	490e      	ldr	r1, [pc, #56]	@ (8019340 <RCC_GetClocksFreq+0x80>)
  tmp = tmp >> 4;
 8019306:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 801930a:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 801930c:	40e3      	lsrs	r3, r4
 801930e:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8019310:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 10;
 8019312:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8019316:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8019318:	fa23 f404 	lsr.w	r4, r3, r4
 801931c:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 801931e:	6892      	ldr	r2, [r2, #8]
  tmp = tmp >> 13;
 8019320:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 8019324:	5c8a      	ldrb	r2, [r1, r2]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8019326:	40d3      	lsrs	r3, r2
 8019328:	60c3      	str	r3, [r0, #12]
}
 801932a:	bd10      	pop	{r4, pc}
  switch (tmp)
 801932c:	4b02      	ldr	r3, [pc, #8]	@ (8019338 <RCC_GetClocksFreq+0x78>)
 801932e:	e7e6      	b.n	80192fe <RCC_GetClocksFreq+0x3e>
 8019330:	4b02      	ldr	r3, [pc, #8]	@ (801933c <RCC_GetClocksFreq+0x7c>)
 8019332:	e7e4      	b.n	80192fe <RCC_GetClocksFreq+0x3e>
 8019334:	40023800 	.word	0x40023800
 8019338:	007a1200 	.word	0x007a1200
 801933c:	00f42400 	.word	0x00f42400
 8019340:	2000000c 	.word	0x2000000c

08019344 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8019344:	f400 7340 	and.w	r3, r0, #768	@ 0x300
 8019348:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 801934c:	4a08      	ldr	r2, [pc, #32]	@ (8019370 <RCC_RTCCLKConfig+0x2c>)
 801934e:	d108      	bne.n	8019362 <RCC_RTCCLKConfig+0x1e>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8019350:	6891      	ldr	r1, [r2, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8019352:	f020 4370 	bic.w	r3, r0, #4026531840	@ 0xf0000000
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8019356:	f421 11f8 	bic.w	r1, r1, #2031616	@ 0x1f0000
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 801935a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 801935e:	430b      	orrs	r3, r1

    /* Store the new value */
    RCC->CFGR = tmpreg;
 8019360:	6093      	str	r3, [r2, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8019362:	6f13      	ldr	r3, [r2, #112]	@ 0x70
 8019364:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8019368:	4318      	orrs	r0, r3
 801936a:	6710      	str	r0, [r2, #112]	@ 0x70
}
 801936c:	4770      	bx	lr
 801936e:	bf00      	nop
 8019370:	40023800 	.word	0x40023800

08019374 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8019374:	4b01      	ldr	r3, [pc, #4]	@ (801937c <RCC_RTCCLKCmd+0x8>)
 8019376:	f8c3 0e3c 	str.w	r0, [r3, #3644]	@ 0xe3c
}
 801937a:	4770      	bx	lr
 801937c:	42470000 	.word	0x42470000

08019380 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8019380:	4b04      	ldr	r3, [pc, #16]	@ (8019394 <RCC_AHB1PeriphClockCmd+0x14>)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8019382:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
  if (NewState != DISABLE)
 8019384:	b111      	cbz	r1, 801938c <RCC_AHB1PeriphClockCmd+0xc>
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8019386:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8019388:	631a      	str	r2, [r3, #48]	@ 0x30
  }
}
 801938a:	4770      	bx	lr
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 801938c:	ea22 0200 	bic.w	r2, r2, r0
 8019390:	e7fa      	b.n	8019388 <RCC_AHB1PeriphClockCmd+0x8>
 8019392:	bf00      	nop
 8019394:	40023800 	.word	0x40023800

08019398 <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8019398:	4b04      	ldr	r3, [pc, #16]	@ (80193ac <RCC_AHB2PeriphClockCmd+0x14>)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 801939a:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
  if (NewState != DISABLE)
 801939c:	b111      	cbz	r1, 80193a4 <RCC_AHB2PeriphClockCmd+0xc>
    RCC->AHB2ENR |= RCC_AHB2Periph;
 801939e:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80193a0:	635a      	str	r2, [r3, #52]	@ 0x34
  }
}
 80193a2:	4770      	bx	lr
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80193a4:	ea22 0200 	bic.w	r2, r2, r0
 80193a8:	e7fa      	b.n	80193a0 <RCC_AHB2PeriphClockCmd+0x8>
 80193aa:	bf00      	nop
 80193ac:	40023800 	.word	0x40023800

080193b0 <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80193b0:	4b04      	ldr	r3, [pc, #16]	@ (80193c4 <RCC_APB1PeriphClockCmd+0x14>)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80193b2:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
  if (NewState != DISABLE)
 80193b4:	b111      	cbz	r1, 80193bc <RCC_APB1PeriphClockCmd+0xc>
    RCC->APB1ENR |= RCC_APB1Periph;
 80193b6:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80193b8:	641a      	str	r2, [r3, #64]	@ 0x40
  }
}
 80193ba:	4770      	bx	lr
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80193bc:	ea22 0200 	bic.w	r2, r2, r0
 80193c0:	e7fa      	b.n	80193b8 <RCC_APB1PeriphClockCmd+0x8>
 80193c2:	bf00      	nop
 80193c4:	40023800 	.word	0x40023800

080193c8 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80193c8:	4b04      	ldr	r3, [pc, #16]	@ (80193dc <RCC_APB2PeriphClockCmd+0x14>)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80193ca:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
  if (NewState != DISABLE)
 80193cc:	b111      	cbz	r1, 80193d4 <RCC_APB2PeriphClockCmd+0xc>
    RCC->APB2ENR |= RCC_APB2Periph;
 80193ce:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80193d0:	645a      	str	r2, [r3, #68]	@ 0x44
  }
}
 80193d2:	4770      	bx	lr
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80193d4:	ea22 0200 	bic.w	r2, r2, r0
 80193d8:	e7fa      	b.n	80193d0 <RCC_APB2PeriphClockCmd+0x8>
 80193da:	bf00      	nop
 80193dc:	40023800 	.word	0x40023800

080193e0 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80193e0:	4b04      	ldr	r3, [pc, #16]	@ (80193f4 <RCC_AHB1PeriphResetCmd+0x14>)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 80193e2:	691a      	ldr	r2, [r3, #16]
  if (NewState != DISABLE)
 80193e4:	b111      	cbz	r1, 80193ec <RCC_AHB1PeriphResetCmd+0xc>
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 80193e6:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 80193e8:	611a      	str	r2, [r3, #16]
  }
}
 80193ea:	4770      	bx	lr
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 80193ec:	ea22 0200 	bic.w	r2, r2, r0
 80193f0:	e7fa      	b.n	80193e8 <RCC_AHB1PeriphResetCmd+0x8>
 80193f2:	bf00      	nop
 80193f4:	40023800 	.word	0x40023800

080193f8 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80193f8:	4b04      	ldr	r3, [pc, #16]	@ (801940c <RCC_AHB2PeriphResetCmd+0x14>)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 80193fa:	695a      	ldr	r2, [r3, #20]
  if (NewState != DISABLE)
 80193fc:	b111      	cbz	r1, 8019404 <RCC_AHB2PeriphResetCmd+0xc>
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 80193fe:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8019400:	615a      	str	r2, [r3, #20]
  }
}
 8019402:	4770      	bx	lr
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8019404:	ea22 0200 	bic.w	r2, r2, r0
 8019408:	e7fa      	b.n	8019400 <RCC_AHB2PeriphResetCmd+0x8>
 801940a:	bf00      	nop
 801940c:	40023800 	.word	0x40023800

08019410 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8019410:	4b04      	ldr	r3, [pc, #16]	@ (8019424 <RCC_APB1PeriphResetCmd+0x14>)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8019412:	6a1a      	ldr	r2, [r3, #32]
  if (NewState != DISABLE)
 8019414:	b111      	cbz	r1, 801941c <RCC_APB1PeriphResetCmd+0xc>
    RCC->APB1RSTR |= RCC_APB1Periph;
 8019416:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8019418:	621a      	str	r2, [r3, #32]
  }
}
 801941a:	4770      	bx	lr
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 801941c:	ea22 0200 	bic.w	r2, r2, r0
 8019420:	e7fa      	b.n	8019418 <RCC_APB1PeriphResetCmd+0x8>
 8019422:	bf00      	nop
 8019424:	40023800 	.word	0x40023800

08019428 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8019428:	4b04      	ldr	r3, [pc, #16]	@ (801943c <RCC_APB2PeriphResetCmd+0x14>)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 801942a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
  if (NewState != DISABLE)
 801942c:	b111      	cbz	r1, 8019434 <RCC_APB2PeriphResetCmd+0xc>
    RCC->APB2RSTR |= RCC_APB2Periph;
 801942e:	4302      	orrs	r2, r0
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8019430:	625a      	str	r2, [r3, #36]	@ 0x24
  }
}
 8019432:	4770      	bx	lr
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8019434:	ea22 0200 	bic.w	r2, r2, r0
 8019438:	e7fa      	b.n	8019430 <RCC_APB2PeriphResetCmd+0x8>
 801943a:	bf00      	nop
 801943c:	40023800 	.word	0x40023800

08019440 <RTC_ByteToBcd2>:
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
 8019440:	2300      	movs	r3, #0
 8019442:	2809      	cmp	r0, #9
 8019444:	f103 0201 	add.w	r2, r3, #1
 8019448:	d803      	bhi.n	8019452 <RTC_ByteToBcd2+0x12>
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 801944a:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 801944e:	b2c0      	uxtb	r0, r0
 8019450:	4770      	bx	lr
    Value -= 10;
 8019452:	380a      	subs	r0, #10
 8019454:	b2c0      	uxtb	r0, r0
 8019456:	4613      	mov	r3, r2
 8019458:	e7f3      	b.n	8019442 <RTC_ByteToBcd2+0x2>

0801945a <RTC_StructInit>:
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 801945a:	237f      	movs	r3, #127	@ 0x7f
 801945c:	2200      	movs	r2, #0
 801945e:	e9c0 2300 	strd	r2, r3, [r0]
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 8019462:	23ff      	movs	r3, #255	@ 0xff
 8019464:	6083      	str	r3, [r0, #8]
}
 8019466:	4770      	bx	lr

08019468 <RTC_EnterInitMode>:
{
 8019468:	b082      	sub	sp, #8
  __IO uint32_t initcounter = 0x00;
 801946a:	2300      	movs	r3, #0
 801946c:	9301      	str	r3, [sp, #4]
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 801946e:	4b0d      	ldr	r3, [pc, #52]	@ (80194a4 <RTC_EnterInitMode+0x3c>)
 8019470:	68da      	ldr	r2, [r3, #12]
 8019472:	0652      	lsls	r2, r2, #25
 8019474:	d413      	bmi.n	801949e <RTC_EnterInitMode+0x36>
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 8019476:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801947a:	60da      	str	r2, [r3, #12]
      initstatus = RTC->ISR & RTC_ISR_INITF;
 801947c:	68da      	ldr	r2, [r3, #12]
      initcounter++;  
 801947e:	9901      	ldr	r1, [sp, #4]
 8019480:	3101      	adds	r1, #1
 8019482:	9101      	str	r1, [sp, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8019484:	9901      	ldr	r1, [sp, #4]
 8019486:	f5b1 3f80 	cmp.w	r1, #65536	@ 0x10000
      initstatus = RTC->ISR & RTC_ISR_INITF;
 801948a:	f002 0240 	and.w	r2, r2, #64	@ 0x40
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 801948e:	d001      	beq.n	8019494 <RTC_EnterInitMode+0x2c>
 8019490:	2a00      	cmp	r2, #0
 8019492:	d0f3      	beq.n	801947c <RTC_EnterInitMode+0x14>
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 8019494:	68d8      	ldr	r0, [r3, #12]
 8019496:	f3c0 1080 	ubfx	r0, r0, #6, #1
}
 801949a:	b002      	add	sp, #8
 801949c:	4770      	bx	lr
    status = SUCCESS;  
 801949e:	2001      	movs	r0, #1
 80194a0:	e7fb      	b.n	801949a <RTC_EnterInitMode+0x32>
 80194a2:	bf00      	nop
 80194a4:	40002800 	.word	0x40002800

080194a8 <RTC_ExitInitMode>:
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 80194a8:	4a02      	ldr	r2, [pc, #8]	@ (80194b4 <RTC_ExitInitMode+0xc>)
 80194aa:	68d3      	ldr	r3, [r2, #12]
 80194ac:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80194b0:	60d3      	str	r3, [r2, #12]
}
 80194b2:	4770      	bx	lr
 80194b4:	40002800 	.word	0x40002800

080194b8 <RTC_Init>:
{
 80194b8:	b538      	push	{r3, r4, r5, lr}
  RTC->WPR = 0xCA;
 80194ba:	4c0f      	ldr	r4, [pc, #60]	@ (80194f8 <RTC_Init+0x40>)
 80194bc:	23ca      	movs	r3, #202	@ 0xca
 80194be:	6263      	str	r3, [r4, #36]	@ 0x24
  RTC->WPR = 0x53;
 80194c0:	2353      	movs	r3, #83	@ 0x53
 80194c2:	6263      	str	r3, [r4, #36]	@ 0x24
{
 80194c4:	4605      	mov	r5, r0
  if (RTC_EnterInitMode() == ERROR)
 80194c6:	f7ff ffcf 	bl	8019468 <RTC_EnterInitMode>
 80194ca:	b188      	cbz	r0, 80194f0 <RTC_Init+0x38>
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 80194cc:	68a3      	ldr	r3, [r4, #8]
 80194ce:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80194d2:	60a3      	str	r3, [r4, #8]
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 80194d4:	68a3      	ldr	r3, [r4, #8]
 80194d6:	682a      	ldr	r2, [r5, #0]
 80194d8:	4313      	orrs	r3, r2
 80194da:	60a3      	str	r3, [r4, #8]
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 80194dc:	68ab      	ldr	r3, [r5, #8]
 80194de:	6123      	str	r3, [r4, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 80194e0:	6923      	ldr	r3, [r4, #16]
 80194e2:	686a      	ldr	r2, [r5, #4]
 80194e4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80194e8:	6123      	str	r3, [r4, #16]
    RTC_ExitInitMode();
 80194ea:	f7ff ffdd 	bl	80194a8 <RTC_ExitInitMode>
    status = SUCCESS;    
 80194ee:	2001      	movs	r0, #1
  RTC->WPR = 0xFF; 
 80194f0:	4b01      	ldr	r3, [pc, #4]	@ (80194f8 <RTC_Init+0x40>)
 80194f2:	22ff      	movs	r2, #255	@ 0xff
 80194f4:	625a      	str	r2, [r3, #36]	@ 0x24
}
 80194f6:	bd38      	pop	{r3, r4, r5, pc}
 80194f8:	40002800 	.word	0x40002800

080194fc <RTC_WaitForSynchro>:
{
 80194fc:	b082      	sub	sp, #8
  __IO uint32_t synchrocounter = 0;
 80194fe:	2300      	movs	r3, #0
 8019500:	9301      	str	r3, [sp, #4]
  RTC->WPR = 0xCA;
 8019502:	4b0e      	ldr	r3, [pc, #56]	@ (801953c <RTC_WaitForSynchro+0x40>)
 8019504:	22ca      	movs	r2, #202	@ 0xca
 8019506:	625a      	str	r2, [r3, #36]	@ 0x24
  RTC->WPR = 0x53;
 8019508:	2253      	movs	r2, #83	@ 0x53
 801950a:	625a      	str	r2, [r3, #36]	@ 0x24
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 801950c:	68da      	ldr	r2, [r3, #12]
 801950e:	f022 02a0 	bic.w	r2, r2, #160	@ 0xa0
 8019512:	60da      	str	r2, [r3, #12]
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8019514:	68da      	ldr	r2, [r3, #12]
    synchrocounter++;  
 8019516:	9901      	ldr	r1, [sp, #4]
 8019518:	3101      	adds	r1, #1
 801951a:	9101      	str	r1, [sp, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 801951c:	9901      	ldr	r1, [sp, #4]
 801951e:	f5b1 3f00 	cmp.w	r1, #131072	@ 0x20000
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8019522:	f002 0220 	and.w	r2, r2, #32
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8019526:	d001      	beq.n	801952c <RTC_WaitForSynchro+0x30>
 8019528:	2a00      	cmp	r2, #0
 801952a:	d0f3      	beq.n	8019514 <RTC_WaitForSynchro+0x18>
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 801952c:	68d8      	ldr	r0, [r3, #12]
  RTC->WPR = 0xFF; 
 801952e:	22ff      	movs	r2, #255	@ 0xff
}
 8019530:	f3c0 1040 	ubfx	r0, r0, #5, #1
  RTC->WPR = 0xFF; 
 8019534:	625a      	str	r2, [r3, #36]	@ 0x24
}
 8019536:	b002      	add	sp, #8
 8019538:	4770      	bx	lr
 801953a:	bf00      	nop
 801953c:	40002800 	.word	0x40002800

08019540 <RTC_SetTime>:
{
 8019540:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019542:	4b20      	ldr	r3, [pc, #128]	@ (80195c4 <RTC_SetTime+0x84>)
 8019544:	780a      	ldrb	r2, [r1, #0]
 8019546:	784d      	ldrb	r5, [r1, #1]
 8019548:	788e      	ldrb	r6, [r1, #2]
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 801954a:	689b      	ldr	r3, [r3, #8]
  if (RTC_Format == RTC_Format_BIN)
 801954c:	b9b0      	cbnz	r0, 801957c <RTC_SetTime+0x3c>
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 801954e:	f013 0340 	ands.w	r3, r3, #64	@ 0x40
 8019552:	d100      	bne.n	8019556 <RTC_SetTime+0x16>
      RTC_TimeStruct->RTC_H12 = 0x00;
 8019554:	70cb      	strb	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8019556:	4610      	mov	r0, r2
 8019558:	f7ff ff72 	bl	8019440 <RTC_ByteToBcd2>
 801955c:	4607      	mov	r7, r0
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 801955e:	4628      	mov	r0, r5
 8019560:	f7ff ff6e 	bl	8019440 <RTC_ByteToBcd2>
 8019564:	4604      	mov	r4, r0
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8019566:	4630      	mov	r0, r6
 8019568:	f7ff ff6a 	bl	8019440 <RTC_ByteToBcd2>
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 801956c:	78cb      	ldrb	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 801956e:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8019572:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 8019576:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
 801957a:	e00b      	b.n	8019594 <RTC_SetTime+0x54>
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 801957c:	f013 0340 	ands.w	r3, r3, #64	@ 0x40
      RTC_TimeStruct->RTC_H12 = 0x00;
 8019580:	bf08      	it	eq
 8019582:	70cb      	strbeq	r3, [r1, #3]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8019584:	022d      	lsls	r5, r5, #8
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8019586:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 801958a:	78ca      	ldrb	r2, [r1, #3]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 801958c:	ea45 0306 	orr.w	r3, r5, r6
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8019590:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
  RTC->WPR = 0xCA;
 8019594:	4d0b      	ldr	r5, [pc, #44]	@ (80195c4 <RTC_SetTime+0x84>)
 8019596:	23ca      	movs	r3, #202	@ 0xca
 8019598:	626b      	str	r3, [r5, #36]	@ 0x24
  RTC->WPR = 0x53;
 801959a:	2353      	movs	r3, #83	@ 0x53
 801959c:	626b      	str	r3, [r5, #36]	@ 0x24
  if (RTC_EnterInitMode() == ERROR)
 801959e:	f7ff ff63 	bl	8019468 <RTC_EnterInitMode>
 80195a2:	b158      	cbz	r0, 80195bc <RTC_SetTime+0x7c>
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80195a4:	f004 347f 	and.w	r4, r4, #2139062143	@ 0x7f7f7f7f
 80195a8:	f024 44fe 	bic.w	r4, r4, #2130706432	@ 0x7f000000
 80195ac:	602c      	str	r4, [r5, #0]
    RTC_ExitInitMode(); 
 80195ae:	f7ff ff7b 	bl	80194a8 <RTC_ExitInitMode>
    if(RTC_WaitForSynchro() == ERROR)
 80195b2:	f7ff ffa3 	bl	80194fc <RTC_WaitForSynchro>
 80195b6:	3800      	subs	r0, #0
 80195b8:	bf18      	it	ne
 80195ba:	2001      	movne	r0, #1
  RTC->WPR = 0xFF; 
 80195bc:	4b01      	ldr	r3, [pc, #4]	@ (80195c4 <RTC_SetTime+0x84>)
 80195be:	22ff      	movs	r2, #255	@ 0xff
 80195c0:	625a      	str	r2, [r3, #36]	@ 0x24
}
 80195c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80195c4:	40002800 	.word	0x40002800

080195c8 <RTC_TimeStructInit>:
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 80195c8:	2300      	movs	r3, #0
 80195ca:	70c3      	strb	r3, [r0, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 80195cc:	7003      	strb	r3, [r0, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 80195ce:	7043      	strb	r3, [r0, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 80195d0:	7083      	strb	r3, [r0, #2]
}
 80195d2:	4770      	bx	lr

080195d4 <SPI_Init>:
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 80195d4:	8803      	ldrh	r3, [r0, #0]
{
 80195d6:	b510      	push	{r4, lr}
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 80195d8:	f403 5241 	and.w	r2, r3, #12352	@ 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 80195dc:	884c      	ldrh	r4, [r1, #2]
 80195de:	880b      	ldrh	r3, [r1, #0]
 80195e0:	4323      	orrs	r3, r4
 80195e2:	888c      	ldrh	r4, [r1, #4]
 80195e4:	4323      	orrs	r3, r4
 80195e6:	88cc      	ldrh	r4, [r1, #6]
 80195e8:	4323      	orrs	r3, r4
 80195ea:	890c      	ldrh	r4, [r1, #8]
 80195ec:	4323      	orrs	r3, r4
 80195ee:	894c      	ldrh	r4, [r1, #10]
 80195f0:	4323      	orrs	r3, r4
 80195f2:	898c      	ldrh	r4, [r1, #12]
 80195f4:	4323      	orrs	r3, r4
 80195f6:	89cc      	ldrh	r4, [r1, #14]
 80195f8:	4323      	orrs	r3, r4
 80195fa:	4313      	orrs	r3, r2
 80195fc:	b29b      	uxth	r3, r3
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 80195fe:	8003      	strh	r3, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8019600:	8b83      	ldrh	r3, [r0, #28]
 8019602:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
 8019606:	041b      	lsls	r3, r3, #16
 8019608:	0c1b      	lsrs	r3, r3, #16
 801960a:	8383      	strh	r3, [r0, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 801960c:	8a0b      	ldrh	r3, [r1, #16]
 801960e:	8203      	strh	r3, [r0, #16]
}
 8019610:	bd10      	pop	{r4, pc}

08019612 <SPI_Cmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8019612:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 8019614:	b121      	cbz	r1, 8019620 <SPI_Cmd+0xe>
    SPIx->CR1 |= SPI_CR1_SPE;
 8019616:	b29b      	uxth	r3, r3
 8019618:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 801961c:	8003      	strh	r3, [r0, #0]
  }
}
 801961e:	4770      	bx	lr
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8019620:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8019624:	041b      	lsls	r3, r3, #16
 8019626:	0c1b      	lsrs	r3, r3, #16
 8019628:	e7f8      	b.n	801961c <SPI_Cmd+0xa>

0801962a <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 801962a:	8883      	ldrh	r3, [r0, #4]
 801962c:	b29b      	uxth	r3, r3
  if (NewState != DISABLE)
 801962e:	b112      	cbz	r2, 8019636 <SPI_I2S_DMACmd+0xc>
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8019630:	4319      	orrs	r1, r3
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8019632:	8081      	strh	r1, [r0, #4]
  }
}
 8019634:	4770      	bx	lr
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8019636:	ea23 0101 	bic.w	r1, r3, r1
 801963a:	e7fa      	b.n	8019632 <SPI_I2S_DMACmd+0x8>

0801963c <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)||
 801963c:	4a1c      	ldr	r2, [pc, #112]	@ (80196b0 <TIM_TimeBaseInit+0x74>)
  tmpcr1 = TIMx->CR1;  
 801963e:	8803      	ldrh	r3, [r0, #0]
  if((TIMx == TIM1) || (TIMx == TIM8)||
 8019640:	4290      	cmp	r0, r2
  tmpcr1 = TIMx->CR1;  
 8019642:	b29b      	uxth	r3, r3
  if((TIMx == TIM1) || (TIMx == TIM8)||
 8019644:	d012      	beq.n	801966c <TIM_TimeBaseInit+0x30>
 8019646:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 801964a:	4290      	cmp	r0, r2
 801964c:	d00e      	beq.n	801966c <TIM_TimeBaseInit+0x30>
 801964e:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 8019652:	d00b      	beq.n	801966c <TIM_TimeBaseInit+0x30>
     (TIMx == TIM2) || (TIMx == TIM3)||
 8019654:	f5a2 3280 	sub.w	r2, r2, #65536	@ 0x10000
 8019658:	4290      	cmp	r0, r2
 801965a:	d007      	beq.n	801966c <TIM_TimeBaseInit+0x30>
 801965c:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8019660:	4290      	cmp	r0, r2
 8019662:	d003      	beq.n	801966c <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 8019664:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8019668:	4290      	cmp	r0, r2
 801966a:	d103      	bne.n	8019674 <TIM_TimeBaseInit+0x38>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 801966c:	884a      	ldrh	r2, [r1, #2]
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 801966e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8019672:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 8019674:	4a0f      	ldr	r2, [pc, #60]	@ (80196b4 <TIM_TimeBaseInit+0x78>)
 8019676:	4290      	cmp	r0, r2
 8019678:	d008      	beq.n	801968c <TIM_TimeBaseInit+0x50>
 801967a:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 801967e:	4290      	cmp	r0, r2
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8019680:	bf1f      	itttt	ne
 8019682:	f423 7340 	bicne.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8019686:	890a      	ldrhne	r2, [r1, #8]
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8019688:	b29b      	uxthne	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 801968a:	4313      	orrne	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 801968c:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 801968e:	684b      	ldr	r3, [r1, #4]
 8019690:	62c3      	str	r3, [r0, #44]	@ 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8019692:	880b      	ldrh	r3, [r1, #0]
 8019694:	8503      	strh	r3, [r0, #40]	@ 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 8019696:	4b06      	ldr	r3, [pc, #24]	@ (80196b0 <TIM_TimeBaseInit+0x74>)
 8019698:	4298      	cmp	r0, r3
 801969a:	d003      	beq.n	80196a4 <TIM_TimeBaseInit+0x68>
 801969c:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80196a0:	4298      	cmp	r0, r3
 80196a2:	d101      	bne.n	80196a8 <TIM_TimeBaseInit+0x6c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 80196a4:	7a8b      	ldrb	r3, [r1, #10]
 80196a6:	8603      	strh	r3, [r0, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 80196a8:	2301      	movs	r3, #1
 80196aa:	8283      	strh	r3, [r0, #20]
}
 80196ac:	4770      	bx	lr
 80196ae:	bf00      	nop
 80196b0:	40010000 	.word	0x40010000
 80196b4:	40001000 	.word	0x40001000

080196b8 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80196b8:	8803      	ldrh	r3, [r0, #0]
  if (NewState != DISABLE)
 80196ba:	b121      	cbz	r1, 80196c6 <TIM_Cmd+0xe>
    TIMx->CR1 |= TIM_CR1_CEN;
 80196bc:	b29b      	uxth	r3, r3
 80196be:	f043 0301 	orr.w	r3, r3, #1
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80196c2:	8003      	strh	r3, [r0, #0]
  }
}
 80196c4:	4770      	bx	lr
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80196c6:	f023 0301 	bic.w	r3, r3, #1
 80196ca:	041b      	lsls	r3, r3, #16
 80196cc:	0c1b      	lsrs	r3, r3, #16
 80196ce:	e7f8      	b.n	80196c2 <TIM_Cmd+0xa>

080196d0 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80196d0:	8a03      	ldrh	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80196d2:	8982      	ldrh	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80196d4:	ea11 0003 	ands.w	r0, r1, r3
  itenable = TIMx->DIER & TIM_IT;
 80196d8:	b292      	uxth	r2, r2
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80196da:	d003      	beq.n	80196e4 <TIM_GetITStatus+0x14>
 80196dc:	420a      	tst	r2, r1
 80196de:	bf14      	ite	ne
 80196e0:	2001      	movne	r0, #1
 80196e2:	2000      	moveq	r0, #0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80196e4:	4770      	bx	lr

080196e6 <TIM_ClearITPendingBit>:
  * @note   TIM6 and TIM7 can generate only an update interrupt.
  * @note   TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.
  *      
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
 80196e6:	43c9      	mvns	r1, r1
 80196e8:	b289      	uxth	r1, r1
 80196ea:	8201      	strh	r1, [r0, #16]
 80196ec:	4770      	bx	lr
	...

080196f0 <USART_Init>:
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80196f0:	8a03      	ldrh	r3, [r0, #16]
{
 80196f2:	b530      	push	{r4, r5, lr}
 80196f4:	460d      	mov	r5, r1
  tmpreg = USARTx->CR2;
 80196f6:	b29b      	uxth	r3, r3
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 80196f8:	88ea      	ldrh	r2, [r5, #6]
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
 80196fa:	8989      	ldrh	r1, [r1, #12]
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80196fc:	f423 5340 	bic.w	r3, r3, #12288	@ 0x3000
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8019700:	4313      	orrs	r3, r2
 8019702:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8019704:	8982      	ldrh	r2, [r0, #12]

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8019706:	88ab      	ldrh	r3, [r5, #4]
{
 8019708:	4604      	mov	r4, r0
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 801970a:	8928      	ldrh	r0, [r5, #8]
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 801970c:	f422 52b0 	bic.w	r2, r2, #5632	@ 0x1600
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8019710:	4303      	orrs	r3, r0
 8019712:	8968      	ldrh	r0, [r5, #10]
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8019714:	f022 020c 	bic.w	r2, r2, #12
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8019718:	4303      	orrs	r3, r0
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 801971a:	0412      	lsls	r2, r2, #16
 801971c:	0c12      	lsrs	r2, r2, #16
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 801971e:	b29b      	uxth	r3, r3
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8019720:	4313      	orrs	r3, r2
 8019722:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8019724:	8aa3      	ldrh	r3, [r4, #20]
 8019726:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8019728:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 801972c:	4319      	orrs	r1, r3
{
 801972e:	b085      	sub	sp, #20
  USARTx->CR3 = (uint16_t)tmpreg;
 8019730:	82a1      	strh	r1, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8019732:	4668      	mov	r0, sp
 8019734:	f7ff fdc4 	bl	80192c0 <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8019738:	4b17      	ldr	r3, [pc, #92]	@ (8019798 <USART_Init+0xa8>)
 801973a:	429c      	cmp	r4, r3
 801973c:	d003      	beq.n	8019746 <USART_Init+0x56>
 801973e:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8019742:	429c      	cmp	r4, r3
 8019744:	d126      	bne.n	8019794 <USART_Init+0xa4>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8019746:	9b03      	ldr	r3, [sp, #12]
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8019748:	89a1      	ldrh	r1, [r4, #12]
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 801974a:	2219      	movs	r2, #25
 801974c:	4353      	muls	r3, r2
 801974e:	682a      	ldr	r2, [r5, #0]
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8019750:	040d      	lsls	r5, r1, #16
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 8019752:	f04f 0164 	mov.w	r1, #100	@ 0x64
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8019756:	bf4c      	ite	mi
 8019758:	0052      	lslmi	r2, r2, #1
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 801975a:	0092      	lslpl	r2, r2, #2
 801975c:	fbb3 f3f2 	udiv	r3, r3, r2
  tmpreg = (integerdivider / 100) << 4;
 8019760:	fbb3 f0f1 	udiv	r0, r3, r1
 8019764:	fb01 3310 	mls	r3, r1, r0, r3
 8019768:	0102      	lsls	r2, r0, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 801976a:	89a0      	ldrh	r0, [r4, #12]
 801976c:	0400      	lsls	r0, r0, #16
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 801976e:	bf4b      	itete	mi
 8019770:	00db      	lslmi	r3, r3, #3
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8019772:	011b      	lslpl	r3, r3, #4
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8019774:	3332      	addmi	r3, #50	@ 0x32
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8019776:	3332      	addpl	r3, #50	@ 0x32
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8019778:	bf4b      	itete	mi
 801977a:	fbb3 f3f1 	udivmi	r3, r3, r1
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 801977e:	fbb3 f3f1 	udivpl	r3, r3, r1
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8019782:	f003 0307 	andmi.w	r3, r3, #7
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8019786:	f003 030f 	andpl.w	r3, r3, #15
 801978a:	4313      	orrs	r3, r2
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 801978c:	b29b      	uxth	r3, r3
 801978e:	8123      	strh	r3, [r4, #8]
}
 8019790:	b005      	add	sp, #20
 8019792:	bd30      	pop	{r4, r5, pc}
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8019794:	9b02      	ldr	r3, [sp, #8]
 8019796:	e7d7      	b.n	8019748 <USART_Init+0x58>
 8019798:	40011000 	.word	0x40011000

0801979c <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 801979c:	8983      	ldrh	r3, [r0, #12]
  if (NewState != DISABLE)
 801979e:	b121      	cbz	r1, 80197aa <USART_Cmd+0xe>
    USARTx->CR1 |= USART_CR1_UE;
 80197a0:	b29b      	uxth	r3, r3
 80197a2:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 80197a6:	8183      	strh	r3, [r0, #12]
  }
}
 80197a8:	4770      	bx	lr
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 80197aa:	f423 5300 	bic.w	r3, r3, #8192	@ 0x2000
 80197ae:	041b      	lsls	r3, r3, #16
 80197b0:	0c1b      	lsrs	r3, r3, #16
 80197b2:	e7f8      	b.n	80197a6 <USART_Cmd+0xa>

080197b4 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 80197b4:	b510      	push	{r4, lr}
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80197b6:	f3c1 1442 	ubfx	r4, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80197ba:	2301      	movs	r3, #1
  itpos = USART_IT & IT_MASK;
 80197bc:	f001 011f 	and.w	r1, r1, #31
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80197c0:	2c01      	cmp	r4, #1
  itmask = (((uint32_t)0x01) << itpos);
 80197c2:	fa03 f301 	lsl.w	r3, r3, r1
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80197c6:	d105      	bne.n	80197d4 <USART_ITConfig+0x20>
  {
    usartxbase += 0x0C;
 80197c8:	300c      	adds	r0, #12
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
 80197ca:	b142      	cbz	r2, 80197de <USART_ITConfig+0x2a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80197cc:	6802      	ldr	r2, [r0, #0]
 80197ce:	4313      	orrs	r3, r2
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80197d0:	6003      	str	r3, [r0, #0]
  }
}
 80197d2:	bd10      	pop	{r4, pc}
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80197d4:	2c02      	cmp	r4, #2
    usartxbase += 0x10;
 80197d6:	bf0c      	ite	eq
 80197d8:	3010      	addeq	r0, #16
    usartxbase += 0x14; 
 80197da:	3014      	addne	r0, #20
 80197dc:	e7f5      	b.n	80197ca <USART_ITConfig+0x16>
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80197de:	6802      	ldr	r2, [r0, #0]
 80197e0:	ea22 0303 	bic.w	r3, r2, r3
 80197e4:	e7f4      	b.n	80197d0 <USART_ITConfig+0x1c>

080197e6 <USBD_Resume>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Resume(USB_OTG_CORE_HANDLE  *pdev)
{
 80197e6:	b510      	push	{r4, lr}
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceResumed(); 
 80197e8:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	@ 0x5e8
{
 80197ec:	4604      	mov	r4, r0
  pdev->dev.usr_cb->DeviceResumed(); 
 80197ee:	691b      	ldr	r3, [r3, #16]
 80197f0:	4798      	blx	r3
  pdev->dev.device_status = pdev->dev.device_old_status;  
  pdev->dev.device_status = USB_OTG_CONFIGURED;  
 80197f2:	2303      	movs	r3, #3
 80197f4:	f884 3112 	strb.w	r3, [r4, #274]	@ 0x112
  return USBD_OK;
}
 80197f8:	2000      	movs	r0, #0
 80197fa:	bd10      	pop	{r4, pc}

080197fc <USBD_Suspend>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_Suspend(USB_OTG_CORE_HANDLE  *pdev)
{
 80197fc:	b508      	push	{r3, lr}
  pdev->dev.device_old_status = pdev->dev.device_status;
 80197fe:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019802:	f880 3113 	strb.w	r3, [r0, #275]	@ 0x113
  pdev->dev.device_status  = USB_OTG_SUSPENDED;
 8019806:	2304      	movs	r3, #4
 8019808:	f880 3112 	strb.w	r3, [r0, #274]	@ 0x112
  /* Upon Resume call usr call back */
  pdev->dev.usr_cb->DeviceSuspended(); 
 801980c:	f8d0 35e8 	ldr.w	r3, [r0, #1512]	@ 0x5e8
 8019810:	68db      	ldr	r3, [r3, #12]
 8019812:	4798      	blx	r3
  return USBD_OK;
}
 8019814:	2000      	movs	r0, #0
 8019816:	bd08      	pop	{r3, pc}

08019818 <USBD_SOF>:
* @param  pdev: device instance
* @retval status
*/

static uint8_t USBD_SOF(USB_OTG_CORE_HANDLE  *pdev)
{
 8019818:	b508      	push	{r3, lr}
  if(pdev->dev.class_cb->SOF)
 801981a:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 801981e:	69db      	ldr	r3, [r3, #28]
 8019820:	b103      	cbz	r3, 8019824 <USBD_SOF+0xc>
  {
    pdev->dev.class_cb->SOF(pdev); 
 8019822:	4798      	blx	r3
  }
  return USBD_OK;
}
 8019824:	2000      	movs	r0, #0
 8019826:	bd08      	pop	{r3, pc}

08019828 <USBD_IsoINIncomplete>:
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoINIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8019828:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoINIncomplete(pdev);   
 801982a:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 801982e:	6a1b      	ldr	r3, [r3, #32]
 8019830:	4798      	blx	r3
  return USBD_OK;
}
 8019832:	2000      	movs	r0, #0
 8019834:	bd08      	pop	{r3, pc}

08019836 <USBD_IsoOUTIncomplete>:
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
static uint8_t USBD_IsoOUTIncomplete(USB_OTG_CORE_HANDLE  *pdev)
{
 8019836:	b508      	push	{r3, lr}
  pdev->dev.class_cb->IsoOUTIncomplete(pdev);   
 8019838:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 801983c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801983e:	4798      	blx	r3
  return USBD_OK;
}
 8019840:	2000      	movs	r0, #0
 8019842:	bd08      	pop	{r3, pc}

08019844 <USBD_Reset>:
  DCD_EP_Open(pdev,
 8019844:	2300      	movs	r3, #0
{
 8019846:	b510      	push	{r4, lr}
  DCD_EP_Open(pdev,
 8019848:	4619      	mov	r1, r3
{
 801984a:	4604      	mov	r4, r0
  DCD_EP_Open(pdev,
 801984c:	2240      	movs	r2, #64	@ 0x40
 801984e:	f001 fe6d 	bl	801b52c <DCD_EP_Open>
  DCD_EP_Open(pdev,
 8019852:	2240      	movs	r2, #64	@ 0x40
 8019854:	2180      	movs	r1, #128	@ 0x80
 8019856:	2300      	movs	r3, #0
 8019858:	4620      	mov	r0, r4
 801985a:	f001 fe67 	bl	801b52c <DCD_EP_Open>
  pdev->dev.device_status = USB_OTG_DEFAULT;
 801985e:	2301      	movs	r3, #1
 8019860:	f884 3112 	strb.w	r3, [r4, #274]	@ 0x112
  pdev->dev.usr_cb->DeviceReset(pdev->cfg.speed);
 8019864:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	@ 0x5e8
 8019868:	78a0      	ldrb	r0, [r4, #2]
 801986a:	685b      	ldr	r3, [r3, #4]
 801986c:	4798      	blx	r3
}
 801986e:	2000      	movs	r0, #0
 8019870:	bd10      	pop	{r4, pc}

08019872 <USBD_SetupStage>:
{
 8019872:	b513      	push	{r0, r1, r4, lr}
  USBD_ParseSetupRequest(pdev , &req);
 8019874:	4669      	mov	r1, sp
{
 8019876:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(pdev , &req);
 8019878:	f000 fae2 	bl	8019e40 <USBD_ParseSetupRequest>
  switch (req.bmRequest & 0x1F) 
 801987c:	f89d 1000 	ldrb.w	r1, [sp]
 8019880:	f001 031f 	and.w	r3, r1, #31
 8019884:	2b01      	cmp	r3, #1
 8019886:	d009      	beq.n	801989c <USBD_SetupStage+0x2a>
 8019888:	2b02      	cmp	r3, #2
 801988a:	d00c      	beq.n	80198a6 <USBD_SetupStage+0x34>
 801988c:	b983      	cbnz	r3, 80198b0 <USBD_SetupStage+0x3e>
    USBD_StdDevReq (pdev, &req);
 801988e:	4669      	mov	r1, sp
 8019890:	4620      	mov	r0, r4
 8019892:	f000 f925 	bl	8019ae0 <USBD_StdDevReq>
}
 8019896:	2000      	movs	r0, #0
 8019898:	b002      	add	sp, #8
 801989a:	bd10      	pop	{r4, pc}
    USBD_StdItfReq(pdev, &req);
 801989c:	4669      	mov	r1, sp
 801989e:	4620      	mov	r0, r4
 80198a0:	f000 fa5c 	bl	8019d5c <USBD_StdItfReq>
    break;
 80198a4:	e7f7      	b.n	8019896 <USBD_SetupStage+0x24>
    USBD_StdEPReq(pdev, &req);   
 80198a6:	4669      	mov	r1, sp
 80198a8:	4620      	mov	r0, r4
 80198aa:	f000 fa6f 	bl	8019d8c <USBD_StdEPReq>
    break;
 80198ae:	e7f2      	b.n	8019896 <USBD_SetupStage+0x24>
    DCD_EP_Stall(pdev , req.bmRequest & 0x80);
 80198b0:	f001 0180 	and.w	r1, r1, #128	@ 0x80
 80198b4:	4620      	mov	r0, r4
 80198b6:	f001 feb0 	bl	801b61a <DCD_EP_Stall>
    break;
 80198ba:	e7ec      	b.n	8019896 <USBD_SetupStage+0x24>

080198bc <USBD_DataOutStage>:
{
 80198bc:	b510      	push	{r4, lr}
 80198be:	4604      	mov	r4, r0
  if(epnum == 0) 
 80198c0:	bb69      	cbnz	r1, 801991e <USBD_DataOutStage+0x62>
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_OUT)
 80198c2:	f890 3111 	ldrb.w	r3, [r0, #273]	@ 0x111
 80198c6:	2b03      	cmp	r3, #3
 80198c8:	d11a      	bne.n	8019900 <USBD_DataOutStage+0x44>
      if(ep->rem_data_len > ep->maxpacket)
 80198ca:	f8d0 3390 	ldr.w	r3, [r0, #912]	@ 0x390
 80198ce:	f8d0 237c 	ldr.w	r2, [r0, #892]	@ 0x37c
 80198d2:	4293      	cmp	r3, r2
 80198d4:	d916      	bls.n	8019904 <USBD_DataOutStage+0x48>
        if(pdev->cfg.dma_enable == 1)
 80198d6:	78c1      	ldrb	r1, [r0, #3]
 80198d8:	2901      	cmp	r1, #1
          ep->xfer_buff += ep->maxpacket; 
 80198da:	bf08      	it	eq
 80198dc:	f8d0 1380 	ldreq.w	r1, [r0, #896]	@ 0x380
        ep->rem_data_len -=  ep->maxpacket;
 80198e0:	eba3 0302 	sub.w	r3, r3, r2
          ep->xfer_buff += ep->maxpacket; 
 80198e4:	bf04      	itt	eq
 80198e6:	1889      	addeq	r1, r1, r2
 80198e8:	f8c0 1380 	streq.w	r1, [r0, #896]	@ 0x380
                            MIN(ep->rem_data_len ,ep->maxpacket));
 80198ec:	429a      	cmp	r2, r3
 80198ee:	bf28      	it	cs
 80198f0:	461a      	movcs	r2, r3
        USBD_CtlContinueRx (pdev, 
 80198f2:	f8d0 1380 	ldr.w	r1, [r0, #896]	@ 0x380
        ep->rem_data_len -=  ep->maxpacket;
 80198f6:	f8c0 3390 	str.w	r3, [r0, #912]	@ 0x390
        USBD_CtlContinueRx (pdev, 
 80198fa:	b292      	uxth	r2, r2
 80198fc:	f000 f8bb 	bl	8019a76 <USBD_CtlContinueRx>
}
 8019900:	2000      	movs	r0, #0
 8019902:	bd10      	pop	{r4, pc}
        if((pdev->dev.class_cb->EP0_RxReady != NULL)&&
 8019904:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 8019908:	691b      	ldr	r3, [r3, #16]
 801990a:	b123      	cbz	r3, 8019916 <USBD_DataOutStage+0x5a>
 801990c:	f890 2112 	ldrb.w	r2, [r0, #274]	@ 0x112
 8019910:	2a03      	cmp	r2, #3
 8019912:	d100      	bne.n	8019916 <USBD_DataOutStage+0x5a>
          pdev->dev.class_cb->EP0_RxReady(pdev); 
 8019914:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8019916:	4620      	mov	r0, r4
 8019918:	f000 f8b5 	bl	8019a86 <USBD_CtlSendStatus>
 801991c:	e7f0      	b.n	8019900 <USBD_DataOutStage+0x44>
  else if((pdev->dev.class_cb->DataOut != NULL)&&
 801991e:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 8019922:	699b      	ldr	r3, [r3, #24]
 8019924:	2b00      	cmp	r3, #0
 8019926:	d0eb      	beq.n	8019900 <USBD_DataOutStage+0x44>
 8019928:	f890 2112 	ldrb.w	r2, [r0, #274]	@ 0x112
 801992c:	2a03      	cmp	r2, #3
 801992e:	d1e7      	bne.n	8019900 <USBD_DataOutStage+0x44>
    pdev->dev.class_cb->DataOut(pdev, epnum); 
 8019930:	4798      	blx	r3
 8019932:	e7e5      	b.n	8019900 <USBD_DataOutStage+0x44>

08019934 <USBD_DataInStage>:
{
 8019934:	b538      	push	{r3, r4, r5, lr}
 8019936:	4604      	mov	r4, r0
  if(epnum == 0) 
 8019938:	2900      	cmp	r1, #0
 801993a:	d149      	bne.n	80199d0 <USBD_DataInStage+0x9c>
    if ( pdev->dev.device_state == USB_OTG_EP0_DATA_IN)
 801993c:	f890 3111 	ldrb.w	r3, [r0, #273]	@ 0x111
 8019940:	2b02      	cmp	r3, #2
 8019942:	d117      	bne.n	8019974 <USBD_DataInStage+0x40>
      if(ep->rem_data_len > ep->maxpacket)
 8019944:	f8d0 2138 	ldr.w	r2, [r0, #312]	@ 0x138
 8019948:	f8d0 3124 	ldr.w	r3, [r0, #292]	@ 0x124
 801994c:	429a      	cmp	r2, r3
 801994e:	d91e      	bls.n	801998e <USBD_DataInStage+0x5a>
        if(pdev->cfg.dma_enable == 1)
 8019950:	78c1      	ldrb	r1, [r0, #3]
 8019952:	2901      	cmp	r1, #1
          ep->xfer_buff += ep->maxpacket;
 8019954:	bf04      	itt	eq
 8019956:	f8d0 1128 	ldreq.w	r1, [r0, #296]	@ 0x128
 801995a:	18c9      	addeq	r1, r1, r3
        ep->rem_data_len -=  ep->maxpacket;
 801995c:	eba2 0203 	sub.w	r2, r2, r3
          ep->xfer_buff += ep->maxpacket;
 8019960:	bf08      	it	eq
 8019962:	f8c0 1128 	streq.w	r1, [r0, #296]	@ 0x128
        ep->rem_data_len -=  ep->maxpacket;
 8019966:	f8c0 2138 	str.w	r2, [r0, #312]	@ 0x138
        USBD_CtlContinueSendData (pdev, 
 801996a:	f8d0 1128 	ldr.w	r1, [r0, #296]	@ 0x128
 801996e:	b292      	uxth	r2, r2
 8019970:	f000 f879 	bl	8019a66 <USBD_CtlContinueSendData>
    if (pdev->dev.test_mode == 1)
 8019974:	f894 3116 	ldrb.w	r3, [r4, #278]	@ 0x116
 8019978:	2b01      	cmp	r3, #1
 801997a:	d106      	bne.n	801998a <USBD_DataInStage+0x56>
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, SET_TEST_MODE.d32);
 801997c:	4a1a      	ldr	r2, [pc, #104]	@ (80199e8 <USBD_DataInStage+0xb4>)
 801997e:	6923      	ldr	r3, [r4, #16]
 8019980:	6812      	ldr	r2, [r2, #0]
 8019982:	605a      	str	r2, [r3, #4]
      pdev->dev.test_mode = 0;
 8019984:	2300      	movs	r3, #0
 8019986:	f884 3116 	strb.w	r3, [r4, #278]	@ 0x116
}
 801998a:	2000      	movs	r0, #0
 801998c:	bd38      	pop	{r3, r4, r5, pc}
        if((ep->total_data_len % ep->maxpacket == 0) &&
 801998e:	f8d0 213c 	ldr.w	r2, [r0, #316]	@ 0x13c
 8019992:	fbb2 f5f3 	udiv	r5, r2, r3
 8019996:	fb03 2515 	mls	r5, r3, r5, r2
 801999a:	b95d      	cbnz	r5, 80199b4 <USBD_DataInStage+0x80>
 801999c:	4293      	cmp	r3, r2
 801999e:	d809      	bhi.n	80199b4 <USBD_DataInStage+0x80>
           (ep->total_data_len >= ep->maxpacket) &&
 80199a0:	f8d0 3140 	ldr.w	r3, [r0, #320]	@ 0x140
 80199a4:	429a      	cmp	r2, r3
 80199a6:	d205      	bcs.n	80199b4 <USBD_DataInStage+0x80>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 80199a8:	462a      	mov	r2, r5
 80199aa:	f000 f85c 	bl	8019a66 <USBD_CtlContinueSendData>
          ep->ctl_data_len = 0;
 80199ae:	f8c4 5140 	str.w	r5, [r4, #320]	@ 0x140
 80199b2:	e7df      	b.n	8019974 <USBD_DataInStage+0x40>
          if((pdev->dev.class_cb->EP0_TxSent != NULL)&&
 80199b4:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	@ 0x5e4
 80199b8:	68db      	ldr	r3, [r3, #12]
 80199ba:	b12b      	cbz	r3, 80199c8 <USBD_DataInStage+0x94>
 80199bc:	f894 2112 	ldrb.w	r2, [r4, #274]	@ 0x112
 80199c0:	2a03      	cmp	r2, #3
 80199c2:	d101      	bne.n	80199c8 <USBD_DataInStage+0x94>
            pdev->dev.class_cb->EP0_TxSent(pdev); 
 80199c4:	4620      	mov	r0, r4
 80199c6:	4798      	blx	r3
          USBD_CtlReceiveStatus(pdev);
 80199c8:	4620      	mov	r0, r4
 80199ca:	f000 f86b 	bl	8019aa4 <USBD_CtlReceiveStatus>
 80199ce:	e7d1      	b.n	8019974 <USBD_DataInStage+0x40>
  else if((pdev->dev.class_cb->DataIn != NULL)&& 
 80199d0:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 80199d4:	695b      	ldr	r3, [r3, #20]
 80199d6:	2b00      	cmp	r3, #0
 80199d8:	d0d7      	beq.n	801998a <USBD_DataInStage+0x56>
 80199da:	f890 2112 	ldrb.w	r2, [r0, #274]	@ 0x112
 80199de:	2a03      	cmp	r2, #3
 80199e0:	d1d3      	bne.n	801998a <USBD_DataInStage+0x56>
    pdev->dev.class_cb->DataIn(pdev, epnum); 
 80199e2:	4798      	blx	r3
 80199e4:	e7d1      	b.n	801998a <USBD_DataInStage+0x56>
 80199e6:	bf00      	nop
 80199e8:	2000426c 	.word	0x2000426c

080199ec <USBD_Init>:
{
 80199ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80199f0:	4604      	mov	r4, r0
 80199f2:	4616      	mov	r6, r2
 80199f4:	461f      	mov	r7, r3
 80199f6:	f8dd 8018 	ldr.w	r8, [sp, #24]
 80199fa:	460d      	mov	r5, r1
  USB_OTG_BSP_Init(pdev);  
 80199fc:	f7fd ffb6 	bl	801796c <USB_OTG_BSP_Init>
  DCD_Init(pdev , coreID);
 8019a00:	4620      	mov	r0, r4
 8019a02:	4629      	mov	r1, r5
  pdev->dev.class_cb = class_cb;
 8019a04:	f8c4 75e4 	str.w	r7, [r4, #1508]	@ 0x5e4
  pdev->dev.usr_cb = usr_cb;  
 8019a08:	f8c4 85e8 	str.w	r8, [r4, #1512]	@ 0x5e8
  pdev->dev.usr_device = pDevice;    
 8019a0c:	f8c4 65ec 	str.w	r6, [r4, #1516]	@ 0x5ec
  DCD_Init(pdev , coreID);
 8019a10:	f001 fd42 	bl	801b498 <DCD_Init>
  pdev->dev.usr_cb->Init();
 8019a14:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	@ 0x5e8
 8019a18:	681b      	ldr	r3, [r3, #0]
 8019a1a:	4798      	blx	r3
  USB_OTG_BSP_EnableInterrupt(pdev);
 8019a1c:	4620      	mov	r0, r4
}
 8019a1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  USB_OTG_BSP_EnableInterrupt(pdev);
 8019a22:	f7fd bfe9 	b.w	80179f8 <USB_OTG_BSP_EnableInterrupt>

08019a26 <USBD_SetCfg>:
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8019a26:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
{
 8019a2a:	b510      	push	{r4, lr}
 8019a2c:	4604      	mov	r4, r0
  pdev->dev.class_cb->Init(pdev, cfgidx); 
 8019a2e:	681b      	ldr	r3, [r3, #0]
 8019a30:	4798      	blx	r3
  pdev->dev.usr_cb->DeviceConfigured();
 8019a32:	f8d4 35e8 	ldr.w	r3, [r4, #1512]	@ 0x5e8
 8019a36:	689b      	ldr	r3, [r3, #8]
 8019a38:	4798      	blx	r3
}
 8019a3a:	2000      	movs	r0, #0
 8019a3c:	bd10      	pop	{r4, pc}

08019a3e <USBD_ClrCfg>:
{
 8019a3e:	b508      	push	{r3, lr}
  pdev->dev.class_cb->DeInit(pdev, cfgidx);   
 8019a40:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 8019a44:	685b      	ldr	r3, [r3, #4]
 8019a46:	4798      	blx	r3
}
 8019a48:	2000      	movs	r0, #0
 8019a4a:	bd08      	pop	{r3, pc}

08019a4c <USBD_CtlSendData>:
* @retval status
*/
USBD_Status  USBD_CtlSendData (USB_OTG_CORE_HANDLE  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 8019a4c:	b510      	push	{r4, lr}
 8019a4e:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  pdev->dev.in_ep[0].total_data_len = len;
  pdev->dev.in_ep[0].rem_data_len   = len;
 8019a50:	e9c0 224e 	strd	r2, r2, [r0, #312]	@ 0x138
  pdev->dev.device_state = USB_OTG_EP0_DATA_IN;
 8019a54:	2202      	movs	r2, #2
 8019a56:	f880 2111 	strb.w	r2, [r0, #273]	@ 0x111

  DCD_EP_Tx (pdev, 0, pbuf, len);
 8019a5a:	460a      	mov	r2, r1
 8019a5c:	2100      	movs	r1, #0
 8019a5e:	f001 fdc0 	bl	801b5e2 <DCD_EP_Tx>
 
  return ret;
}
 8019a62:	2000      	movs	r0, #0
 8019a64:	bd10      	pop	{r4, pc}

08019a66 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_Status  USBD_CtlContinueSendData (USB_OTG_CORE_HANDLE  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8019a66:	b508      	push	{r3, lr}
 8019a68:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_Tx (pdev, 0, pbuf, len);
 8019a6a:	460a      	mov	r2, r1
 8019a6c:	2100      	movs	r1, #0
 8019a6e:	f001 fdb8 	bl	801b5e2 <DCD_EP_Tx>
  
  
  return ret;
}
 8019a72:	2000      	movs	r0, #0
 8019a74:	bd08      	pop	{r3, pc}

08019a76 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_Status  USBD_CtlContinueRx (USB_OTG_CORE_HANDLE  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8019a76:	b508      	push	{r3, lr}
 8019a78:	4613      	mov	r3, r2
  USBD_Status ret = USBD_OK;
  
  DCD_EP_PrepareRx (pdev,
 8019a7a:	460a      	mov	r2, r1
 8019a7c:	2100      	movs	r1, #0
 8019a7e:	f001 fd8e 	bl	801b59e <DCD_EP_PrepareRx>
                    0,                     
                    pbuf,                         
                    len);
  return ret;
}
 8019a82:	2000      	movs	r0, #0
 8019a84:	bd08      	pop	{r3, pc}

08019a86 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlSendStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8019a86:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_IN;
 8019a88:	2304      	movs	r3, #4
 8019a8a:	f880 3111 	strb.w	r3, [r0, #273]	@ 0x111
  DCD_EP_Tx (pdev,
 8019a8e:	2300      	movs	r3, #0
{
 8019a90:	4604      	mov	r4, r0
  DCD_EP_Tx (pdev,
 8019a92:	461a      	mov	r2, r3
 8019a94:	4619      	mov	r1, r3
 8019a96:	f001 fda4 	bl	801b5e2 <DCD_EP_Tx>
             0,
             NULL, 
             0); 
  
  USB_OTG_EP0_OutStart(pdev);  
 8019a9a:	4620      	mov	r0, r4
 8019a9c:	f001 fcec 	bl	801b478 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 8019aa0:	2000      	movs	r0, #0
 8019aa2:	bd10      	pop	{r4, pc}

08019aa4 <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: USB OTG device instance
* @retval status
*/
USBD_Status  USBD_CtlReceiveStatus (USB_OTG_CORE_HANDLE  *pdev)
{
 8019aa4:	b510      	push	{r4, lr}
  USBD_Status ret = USBD_OK;
  pdev->dev.device_state = USB_OTG_EP0_STATUS_OUT;  
 8019aa6:	2305      	movs	r3, #5
 8019aa8:	f880 3111 	strb.w	r3, [r0, #273]	@ 0x111
  DCD_EP_PrepareRx ( pdev,
 8019aac:	2300      	movs	r3, #0
{
 8019aae:	4604      	mov	r4, r0
  DCD_EP_PrepareRx ( pdev,
 8019ab0:	461a      	mov	r2, r3
 8019ab2:	4619      	mov	r1, r3
 8019ab4:	f001 fd73 	bl	801b59e <DCD_EP_PrepareRx>
                    0,
                    NULL,
                    0);  

  USB_OTG_EP0_OutStart(pdev);
 8019ab8:	4620      	mov	r0, r4
 8019aba:	f001 fcdd 	bl	801b478 <USB_OTG_EP0_OutStart>
  
  return ret;
}
 8019abe:	2000      	movs	r0, #0
 8019ac0:	bd10      	pop	{r4, pc}

08019ac2 <USBD_CtlError.constprop.0>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
 8019ac2:	b510      	push	{r4, lr}
                            USB_SETUP_REQ *req)
{
  
  DCD_EP_Stall(pdev , 0x80);
 8019ac4:	2180      	movs	r1, #128	@ 0x80
void USBD_CtlError( USB_OTG_CORE_HANDLE  *pdev,
 8019ac6:	4604      	mov	r4, r0
  DCD_EP_Stall(pdev , 0x80);
 8019ac8:	f001 fda7 	bl	801b61a <DCD_EP_Stall>
  DCD_EP_Stall(pdev , 0);
 8019acc:	4620      	mov	r0, r4
 8019ace:	2100      	movs	r1, #0
 8019ad0:	f001 fda3 	bl	801b61a <DCD_EP_Stall>
  USB_OTG_EP0_OutStart(pdev);  
 8019ad4:	4620      	mov	r0, r4
}
 8019ad6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USB_OTG_EP0_OutStart(pdev);  
 8019ada:	f001 bccd 	b.w	801b478 <USB_OTG_EP0_OutStart>
	...

08019ae0 <USBD_StdDevReq>:
{
 8019ae0:	b570      	push	{r4, r5, r6, lr}
  switch (req->bRequest) 
 8019ae2:	784b      	ldrb	r3, [r1, #1]
 8019ae4:	2b09      	cmp	r3, #9
{
 8019ae6:	b0a0      	sub	sp, #128	@ 0x80
 8019ae8:	4604      	mov	r4, r0
 8019aea:	460d      	mov	r5, r1
  switch (req->bRequest) 
 8019aec:	d80d      	bhi.n	8019b0a <USBD_StdDevReq+0x2a>
 8019aee:	2b09      	cmp	r3, #9
 8019af0:	d80e      	bhi.n	8019b10 <USBD_StdDevReq+0x30>
 8019af2:	e8df f013 	tbh	[pc, r3, lsl #1]
 8019af6:	00ca      	.short	0x00ca
 8019af8:	000d0109 	.word	0x000d0109
 8019afc:	000d00db 	.word	0x000d00db
 8019b00:	0011006d 	.word	0x0011006d
 8019b04:	00ba000d 	.word	0x00ba000d
 8019b08:	008b      	.short	0x008b
 8019b0a:	2b55      	cmp	r3, #85	@ 0x55
 8019b0c:	f000 8108 	beq.w	8019d20 <USBD_StdDevReq+0x240>
       USBD_CtlError(pdev , req);                     
 8019b10:	4620      	mov	r0, r4
 8019b12:	f7ff ffd6 	bl	8019ac2 <USBD_CtlError.constprop.0>
      break;
 8019b16:	e074      	b.n	8019c02 <USBD_StdDevReq+0x122>
  switch (req->wValue >> 8)
 8019b18:	8849      	ldrh	r1, [r1, #2]
 8019b1a:	0a0e      	lsrs	r6, r1, #8
 8019b1c:	2e02      	cmp	r6, #2
 8019b1e:	d024      	beq.n	8019b6a <USBD_StdDevReq+0x8a>
 8019b20:	2e03      	cmp	r6, #3
 8019b22:	d02c      	beq.n	8019b7e <USBD_StdDevReq+0x9e>
 8019b24:	2e01      	cmp	r6, #1
 8019b26:	d1f3      	bne.n	8019b10 <USBD_StdDevReq+0x30>
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8019b28:	f8d0 35ec 	ldr.w	r3, [r0, #1516]	@ 0x5ec
 8019b2c:	7880      	ldrb	r0, [r0, #2]
 8019b2e:	681b      	ldr	r3, [r3, #0]
 8019b30:	4669      	mov	r1, sp
 8019b32:	4798      	blx	r3
    if ((req->wLength == 64) ||( pdev->dev.device_status == USB_OTG_DEFAULT))  
 8019b34:	88eb      	ldrh	r3, [r5, #6]
 8019b36:	2b40      	cmp	r3, #64	@ 0x40
 8019b38:	d003      	beq.n	8019b42 <USBD_StdDevReq+0x62>
 8019b3a:	f894 3112 	ldrb.w	r3, [r4, #274]	@ 0x112
 8019b3e:	2b01      	cmp	r3, #1
 8019b40:	d102      	bne.n	8019b48 <USBD_StdDevReq+0x68>
      len = 8;
 8019b42:	2308      	movs	r3, #8
 8019b44:	f8ad 3000 	strh.w	r3, [sp]
  if((len != 0)&& (req->wLength != 0))
 8019b48:	f8bd 2000 	ldrh.w	r2, [sp]
 8019b4c:	2a00      	cmp	r2, #0
 8019b4e:	d058      	beq.n	8019c02 <USBD_StdDevReq+0x122>
 8019b50:	88eb      	ldrh	r3, [r5, #6]
 8019b52:	2b00      	cmp	r3, #0
 8019b54:	d055      	beq.n	8019c02 <USBD_StdDevReq+0x122>
    len = MIN(len , req->wLength);
 8019b56:	429a      	cmp	r2, r3
 8019b58:	bf28      	it	cs
 8019b5a:	461a      	movcs	r2, r3
 8019b5c:	f8ad 2000 	strh.w	r2, [sp]
    USBD_CtlSendData (pdev, 
 8019b60:	4601      	mov	r1, r0
      USBD_CtlSendData(pdev, (uint8_t *)midi_indicator, 0x80);
 8019b62:	4620      	mov	r0, r4
 8019b64:	f7ff ff72 	bl	8019a4c <USBD_CtlSendData>
    if( (req->bmRequest == 0xc0) && (req->wValue == 0) && (req->wLength == 0x0080) ) {
 8019b68:	e04b      	b.n	8019c02 <USBD_StdDevReq+0x122>
      pbuf   = (uint8_t *)pdev->dev.class_cb->GetConfigDescriptor(pdev->cfg.speed, &len);
 8019b6a:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 8019b6e:	7880      	ldrb	r0, [r0, #2]
 8019b70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8019b72:	4669      	mov	r1, sp
 8019b74:	4798      	blx	r3
    pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8019b76:	7046      	strb	r6, [r0, #1]
    pdev->dev.pConfig_descriptor = pbuf;    
 8019b78:	f8c4 05f0 	str.w	r0, [r4, #1520]	@ 0x5f0
    break;
 8019b7c:	e7e4      	b.n	8019b48 <USBD_StdDevReq+0x68>
    switch ((uint8_t)(req->wValue))
 8019b7e:	b2c9      	uxtb	r1, r1
    pbuf = pdev->dev.usr_device->GetDeviceDescriptor(pdev->cfg.speed, &len);
 8019b80:	7880      	ldrb	r0, [r0, #2]
 8019b82:	2905      	cmp	r1, #5
 8019b84:	d81e      	bhi.n	8019bc4 <USBD_StdDevReq+0xe4>
 8019b86:	e8df f001 	tbb	[pc, r1]
 8019b8a:	0903      	.short	0x0903
 8019b8c:	1915110d 	.word	0x1915110d
     pbuf = pdev->dev.usr_device->GetLangIDStrDescriptor(pdev->cfg.speed, &len);        
 8019b90:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019b94:	685b      	ldr	r3, [r3, #4]
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 8019b96:	4669      	mov	r1, sp
 8019b98:	4798      	blx	r3
      break;
 8019b9a:	e7d5      	b.n	8019b48 <USBD_StdDevReq+0x68>
      pbuf = pdev->dev.usr_device->GetManufacturerStrDescriptor(pdev->cfg.speed, &len);
 8019b9c:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019ba0:	689b      	ldr	r3, [r3, #8]
 8019ba2:	e7f8      	b.n	8019b96 <USBD_StdDevReq+0xb6>
      pbuf = pdev->dev.usr_device->GetProductStrDescriptor(pdev->cfg.speed, &len);
 8019ba4:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019ba8:	68db      	ldr	r3, [r3, #12]
 8019baa:	e7f4      	b.n	8019b96 <USBD_StdDevReq+0xb6>
      pbuf = pdev->dev.usr_device->GetSerialStrDescriptor(pdev->cfg.speed, &len);
 8019bac:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019bb0:	691b      	ldr	r3, [r3, #16]
 8019bb2:	e7f0      	b.n	8019b96 <USBD_StdDevReq+0xb6>
      pbuf = pdev->dev.usr_device->GetConfigurationStrDescriptor(pdev->cfg.speed, &len);
 8019bb4:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019bb8:	695b      	ldr	r3, [r3, #20]
 8019bba:	e7ec      	b.n	8019b96 <USBD_StdDevReq+0xb6>
      pbuf = pdev->dev.usr_device->GetInterfaceStrDescriptor(pdev->cfg.speed, &len);
 8019bbc:	f8d4 35ec 	ldr.w	r3, [r4, #1516]	@ 0x5ec
 8019bc0:	699b      	ldr	r3, [r3, #24]
 8019bc2:	e7e8      	b.n	8019b96 <USBD_StdDevReq+0xb6>
      pbuf = pdev->dev.class_cb->GetUsrStrDescriptor(pdev->cfg.speed, (req->wValue) , &len);
 8019bc4:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	@ 0x5e4
 8019bc8:	466a      	mov	r2, sp
 8019bca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8019bcc:	4798      	blx	r3
      break;
 8019bce:	e7bb      	b.n	8019b48 <USBD_StdDevReq+0x68>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8019bd0:	888b      	ldrh	r3, [r1, #4]
 8019bd2:	2b00      	cmp	r3, #0
 8019bd4:	d19c      	bne.n	8019b10 <USBD_StdDevReq+0x30>
 8019bd6:	88cb      	ldrh	r3, [r1, #6]
 8019bd8:	2b00      	cmp	r3, #0
 8019bda:	d199      	bne.n	8019b10 <USBD_StdDevReq+0x30>
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 8019bdc:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8019be0:	884d      	ldrh	r5, [r1, #2]
    if (pdev->dev.device_status == USB_OTG_CONFIGURED) 
 8019be2:	2b03      	cmp	r3, #3
 8019be4:	d094      	beq.n	8019b10 <USBD_StdDevReq+0x30>
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8019be6:	f005 057f 	and.w	r5, r5, #127	@ 0x7f
      pdev->dev.device_address = dev_addr;
 8019bea:	f880 5114 	strb.w	r5, [r0, #276]	@ 0x114
      DCD_EP_SetAddress(pdev, dev_addr);               
 8019bee:	4629      	mov	r1, r5
 8019bf0:	f001 fd45 	bl	801b67e <DCD_EP_SetAddress>
      USBD_CtlSendStatus(pdev);                         
 8019bf4:	4620      	mov	r0, r4
 8019bf6:	f7ff ff46 	bl	8019a86 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 8019bfa:	b12d      	cbz	r5, 8019c08 <USBD_StdDevReq+0x128>
        pdev->dev.device_status  = USB_OTG_ADDRESSED;
 8019bfc:	2302      	movs	r3, #2
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 8019bfe:	f884 3112 	strb.w	r3, [r4, #274]	@ 0x112
}
 8019c02:	2000      	movs	r0, #0
 8019c04:	b020      	add	sp, #128	@ 0x80
 8019c06:	bd70      	pop	{r4, r5, r6, pc}
        pdev->dev.device_status  = USB_OTG_DEFAULT; 
 8019c08:	2301      	movs	r3, #1
 8019c0a:	e7f8      	b.n	8019bfe <USBD_StdDevReq+0x11e>
  cfgidx = (uint8_t)(req->wValue);                 
 8019c0c:	7889      	ldrb	r1, [r1, #2]
 8019c0e:	4d4e      	ldr	r5, [pc, #312]	@ (8019d48 <USBD_StdDevReq+0x268>)
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8019c10:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);                 
 8019c12:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_CFG_MAX_NUM ) 
 8019c14:	f63f af7c 	bhi.w	8019b10 <USBD_StdDevReq+0x30>
    switch (pdev->dev.device_status) 
 8019c18:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019c1c:	2b02      	cmp	r3, #2
 8019c1e:	d00e      	beq.n	8019c3e <USBD_StdDevReq+0x15e>
 8019c20:	2b03      	cmp	r3, #3
 8019c22:	f47f af75 	bne.w	8019b10 <USBD_StdDevReq+0x30>
      if (cfgidx == 0) 
 8019c26:	b9b1      	cbnz	r1, 8019c56 <USBD_StdDevReq+0x176>
        pdev->dev.device_status = USB_OTG_ADDRESSED;
 8019c28:	2302      	movs	r3, #2
 8019c2a:	f880 3112 	strb.w	r3, [r0, #274]	@ 0x112
        pdev->dev.device_config = cfgidx;          
 8019c2e:	f880 1110 	strb.w	r1, [r0, #272]	@ 0x110
        USBD_ClrCfg(pdev , cfgidx);
 8019c32:	f7ff ff04 	bl	8019a3e <USBD_ClrCfg>
    USBD_CtlSendStatus(pdev);
 8019c36:	4620      	mov	r0, r4
 8019c38:	f7ff ff25 	bl	8019a86 <USBD_CtlSendStatus>
 8019c3c:	e7e1      	b.n	8019c02 <USBD_StdDevReq+0x122>
      if (cfgidx) 
 8019c3e:	2900      	cmp	r1, #0
 8019c40:	d0f9      	beq.n	8019c36 <USBD_StdDevReq+0x156>
        pdev->dev.device_config = cfgidx;
 8019c42:	2101      	movs	r1, #1
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 8019c44:	2303      	movs	r3, #3
        pdev->dev.device_config = cfgidx;
 8019c46:	f880 1110 	strb.w	r1, [r0, #272]	@ 0x110
        pdev->dev.device_status = USB_OTG_CONFIGURED;
 8019c4a:	f880 3112 	strb.w	r3, [r0, #274]	@ 0x112
        USBD_SetCfg(pdev , cfgidx);
 8019c4e:	4620      	mov	r0, r4
 8019c50:	f7ff fee9 	bl	8019a26 <USBD_SetCfg>
        USBD_CtlSendStatus(pdev);
 8019c54:	e7ef      	b.n	8019c36 <USBD_StdDevReq+0x156>
      else  if (cfgidx != pdev->dev.device_config) 
 8019c56:	f890 1110 	ldrb.w	r1, [r0, #272]	@ 0x110
 8019c5a:	2901      	cmp	r1, #1
 8019c5c:	d0eb      	beq.n	8019c36 <USBD_StdDevReq+0x156>
        USBD_ClrCfg(pdev , pdev->dev.device_config);
 8019c5e:	f7ff feee 	bl	8019a3e <USBD_ClrCfg>
        pdev->dev.device_config = cfgidx;
 8019c62:	7829      	ldrb	r1, [r5, #0]
 8019c64:	f884 1110 	strb.w	r1, [r4, #272]	@ 0x110
 8019c68:	e7f1      	b.n	8019c4e <USBD_StdDevReq+0x16e>
  if (req->wLength != 1) 
 8019c6a:	88ca      	ldrh	r2, [r1, #6]
 8019c6c:	2a01      	cmp	r2, #1
 8019c6e:	f47f af4f 	bne.w	8019b10 <USBD_StdDevReq+0x30>
    switch (pdev->dev.device_status )  
 8019c72:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019c76:	2b02      	cmp	r3, #2
 8019c78:	d005      	beq.n	8019c86 <USBD_StdDevReq+0x1a6>
 8019c7a:	2b03      	cmp	r3, #3
 8019c7c:	f47f af48 	bne.w	8019b10 <USBD_StdDevReq+0x30>
      USBD_CtlSendData (pdev, 
 8019c80:	f500 7188 	add.w	r1, r0, #272	@ 0x110
 8019c84:	e76d      	b.n	8019b62 <USBD_StdDevReq+0x82>
      USBD_CtlSendData (pdev, 
 8019c86:	4931      	ldr	r1, [pc, #196]	@ (8019d4c <USBD_StdDevReq+0x26c>)
 8019c88:	e76b      	b.n	8019b62 <USBD_StdDevReq+0x82>
  switch (pdev->dev.device_status) 
 8019c8a:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019c8e:	3b02      	subs	r3, #2
 8019c90:	2b01      	cmp	r3, #1
 8019c92:	f63f af3d 	bhi.w	8019b10 <USBD_StdDevReq+0x30>
    USBD_cfg_status = 0x00;                                    
 8019c96:	4b2e      	ldr	r3, [pc, #184]	@ (8019d50 <USBD_StdDevReq+0x270>)
 8019c98:	2200      	movs	r2, #0
 8019c9a:	601a      	str	r2, [r3, #0]
    if (pdev->dev.DevRemoteWakeup) 
 8019c9c:	f8d0 2118 	ldr.w	r2, [r0, #280]	@ 0x118
 8019ca0:	b10a      	cbz	r2, 8019ca6 <USBD_StdDevReq+0x1c6>
      USBD_cfg_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8019ca2:	2202      	movs	r2, #2
 8019ca4:	601a      	str	r2, [r3, #0]
    USBD_CtlSendData (pdev, 
 8019ca6:	492a      	ldr	r1, [pc, #168]	@ (8019d50 <USBD_StdDevReq+0x270>)
 8019ca8:	2202      	movs	r2, #2
 8019caa:	e75a      	b.n	8019b62 <USBD_StdDevReq+0x82>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 8019cac:	884b      	ldrh	r3, [r1, #2]
 8019cae:	2b01      	cmp	r3, #1
 8019cb0:	d108      	bne.n	8019cc4 <USBD_StdDevReq+0x1e4>
    pdev->dev.DevRemoteWakeup = 1;  
 8019cb2:	f8c4 3118 	str.w	r3, [r4, #280]	@ 0x118
    pdev->dev.class_cb->Setup (pdev, req);   
 8019cb6:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	@ 0x5e4
 8019cba:	4629      	mov	r1, r5
 8019cbc:	689b      	ldr	r3, [r3, #8]
 8019cbe:	4620      	mov	r0, r4
 8019cc0:	4798      	blx	r3
 8019cc2:	e7b8      	b.n	8019c36 <USBD_StdDevReq+0x156>
  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 8019cc4:	2b02      	cmp	r3, #2
 8019cc6:	d19c      	bne.n	8019c02 <USBD_StdDevReq+0x122>
 8019cc8:	790b      	ldrb	r3, [r1, #4]
           ((req->wIndex & 0xFF) == 0))
 8019cca:	888a      	ldrh	r2, [r1, #4]
  else if ((req->wValue == USB_FEATURE_TEST_MODE) && 
 8019ccc:	2b00      	cmp	r3, #0
 8019cce:	d198      	bne.n	8019c02 <USBD_StdDevReq+0x122>
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8019cd0:	6903      	ldr	r3, [r0, #16]
    switch (test_mode) 
 8019cd2:	0a12      	lsrs	r2, r2, #8
 8019cd4:	3a01      	subs	r2, #1
    dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
 8019cd6:	685b      	ldr	r3, [r3, #4]
    switch (test_mode) 
 8019cd8:	2a04      	cmp	r2, #4
 8019cda:	d807      	bhi.n	8019cec <USBD_StdDevReq+0x20c>
 8019cdc:	e8df f002 	tbb	[pc, r2]
 8019ce0:	100e0c03 	.word	0x100e0c03
 8019ce4:	12          	.byte	0x12
 8019ce5:	00          	.byte	0x00
      dctl.b.tstctl = 1;
 8019ce6:	2201      	movs	r2, #1
      dctl.b.tstctl = 5;
 8019ce8:	f362 1306 	bfi	r3, r2, #4, #3
    SET_TEST_MODE = dctl;
 8019cec:	4a19      	ldr	r2, [pc, #100]	@ (8019d54 <USBD_StdDevReq+0x274>)
 8019cee:	6013      	str	r3, [r2, #0]
    pdev->dev.test_mode = 1;
 8019cf0:	2301      	movs	r3, #1
 8019cf2:	f884 3116 	strb.w	r3, [r4, #278]	@ 0x116
    USBD_CtlSendStatus(pdev);
 8019cf6:	e79e      	b.n	8019c36 <USBD_StdDevReq+0x156>
      dctl.b.tstctl = 2;
 8019cf8:	2202      	movs	r2, #2
 8019cfa:	e7f5      	b.n	8019ce8 <USBD_StdDevReq+0x208>
      dctl.b.tstctl = 3;
 8019cfc:	2203      	movs	r2, #3
 8019cfe:	e7f3      	b.n	8019ce8 <USBD_StdDevReq+0x208>
      dctl.b.tstctl = 4;
 8019d00:	2204      	movs	r2, #4
 8019d02:	e7f1      	b.n	8019ce8 <USBD_StdDevReq+0x208>
      dctl.b.tstctl = 5;
 8019d04:	2205      	movs	r2, #5
 8019d06:	e7ef      	b.n	8019ce8 <USBD_StdDevReq+0x208>
  switch (pdev->dev.device_status)
 8019d08:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019d0c:	3b02      	subs	r3, #2
 8019d0e:	2b01      	cmp	r3, #1
 8019d10:	f63f aefe 	bhi.w	8019b10 <USBD_StdDevReq+0x30>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8019d14:	884b      	ldrh	r3, [r1, #2]
 8019d16:	2b01      	cmp	r3, #1
 8019d18:	f47f af73 	bne.w	8019c02 <USBD_StdDevReq+0x122>
      pdev->dev.DevRemoteWakeup = 0; 
 8019d1c:	2300      	movs	r3, #0
 8019d1e:	e7c8      	b.n	8019cb2 <USBD_StdDevReq+0x1d2>
    if( (req->bmRequest == 0xc0) && (req->wValue == 0) && (req->wLength == 0x0080) ) {
 8019d20:	780b      	ldrb	r3, [r1, #0]
 8019d22:	2bc0      	cmp	r3, #192	@ 0xc0
 8019d24:	f47f aef4 	bne.w	8019b10 <USBD_StdDevReq+0x30>
 8019d28:	884b      	ldrh	r3, [r1, #2]
 8019d2a:	2b00      	cmp	r3, #0
 8019d2c:	f47f aef0 	bne.w	8019b10 <USBD_StdDevReq+0x30>
 8019d30:	88cd      	ldrh	r5, [r1, #6]
 8019d32:	2d80      	cmp	r5, #128	@ 0x80
 8019d34:	f47f aeec 	bne.w	8019b10 <USBD_StdDevReq+0x30>
      const uint8_t midi_indicator[128] = {
 8019d38:	4907      	ldr	r1, [pc, #28]	@ (8019d58 <USBD_StdDevReq+0x278>)
 8019d3a:	462a      	mov	r2, r5
 8019d3c:	4668      	mov	r0, sp
 8019d3e:	f009 fc6e 	bl	802361e <memcpy>
      USBD_CtlSendData(pdev, (uint8_t *)midi_indicator, 0x80);
 8019d42:	462a      	mov	r2, r5
 8019d44:	4669      	mov	r1, sp
 8019d46:	e70c      	b.n	8019b62 <USBD_StdDevReq+0x82>
 8019d48:	20004270 	.word	0x20004270
 8019d4c:	200042dc 	.word	0x200042dc
 8019d50:	200042d8 	.word	0x200042d8
 8019d54:	2000426c 	.word	0x2000426c
 8019d58:	080270ef 	.word	0x080270ef

08019d5c <USBD_StdItfReq>:
{
 8019d5c:	b538      	push	{r3, r4, r5, lr}
  switch (pdev->dev.device_status) 
 8019d5e:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019d62:	2b03      	cmp	r3, #3
{
 8019d64:	4604      	mov	r4, r0
 8019d66:	460d      	mov	r5, r1
  switch (pdev->dev.device_status) 
 8019d68:	d10d      	bne.n	8019d86 <USBD_StdItfReq+0x2a>
    if (LOBYTE(req->wIndex) <= USBD_ITF_MAX_NUM) 
 8019d6a:	790b      	ldrb	r3, [r1, #4]
 8019d6c:	2b01      	cmp	r3, #1
 8019d6e:	d80a      	bhi.n	8019d86 <USBD_StdItfReq+0x2a>
      pdev->dev.class_cb->Setup (pdev, req); 
 8019d70:	f8d0 35e4 	ldr.w	r3, [r0, #1508]	@ 0x5e4
 8019d74:	689b      	ldr	r3, [r3, #8]
 8019d76:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 8019d78:	88eb      	ldrh	r3, [r5, #6]
 8019d7a:	b913      	cbnz	r3, 8019d82 <USBD_StdItfReq+0x26>
         USBD_CtlSendStatus(pdev);
 8019d7c:	4620      	mov	r0, r4
 8019d7e:	f7ff fe82 	bl	8019a86 <USBD_CtlSendStatus>
}
 8019d82:	2000      	movs	r0, #0
 8019d84:	bd38      	pop	{r3, r4, r5, pc}
     USBD_CtlError(pdev , req);
 8019d86:	f7ff fe9c 	bl	8019ac2 <USBD_CtlError.constprop.0>
    break;
 8019d8a:	e7fa      	b.n	8019d82 <USBD_StdItfReq+0x26>

08019d8c <USBD_StdEPReq>:
{
 8019d8c:	b538      	push	{r3, r4, r5, lr}
 8019d8e:	460d      	mov	r5, r1
  ep_addr  = LOBYTE(req->wIndex);   
 8019d90:	888a      	ldrh	r2, [r1, #4]
  switch (req->bRequest) 
 8019d92:	786b      	ldrb	r3, [r5, #1]
  ep_addr  = LOBYTE(req->wIndex);   
 8019d94:	7909      	ldrb	r1, [r1, #4]
  switch (req->bRequest) 
 8019d96:	2b01      	cmp	r3, #1
{
 8019d98:	4604      	mov	r4, r0
  switch (req->bRequest) 
 8019d9a:	d03c      	beq.n	8019e16 <USBD_StdEPReq+0x8a>
 8019d9c:	2b03      	cmp	r3, #3
 8019d9e:	d01f      	beq.n	8019de0 <USBD_StdEPReq+0x54>
 8019da0:	bb3b      	cbnz	r3, 8019df2 <USBD_StdEPReq+0x66>
    switch (pdev->dev.device_status) 
 8019da2:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019da6:	2b02      	cmp	r3, #2
 8019da8:	d043      	beq.n	8019e32 <USBD_StdEPReq+0xa6>
 8019daa:	2b03      	cmp	r3, #3
 8019dac:	d11e      	bne.n	8019dec <USBD_StdEPReq+0x60>
      if ((ep_addr & 0x80)== 0x80)
 8019dae:	f012 0f80 	tst.w	r2, #128	@ 0x80
 8019db2:	f04f 0328 	mov.w	r3, #40	@ 0x28
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 8019db6:	bf1b      	ittet	ne
 8019db8:	f001 017f 	andne.w	r1, r1, #127	@ 0x7f
 8019dbc:	fb03 0101 	mlane	r1, r3, r1, r0
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8019dc0:	fb03 0101 	mlaeq	r1, r3, r1, r0
        if(pdev->dev.in_ep[ep_addr & 0x7F].is_stall)
 8019dc4:	f891 311e 	ldrbne.w	r3, [r1, #286]	@ 0x11e
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8019dc8:	bf08      	it	eq
 8019dca:	f891 3376 	ldrbeq.w	r3, [r1, #886]	@ 0x376
          USBD_ep_status = 0x0000;  
 8019dce:	491b      	ldr	r1, [pc, #108]	@ (8019e3c <USBD_StdEPReq+0xb0>)
        if(pdev->dev.out_ep[ep_addr].is_stall)
 8019dd0:	3b00      	subs	r3, #0
 8019dd2:	bf18      	it	ne
 8019dd4:	2301      	movne	r3, #1
      USBD_CtlSendData (pdev,
 8019dd6:	2202      	movs	r2, #2
          USBD_ep_status = 0x0000;  
 8019dd8:	600b      	str	r3, [r1, #0]
      USBD_CtlSendData (pdev,
 8019dda:	f7ff fe37 	bl	8019a4c <USBD_CtlSendData>
      break;
 8019dde:	e008      	b.n	8019df2 <USBD_StdEPReq+0x66>
    switch (pdev->dev.device_status) 
 8019de0:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019de4:	2b02      	cmp	r3, #2
 8019de6:	d024      	beq.n	8019e32 <USBD_StdEPReq+0xa6>
 8019de8:	2b03      	cmp	r3, #3
 8019dea:	d004      	beq.n	8019df6 <USBD_StdEPReq+0x6a>
      USBD_CtlError(pdev , req);
 8019dec:	4620      	mov	r0, r4
 8019dee:	f7ff fe68 	bl	8019ac2 <USBD_CtlError.constprop.0>
}
 8019df2:	2000      	movs	r0, #0
 8019df4:	bd38      	pop	{r3, r4, r5, pc}
      if (req->wValue == USB_FEATURE_EP_HALT)
 8019df6:	886b      	ldrh	r3, [r5, #2]
 8019df8:	b91b      	cbnz	r3, 8019e02 <USBD_StdEPReq+0x76>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8019dfa:	064b      	lsls	r3, r1, #25
 8019dfc:	d001      	beq.n	8019e02 <USBD_StdEPReq+0x76>
          DCD_EP_Stall(pdev , ep_addr);
 8019dfe:	f001 fc0c 	bl	801b61a <DCD_EP_Stall>
          pdev->dev.class_cb->Setup (pdev, req);
 8019e02:	f8d4 35e4 	ldr.w	r3, [r4, #1508]	@ 0x5e4
 8019e06:	4629      	mov	r1, r5
 8019e08:	689b      	ldr	r3, [r3, #8]
 8019e0a:	4620      	mov	r0, r4
 8019e0c:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8019e0e:	4620      	mov	r0, r4
 8019e10:	f7ff fe39 	bl	8019a86 <USBD_CtlSendStatus>
 8019e14:	e7ed      	b.n	8019df2 <USBD_StdEPReq+0x66>
    switch (pdev->dev.device_status) 
 8019e16:	f890 3112 	ldrb.w	r3, [r0, #274]	@ 0x112
 8019e1a:	2b02      	cmp	r3, #2
 8019e1c:	d009      	beq.n	8019e32 <USBD_StdEPReq+0xa6>
 8019e1e:	2b03      	cmp	r3, #3
 8019e20:	d1e4      	bne.n	8019dec <USBD_StdEPReq+0x60>
      if (req->wValue == USB_FEATURE_EP_HALT)
 8019e22:	886b      	ldrh	r3, [r5, #2]
 8019e24:	2b00      	cmp	r3, #0
 8019e26:	d1e4      	bne.n	8019df2 <USBD_StdEPReq+0x66>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8019e28:	064a      	lsls	r2, r1, #25
 8019e2a:	d0f0      	beq.n	8019e0e <USBD_StdEPReq+0x82>
          DCD_EP_ClrStall(pdev , ep_addr);
 8019e2c:	f001 fc0e 	bl	801b64c <DCD_EP_ClrStall>
 8019e30:	e7e7      	b.n	8019e02 <USBD_StdEPReq+0x76>
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8019e32:	064b      	lsls	r3, r1, #25
 8019e34:	d0dd      	beq.n	8019df2 <USBD_StdEPReq+0x66>
        DCD_EP_Stall(pdev , ep_addr);
 8019e36:	f001 fbf0 	bl	801b61a <DCD_EP_Stall>
 8019e3a:	e7da      	b.n	8019df2 <USBD_StdEPReq+0x66>
 8019e3c:	200042e0 	.word	0x200042e0

08019e40 <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdev->dev.setup_packet);
 8019e40:	f890 35cc 	ldrb.w	r3, [r0, #1484]	@ 0x5cc
 8019e44:	700b      	strb	r3, [r1, #0]
  req->bRequest      = *(uint8_t *)  (pdev->dev.setup_packet +  1);
 8019e46:	f890 35cd 	ldrb.w	r3, [r0, #1485]	@ 0x5cd
 8019e4a:	704b      	strb	r3, [r1, #1]
  req->wValue        = SWAPBYTE      (pdev->dev.setup_packet +  2);
 8019e4c:	f8b0 35ce 	ldrh.w	r3, [r0, #1486]	@ 0x5ce
 8019e50:	804b      	strh	r3, [r1, #2]
  req->wIndex        = SWAPBYTE      (pdev->dev.setup_packet +  4);
 8019e52:	f8b0 35d0 	ldrh.w	r3, [r0, #1488]	@ 0x5d0
 8019e56:	808b      	strh	r3, [r1, #4]
  req->wLength       = SWAPBYTE      (pdev->dev.setup_packet +  6);
 8019e58:	f8b0 35d2 	ldrh.w	r3, [r0, #1490]	@ 0x5d2
 8019e5c:	80cb      	strh	r3, [r1, #6]
  pdev->dev.in_ep[0].ctl_data_len = req->wLength  ;
 8019e5e:	f8c0 3140 	str.w	r3, [r0, #320]	@ 0x140
  pdev->dev.device_state = USB_OTG_EP0_SETUP;
 8019e62:	2301      	movs	r3, #1
 8019e64:	f880 3111 	strb.w	r3, [r0, #273]	@ 0x111
}
 8019e68:	4770      	bx	lr

08019e6a <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 8019e6a:	b570      	push	{r4, r5, r6, lr}
 8019e6c:	460d      	mov	r5, r1
 8019e6e:	4616      	mov	r6, r2
  uint8_t idx = 0;
  
  if (desc != NULL) 
 8019e70:	4604      	mov	r4, r0
 8019e72:	b170      	cbz	r0, 8019e92 <USBD_GetString+0x28>
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != NULL) 
 8019e74:	f009 fb4a 	bl	802350c <strlen>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 8019e78:	b2c3      	uxtb	r3, r0
 8019e7a:	3301      	adds	r3, #1
 8019e7c:	005b      	lsls	r3, r3, #1
 8019e7e:	8033      	strh	r3, [r6, #0]
    unicode[idx++] = *len;
 8019e80:	702b      	strb	r3, [r5, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8019e82:	2303      	movs	r3, #3
 8019e84:	706b      	strb	r3, [r5, #1]
    while (*desc != NULL) 
 8019e86:	3c01      	subs	r4, #1
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 8019e88:	2302      	movs	r3, #2
      unicode[idx++] =  0x00;
 8019e8a:	2000      	movs	r0, #0
    while (*desc != NULL) 
 8019e8c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8019e90:	b901      	cbnz	r1, 8019e94 <USBD_GetString+0x2a>
}
 8019e92:	bd70      	pop	{r4, r5, r6, pc}
      unicode[idx++] = *desc++;
 8019e94:	1c5a      	adds	r2, r3, #1
 8019e96:	b2d2      	uxtb	r2, r2
 8019e98:	54e9      	strb	r1, [r5, r3]
      unicode[idx++] =  0x00;
 8019e9a:	3302      	adds	r3, #2
 8019e9c:	54a8      	strb	r0, [r5, r2]
 8019e9e:	b2db      	uxtb	r3, r3
 8019ea0:	e7f4      	b.n	8019e8c <USBD_GetString+0x22>

08019ea2 <USBH_Connected>:
  * @param  selected device
  * @retval Status
*/
uint8_t USBH_Connected (USB_OTG_CORE_HANDLE *pdev)
{
  pdev->host.ConnSts = 1;
 8019ea2:	2301      	movs	r3, #1
 8019ea4:	f8c0 37f4 	str.w	r3, [r0, #2036]	@ 0x7f4
  return 0;
}
 8019ea8:	2000      	movs	r0, #0
 8019eaa:	4770      	bx	lr

08019eac <USBH_Disconnected>:
* @param  selected device
* @retval Status
*/

uint8_t USBH_Disconnected (USB_OTG_CORE_HANDLE *pdev)
{
 8019eac:	4603      	mov	r3, r0
  pdev->host.ConnSts = 0;
 8019eae:	2000      	movs	r0, #0
 8019eb0:	f8c3 07f4 	str.w	r0, [r3, #2036]	@ 0x7f4
  return 0;  
}
 8019eb4:	4770      	bx	lr

08019eb6 <USBH_SOF>:

uint8_t USBH_SOF (USB_OTG_CORE_HANDLE *pdev)
{
  /* This callback could be used to implement a scheduler process */
  return 0;  
}
 8019eb6:	2000      	movs	r0, #0
 8019eb8:	4770      	bx	lr

08019eba <USBH_DeInit>:
  *         Re-Initialize Host
  * @param  None 
  * @retval status: USBH_Status
  */
USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8019eba:	b538      	push	{r3, r4, r5, lr}
  /* Software Init */
  
  phost->gState = HOST_IDLE;
 8019ebc:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8019ec0:	600b      	str	r3, [r1, #0]
  phost->gStateBkp = HOST_IDLE; 
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;  
  
  phost->Control.state = CTRL_SETUP;
 8019ec2:	2301      	movs	r3, #1
 8019ec4:	770b      	strb	r3, [r1, #28]
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8019ec6:	2340      	movs	r3, #64	@ 0x40
{
 8019ec8:	460c      	mov	r4, r1
  phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
 8019eca:	718b      	strb	r3, [r1, #6]
  
  phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
 8019ecc:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8019ed0:	840b      	strh	r3, [r1, #32]
{
 8019ed2:	4605      	mov	r5, r0
  phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
  
  USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
 8019ed4:	7909      	ldrb	r1, [r1, #4]
 8019ed6:	f000 fb0e 	bl	801a4f6 <USBH_Free_Channel>
  USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
 8019eda:	7961      	ldrb	r1, [r4, #5]
 8019edc:	4628      	mov	r0, r5
 8019ede:	f000 fb0a 	bl	801a4f6 <USBH_Free_Channel>
  return USBH_OK;
}
 8019ee2:	2000      	movs	r0, #0
 8019ee4:	bd38      	pop	{r3, r4, r5, pc}

08019ee6 <USBH_Init>:
{
 8019ee6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8019eea:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8019eee:	4614      	mov	r4, r2
 8019ef0:	461f      	mov	r7, r3
 8019ef2:	4605      	mov	r5, r0
 8019ef4:	460e      	mov	r6, r1
  USB_OTG_BSP_Init(pdev);  
 8019ef6:	f7fd fd39 	bl	801796c <USB_OTG_BSP_Init>
  USB_OTG_BSP_ConfigVBUS(0);  
 8019efa:	2000      	movs	r0, #0
 8019efc:	f7fd fd9e 	bl	8017a3c <USB_OTG_BSP_ConfigVBUS>
  USBH_DeInit(pdev, phost);
 8019f00:	4621      	mov	r1, r4
 8019f02:	4628      	mov	r0, r5
 8019f04:	f7ff ffd9 	bl	8019eba <USBH_DeInit>
   HCD_Init(pdev , coreID);
 8019f08:	4631      	mov	r1, r6
  phost->usr_cb = usr_cb;  
 8019f0a:	e9c4 781f 	strd	r7, r8, [r4, #124]	@ 0x7c
   HCD_Init(pdev , coreID);
 8019f0e:	4628      	mov	r0, r5
 8019f10:	f001 fdf8 	bl	801bb04 <HCD_Init>
  phost->usr_cb->Init();
 8019f14:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 8019f18:	681b      	ldr	r3, [r3, #0]
 8019f1a:	4798      	blx	r3
  USB_OTG_BSP_EnableInterrupt(pdev);
 8019f1c:	4628      	mov	r0, r5
}
 8019f1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  USB_OTG_BSP_EnableInterrupt(pdev);
 8019f22:	f7fd bd69 	b.w	80179f8 <USB_OTG_BSP_EnableInterrupt>

08019f26 <USBH_ErrorHandle>:
  * @retval None
  */
void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
{
  /* Error unrecovered or not supported device speed */
  if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
 8019f26:	1f0b      	subs	r3, r1, #4
 8019f28:	2b01      	cmp	r3, #1
{
 8019f2a:	b510      	push	{r4, lr}
 8019f2c:	4604      	mov	r4, r0
  if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
 8019f2e:	d806      	bhi.n	8019f3e <USBH_ErrorHandle+0x18>
       (errType == USBH_UNRECOVERED_ERROR) )
  {
    phost->usr_cb->UnrecoveredError(); 
 8019f30:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
 8019f34:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8019f36:	4798      	blx	r3
    phost->gState = HOST_ERROR_STATE;   
 8019f38:	230a      	movs	r3, #10
 8019f3a:	7023      	strb	r3, [r4, #0]
  {
    phost->gState = HOST_ERROR_STATE;  
    /* user callback for initalization */
    phost->usr_cb->Init();
  } 
}
 8019f3c:	bd10      	pop	{r4, pc}
  else if(errType == USBH_APPLY_DEINIT)
 8019f3e:	2906      	cmp	r1, #6
 8019f40:	d1fc      	bne.n	8019f3c <USBH_ErrorHandle+0x16>
    phost->gState = HOST_ERROR_STATE;  
 8019f42:	230a      	movs	r3, #10
 8019f44:	7003      	strb	r3, [r0, #0]
    phost->usr_cb->Init();
 8019f46:	f8d0 3080 	ldr.w	r3, [r0, #128]	@ 0x80
}
 8019f4a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    phost->usr_cb->Init();
 8019f4e:	681b      	ldr	r3, [r3, #0]
 8019f50:	4718      	bx	r3
	...

08019f54 <USBH_HandleControl>:
  *         Handles the USB control transfer state machine
  * @param  pdev: Selected device
  * @retval Status
  */
USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
{
 8019f54:	b570      	push	{r4, r5, r6, lr}
  uint8_t direction;  
  static uint16_t timeout = 0;
  USBH_Status status = USBH_OK;
  URB_STATE URB_Status = URB_IDLE;
  
  phost->Control.status = CTRL_START;
 8019f56:	2300      	movs	r3, #0
 8019f58:	748b      	strb	r3, [r1, #18]

  
  switch (phost->Control.state)
 8019f5a:	7f0b      	ldrb	r3, [r1, #28]
 8019f5c:	3b01      	subs	r3, #1
{
 8019f5e:	4605      	mov	r5, r0
 8019f60:	460c      	mov	r4, r1
  switch (phost->Control.state)
 8019f62:	2b0a      	cmp	r3, #10
 8019f64:	d824      	bhi.n	8019fb0 <USBH_HandleControl+0x5c>
 8019f66:	e8df f003 	tbb	[pc, r3]
 8019f6a:	0d06      	.short	0x0d06
 8019f6c:	60543a33 	.word	0x60543a33
 8019f70:	a3947871 	.word	0xa3947871
 8019f74:	b0          	.byte	0xb0
 8019f75:	00          	.byte	0x00
  {
  case CTRL_SETUP:
    /* send a SETUP packet */
    USBH_CtlSendSetup     (pdev, 
 8019f76:	794a      	ldrb	r2, [r1, #5]
 8019f78:	3114      	adds	r1, #20
 8019f7a:	f000 faf5 	bl	801a568 <USBH_CtlSendSetup>
	                   phost->Control.setup.d8 , 
	                   phost->Control.hc_num_out);  
    phost->Control.state = CTRL_SETUP_WAIT;  
 8019f7e:	2302      	movs	r3, #2
    accepted.
    */
    if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
    {
      /* Do the transmission again, starting from SETUP Packet */
      phost->Control.state = CTRL_SETUP; 
 8019f80:	7723      	strb	r3, [r4, #28]
 8019f82:	e015      	b.n	8019fb0 <USBH_HandleControl+0x5c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
 8019f84:	7949      	ldrb	r1, [r1, #5]
 8019f86:	f001 fdf9 	bl	801bb7c <HCD_GetURB_State>
    if(URB_Status == URB_DONE)
 8019f8a:	2801      	cmp	r0, #1
 8019f8c:	d119      	bne.n	8019fc2 <USBH_HandleControl+0x6e>
      if (phost->Control.setup.b.wLength.w != 0 )
 8019f8e:	8b62      	ldrh	r2, [r4, #26]
 8019f90:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8019f94:	b172      	cbz	r2, 8019fb4 <USBH_HandleControl+0x60>
        if (direction == USB_D2H)
 8019f96:	2b00      	cmp	r3, #0
 8019f98:	f241 3288 	movw	r2, #5000	@ 0x1388
 8019f9c:	bfb4      	ite	lt
 8019f9e:	2303      	movlt	r3, #3
 8019fa0:	2305      	movge	r3, #5
        timeout = DATA_STAGE_TIMEOUT;
 8019fa2:	4951      	ldr	r1, [pc, #324]	@ (801a0e8 <USBH_HandleControl+0x194>)
          phost->Control.state = CTRL_DATA_OUT;
 8019fa4:	7723      	strb	r3, [r4, #28]
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
 8019fa6:	4628      	mov	r0, r5
        timeout = DATA_STAGE_TIMEOUT;
 8019fa8:	800a      	strh	r2, [r1, #0]
      phost->Control.timer = HCD_GetCurrentFrame(pdev);
 8019faa:	f001 fde3 	bl	801bb74 <HCD_GetCurrentFrame>
 8019fae:	8220      	strh	r0, [r4, #16]
  USBH_Status status = USBH_OK;
 8019fb0:	2000      	movs	r0, #0
    
  default:
    break;
  }
  return status;
}
 8019fb2:	bd70      	pop	{r4, r5, r6, pc}
        if (direction == USB_D2H)
 8019fb4:	2b00      	cmp	r3, #0
 8019fb6:	f04f 0232 	mov.w	r2, #50	@ 0x32
 8019fba:	bfb4      	ite	lt
 8019fbc:	2309      	movlt	r3, #9
 8019fbe:	2307      	movge	r3, #7
 8019fc0:	e7ef      	b.n	8019fa2 <USBH_HandleControl+0x4e>
    else if(URB_Status == URB_ERROR)
 8019fc2:	2803      	cmp	r0, #3
 8019fc4:	d1f4      	bne.n	8019fb0 <USBH_HandleControl+0x5c>
      phost->Control.state = CTRL_ERROR;     
 8019fc6:	230b      	movs	r3, #11
 8019fc8:	7723      	strb	r3, [r4, #28]
      phost->Control.status = CTRL_XACTERR;
 8019fca:	2305      	movs	r3, #5
 8019fcc:	74a3      	strb	r3, [r4, #18]
 8019fce:	e7ef      	b.n	8019fb0 <USBH_HandleControl+0x5c>
    USBH_CtlReceiveData(pdev,
 8019fd0:	790b      	ldrb	r3, [r1, #4]
 8019fd2:	898a      	ldrh	r2, [r1, #12]
 8019fd4:	6889      	ldr	r1, [r1, #8]
 8019fd6:	f000 fb03 	bl	801a5e0 <USBH_CtlReceiveData>
    phost->Control.state = CTRL_DATA_IN_WAIT;
 8019fda:	2304      	movs	r3, #4
 8019fdc:	e7d0      	b.n	8019f80 <USBH_HandleControl+0x2c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 8019fde:	7909      	ldrb	r1, [r1, #4]
 8019fe0:	f001 fdcc 	bl	801bb7c <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 8019fe4:	2801      	cmp	r0, #1
 8019fe6:	d10b      	bne.n	801a000 <USBH_HandleControl+0xac>
      phost->Control.state = CTRL_STATUS_OUT;
 8019fe8:	2309      	movs	r3, #9
 8019fea:	7723      	strb	r3, [r4, #28]
    else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
 8019fec:	4628      	mov	r0, r5
 8019fee:	f001 fdc1 	bl	801bb74 <HCD_GetCurrentFrame>
 8019ff2:	8a23      	ldrh	r3, [r4, #16]
 8019ff4:	1ac0      	subs	r0, r0, r3
 8019ff6:	4b3c      	ldr	r3, [pc, #240]	@ (801a0e8 <USBH_HandleControl+0x194>)
 8019ff8:	881b      	ldrh	r3, [r3, #0]
 8019ffa:	4298      	cmp	r0, r3
 8019ffc:	d807      	bhi.n	801a00e <USBH_HandleControl+0xba>
 8019ffe:	e7d7      	b.n	8019fb0 <USBH_HandleControl+0x5c>
    if  (URB_Status == URB_STALL) 
 801a000:	2804      	cmp	r0, #4
 801a002:	d102      	bne.n	801a00a <USBH_HandleControl+0xb6>
      phost->gState =   phost->gStateBkp;
 801a004:	7863      	ldrb	r3, [r4, #1]
 801a006:	7023      	strb	r3, [r4, #0]
 801a008:	e7d2      	b.n	8019fb0 <USBH_HandleControl+0x5c>
    else if (URB_Status == URB_ERROR)
 801a00a:	2803      	cmp	r0, #3
 801a00c:	d1ee      	bne.n	8019fec <USBH_HandleControl+0x98>
      phost->Control.state = CTRL_ERROR;    
 801a00e:	230b      	movs	r3, #11
 801a010:	e7b6      	b.n	8019f80 <USBH_HandleControl+0x2c>
    pdev->host.hc[phost->Control.hc_num_out].toggle_out = 1; 
 801a012:	794b      	ldrb	r3, [r1, #5]
 801a014:	eb00 1243 	add.w	r2, r0, r3, lsl #5
 801a018:	2101      	movs	r1, #1
 801a01a:	f882 18a9 	strb.w	r1, [r2, #2217]	@ 0x8a9
    USBH_CtlSendData (pdev,
 801a01e:	89a2      	ldrh	r2, [r4, #12]
 801a020:	68a1      	ldr	r1, [r4, #8]
 801a022:	f000 fab8 	bl	801a596 <USBH_CtlSendData>
    phost->Control.state = CTRL_DATA_OUT_WAIT;
 801a026:	2306      	movs	r3, #6
 801a028:	e7aa      	b.n	8019f80 <USBH_HandleControl+0x2c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
 801a02a:	7949      	ldrb	r1, [r1, #5]
 801a02c:	f001 fda6 	bl	801bb7c <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 801a030:	2801      	cmp	r0, #1
 801a032:	d101      	bne.n	801a038 <USBH_HandleControl+0xe4>
      phost->Control.state = CTRL_STATUS_IN;
 801a034:	2307      	movs	r3, #7
 801a036:	e7a3      	b.n	8019f80 <USBH_HandleControl+0x2c>
    else if  (URB_Status == URB_STALL) 
 801a038:	2804      	cmp	r0, #4
 801a03a:	d103      	bne.n	801a044 <USBH_HandleControl+0xf0>
      phost->gState =   phost->gStateBkp;
 801a03c:	7863      	ldrb	r3, [r4, #1]
 801a03e:	7023      	strb	r3, [r4, #0]
      phost->Control.state = CTRL_STALLED;  
 801a040:	230c      	movs	r3, #12
 801a042:	e79d      	b.n	8019f80 <USBH_HandleControl+0x2c>
    else if  (URB_Status == URB_NOTREADY)
 801a044:	2802      	cmp	r0, #2
 801a046:	d13c      	bne.n	801a0c2 <USBH_HandleControl+0x16e>
      phost->Control.state = CTRL_DATA_OUT;
 801a048:	2305      	movs	r3, #5
 801a04a:	e799      	b.n	8019f80 <USBH_HandleControl+0x2c>
    USBH_CtlReceiveData (pdev,
 801a04c:	2200      	movs	r2, #0
 801a04e:	790b      	ldrb	r3, [r1, #4]
 801a050:	4611      	mov	r1, r2
 801a052:	f000 fac5 	bl	801a5e0 <USBH_CtlReceiveData>
    phost->Control.state = CTRL_STATUS_IN_WAIT;
 801a056:	2308      	movs	r3, #8
 801a058:	e792      	b.n	8019f80 <USBH_HandleControl+0x2c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 801a05a:	7909      	ldrb	r1, [r1, #4]
 801a05c:	f001 fd8e 	bl	801bb7c <HCD_GetURB_State>
    if  ( URB_Status == URB_DONE)
 801a060:	2801      	cmp	r0, #1
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
 801a062:	4606      	mov	r6, r0
    if  ( URB_Status == URB_DONE)
 801a064:	d103      	bne.n	801a06e <USBH_HandleControl+0x11a>
      phost->gState =   phost->gStateBkp; 
 801a066:	7863      	ldrb	r3, [r4, #1]
 801a068:	7023      	strb	r3, [r4, #0]
      phost->Control.state = CTRL_COMPLETE; 
 801a06a:	230d      	movs	r3, #13
 801a06c:	e788      	b.n	8019f80 <USBH_HandleControl+0x2c>
    else if (URB_Status == URB_ERROR)
 801a06e:	2803      	cmp	r0, #3
 801a070:	d0cd      	beq.n	801a00e <USBH_HandleControl+0xba>
    else if((HCD_GetCurrentFrame(pdev)\
 801a072:	4628      	mov	r0, r5
 801a074:	f001 fd7e 	bl	801bb74 <HCD_GetCurrentFrame>
      - phost->Control.timer) > timeout)
 801a078:	8a23      	ldrh	r3, [r4, #16]
 801a07a:	1ac0      	subs	r0, r0, r3
 801a07c:	4b1a      	ldr	r3, [pc, #104]	@ (801a0e8 <USBH_HandleControl+0x194>)
 801a07e:	881b      	ldrh	r3, [r3, #0]
    else if((HCD_GetCurrentFrame(pdev)\
 801a080:	4298      	cmp	r0, r3
 801a082:	d8c4      	bhi.n	801a00e <USBH_HandleControl+0xba>
     else if(URB_Status == URB_STALL)
 801a084:	2e04      	cmp	r6, #4
 801a086:	d193      	bne.n	8019fb0 <USBH_HandleControl+0x5c>
      phost->gState =   phost->gStateBkp;
 801a088:	7863      	ldrb	r3, [r4, #1]
 801a08a:	7023      	strb	r3, [r4, #0]
      phost->Control.status = CTRL_STALL;
 801a08c:	74a6      	strb	r6, [r4, #18]
      status = USBH_NOT_SUPPORTED;
 801a08e:	2003      	movs	r0, #3
 801a090:	e78f      	b.n	8019fb2 <USBH_HandleControl+0x5e>
    pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
 801a092:	794b      	ldrb	r3, [r1, #5]
 801a094:	eb00 1243 	add.w	r2, r0, r3, lsl #5
 801a098:	f892 18a9 	ldrb.w	r1, [r2, #2217]	@ 0x8a9
 801a09c:	f081 0101 	eor.w	r1, r1, #1
 801a0a0:	f882 18a9 	strb.w	r1, [r2, #2217]	@ 0x8a9
    USBH_CtlSendData (pdev,
 801a0a4:	2200      	movs	r2, #0
 801a0a6:	4611      	mov	r1, r2
 801a0a8:	f000 fa75 	bl	801a596 <USBH_CtlSendData>
    phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801a0ac:	230a      	movs	r3, #10
 801a0ae:	e767      	b.n	8019f80 <USBH_HandleControl+0x2c>
    URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
 801a0b0:	7949      	ldrb	r1, [r1, #5]
 801a0b2:	f001 fd63 	bl	801bb7c <HCD_GetURB_State>
    if  (URB_Status == URB_DONE)
 801a0b6:	2801      	cmp	r0, #1
 801a0b8:	d0d5      	beq.n	801a066 <USBH_HandleControl+0x112>
    else if  (URB_Status == URB_NOTREADY)
 801a0ba:	2802      	cmp	r0, #2
 801a0bc:	d101      	bne.n	801a0c2 <USBH_HandleControl+0x16e>
      phost->Control.state = CTRL_STATUS_OUT;
 801a0be:	2309      	movs	r3, #9
 801a0c0:	e75e      	b.n	8019f80 <USBH_HandleControl+0x2c>
    else if (URB_Status == URB_ERROR)
 801a0c2:	2803      	cmp	r0, #3
 801a0c4:	f47f af74 	bne.w	8019fb0 <USBH_HandleControl+0x5c>
 801a0c8:	e7a1      	b.n	801a00e <USBH_HandleControl+0xba>
    if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 801a0ca:	7b8b      	ldrb	r3, [r1, #14]
 801a0cc:	3301      	adds	r3, #1
 801a0ce:	b2db      	uxtb	r3, r3
 801a0d0:	2b02      	cmp	r3, #2
 801a0d2:	738b      	strb	r3, [r1, #14]
 801a0d4:	d801      	bhi.n	801a0da <USBH_HandleControl+0x186>
      phost->Control.state = CTRL_SETUP; 
 801a0d6:	2301      	movs	r3, #1
 801a0d8:	e752      	b.n	8019f80 <USBH_HandleControl+0x2c>
      phost->Control.status = CTRL_FAIL;
 801a0da:	2308      	movs	r3, #8
 801a0dc:	748b      	strb	r3, [r1, #18]
      phost->gState =   phost->gStateBkp;
 801a0de:	784b      	ldrb	r3, [r1, #1]
 801a0e0:	700b      	strb	r3, [r1, #0]
      status = USBH_FAIL;
 801a0e2:	2002      	movs	r0, #2
 801a0e4:	e765      	b.n	8019fb2 <USBH_HandleControl+0x5e>
 801a0e6:	bf00      	nop
 801a0e8:	200042e4 	.word	0x200042e4

0801a0ec <USBH_Process>:
{
 801a0ec:	b570      	push	{r4, r5, r6, lr}
 801a0ee:	b094      	sub	sp, #80	@ 0x50
  volatile USBH_Status status = USBH_FAIL;
 801a0f0:	2602      	movs	r6, #2
{
 801a0f2:	460c      	mov	r4, r1
 801a0f4:	4605      	mov	r5, r0
  volatile USBH_Status status = USBH_FAIL;
 801a0f6:	f88d 600f 	strb.w	r6, [sp, #15]
  if ((HCD_IsDeviceConnected(pdev) == 0)&& (phost->gState != HOST_IDLE)) 
 801a0fa:	f001 fd38 	bl	801bb6e <HCD_IsDeviceConnected>
 801a0fe:	7823      	ldrb	r3, [r4, #0]
 801a100:	b9d8      	cbnz	r0, 801a13a <USBH_Process+0x4e>
 801a102:	2b00      	cmp	r3, #0
 801a104:	d034      	beq.n	801a170 <USBH_Process+0x84>
    if(phost->gState != HOST_DEV_DISCONNECTED) 
 801a106:	42b3      	cmp	r3, r6
 801a108:	d000      	beq.n	801a10c <USBH_Process+0x20>
      phost->gState = HOST_DEV_DISCONNECTED;
 801a10a:	7026      	strb	r6, [r4, #0]
    phost->usr_cb->DeviceDisconnected();
 801a10c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a110:	691b      	ldr	r3, [r3, #16]
 801a112:	4798      	blx	r3
    USBH_DeInit(pdev, phost);
 801a114:	4621      	mov	r1, r4
 801a116:	4628      	mov	r0, r5
 801a118:	f7ff fecf 	bl	8019eba <USBH_DeInit>
    phost->usr_cb->DeInit();
 801a11c:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a120:	685b      	ldr	r3, [r3, #4]
 801a122:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop); 
 801a124:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 801a126:	f104 0120 	add.w	r1, r4, #32
 801a12a:	685b      	ldr	r3, [r3, #4]
 801a12c:	4628      	mov	r0, r5
 801a12e:	4798      	blx	r3
    USBH_DeAllocate_AllChannel(pdev);  
 801a130:	4628      	mov	r0, r5
 801a132:	f000 f9ec 	bl	801a50e <USBH_DeAllocate_AllChannel>
    phost->gState = HOST_IDLE;
 801a136:	2300      	movs	r3, #0
 801a138:	e071      	b.n	801a21e <USBH_Process+0x132>
  switch (phost->gState)
 801a13a:	2b0a      	cmp	r3, #10
 801a13c:	d85e      	bhi.n	801a1fc <USBH_Process+0x110>
 801a13e:	a201      	add	r2, pc, #4	@ (adr r2, 801a144 <USBH_Process+0x58>)
 801a140:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a144:	0801a171 	.word	0x0801a171
 801a148:	0801a18b 	.word	0x0801a18b
 801a14c:	0801a10d 	.word	0x0801a10d
 801a150:	0801a1fd 	.word	0x0801a1fd
 801a154:	0801a201 	.word	0x0801a201
 801a158:	0801a3d7 	.word	0x0801a3d7
 801a15c:	0801a3ef 	.word	0x0801a3ef
 801a160:	0801a40d 	.word	0x0801a40d
 801a164:	0801a3b5 	.word	0x0801a3b5
 801a168:	0801a1fd 	.word	0x0801a1fd
 801a16c:	0801a41b 	.word	0x0801a41b
    if (HCD_IsDeviceConnected(pdev))  
 801a170:	4628      	mov	r0, r5
 801a172:	f001 fcfc 	bl	801bb6e <HCD_IsDeviceConnected>
 801a176:	2800      	cmp	r0, #0
 801a178:	d040      	beq.n	801a1fc <USBH_Process+0x110>
      phost->gState = HOST_DEV_ATTACHED;
 801a17a:	2301      	movs	r3, #1
      USB_OTG_BSP_mDelay(100);
 801a17c:	2064      	movs	r0, #100	@ 0x64
      phost->gState = HOST_DEV_ATTACHED;
 801a17e:	7023      	strb	r3, [r4, #0]
}
 801a180:	b014      	add	sp, #80	@ 0x50
 801a182:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      USB_OTG_BSP_mDelay(100);
 801a186:	f7fd bc52 	b.w	8017a2e <USB_OTG_BSP_mDelay>
    phost->usr_cb->DeviceAttached();
 801a18a:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a18e:	689b      	ldr	r3, [r3, #8]
 801a190:	4798      	blx	r3
    phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
 801a192:	2100      	movs	r1, #0
 801a194:	4628      	mov	r0, r5
 801a196:	f000 f995 	bl	801a4c4 <USBH_Alloc_Channel>
    phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
 801a19a:	2180      	movs	r1, #128	@ 0x80
    phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
 801a19c:	7160      	strb	r0, [r4, #5]
    phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
 801a19e:	4628      	mov	r0, r5
 801a1a0:	f000 f990 	bl	801a4c4 <USBH_Alloc_Channel>
 801a1a4:	7120      	strb	r0, [r4, #4]
    if ( HCD_ResetPort(pdev) == 0)
 801a1a6:	4628      	mov	r0, r5
 801a1a8:	f001 fcdc 	bl	801bb64 <HCD_ResetPort>
 801a1ac:	4606      	mov	r6, r0
 801a1ae:	bb28      	cbnz	r0, 801a1fc <USBH_Process+0x110>
      phost->usr_cb->ResetDevice();
 801a1b0:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a1b4:	68db      	ldr	r3, [r3, #12]
 801a1b6:	4798      	blx	r3
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 801a1b8:	4628      	mov	r0, r5
 801a1ba:	f001 fccd 	bl	801bb58 <HCD_GetCurrentSpeed>
      phost->gState = HOST_ENUMERATION;
 801a1be:	2304      	movs	r3, #4
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 801a1c0:	b2c0      	uxtb	r0, r0
      phost->gState = HOST_ENUMERATION;
 801a1c2:	7023      	strb	r3, [r4, #0]
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 801a1c4:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
      phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
 801a1c8:	f884 0021 	strb.w	r0, [r4, #33]	@ 0x21
      phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
 801a1cc:	699b      	ldr	r3, [r3, #24]
 801a1ce:	4798      	blx	r3
      USBH_Open_Channel (pdev,
 801a1d0:	79a3      	ldrb	r3, [r4, #6]
 801a1d2:	e9cd 6300 	strd	r6, r3, [sp]
 801a1d6:	4628      	mov	r0, r5
 801a1d8:	f894 3021 	ldrb.w	r3, [r4, #33]	@ 0x21
 801a1dc:	f894 2020 	ldrb.w	r2, [r4, #32]
 801a1e0:	7921      	ldrb	r1, [r4, #4]
 801a1e2:	f000 f92d 	bl	801a440 <USBH_Open_Channel>
      USBH_Open_Channel (pdev,
 801a1e6:	79a3      	ldrb	r3, [r4, #6]
 801a1e8:	e9cd 6300 	strd	r6, r3, [sp]
 801a1ec:	4628      	mov	r0, r5
 801a1ee:	f894 3021 	ldrb.w	r3, [r4, #33]	@ 0x21
 801a1f2:	f894 2020 	ldrb.w	r2, [r4, #32]
 801a1f6:	7961      	ldrb	r1, [r4, #5]
 801a1f8:	f000 f922 	bl	801a440 <USBH_Open_Channel>
}
 801a1fc:	b014      	add	sp, #80	@ 0x50
 801a1fe:	bd70      	pop	{r4, r5, r6, pc}
  switch (phost->EnumState)
 801a200:	78a3      	ldrb	r3, [r4, #2]
 801a202:	2b09      	cmp	r3, #9
 801a204:	d8fa      	bhi.n	801a1fc <USBH_Process+0x110>
 801a206:	e8df f003 	tbb	[pc, r3]
 801a20a:	2f0c      	.short	0x2f0c
 801a20c:	7f6c633f 	.word	0x7f6c633f
 801a210:	05cab198 	.word	0x05cab198
      phost->usr_cb->EnumerationDone();
 801a214:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a218:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 801a21a:	4798      	blx	r3
      phost->gState  = HOST_USR_INPUT;    
 801a21c:	2308      	movs	r3, #8
    phost->gState = HOST_IDLE;
 801a21e:	7023      	strb	r3, [r4, #0]
}
 801a220:	e7ec      	b.n	801a1fc <USBH_Process+0x110>
    if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
 801a222:	2208      	movs	r2, #8
 801a224:	4621      	mov	r1, r4
 801a226:	4628      	mov	r0, r5
 801a228:	f000 fa3f 	bl	801a6aa <USBH_Get_DevDesc>
 801a22c:	4606      	mov	r6, r0
 801a22e:	2800      	cmp	r0, #0
 801a230:	d1e4      	bne.n	801a1fc <USBH_Process+0x110>
      phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
 801a232:	f894 3029 	ldrb.w	r3, [r4, #41]	@ 0x29
 801a236:	71a3      	strb	r3, [r4, #6]
      HCD_ResetPort(pdev);
 801a238:	4628      	mov	r0, r5
 801a23a:	f001 fc93 	bl	801bb64 <HCD_ResetPort>
      phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 801a23e:	2301      	movs	r3, #1
 801a240:	70a3      	strb	r3, [r4, #2]
      USBH_Modify_Channel (pdev,
 801a242:	79a3      	ldrb	r3, [r4, #6]
 801a244:	e9cd 6300 	strd	r6, r3, [sp]
 801a248:	4632      	mov	r2, r6
 801a24a:	7961      	ldrb	r1, [r4, #5]
 801a24c:	4633      	mov	r3, r6
 801a24e:	4628      	mov	r0, r5
 801a250:	f000 f91c 	bl	801a48c <USBH_Modify_Channel>
      USBH_Modify_Channel (pdev,
 801a254:	79a3      	ldrb	r3, [r4, #6]
 801a256:	e9cd 6300 	strd	r6, r3, [sp]
 801a25a:	7921      	ldrb	r1, [r4, #4]
 801a25c:	4633      	mov	r3, r6
 801a25e:	4632      	mov	r2, r6
      USBH_Modify_Channel (pdev,
 801a260:	4628      	mov	r0, r5
 801a262:	f000 f913 	bl	801a48c <USBH_Modify_Channel>
  return Status;
 801a266:	e7c9      	b.n	801a1fc <USBH_Process+0x110>
    if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
 801a268:	2212      	movs	r2, #18
 801a26a:	4621      	mov	r1, r4
 801a26c:	4628      	mov	r0, r5
 801a26e:	f000 fa1c 	bl	801a6aa <USBH_Get_DevDesc>
 801a272:	2800      	cmp	r0, #0
 801a274:	d1c2      	bne.n	801a1fc <USBH_Process+0x110>
      phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
 801a276:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a27a:	f104 0022 	add.w	r0, r4, #34	@ 0x22
 801a27e:	69db      	ldr	r3, [r3, #28]
 801a280:	4798      	blx	r3
      phost->EnumState = ENUM_SET_ADDR;
 801a282:	2302      	movs	r3, #2
      phost->EnumState = ENUM_DEV_CONFIGURED;
 801a284:	70a3      	strb	r3, [r4, #2]
  return Status;
 801a286:	e7b9      	b.n	801a1fc <USBH_Process+0x110>
    if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
 801a288:	2201      	movs	r2, #1
 801a28a:	4621      	mov	r1, r4
 801a28c:	4628      	mov	r0, r5
 801a28e:	f000 fb4b 	bl	801a928 <USBH_SetAddress>
 801a292:	4606      	mov	r6, r0
 801a294:	2800      	cmp	r0, #0
 801a296:	d1b1      	bne.n	801a1fc <USBH_Process+0x110>
      USB_OTG_BSP_mDelay(2);
 801a298:	2002      	movs	r0, #2
 801a29a:	f7fd fbc8 	bl	8017a2e <USB_OTG_BSP_mDelay>
      phost->device_prop.address = USBH_DEVICE_ADDRESS;
 801a29e:	2301      	movs	r3, #1
 801a2a0:	f884 3020 	strb.w	r3, [r4, #32]
      phost->usr_cb->DeviceAddressAssigned();
 801a2a4:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a2a8:	6a1b      	ldr	r3, [r3, #32]
 801a2aa:	4798      	blx	r3
      phost->EnumState = ENUM_GET_CFG_DESC;
 801a2ac:	2303      	movs	r3, #3
 801a2ae:	70a3      	strb	r3, [r4, #2]
      USBH_Modify_Channel (pdev,
 801a2b0:	e9cd 6600 	strd	r6, r6, [sp]
 801a2b4:	4633      	mov	r3, r6
 801a2b6:	f894 2020 	ldrb.w	r2, [r4, #32]
 801a2ba:	7921      	ldrb	r1, [r4, #4]
 801a2bc:	4628      	mov	r0, r5
 801a2be:	f000 f8e5 	bl	801a48c <USBH_Modify_Channel>
      USBH_Modify_Channel (pdev,
 801a2c2:	e9cd 6600 	strd	r6, r6, [sp]
 801a2c6:	4633      	mov	r3, r6
 801a2c8:	f894 2020 	ldrb.w	r2, [r4, #32]
 801a2cc:	7961      	ldrb	r1, [r4, #5]
 801a2ce:	e7c7      	b.n	801a260 <USBH_Process+0x174>
    if ( USBH_Get_CfgDesc(pdev, 
 801a2d0:	2209      	movs	r2, #9
 801a2d2:	4621      	mov	r1, r4
 801a2d4:	4628      	mov	r0, r5
 801a2d6:	f000 fa57 	bl	801a788 <USBH_Get_CfgDesc>
 801a2da:	2800      	cmp	r0, #0
 801a2dc:	d18e      	bne.n	801a1fc <USBH_Process+0x110>
      phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 801a2de:	2304      	movs	r3, #4
 801a2e0:	e7d0      	b.n	801a284 <USBH_Process+0x198>
    if (USBH_Get_CfgDesc(pdev, 
 801a2e2:	8ee2      	ldrh	r2, [r4, #54]	@ 0x36
 801a2e4:	4621      	mov	r1, r4
 801a2e6:	4628      	mov	r0, r5
 801a2e8:	f000 fa4e 	bl	801a788 <USBH_Get_CfgDesc>
 801a2ec:	2800      	cmp	r0, #0
 801a2ee:	d185      	bne.n	801a1fc <USBH_Process+0x110>
      phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
 801a2f0:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a2f4:	f104 0250 	add.w	r2, r4, #80	@ 0x50
 801a2f8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 801a2fa:	f104 013e 	add.w	r1, r4, #62	@ 0x3e
 801a2fe:	f104 0034 	add.w	r0, r4, #52	@ 0x34
 801a302:	4798      	blx	r3
      phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 801a304:	2305      	movs	r3, #5
 801a306:	e7bd      	b.n	801a284 <USBH_Process+0x198>
    if (phost->device_prop.Dev_Desc.iManufacturer != 0)
 801a308:	f894 2030 	ldrb.w	r2, [r4, #48]	@ 0x30
 801a30c:	b182      	cbz	r2, 801a330 <USBH_Process+0x244>
      if ( USBH_Get_StringDesc(pdev,
 801a30e:	23ff      	movs	r3, #255	@ 0xff
 801a310:	9300      	str	r3, [sp, #0]
 801a312:	4621      	mov	r1, r4
 801a314:	ab04      	add	r3, sp, #16
 801a316:	4628      	mov	r0, r5
 801a318:	f000 fa0d 	bl	801a736 <USBH_Get_StringDesc>
 801a31c:	2800      	cmp	r0, #0
 801a31e:	f47f af6d 	bne.w	801a1fc <USBH_Process+0x110>
        phost->usr_cb->ManufacturerString(Local_Buffer);
 801a322:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a326:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801a328:	a804      	add	r0, sp, #16
      phost->usr_cb->ManufacturerString("N/A");      
 801a32a:	4798      	blx	r3
      phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 801a32c:	2306      	movs	r3, #6
 801a32e:	e7a9      	b.n	801a284 <USBH_Process+0x198>
      phost->usr_cb->ManufacturerString("N/A");      
 801a330:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a334:	4841      	ldr	r0, [pc, #260]	@ (801a43c <USBH_Process+0x350>)
 801a336:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 801a338:	e7f7      	b.n	801a32a <USBH_Process+0x23e>
    if (phost->device_prop.Dev_Desc.iProduct != 0)
 801a33a:	f894 2031 	ldrb.w	r2, [r4, #49]	@ 0x31
 801a33e:	b182      	cbz	r2, 801a362 <USBH_Process+0x276>
      if ( USBH_Get_StringDesc(pdev,
 801a340:	23ff      	movs	r3, #255	@ 0xff
 801a342:	9300      	str	r3, [sp, #0]
 801a344:	4621      	mov	r1, r4
 801a346:	ab04      	add	r3, sp, #16
 801a348:	4628      	mov	r0, r5
 801a34a:	f000 f9f4 	bl	801a736 <USBH_Get_StringDesc>
 801a34e:	2800      	cmp	r0, #0
 801a350:	f47f af54 	bne.w	801a1fc <USBH_Process+0x110>
        phost->usr_cb->ProductString(Local_Buffer);
 801a354:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a358:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801a35a:	a804      	add	r0, sp, #16
      phost->usr_cb->ProductString("N/A");
 801a35c:	4798      	blx	r3
      phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 801a35e:	2307      	movs	r3, #7
 801a360:	e790      	b.n	801a284 <USBH_Process+0x198>
      phost->usr_cb->ProductString("N/A");
 801a362:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a366:	4835      	ldr	r0, [pc, #212]	@ (801a43c <USBH_Process+0x350>)
 801a368:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801a36a:	e7f7      	b.n	801a35c <USBH_Process+0x270>
    if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
 801a36c:	f894 2032 	ldrb.w	r2, [r4, #50]	@ 0x32
 801a370:	b182      	cbz	r2, 801a394 <USBH_Process+0x2a8>
      if ( USBH_Get_StringDesc(pdev, 
 801a372:	23ff      	movs	r3, #255	@ 0xff
 801a374:	9300      	str	r3, [sp, #0]
 801a376:	4621      	mov	r1, r4
 801a378:	ab04      	add	r3, sp, #16
 801a37a:	4628      	mov	r0, r5
 801a37c:	f000 f9db 	bl	801a736 <USBH_Get_StringDesc>
 801a380:	2800      	cmp	r0, #0
 801a382:	f47f af3b 	bne.w	801a1fc <USBH_Process+0x110>
        phost->usr_cb->SerialNumString(Local_Buffer);
 801a386:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a38a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a38c:	a804      	add	r0, sp, #16
      phost->usr_cb->SerialNumString("N/A");      
 801a38e:	4798      	blx	r3
      phost->EnumState = ENUM_SET_CONFIGURATION;
 801a390:	2308      	movs	r3, #8
 801a392:	e777      	b.n	801a284 <USBH_Process+0x198>
      phost->usr_cb->SerialNumString("N/A");      
 801a394:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a398:	4828      	ldr	r0, [pc, #160]	@ (801a43c <USBH_Process+0x350>)
 801a39a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 801a39c:	e7f7      	b.n	801a38e <USBH_Process+0x2a2>
    if (USBH_SetCfg(pdev, 
 801a39e:	f894 2039 	ldrb.w	r2, [r4, #57]	@ 0x39
 801a3a2:	4621      	mov	r1, r4
 801a3a4:	4628      	mov	r0, r5
 801a3a6:	f000 faca 	bl	801a93e <USBH_SetCfg>
 801a3aa:	2800      	cmp	r0, #0
 801a3ac:	f47f af26 	bne.w	801a1fc <USBH_Process+0x110>
      phost->EnumState = ENUM_DEV_CONFIGURED;
 801a3b0:	2309      	movs	r3, #9
 801a3b2:	e767      	b.n	801a284 <USBH_Process+0x198>
    if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
 801a3b4:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a3b8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 801a3ba:	4798      	blx	r3
 801a3bc:	2801      	cmp	r0, #1
 801a3be:	f47f af1d 	bne.w	801a1fc <USBH_Process+0x110>
      if((phost->class_cb->Init(pdev, phost))\
 801a3c2:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 801a3c4:	4621      	mov	r1, r4
 801a3c6:	681b      	ldr	r3, [r3, #0]
 801a3c8:	4628      	mov	r0, r5
 801a3ca:	4798      	blx	r3
 801a3cc:	2800      	cmp	r0, #0
 801a3ce:	f47f af15 	bne.w	801a1fc <USBH_Process+0x110>
        phost->gState  = HOST_CLASS_REQUEST;     
 801a3d2:	2305      	movs	r3, #5
 801a3d4:	e723      	b.n	801a21e <USBH_Process+0x132>
    status = phost->class_cb->Requests(pdev, phost);
 801a3d6:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 801a3d8:	4621      	mov	r1, r4
 801a3da:	689b      	ldr	r3, [r3, #8]
 801a3dc:	4628      	mov	r0, r5
 801a3de:	4798      	blx	r3
 801a3e0:	f88d 000f 	strb.w	r0, [sp, #15]
     if(status == USBH_OK)
 801a3e4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801a3e8:	b943      	cbnz	r3, 801a3fc <USBH_Process+0x310>
       phost->gState  = HOST_CLASS;
 801a3ea:	2306      	movs	r3, #6
 801a3ec:	e717      	b.n	801a21e <USBH_Process+0x132>
    status = phost->class_cb->Machine(pdev, phost);
 801a3ee:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 801a3f0:	4621      	mov	r1, r4
 801a3f2:	68db      	ldr	r3, [r3, #12]
 801a3f4:	4628      	mov	r0, r5
 801a3f6:	4798      	blx	r3
 801a3f8:	f88d 000f 	strb.w	r0, [sp, #15]
    USBH_ErrorHandle(phost, status);
 801a3fc:	f89d 100f 	ldrb.w	r1, [sp, #15]
 801a400:	4620      	mov	r0, r4
}
 801a402:	b014      	add	sp, #80	@ 0x50
 801a404:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    USBH_ErrorHandle(phost, status);
 801a408:	f7ff bd8d 	b.w	8019f26 <USBH_ErrorHandle>
    USBH_HandleControl(pdev, phost);    
 801a40c:	4621      	mov	r1, r4
 801a40e:	4628      	mov	r0, r5
}
 801a410:	b014      	add	sp, #80	@ 0x50
 801a412:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    USBH_HandleControl(pdev, phost);    
 801a416:	f7ff bd9d 	b.w	8019f54 <USBH_HandleControl>
    USBH_DeInit(pdev, phost);
 801a41a:	4621      	mov	r1, r4
 801a41c:	4628      	mov	r0, r5
 801a41e:	f7ff fd4c 	bl	8019eba <USBH_DeInit>
    phost->usr_cb->DeInit();
 801a422:	f8d4 3080 	ldr.w	r3, [r4, #128]	@ 0x80
 801a426:	685b      	ldr	r3, [r3, #4]
 801a428:	4798      	blx	r3
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 801a42a:	6fe3      	ldr	r3, [r4, #124]	@ 0x7c
 801a42c:	685b      	ldr	r3, [r3, #4]
 801a42e:	f104 0120 	add.w	r1, r4, #32
 801a432:	4628      	mov	r0, r5
}
 801a434:	b014      	add	sp, #80	@ 0x50
 801a436:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    phost->class_cb->DeInit(pdev, &phost->device_prop);
 801a43a:	4718      	bx	r3
 801a43c:	0802716f 	.word	0x0802716f

0801a440 <USBH_Open_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 801a440:	b570      	push	{r4, r5, r6, lr}

  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 801a442:	eb00 0441 	add.w	r4, r0, r1, lsl #1
 801a446:	f8b4 5a70 	ldrh.w	r5, [r4, #2672]	@ 0xa70
 801a44a:	eb00 1441 	add.w	r4, r0, r1, lsl #5
 801a44e:	f005 067f 	and.w	r6, r5, #127	@ 0x7f
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
  pdev->host.hc[hc_num].dev_addr = dev_address;  
 801a452:	f884 2890 	strb.w	r2, [r4, #2192]	@ 0x890
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 801a456:	f3c5 15c0 	ubfx	r5, r5, #7, #1
  pdev->host.hc[hc_num].ep_type = ep_type;  
 801a45a:	f89d 2010 	ldrb.w	r2, [sp, #16]
  pdev->host.hc[hc_num].ep_is_in = (pdev->host.channel[hc_num] & 0x80 ) == 0x80;  
 801a45e:	f884 5892 	strb.w	r5, [r4, #2194]	@ 0x892
  pdev->host.hc[hc_num].ep_type = ep_type;  
 801a462:	f884 2895 	strb.w	r2, [r4, #2197]	@ 0x895
  pdev->host.hc[hc_num].max_packet = mps; 
  pdev->host.hc[hc_num].speed = speed; 
  pdev->host.hc[hc_num].toggle_in = 0; 
 801a466:	2500      	movs	r5, #0
  pdev->host.hc[hc_num].max_packet = mps; 
 801a468:	f8bd 2014 	ldrh.w	r2, [sp, #20]
  pdev->host.hc[hc_num].ep_num = pdev->host.channel[hc_num]& 0x7F;
 801a46c:	f884 6891 	strb.w	r6, [r4, #2193]	@ 0x891
  pdev->host.hc[hc_num].max_packet = mps; 
 801a470:	f8a4 2896 	strh.w	r2, [r4, #2198]	@ 0x896
  pdev->host.hc[hc_num].speed = speed; 
 801a474:	f884 3893 	strb.w	r3, [r4, #2195]	@ 0x893
  pdev->host.hc[hc_num].toggle_in = 0; 
 801a478:	f8a4 58a8 	strh.w	r5, [r4, #2216]	@ 0x8a8
  pdev->host.hc[hc_num].toggle_out = 0;   
  if(speed == HPRT0_PRTSPD_HIGH_SPEED)
 801a47c:	b913      	cbnz	r3, 801a484 <USBH_Open_Channel+0x44>
  {
    pdev->host.hc[hc_num].do_ping = 1;
 801a47e:	2301      	movs	r3, #1
 801a480:	f884 3894 	strb.w	r3, [r4, #2196]	@ 0x894
  }
  
  USB_OTG_HC_Init(pdev, hc_num) ;
 801a484:	f000 fc92 	bl	801adac <USB_OTG_HC_Init>
  
  return HC_OK; 

}
 801a488:	2000      	movs	r0, #0
 801a48a:	bd70      	pop	{r4, r5, r6, pc}

0801a48c <USBH_Modify_Channel>:
                            uint8_t hc_num,
                            uint8_t dev_address,
                            uint8_t speed,
                            uint8_t ep_type,
                            uint16_t mps)
{
 801a48c:	b570      	push	{r4, r5, r6, lr}
 801a48e:	014c      	lsls	r4, r1, #5
 801a490:	f8bd 5014 	ldrh.w	r5, [sp, #20]
  
  if(dev_address != 0)
 801a494:	b112      	cbz	r2, 801a49c <USBH_Modify_Channel+0x10>
  {
    pdev->host.hc[hc_num].dev_addr = dev_address;  
 801a496:	1906      	adds	r6, r0, r4
 801a498:	f886 2890 	strb.w	r2, [r6, #2192]	@ 0x890
  }
  
  if((pdev->host.hc[hc_num].max_packet != mps) && (mps != 0))
 801a49c:	1902      	adds	r2, r0, r4
 801a49e:	f8b2 6896 	ldrh.w	r6, [r2, #2198]	@ 0x896
 801a4a2:	42ae      	cmp	r6, r5
 801a4a4:	d002      	beq.n	801a4ac <USBH_Modify_Channel+0x20>
 801a4a6:	b10d      	cbz	r5, 801a4ac <USBH_Modify_Channel+0x20>
  {
    pdev->host.hc[hc_num].max_packet = mps; 
 801a4a8:	f8a2 5896 	strh.w	r5, [r2, #2198]	@ 0x896
  }
  
  if((pdev->host.hc[hc_num].speed != speed ) && (speed != 0 )) 
 801a4ac:	4404      	add	r4, r0
 801a4ae:	f894 2893 	ldrb.w	r2, [r4, #2195]	@ 0x893
 801a4b2:	429a      	cmp	r2, r3
 801a4b4:	d002      	beq.n	801a4bc <USBH_Modify_Channel+0x30>
 801a4b6:	b10b      	cbz	r3, 801a4bc <USBH_Modify_Channel+0x30>
  {
    pdev->host.hc[hc_num].speed = speed; 
 801a4b8:	f884 3893 	strb.w	r3, [r4, #2195]	@ 0x893
  }
  
  USB_OTG_HC_Init(pdev, hc_num);
 801a4bc:	f000 fc76 	bl	801adac <USB_OTG_HC_Init>
  return HC_OK; 

}
 801a4c0:	2000      	movs	r0, #0
 801a4c2:	bd70      	pop	{r4, r5, r6, pc}

0801a4c4 <USBH_Alloc_Channel>:
  *         Allocate a new channel for the pipe
  * @param  ep_addr: End point for which the channel to be allocated
  * @retval hc_num: Host channel number
  */
uint8_t USBH_Alloc_Channel  (USB_OTG_CORE_HANDLE *pdev, uint8_t ep_addr)
{
 801a4c4:	b510      	push	{r4, lr}
 801a4c6:	f600 226e 	addw	r2, r0, #2670	@ 0xa6e
 801a4ca:	2300      	movs	r3, #0
{
  uint8_t idx = 0;
  
  for (idx = 0 ; idx < HC_MAX ; idx++)
  {
	if ((pdev->host.channel[idx] & HC_USED) == 0)
 801a4cc:	f932 4f02 	ldrsh.w	r4, [r2, #2]!
 801a4d0:	2c00      	cmp	r4, #0
 801a4d2:	db0a      	blt.n	801a4ea <USBH_Alloc_Channel+0x26>
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
 801a4d4:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 801a4d8:	ea6f 4141 	mvn.w	r1, r1, lsl #17
 801a4dc:	ea6f 4151 	mvn.w	r1, r1, lsr #17
	{
	   return idx;
 801a4e0:	b2da      	uxtb	r2, r3
	pdev->host.channel[hc_num] = HC_USED | ep_addr;
 801a4e2:	f8a0 1a70 	strh.w	r1, [r0, #2672]	@ 0xa70
}
 801a4e6:	b2d0      	uxtb	r0, r2
 801a4e8:	bd10      	pop	{r4, pc}
  for (idx = 0 ; idx < HC_MAX ; idx++)
 801a4ea:	3301      	adds	r3, #1
 801a4ec:	2b08      	cmp	r3, #8
 801a4ee:	d1ed      	bne.n	801a4cc <USBH_Alloc_Channel+0x8>
 801a4f0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801a4f4:	e7f7      	b.n	801a4e6 <USBH_Alloc_Channel+0x22>

0801a4f6 <USBH_Free_Channel>:
   if(idx < HC_MAX)
 801a4f6:	2907      	cmp	r1, #7
	 pdev->host.channel[idx] &= HC_USED_MASK;
 801a4f8:	bf9f      	itttt	ls
 801a4fa:	eb00 0041 	addls.w	r0, r0, r1, lsl #1
 801a4fe:	f8b0 3a70 	ldrhls.w	r3, [r0, #2672]	@ 0xa70
 801a502:	f3c3 030e 	ubfxls	r3, r3, #0, #15
 801a506:	f8a0 3a70 	strhls.w	r3, [r0, #2672]	@ 0xa70
}
 801a50a:	2000      	movs	r0, #0
 801a50c:	4770      	bx	lr

0801a50e <USBH_DeAllocate_AllChannel>:
{
 801a50e:	4603      	mov	r3, r0
	 pdev->host.channel[idx] = 0;
 801a510:	2000      	movs	r0, #0
 801a512:	f8c3 0a74 	str.w	r0, [r3, #2676]	@ 0xa74
 801a516:	f8c3 0a78 	str.w	r0, [r3, #2680]	@ 0xa78
 801a51a:	f8c3 0a7c 	str.w	r0, [r3, #2684]	@ 0xa7c
}
 801a51e:	4770      	bx	lr

0801a520 <USBH_CtlReq>:
                             uint16_t            length)
{
  USBH_Status status;
  status = USBH_BUSY;
  
  switch (phost->RequestState)
 801a520:	78c8      	ldrb	r0, [r1, #3]
 801a522:	2801      	cmp	r0, #1
{
 801a524:	b510      	push	{r4, lr}
  switch (phost->RequestState)
 801a526:	d003      	beq.n	801a530 <USBH_CtlReq+0x10>
 801a528:	2802      	cmp	r0, #2
 801a52a:	d00b      	beq.n	801a544 <USBH_CtlReq+0x24>
{
 801a52c:	2001      	movs	r0, #1
    
  default:
    break; 
  }
  return status;
}
 801a52e:	bd10      	pop	{r4, pc}
                                           uint8_t* buff, 
                                           uint16_t length)
{
  
  /* Save Global State */
  phost->gStateBkp =   phost->gState; 
 801a530:	780c      	ldrb	r4, [r1, #0]
 801a532:	704c      	strb	r4, [r1, #1]
  
  /* Prepare the Transactions */
  phost->gState = HOST_CTRL_XFER;
  phost->Control.buff = buff; 
  phost->Control.length = length;
 801a534:	818b      	strh	r3, [r1, #12]
  phost->gState = HOST_CTRL_XFER;
 801a536:	2407      	movs	r4, #7
    phost->RequestState = CMD_WAIT;
 801a538:	2302      	movs	r3, #2
  phost->gState = HOST_CTRL_XFER;
 801a53a:	700c      	strb	r4, [r1, #0]
  phost->Control.buff = buff; 
 801a53c:	608a      	str	r2, [r1, #8]
  phost->Control.state = CTRL_SETUP;  
 801a53e:	7708      	strb	r0, [r1, #28]
    phost->RequestState = CMD_WAIT;
 801a540:	70cb      	strb	r3, [r1, #3]
    break;
 801a542:	e7f3      	b.n	801a52c <USBH_CtlReq+0xc>
     if (phost->Control.state == CTRL_COMPLETE ) 
 801a544:	7f0a      	ldrb	r2, [r1, #28]
 801a546:	2a0d      	cmp	r2, #13
 801a548:	f04f 0301 	mov.w	r3, #1
 801a54c:	d103      	bne.n	801a556 <USBH_CtlReq+0x36>
      phost->Control.state =CTRL_IDLE;  
 801a54e:	2000      	movs	r0, #0
      phost->RequestState = CMD_SEND;
 801a550:	70cb      	strb	r3, [r1, #3]
      phost->Control.state =CTRL_IDLE;  
 801a552:	7708      	strb	r0, [r1, #28]
      status = USBH_OK;      
 801a554:	e7eb      	b.n	801a52e <USBH_CtlReq+0xe>
    else if  (phost->Control.state == CTRL_ERROR)
 801a556:	2a0b      	cmp	r2, #11
 801a558:	d101      	bne.n	801a55e <USBH_CtlReq+0x3e>
      phost->RequestState = CMD_SEND;
 801a55a:	70cb      	strb	r3, [r1, #3]
      status = USBH_FAIL;
 801a55c:	e7e7      	b.n	801a52e <USBH_CtlReq+0xe>
     else if  (phost->Control.state == CTRL_STALLED )
 801a55e:	2a0c      	cmp	r2, #12
 801a560:	d1e4      	bne.n	801a52c <USBH_CtlReq+0xc>
      phost->RequestState = CMD_SEND;
 801a562:	70cb      	strb	r3, [r1, #3]
      status = USBH_NOT_SUPPORTED;
 801a564:	2003      	movs	r0, #3
 801a566:	e7e2      	b.n	801a52e <USBH_CtlReq+0xe>

0801a568 <USBH_CtlSendSetup>:
                                uint8_t hc_num){
 801a568:	b538      	push	{r3, r4, r5, lr}
  pdev->host.hc[hc_num].ep_is_in = 0;
 801a56a:	eb00 1442 	add.w	r4, r0, r2, lsl #5
 801a56e:	2500      	movs	r5, #0
 801a570:	f884 5892 	strb.w	r5, [r4, #2194]	@ 0x892
  pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
 801a574:	f102 0515 	add.w	r5, r2, #21
 801a578:	eb00 1345 	add.w	r3, r0, r5, lsl #5
 801a57c:	2503      	movs	r5, #3
 801a57e:	f883 55f8 	strb.w	r5, [r3, #1528]	@ 0x5f8
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a582:	f8c3 15fc 	str.w	r1, [r3, #1532]	@ 0x5fc
  pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
 801a586:	2308      	movs	r3, #8
 801a588:	f8c4 38a0 	str.w	r3, [r4, #2208]	@ 0x8a0
  return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
 801a58c:	4611      	mov	r1, r2
 801a58e:	f001 faf9 	bl	801bb84 <HCD_SubmitRequest>
}
 801a592:	b2c0      	uxtb	r0, r0
 801a594:	bd38      	pop	{r3, r4, r5, pc}

0801a596 <USBH_CtlSendData>:
{
 801a596:	b570      	push	{r4, r5, r6, lr}
  pdev->host.hc[hc_num].ep_is_in = 0;
 801a598:	eb00 1543 	add.w	r5, r0, r3, lsl #5
 801a59c:	2400      	movs	r4, #0
 801a59e:	f885 4892 	strb.w	r4, [r5, #2194]	@ 0x892
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a5a2:	f103 0415 	add.w	r4, r3, #21
 801a5a6:	eb00 1644 	add.w	r6, r0, r4, lsl #5
 801a5aa:	f8c6 15fc 	str.w	r1, [r6, #1532]	@ 0x5fc
  pdev->host.hc[hc_num].xfer_len = length;
 801a5ae:	f8c5 28a0 	str.w	r2, [r5, #2208]	@ 0x8a0
  if ( length == 0 )
 801a5b2:	f103 0145 	add.w	r1, r3, #69	@ 0x45
 801a5b6:	b91a      	cbnz	r2, 801a5c0 <USBH_CtlSendData+0x2a>
    pdev->host.hc[hc_num].toggle_out = 1;   
 801a5b8:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 801a5bc:	2501      	movs	r5, #1
 801a5be:	7255      	strb	r5, [r2, #9]
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 801a5c0:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 801a5c4:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 801a5c8:	7a4a      	ldrb	r2, [r1, #9]
 801a5ca:	3a00      	subs	r2, #0
 801a5cc:	bf18      	it	ne
 801a5ce:	2201      	movne	r2, #1
 801a5d0:	0052      	lsls	r2, r2, #1
 801a5d2:	f884 25f8 	strb.w	r2, [r4, #1528]	@ 0x5f8
  HCD_SubmitRequest (pdev , hc_num);   
 801a5d6:	4619      	mov	r1, r3
 801a5d8:	f001 fad4 	bl	801bb84 <HCD_SubmitRequest>
}
 801a5dc:	2000      	movs	r0, #0
 801a5de:	bd70      	pop	{r4, r5, r6, pc}

0801a5e0 <USBH_CtlReceiveData>:
{
 801a5e0:	b570      	push	{r4, r5, r6, lr}
  pdev->host.hc[hc_num].ep_is_in = 1;
 801a5e2:	eb00 1543 	add.w	r5, r0, r3, lsl #5
 801a5e6:	2601      	movs	r6, #1
 801a5e8:	f885 6892 	strb.w	r6, [r5, #2194]	@ 0x892
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 801a5ec:	f103 0615 	add.w	r6, r3, #21
 801a5f0:	eb00 1446 	add.w	r4, r0, r6, lsl #5
 801a5f4:	2602      	movs	r6, #2
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a5f6:	f8c4 15fc 	str.w	r1, [r4, #1532]	@ 0x5fc
  pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
 801a5fa:	f884 65f8 	strb.w	r6, [r4, #1528]	@ 0x5f8
  HCD_SubmitRequest (pdev , hc_num);   
 801a5fe:	4619      	mov	r1, r3
  pdev->host.hc[hc_num].xfer_len = length;  
 801a600:	f8c5 28a0 	str.w	r2, [r5, #2208]	@ 0x8a0
  HCD_SubmitRequest (pdev , hc_num);   
 801a604:	f001 fabe 	bl	801bb84 <HCD_SubmitRequest>
}
 801a608:	2000      	movs	r0, #0
 801a60a:	bd70      	pop	{r4, r5, r6, pc}

0801a60c <USBH_BulkSendData>:
{ 
 801a60c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a60e:	f103 0515 	add.w	r5, r3, #21
  pdev->host.hc[hc_num].ep_is_in = 0;
 801a612:	eb00 1743 	add.w	r7, r0, r3, lsl #5
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a616:	eb00 1545 	add.w	r5, r0, r5, lsl #5
  pdev->host.hc[hc_num].ep_is_in = 0;
 801a61a:	2600      	movs	r6, #0
 801a61c:	f887 6892 	strb.w	r6, [r7, #2194]	@ 0x892
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a620:	f8c5 15fc 	str.w	r1, [r5, #1532]	@ 0x5fc
  pdev->host.hc[hc_num].xfer_len = length;  
 801a624:	f8c7 28a0 	str.w	r2, [r7, #2208]	@ 0x8a0
  if ( pdev->host.hc[hc_num].toggle_out == 0)
 801a628:	f897 28a9 	ldrb.w	r2, [r7, #2217]	@ 0x8a9
 801a62c:	1b92      	subs	r2, r2, r6
 801a62e:	bf18      	it	ne
 801a630:	2201      	movne	r2, #1
 801a632:	0052      	lsls	r2, r2, #1
 801a634:	f885 25f8 	strb.w	r2, [r5, #1528]	@ 0x5f8
  HCD_SubmitRequest (pdev , hc_num);   
 801a638:	4619      	mov	r1, r3
 801a63a:	f001 faa3 	bl	801bb84 <HCD_SubmitRequest>
}
 801a63e:	4630      	mov	r0, r6
 801a640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801a642 <USBH_BulkReceiveData>:
{
 801a642:	b570      	push	{r4, r5, r6, lr}
  pdev->host.hc[hc_num].ep_is_in = 1;   
 801a644:	eb00 1643 	add.w	r6, r0, r3, lsl #5
 801a648:	2501      	movs	r5, #1
 801a64a:	f886 5892 	strb.w	r5, [r6, #2194]	@ 0x892
  pdev->host.hc[hc_num].xfer_buff = buff;
 801a64e:	f103 0515 	add.w	r5, r3, #21
 801a652:	eb00 1545 	add.w	r5, r0, r5, lsl #5
 801a656:	f8c5 15fc 	str.w	r1, [r5, #1532]	@ 0x5fc
  pdev->host.hc[hc_num].xfer_len = length;
 801a65a:	f8c6 28a0 	str.w	r2, [r6, #2208]	@ 0x8a0
  if( pdev->host.hc[hc_num].toggle_in == 0)
 801a65e:	f896 28a8 	ldrb.w	r2, [r6, #2216]	@ 0x8a8
 801a662:	3a00      	subs	r2, #0
 801a664:	bf18      	it	ne
 801a666:	2201      	movne	r2, #1
 801a668:	0052      	lsls	r2, r2, #1
 801a66a:	f885 25f8 	strb.w	r2, [r5, #1528]	@ 0x5f8
  HCD_SubmitRequest (pdev , hc_num);  
 801a66e:	4619      	mov	r1, r3
 801a670:	f001 fa88 	bl	801bb84 <HCD_SubmitRequest>
}
 801a674:	2000      	movs	r0, #0
 801a676:	bd70      	pop	{r4, r5, r6, pc}

0801a678 <USBH_GetDescriptor>:
                               USBH_HOST           *phost,                                
                               uint8_t  req_type,
                               uint16_t value_idx, 
                               uint8_t* buff, 
                               uint16_t length )
{ 
 801a678:	b430      	push	{r4, r5}
 801a67a:	461d      	mov	r5, r3
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 801a67c:	f062 027f 	orn	r2, r2, #127	@ 0x7f
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
  phost->Control.setup.b.wValue.w = value_idx;
 801a680:	82cd      	strh	r5, [r1, #22]
  
  if ((value_idx & 0xff00) == USB_DESC_STRING)
 801a682:	f405 457f 	and.w	r5, r5, #65280	@ 0xff00
  {
    phost->Control.setup.b.wIndex.w = 0x0409;
 801a686:	f5b5 7f40 	cmp.w	r5, #768	@ 0x300
  phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 801a68a:	750a      	strb	r2, [r1, #20]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 801a68c:	f04f 0206 	mov.w	r2, #6
{ 
 801a690:	f8bd 300c 	ldrh.w	r3, [sp, #12]
  phost->Control.setup.b.bRequest = USB_REQ_GET_DESCRIPTOR;
 801a694:	754a      	strb	r2, [r1, #21]
    phost->Control.setup.b.wIndex.w = 0x0409;
 801a696:	f240 4209 	movw	r2, #1033	@ 0x409
 801a69a:	bf18      	it	ne
 801a69c:	2200      	movne	r2, #0
 801a69e:	830a      	strh	r2, [r1, #24]
  }
  else
  {
    phost->Control.setup.b.wIndex.w = 0;
  }
  phost->Control.setup.b.wLength.w = length;           
 801a6a0:	834b      	strh	r3, [r1, #26]
  return USBH_CtlReq(pdev, phost, buff , length );     
 801a6a2:	9a02      	ldr	r2, [sp, #8]
}
 801a6a4:	bc30      	pop	{r4, r5}
  return USBH_CtlReq(pdev, phost, buff , length );     
 801a6a6:	f7ff bf3b 	b.w	801a520 <USBH_CtlReq>

0801a6aa <USBH_Get_DevDesc>:
{
 801a6aa:	b573      	push	{r0, r1, r4, r5, r6, lr}
                                  pdev->host.Rx_Buffer,
 801a6ac:	f200 53f4 	addw	r3, r0, #1524	@ 0x5f4
{
 801a6b0:	4616      	mov	r6, r2
  if((status = USBH_GetDescriptor(pdev, 
 801a6b2:	9201      	str	r2, [sp, #4]
 801a6b4:	9300      	str	r3, [sp, #0]
 801a6b6:	2200      	movs	r2, #0
 801a6b8:	f44f 7380 	mov.w	r3, #256	@ 0x100
{
 801a6bc:	4604      	mov	r4, r0
 801a6be:	460d      	mov	r5, r1
  if((status = USBH_GetDescriptor(pdev, 
 801a6c0:	f7ff ffda 	bl	801a678 <USBH_GetDescriptor>
 801a6c4:	bba8      	cbnz	r0, 801a732 <USBH_Get_DevDesc+0x88>
*/
static void  USBH_ParseDevDesc (USBH_DevDesc_TypeDef* dev_desc,
                                uint8_t *buf, 
                                uint16_t length)
{
  dev_desc->bLength            = *(uint8_t  *) (buf +  0);
 801a6c6:	f894 35f4 	ldrb.w	r3, [r4, #1524]	@ 0x5f4
 801a6ca:	f885 3022 	strb.w	r3, [r5, #34]	@ 0x22
  dev_desc->bDescriptorType    = *(uint8_t  *) (buf +  1);
 801a6ce:	f894 35f5 	ldrb.w	r3, [r4, #1525]	@ 0x5f5
 801a6d2:	f885 3023 	strb.w	r3, [r5, #35]	@ 0x23
  dev_desc->bcdUSB             = LE16 (buf +  2);
 801a6d6:	f8b4 35f6 	ldrh.w	r3, [r4, #1526]	@ 0x5f6
 801a6da:	84ab      	strh	r3, [r5, #36]	@ 0x24
  dev_desc->bDeviceClass       = *(uint8_t  *) (buf +  4);
 801a6dc:	f894 35f8 	ldrb.w	r3, [r4, #1528]	@ 0x5f8
 801a6e0:	f885 3026 	strb.w	r3, [r5, #38]	@ 0x26
  dev_desc->bDeviceSubClass    = *(uint8_t  *) (buf +  5);
 801a6e4:	f894 35f9 	ldrb.w	r3, [r4, #1529]	@ 0x5f9
 801a6e8:	f885 3027 	strb.w	r3, [r5, #39]	@ 0x27
  dev_desc->bDeviceProtocol    = *(uint8_t  *) (buf +  6);
 801a6ec:	f894 35fa 	ldrb.w	r3, [r4, #1530]	@ 0x5fa
 801a6f0:	f885 3028 	strb.w	r3, [r5, #40]	@ 0x28
  dev_desc->bMaxPacketSize     = *(uint8_t  *) (buf +  7);
 801a6f4:	f894 35fb 	ldrb.w	r3, [r4, #1531]	@ 0x5fb
 801a6f8:	f885 3029 	strb.w	r3, [r5, #41]	@ 0x29
  
  if (length > 8)
 801a6fc:	2e08      	cmp	r6, #8
 801a6fe:	d918      	bls.n	801a732 <USBH_Get_DevDesc+0x88>
  { /* For 1st time after device connection, Host may issue only 8 bytes for 
    Device Descriptor Length  */
    dev_desc->idVendor           = LE16 (buf +  8);
 801a700:	f8b4 35fc 	ldrh.w	r3, [r4, #1532]	@ 0x5fc
 801a704:	856b      	strh	r3, [r5, #42]	@ 0x2a
    dev_desc->idProduct          = LE16 (buf + 10);
 801a706:	f8b4 35fe 	ldrh.w	r3, [r4, #1534]	@ 0x5fe
 801a70a:	85ab      	strh	r3, [r5, #44]	@ 0x2c
    dev_desc->bcdDevice          = LE16 (buf + 12);
 801a70c:	f8b4 3600 	ldrh.w	r3, [r4, #1536]	@ 0x600
 801a710:	85eb      	strh	r3, [r5, #46]	@ 0x2e
    dev_desc->iManufacturer      = *(uint8_t  *) (buf + 14);
 801a712:	f894 3602 	ldrb.w	r3, [r4, #1538]	@ 0x602
 801a716:	f885 3030 	strb.w	r3, [r5, #48]	@ 0x30
    dev_desc->iProduct           = *(uint8_t  *) (buf + 15);
 801a71a:	f894 3603 	ldrb.w	r3, [r4, #1539]	@ 0x603
 801a71e:	f885 3031 	strb.w	r3, [r5, #49]	@ 0x31
    dev_desc->iSerialNumber      = *(uint8_t  *) (buf + 16);
 801a722:	f894 3604 	ldrb.w	r3, [r4, #1540]	@ 0x604
 801a726:	f885 3032 	strb.w	r3, [r5, #50]	@ 0x32
    dev_desc->bNumConfigurations = *(uint8_t  *) (buf + 17);
 801a72a:	f894 3605 	ldrb.w	r3, [r4, #1541]	@ 0x605
 801a72e:	f885 3033 	strb.w	r3, [r5, #51]	@ 0x33
}
 801a732:	b002      	add	sp, #8
 801a734:	bd70      	pop	{r4, r5, r6, pc}

0801a736 <USBH_Get_StringDesc>:
{
 801a736:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801a738:	f8bd 7020 	ldrh.w	r7, [sp, #32]
                                  pdev->host.Rx_Buffer,
 801a73c:	f200 55f4 	addw	r5, r0, #1524	@ 0x5f4
{
 801a740:	461c      	mov	r4, r3
  if((status = USBH_GetDescriptor(pdev,
 801a742:	e9cd 5700 	strd	r5, r7, [sp]
 801a746:	f442 7340 	orr.w	r3, r2, #768	@ 0x300
 801a74a:	2200      	movs	r2, #0
{
 801a74c:	4606      	mov	r6, r0
  if((status = USBH_GetDescriptor(pdev,
 801a74e:	f7ff ff93 	bl	801a678 <USBH_GetDescriptor>
 801a752:	b978      	cbnz	r0, 801a774 <USBH_Get_StringDesc+0x3e>
  */
  
  /* Check which is lower size, the Size of string or the length of bytes read 
  from the device */
  
  if ( psrc[1] == USB_DESC_TYPE_STRING)
 801a754:	f896 35f5 	ldrb.w	r3, [r6, #1525]	@ 0x5f5
 801a758:	2b03      	cmp	r3, #3
 801a75a:	d10b      	bne.n	801a774 <USBH_Get_StringDesc+0x3e>
  { /* Make sure the Descriptor is String Type */
    
    /* psrc[0] contains Size of Descriptor, subtract 2 to get the length of string */      
    strlength = ( ( (psrc[0]-2) <= length) ? (psrc[0]-2) :length); 
 801a75c:	f896 25f4 	ldrb.w	r2, [r6, #1524]	@ 0x5f4
 801a760:	3a02      	subs	r2, #2
 801a762:	42ba      	cmp	r2, r7
 801a764:	bfa8      	it	ge
 801a766:	463a      	movge	r2, r7
 801a768:	b292      	uxth	r2, r2
    psrc += 2; /* Adjust the offset ignoring the String Len and Descriptor type */
    
    for (idx = 0; idx < strlength; idx+=2 )
 801a76a:	4601      	mov	r1, r0
 801a76c:	428a      	cmp	r2, r1
 801a76e:	d803      	bhi.n	801a778 <USBH_Get_StringDesc+0x42>
    {/* Copy Only the string and ignore the UNICODE ID, hence add the src */
      *pdest =  psrc[idx];
      pdest++;
    }  
    *pdest = 0; /* mark end of string */  
 801a770:	2300      	movs	r3, #0
 801a772:	7023      	strb	r3, [r4, #0]
}
 801a774:	b003      	add	sp, #12
 801a776:	bdf0      	pop	{r4, r5, r6, r7, pc}
      *pdest =  psrc[idx];
 801a778:	186b      	adds	r3, r5, r1
    for (idx = 0; idx < strlength; idx+=2 )
 801a77a:	3102      	adds	r1, #2
      *pdest =  psrc[idx];
 801a77c:	789b      	ldrb	r3, [r3, #2]
 801a77e:	f804 3b01 	strb.w	r3, [r4], #1
    for (idx = 0; idx < strlength; idx+=2 )
 801a782:	b289      	uxth	r1, r1
 801a784:	e7f2      	b.n	801a76c <USBH_Get_StringDesc+0x36>
	...

0801a788 <USBH_Get_CfgDesc>:
{
 801a788:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                                  pdev->host.Rx_Buffer,
 801a78c:	f200 54f4 	addw	r4, r0, #1524	@ 0x5f4
{
 801a790:	b08d      	sub	sp, #52	@ 0x34
  if((status = USBH_GetDescriptor(pdev,
 801a792:	e9cd 4200 	strd	r4, r2, [sp]
 801a796:	f44f 7300 	mov.w	r3, #512	@ 0x200
{
 801a79a:	4617      	mov	r7, r2
  if((status = USBH_GetDescriptor(pdev,
 801a79c:	2200      	movs	r2, #0
{
 801a79e:	4606      	mov	r6, r0
 801a7a0:	460d      	mov	r5, r1
  if((status = USBH_GetDescriptor(pdev,
 801a7a2:	f7ff ff69 	bl	801a678 <USBH_GetDescriptor>
 801a7a6:	9002      	str	r0, [sp, #8]
 801a7a8:	4603      	mov	r3, r0
 801a7aa:	2800      	cmp	r0, #0
 801a7ac:	d13d      	bne.n	801a82a <USBH_Get_CfgDesc+0xa2>
 801a7ae:	4a5b      	ldr	r2, [pc, #364]	@ (801a91c <USBH_Get_CfgDesc+0x194>)
 801a7b0:	f206 51f3 	addw	r1, r6, #1523	@ 0x5f3
    for( ; index < length ; index ++)
 801a7b4:	fa1f fc83 	uxth.w	ip, r3
 801a7b8:	4567      	cmp	r7, ip
 801a7ba:	d83a      	bhi.n	801a832 <USBH_Get_CfgDesc+0xaa>
  cfg_desc->bLength             = *(uint8_t  *) (buf + 0);
 801a7bc:	f896 35f4 	ldrb.w	r3, [r6, #1524]	@ 0x5f4
 801a7c0:	f885 3034 	strb.w	r3, [r5, #52]	@ 0x34
  cfg_desc->bDescriptorType     = *(uint8_t  *) (buf + 1);
 801a7c4:	f896 35f5 	ldrb.w	r3, [r6, #1525]	@ 0x5f5
 801a7c8:	f885 3035 	strb.w	r3, [r5, #53]	@ 0x35
  cfg_desc->wTotalLength        = LE16 (buf + 2);
 801a7cc:	f8b6 b5f6 	ldrh.w	fp, [r6, #1526]	@ 0x5f6
 801a7d0:	f8a5 b036 	strh.w	fp, [r5, #54]	@ 0x36
  cfg_desc->bNumInterfaces      = *(uint8_t  *) (buf + 4);
 801a7d4:	f896 35f8 	ldrb.w	r3, [r6, #1528]	@ 0x5f8
 801a7d8:	f885 3038 	strb.w	r3, [r5, #56]	@ 0x38
  cfg_desc->bConfigurationValue = *(uint8_t  *) (buf + 5);
 801a7dc:	f896 25f9 	ldrb.w	r2, [r6, #1529]	@ 0x5f9
 801a7e0:	f885 2039 	strb.w	r2, [r5, #57]	@ 0x39
  cfg_desc->iConfiguration      = *(uint8_t  *) (buf + 6);
 801a7e4:	f896 25fa 	ldrb.w	r2, [r6, #1530]	@ 0x5fa
 801a7e8:	f885 203a 	strb.w	r2, [r5, #58]	@ 0x3a
  cfg_desc->bmAttributes        = *(uint8_t  *) (buf + 7);
 801a7ec:	f896 25fb 	ldrb.w	r2, [r6, #1531]	@ 0x5fb
 801a7f0:	f885 203b 	strb.w	r2, [r5, #59]	@ 0x3b
  cfg_desc->bMaxPower           = *(uint8_t  *) (buf + 8);    
 801a7f4:	f896 25fc 	ldrb.w	r2, [r6, #1532]	@ 0x5fc
 801a7f8:	f885 203c 	strb.w	r2, [r5, #60]	@ 0x3c
  if (length > USB_CONFIGURATION_DESC_SIZE)
 801a7fc:	2f09      	cmp	r7, #9
 801a7fe:	d914      	bls.n	801a82a <USBH_Get_CfgDesc+0xa2>
    if ( cfg_desc->bNumInterfaces <= USBH_MAX_NUM_INTERFACES) 
 801a800:	2b02      	cmp	r3, #2
 801a802:	d80d      	bhi.n	801a820 <USBH_Get_CfgDesc+0x98>
                       phost->device_prop.Itf_Desc,
 801a804:	f105 033e 	add.w	r3, r5, #62	@ 0x3e
 801a808:	9304      	str	r3, [sp, #16]
                       phost->device_prop.Ep_Desc, 
 801a80a:	f105 0350 	add.w	r3, r5, #80	@ 0x50
 801a80e:	469c      	mov	ip, r3
 801a810:	4b43      	ldr	r3, [pc, #268]	@ (801a920 <USBH_Get_CfgDesc+0x198>)
 801a812:	781b      	ldrb	r3, [r3, #0]
 801a814:	9303      	str	r3, [sp, #12]
 801a816:	4b43      	ldr	r3, [pc, #268]	@ (801a924 <USBH_Get_CfgDesc+0x19c>)
 801a818:	881d      	ldrh	r5, [r3, #0]
    ptr = USB_LEN_CFG_DESC;
 801a81a:	2209      	movs	r2, #9
      while (ptr < cfg_desc->wTotalLength ) 
 801a81c:	4593      	cmp	fp, r2
 801a81e:	d80e      	bhi.n	801a83e <USBH_Get_CfgDesc+0xb6>
    prev_ep_size = 0;
 801a820:	4a40      	ldr	r2, [pc, #256]	@ (801a924 <USBH_Get_CfgDesc+0x19c>)
 801a822:	2300      	movs	r3, #0
 801a824:	8013      	strh	r3, [r2, #0]
    prev_itf = 0; 
 801a826:	4a3e      	ldr	r2, [pc, #248]	@ (801a920 <USBH_Get_CfgDesc+0x198>)
 801a828:	7013      	strb	r3, [r2, #0]
}
 801a82a:	9802      	ldr	r0, [sp, #8]
 801a82c:	b00d      	add	sp, #52	@ 0x34
 801a82e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      USBH_CfgDesc[index] = pdev->host.Rx_Buffer[index];
 801a832:	f811 cf01 	ldrb.w	ip, [r1, #1]!
 801a836:	f802 cb01 	strb.w	ip, [r2], #1
    for( ; index < length ; index ++)
 801a83a:	3301      	adds	r3, #1
 801a83c:	e7ba      	b.n	801a7b4 <USBH_Get_CfgDesc+0x2c>
*/
USBH_DescHeader_t  *USBH_GetNextDesc (uint8_t   *pbuf, uint16_t  *ptr)
{
  USBH_DescHeader_t  *pnext;
 
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a83e:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
 801a840:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a842:	441a      	add	r2, r3
        if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
 801a844:	f894 9001 	ldrb.w	r9, [r4, #1]
 801a848:	f1b9 0f04 	cmp.w	r9, #4
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a84c:	b292      	uxth	r2, r2
        if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE) 
 801a84e:	d1e5      	bne.n	801a81c <USBH_Get_CfgDesc+0x94>
          if((*((uint8_t *)pdesc + 3)) < 3)
 801a850:	f894 8003 	ldrb.w	r8, [r4, #3]
 801a854:	f1b8 0f02 	cmp.w	r8, #2
 801a858:	d8e0      	bhi.n	801a81c <USBH_Get_CfgDesc+0x94>
  if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
 801a85a:	7927      	ldrb	r7, [r4, #4]
          if(temp_pif.bNumEndpoints <= USBH_MAX_NUM_ENDPOINTS)
 801a85c:	2f02      	cmp	r7, #2
 801a85e:	d8dd      	bhi.n	801a81c <USBH_Get_CfgDesc+0x94>
          if_ix             = *(((uint8_t *)pdesc ) + 2);
 801a860:	f994 6002 	ldrsb.w	r6, [r4, #2]
          pif               = &itf_desc[if_ix];
 801a864:	9904      	ldr	r1, [sp, #16]
          if_ix             = *(((uint8_t *)pdesc ) + 2);
 801a866:	f894 e002 	ldrb.w	lr, [r4, #2]
          pif               = &itf_desc[if_ix];
 801a86a:	eb06 03c6 	add.w	r3, r6, r6, lsl #3
 801a86e:	440b      	add	r3, r1
  if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
 801a870:	7821      	ldrb	r1, [r4, #0]
 801a872:	9106      	str	r1, [sp, #24]
  if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
 801a874:	7961      	ldrb	r1, [r4, #5]
 801a876:	9107      	str	r1, [sp, #28]
  if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
 801a878:	79a1      	ldrb	r1, [r4, #6]
 801a87a:	9108      	str	r1, [sp, #32]
  if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
 801a87c:	79e1      	ldrb	r1, [r4, #7]
 801a87e:	9109      	str	r1, [sp, #36]	@ 0x24
  if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
 801a880:	7a21      	ldrb	r1, [r4, #8]
 801a882:	910a      	str	r1, [sp, #40]	@ 0x28
                pep               = &ep_desc[if_ix][ep_ix];
 801a884:	0131      	lsls	r1, r6, #4
 801a886:	9105      	str	r1, [sp, #20]
          ep_ix = 0;
 801a888:	2100      	movs	r1, #0
            while (ep_ix < temp_pif.bNumEndpoints) 
 801a88a:	42b9      	cmp	r1, r7
 801a88c:	dac6      	bge.n	801a81c <USBH_Get_CfgDesc+0x94>
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a88e:	f894 a000 	ldrb.w	sl, [r4]
  pnext = (USBH_DescHeader_t *)((uint8_t *)pbuf + \
 801a892:	4454      	add	r4, sl
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a894:	4452      	add	r2, sl
              if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
 801a896:	f894 a001 	ldrb.w	sl, [r4, #1]
 801a89a:	f1ba 0f05 	cmp.w	sl, #5
  *ptr += ((USBH_DescHeader_t *)pbuf)->bLength;  
 801a89e:	b292      	uxth	r2, r2
              if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT) 
 801a8a0:	d1f3      	bne.n	801a88a <USBH_Get_CfgDesc+0x102>
                if(prev_itf != if_ix)
 801a8a2:	9803      	ldr	r0, [sp, #12]
 801a8a4:	42b0      	cmp	r0, r6
 801a8a6:	d136      	bne.n	801a916 <USBH_Get_CfgDesc+0x18e>
                  if(prev_ep_size > LE16((uint8_t *)pdesc + 4))
 801a8a8:	f8b4 a004 	ldrh.w	sl, [r4, #4]
 801a8ac:	45aa      	cmp	sl, r5
 801a8ae:	d3b5      	bcc.n	801a81c <USBH_Get_CfgDesc+0x94>
  if_descriptor->bLength            = *(uint8_t  *) (buf + 0);
 801a8b0:	9d06      	ldr	r5, [sp, #24]
 801a8b2:	701d      	strb	r5, [r3, #0]
  if_descriptor->bInterfaceClass    = *(uint8_t  *) (buf + 5);
 801a8b4:	9d07      	ldr	r5, [sp, #28]
 801a8b6:	715d      	strb	r5, [r3, #5]
  if_descriptor->bInterfaceSubClass = *(uint8_t  *) (buf + 6);
 801a8b8:	9d08      	ldr	r5, [sp, #32]
 801a8ba:	719d      	strb	r5, [r3, #6]
  if_descriptor->bInterfaceProtocol = *(uint8_t  *) (buf + 7);
 801a8bc:	9d09      	ldr	r5, [sp, #36]	@ 0x24
 801a8be:	71dd      	strb	r5, [r3, #7]
  if_descriptor->iInterface         = *(uint8_t  *) (buf + 8);
 801a8c0:	9d0a      	ldr	r5, [sp, #40]	@ 0x28
 801a8c2:	721d      	strb	r5, [r3, #8]
  if_descriptor->bDescriptorType    = *(uint8_t  *) (buf + 1);
 801a8c4:	f883 9001 	strb.w	r9, [r3, #1]
  if_descriptor->bInterfaceNumber   = *(uint8_t  *) (buf + 2);
 801a8c8:	f883 e002 	strb.w	lr, [r3, #2]
  if_descriptor->bAlternateSetting  = *(uint8_t  *) (buf + 3);
 801a8cc:	f883 8003 	strb.w	r8, [r3, #3]
  if_descriptor->bNumEndpoints      = *(uint8_t  *) (buf + 4);
 801a8d0:	711f      	strb	r7, [r3, #4]
  ep_descriptor->bLength          = *(uint8_t  *) (buf + 0);
 801a8d2:	7820      	ldrb	r0, [r4, #0]
 801a8d4:	900b      	str	r0, [sp, #44]	@ 0x2c
 801a8d6:	9805      	ldr	r0, [sp, #20]
 801a8d8:	eb00 0ac1 	add.w	sl, r0, r1, lsl #3
 801a8dc:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 801a8de:	f80c 000a 	strb.w	r0, [ip, sl]
  ep_descriptor->bDescriptorType  = *(uint8_t  *) (buf + 1);
 801a8e2:	eb0c 050a 	add.w	r5, ip, sl
 801a8e6:	f894 a001 	ldrb.w	sl, [r4, #1]
 801a8ea:	f885 a001 	strb.w	sl, [r5, #1]
  ep_descriptor->bEndpointAddress = *(uint8_t  *) (buf + 2);
 801a8ee:	f894 a002 	ldrb.w	sl, [r4, #2]
 801a8f2:	f885 a002 	strb.w	sl, [r5, #2]
  ep_descriptor->bmAttributes     = *(uint8_t  *) (buf + 3);
 801a8f6:	f894 a003 	ldrb.w	sl, [r4, #3]
 801a8fa:	f885 a003 	strb.w	sl, [r5, #3]
  ep_descriptor->wMaxPacketSize   = LE16 (buf + 4);
 801a8fe:	f8b4 a004 	ldrh.w	sl, [r4, #4]
 801a902:	f8a5 a004 	strh.w	sl, [r5, #4]
  ep_descriptor->bInterval        = *(uint8_t  *) (buf + 6);
 801a906:	f894 a006 	ldrb.w	sl, [r4, #6]
 801a90a:	f885 a006 	strb.w	sl, [r5, #6]
                ep_ix++;
 801a90e:	3101      	adds	r1, #1
                prev_ep_size = LE16((uint8_t *)pdesc + 4);
 801a910:	88a5      	ldrh	r5, [r4, #4]
                ep_ix++;
 801a912:	b249      	sxtb	r1, r1
 801a914:	e7b9      	b.n	801a88a <USBH_Get_CfgDesc+0x102>
                  prev_itf = if_ix;
 801a916:	f8cd e00c 	str.w	lr, [sp, #12]
 801a91a:	e7c9      	b.n	801a8b0 <USBH_Get_CfgDesc+0x128>
 801a91c:	200042e9 	.word	0x200042e9
 801a920:	200042e8 	.word	0x200042e8
 801a924:	200042e6 	.word	0x200042e6

0801a928 <USBH_SetAddress>:
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 801a928:	f44f 63a0 	mov.w	r3, #1280	@ 0x500
{
 801a92c:	b410      	push	{r4}
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 801a92e:	828b      	strh	r3, [r1, #20]
  phost->Control.setup.b.wIndex.w = 0;
 801a930:	2300      	movs	r3, #0
  phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 801a932:	82ca      	strh	r2, [r1, #22]
}
 801a934:	bc10      	pop	{r4}
  phost->Control.setup.b.wIndex.w = 0;
 801a936:	618b      	str	r3, [r1, #24]
  return USBH_CtlReq(pdev, phost, 0 , 0 );
 801a938:	461a      	mov	r2, r3
 801a93a:	f7ff bdf1 	b.w	801a520 <USBH_CtlReq>

0801a93e <USBH_SetCfg>:
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
 801a93e:	f44f 6310 	mov.w	r3, #2304	@ 0x900
{
 801a942:	b410      	push	{r4}
  phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE |\
 801a944:	828b      	strh	r3, [r1, #20]
  phost->Control.setup.b.wIndex.w = 0;
 801a946:	2300      	movs	r3, #0
  phost->Control.setup.b.wValue.w = cfg_idx;
 801a948:	82ca      	strh	r2, [r1, #22]
}
 801a94a:	bc10      	pop	{r4}
  phost->Control.setup.b.wIndex.w = 0;
 801a94c:	618b      	str	r3, [r1, #24]
  return USBH_CtlReq(pdev, phost, 0 , 0 );      
 801a94e:	461a      	mov	r2, r3
 801a950:	f7ff bde6 	b.w	801a520 <USBH_CtlReq>

0801a954 <USBH_ClrFeature>:
  phost->Control.setup.b.wValue.w = FEATURE_SELECTOR_ENDPOINT;
 801a954:	3345      	adds	r3, #69	@ 0x45
{
 801a956:	b410      	push	{r4}
    pdev->host.hc[hc_num].toggle_in = 0; 
 801a958:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  phost->Control.setup.b.bmRequestType = USB_H2D | 
 801a95c:	f44f 7481 	mov.w	r4, #258	@ 0x102
 801a960:	614c      	str	r4, [r1, #20]
  if ((ep_num & USB_REQ_DIR_MASK ) == USB_D2H)
 801a962:	f012 0f80 	tst.w	r2, #128	@ 0x80
  phost->Control.setup.b.wLength.w = 0;           
 801a966:	f04f 0400 	mov.w	r4, #0
  phost->Control.setup.b.wIndex.w = ep_num;
 801a96a:	830a      	strh	r2, [r1, #24]
  phost->Control.setup.b.wLength.w = 0;           
 801a96c:	834c      	strh	r4, [r1, #26]
    pdev->host.hc[hc_num].toggle_in = 0; 
 801a96e:	bf14      	ite	ne
 801a970:	721c      	strbne	r4, [r3, #8]
    pdev->host.hc[hc_num].toggle_out = 0; 
 801a972:	725c      	strbeq	r4, [r3, #9]
  return USBH_CtlReq(pdev, phost, 0 , 0 );   
 801a974:	2300      	movs	r3, #0
}
 801a976:	bc10      	pop	{r4}
  return USBH_CtlReq(pdev, phost, 0 , 0 );   
 801a978:	461a      	mov	r2, r3
 801a97a:	f7ff bdd1 	b.w	801a520 <USBH_CtlReq>
	...

0801a980 <USB_OTG_CoreReset.isra.0>:
/**
* @brief  USB_OTG_CoreReset : Soft reset of the core
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 801a980:	b537      	push	{r0, r1, r2, r4, r5, lr}
{
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 801a982:	2300      	movs	r3, #0
 801a984:	4c11      	ldr	r4, [pc, #68]	@ (801a9cc <USB_OTG_CoreReset.isra.0+0x4c>)
 801a986:	9301      	str	r3, [sp, #4]
static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
 801a988:	4605      	mov	r5, r0
  /* Wait for AHB master IDLE state. */
  do
  {
    USB_OTG_BSP_uDelay(3);
 801a98a:	2003      	movs	r0, #3
 801a98c:	f7fd f84c 	bl	8017a28 <USB_OTG_BSP_uDelay>
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801a990:	68eb      	ldr	r3, [r5, #12]
    if (++count > 200000)
 801a992:	3c01      	subs	r4, #1
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801a994:	691a      	ldr	r2, [r3, #16]
 801a996:	9201      	str	r2, [sp, #4]
    if (++count > 200000)
 801a998:	d016      	beq.n	801a9c8 <USB_OTG_CoreReset.isra.0+0x48>
    {
      return USB_OTG_OK;
    }
  }
  while (greset.b.ahbidle == 0);
 801a99a:	9a01      	ldr	r2, [sp, #4]
 801a99c:	2a00      	cmp	r2, #0
 801a99e:	daf4      	bge.n	801a98a <USB_OTG_CoreReset.isra.0+0xa>
  /* Core Soft Reset */
  count = 0;
  greset.b.csftrst = 1;
 801a9a0:	9a01      	ldr	r2, [sp, #4]
 801a9a2:	f042 0201 	orr.w	r2, r2, #1
 801a9a6:	9201      	str	r2, [sp, #4]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801a9a8:	9a01      	ldr	r2, [sp, #4]
 801a9aa:	611a      	str	r2, [r3, #16]
 801a9ac:	4a07      	ldr	r2, [pc, #28]	@ (801a9cc <USB_OTG_CoreReset.isra.0+0x4c>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
 801a9ae:	6919      	ldr	r1, [r3, #16]
 801a9b0:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 801a9b2:	3a01      	subs	r2, #1
 801a9b4:	d002      	beq.n	801a9bc <USB_OTG_CoreReset.isra.0+0x3c>
    {
      break;
    }
  }
  while (greset.b.csftrst == 1);
 801a9b6:	9901      	ldr	r1, [sp, #4]
 801a9b8:	07c9      	lsls	r1, r1, #31
 801a9ba:	d4f8      	bmi.n	801a9ae <USB_OTG_CoreReset.isra.0+0x2e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 801a9bc:	2003      	movs	r0, #3
  return status;
}
 801a9be:	b003      	add	sp, #12
 801a9c0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
  USB_OTG_BSP_uDelay(3);
 801a9c4:	f7fd b830 	b.w	8017a28 <USB_OTG_BSP_uDelay>
}
 801a9c8:	b003      	add	sp, #12
 801a9ca:	bd30      	pop	{r4, r5, pc}
 801a9cc:	00030d41 	.word	0x00030d41

0801a9d0 <USB_OTG_WritePacket>:
*/
USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
                                uint8_t             *src, 
                                uint8_t             ch_ep_num, 
                                uint16_t            len)
{
 801a9d0:	b510      	push	{r4, lr}
 801a9d2:	4614      	mov	r4, r2
  USB_OTG_STS status = USB_OTG_OK;
  if (pdev->cfg.dma_enable == 0)
 801a9d4:	78c2      	ldrb	r2, [r0, #3]
 801a9d6:	b93a      	cbnz	r2, 801a9e8 <USB_OTG_WritePacket+0x18>
  {
    uint32_t count32b= 0 , i= 0;
    __IO uint32_t *fifo;
    
    count32b =  (len + 3) / 4;
    fifo = pdev->regs.DFIFO[ch_ep_num];
 801a9d8:	eb00 0084 	add.w	r0, r0, r4, lsl #2
    count32b =  (len + 3) / 4;
 801a9dc:	3303      	adds	r3, #3
    fifo = pdev->regs.DFIFO[ch_ep_num];
 801a9de:	f8d0 00d0 	ldr.w	r0, [r0, #208]	@ 0xd0
    count32b =  (len + 3) / 4;
 801a9e2:	109b      	asrs	r3, r3, #2
    for (i = 0; i < count32b; i++, src+=4)
 801a9e4:	4293      	cmp	r3, r2
 801a9e6:	d101      	bne.n	801a9ec <USB_OTG_WritePacket+0x1c>
    {
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
    }
  }
  return status;
}
 801a9e8:	2000      	movs	r0, #0
 801a9ea:	bd10      	pop	{r4, pc}
      USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
 801a9ec:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
 801a9f0:	6004      	str	r4, [r0, #0]
    for (i = 0; i < count32b; i++, src+=4)
 801a9f2:	3201      	adds	r2, #1
 801a9f4:	e7f6      	b.n	801a9e4 <USB_OTG_WritePacket+0x14>

0801a9f6 <USB_OTG_ReadPacket>:
* @retval None
*/
void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
                         uint8_t *dest, 
                         uint16_t len)
{
 801a9f6:	b510      	push	{r4, lr}
  uint32_t i=0;
  uint32_t count32b = (len + 3) / 4;
 801a9f8:	3203      	adds	r2, #3
  
  __IO uint32_t *fifo = pdev->regs.DFIFO[0];
 801a9fa:	f8d0 00d0 	ldr.w	r0, [r0, #208]	@ 0xd0
  uint32_t count32b = (len + 3) / 4;
 801a9fe:	1092      	asrs	r2, r2, #2
  
  for ( i = 0; i < count32b; i++, dest += 4 )
 801aa00:	2300      	movs	r3, #0
 801aa02:	4293      	cmp	r3, r2
 801aa04:	d102      	bne.n	801aa0c <USB_OTG_ReadPacket+0x16>
  {
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
    
  }
  return ((void *)dest);
}
 801aa06:	eb01 0083 	add.w	r0, r1, r3, lsl #2
 801aa0a:	bd10      	pop	{r4, pc}
    *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
 801aa0c:	6804      	ldr	r4, [r0, #0]
 801aa0e:	f841 4023 	str.w	r4, [r1, r3, lsl #2]
  for ( i = 0; i < count32b; i++, dest += 4 )
 801aa12:	3301      	adds	r3, #1
 801aa14:	e7f5      	b.n	801aa02 <USB_OTG_ReadPacket+0xc>
	...

0801aa18 <USB_OTG_SelectCore>:
  USB_OTG_STS status = USB_OTG_OK;
  
  pdev->cfg.dma_enable       = 0;
  
  /* at startup the core is in FS mode */
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 801aa18:	2301      	movs	r3, #1
{
 801aa1a:	b570      	push	{r4, r5, r6, lr}
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
  
  /* initialize device cfg following its address */
  if (coreID == USB_OTG_FS_CORE_ID)
 801aa1c:	2901      	cmp	r1, #1
  pdev->cfg.speed            = USB_OTG_SPEED_FULL;
 801aa1e:	8043      	strh	r3, [r0, #2]
  pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
 801aa20:	f04f 0340 	mov.w	r3, #64	@ 0x40
 801aa24:	8083      	strh	r3, [r0, #4]
  if (coreID == USB_OTG_FS_CORE_ID)
 801aa26:	d132      	bne.n	801aa8e <USB_OTG_SelectCore+0x76>
  {
    baseAddress                = USB_OTG_FS_BASE_ADDR;
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
    pdev->cfg.host_channels    = 8 ;
 801aa28:	f44f 6381 	mov.w	r3, #1032	@ 0x408
 801aa2c:	8003      	strh	r3, [r0, #0]
    pdev->cfg.dev_endpoints    = 4 ;
    pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
 801aa2e:	f44f 73a0 	mov.w	r3, #320	@ 0x140
 801aa32:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
 801aa34:	2302      	movs	r3, #2
 801aa36:	7203      	strb	r3, [r0, #8]
    pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
 801aa38:	72c1      	strb	r1, [r0, #11]
    baseAddress                = USB_OTG_FS_BASE_ADDR;
 801aa3a:	f04f 43a0 	mov.w	r3, #1342177280	@ 0x50000000
    
  }
  
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
    USB_OTG_CORE_GLOBAL_REGS_OFFSET);
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 801aa3e:	f503 6200 	add.w	r2, r3, #2048	@ 0x800
    USB_OTG_DEV_GLOBAL_REG_OFFSET);
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801aa42:	7845      	ldrb	r5, [r0, #1]
  pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
 801aa44:	6102      	str	r2, [r0, #16]
  pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
 801aa46:	60c3      	str	r3, [r0, #12]
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801aa48:	f503 6210 	add.w	r2, r3, #2304	@ 0x900
 801aa4c:	f100 0414 	add.w	r4, r0, #20
 801aa50:	2100      	movs	r1, #0
 801aa52:	428d      	cmp	r5, r1
 801aa54:	d827      	bhi.n	801aaa6 <USB_OTG_SelectCore+0x8e>
        (i * USB_OTG_EP_REG_OFFSET));
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
      (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
        (i * USB_OTG_EP_REG_OFFSET));
  }
  pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
 801aa56:	f503 6280 	add.w	r2, r3, #1024	@ 0x400
 801aa5a:	6142      	str	r2, [r0, #20]
    USB_OTG_HOST_GLOBAL_REG_OFFSET);
  pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
 801aa5c:	f503 6288 	add.w	r2, r3, #1088	@ 0x440
 801aa60:	f8c0 20cc 	str.w	r2, [r0, #204]	@ 0xcc
  
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801aa64:	4602      	mov	r2, r0
 801aa66:	f503 64a0 	add.w	r4, r3, #1280	@ 0x500
 801aa6a:	f812 5b8c 	ldrb.w	r5, [r2], #140
 801aa6e:	2100      	movs	r1, #0
 801aa70:	428d      	cmp	r5, r1
 801aa72:	d820      	bhi.n	801aab6 <USB_OTG_SelectCore+0x9e>
 801aa74:	f503 5180 	add.w	r1, r3, #4096	@ 0x1000
 801aa78:	f100 04cc 	add.w	r4, r0, #204	@ 0xcc
  {
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
      USB_OTG_HOST_CHAN_REGS_OFFSET + \
        (i * USB_OTG_CHAN_REGS_OFFSET));
  }
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801aa7c:	2200      	movs	r2, #0
 801aa7e:	4295      	cmp	r5, r2
 801aa80:	d81e      	bhi.n	801aac0 <USB_OTG_SelectCore+0xa8>
  {
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
      (i * USB_OTG_DATA_FIFO_SIZE));
  }
  pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
 801aa82:	f503 6360 	add.w	r3, r3, #3584	@ 0xe00
 801aa86:	f8c0 310c 	str.w	r3, [r0, #268]	@ 0x10c
  
  return status;
}
 801aa8a:	2000      	movs	r0, #0
 801aa8c:	bd70      	pop	{r4, r5, r6, pc}
  else if (coreID == USB_OTG_HS_CORE_ID)
 801aa8e:	b941      	cbnz	r1, 801aaa2 <USB_OTG_SelectCore+0x8a>
    pdev->cfg.host_channels    = 12 ;
 801aa90:	f240 630c 	movw	r3, #1548	@ 0x60c
 801aa94:	8003      	strh	r3, [r0, #0]
    pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
 801aa96:	f44f 63a0 	mov.w	r3, #1280	@ 0x500
 801aa9a:	80c3      	strh	r3, [r0, #6]
    pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
 801aa9c:	72c1      	strb	r1, [r0, #11]
    baseAddress                = USB_OTG_HS_BASE_ADDR;
 801aa9e:	4b0b      	ldr	r3, [pc, #44]	@ (801aacc <USB_OTG_SelectCore+0xb4>)
 801aaa0:	e7cd      	b.n	801aa3e <USB_OTG_SelectCore+0x26>
  uint32_t i , baseAddress = 0;
 801aaa2:	2300      	movs	r3, #0
 801aaa4:	e7cb      	b.n	801aa3e <USB_OTG_SelectCore+0x26>
    pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
 801aaa6:	f844 2f04 	str.w	r2, [r4, #4]!
    pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
 801aaaa:	f502 7600 	add.w	r6, r2, #512	@ 0x200
 801aaae:	63e6      	str	r6, [r4, #60]	@ 0x3c
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801aab0:	3101      	adds	r1, #1
 801aab2:	3220      	adds	r2, #32
 801aab4:	e7cd      	b.n	801aa52 <USB_OTG_SelectCore+0x3a>
    pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
 801aab6:	f842 4f04 	str.w	r4, [r2, #4]!
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801aaba:	3101      	adds	r1, #1
 801aabc:	3420      	adds	r4, #32
 801aabe:	e7d7      	b.n	801aa70 <USB_OTG_SelectCore+0x58>
    pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
 801aac0:	f844 1f04 	str.w	r1, [r4, #4]!
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801aac4:	3201      	adds	r2, #1
 801aac6:	f501 5180 	add.w	r1, r1, #4096	@ 0x1000
 801aaca:	e7d8      	b.n	801aa7e <USB_OTG_SelectCore+0x66>
 801aacc:	40040000 	.word	0x40040000

0801aad0 <USB_OTG_CoreInit>:
*         device mode or host mode operation.
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
{
 801aad0:	b538      	push	{r3, r4, r5, lr}
  gccfg.d32 = 0;
  ahbcfg.d32 = 0;
  
  
  
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801aad2:	7a03      	ldrb	r3, [r0, #8]
  {
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 801aad4:	68c2      	ldr	r2, [r0, #12]
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801aad6:	2b01      	cmp	r3, #1
{
 801aad8:	4604      	mov	r4, r0
  gccfg.d32 = 0;
 801aada:	f04f 0500 	mov.w	r5, #0
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801aade:	d122      	bne.n	801ab26 <USB_OTG_CoreInit+0x56>
    gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
 801aae0:	6b95      	ldr	r5, [r2, #56]	@ 0x38
    gccfg.b.pwdn = 0;
    
    if (pdev->cfg.Sof_output)
 801aae2:	7a41      	ldrb	r1, [r0, #9]
    gccfg.b.pwdn = 0;
 801aae4:	f36f 4510 	bfc	r5, #16, #1
    if (pdev->cfg.Sof_output)
 801aae8:	b909      	cbnz	r1, 801aaee <USB_OTG_CoreInit+0x1e>
    {
      gccfg.b.sofouten = 1;   
 801aaea:	f3c5 5300 	ubfx	r3, r5, #20, #1
 801aaee:	f363 5514 	bfi	r5, r3, #20, #1
    }
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 801aaf2:	6395      	str	r5, [r2, #56]	@ 0x38
    
    /* Init The ULPI Interface */
    usbcfg.d32 = 0;
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801aaf4:	68d3      	ldr	r3, [r2, #12]
    
    usbcfg.b.physel            = 0; /* HS Interface */
 801aaf6:	f423 0394 	bic.w	r3, r3, #4849664	@ 0x4a0000
 801aafa:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
#endif 
    usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
    
    usbcfg.b.ulpi_fsls = 0;
    usbcfg.b.ulpi_clk_sus_m = 0;
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 801aafe:	60d3      	str	r3, [r2, #12]
    
    /* Reset after a PHY select  */
    USB_OTG_CoreReset(pdev);
 801ab00:	4620      	mov	r0, r4
 801ab02:	f7ff ff3d 	bl	801a980 <USB_OTG_CoreReset.isra.0>
    
    if(pdev->cfg.dma_enable == 1)
 801ab06:	78e3      	ldrb	r3, [r4, #3]
 801ab08:	2b01      	cmp	r3, #1
 801ab0a:	d123      	bne.n	801ab54 <USB_OTG_CoreInit+0x84>
    {
      
      ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
      ahbcfg.b.dmaenable = 1;
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 801ab0c:	68e3      	ldr	r3, [r4, #12]
 801ab0e:	222a      	movs	r2, #42	@ 0x2a
 801ab10:	609a      	str	r2, [r3, #8]
  }
  /* case the HS core is working in FS mode */
  if(pdev->cfg.dma_enable == 1)
  {
    
    ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
 801ab12:	68e1      	ldr	r1, [r4, #12]
 801ab14:	688b      	ldr	r3, [r1, #8]
    ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
 801ab16:	f023 023e 	bic.w	r2, r3, #62	@ 0x3e
 801ab1a:	f042 022a 	orr.w	r2, r2, #42	@ 0x2a
 801ab1e:	f362 0307 	bfi	r3, r2, #0, #8
    ahbcfg.b.dmaenable = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
 801ab22:	608b      	str	r3, [r1, #8]
 801ab24:	e016      	b.n	801ab54 <USB_OTG_CoreInit+0x84>
    usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
 801ab26:	68d3      	ldr	r3, [r2, #12]
    usbcfg.b.physel  = 1; /* FS Interface */
 801ab28:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 801ab2c:	60d3      	str	r3, [r2, #12]
    USB_OTG_CoreReset(pdev);
 801ab2e:	f7ff ff27 	bl	801a980 <USB_OTG_CoreReset.isra.0>
    if(pdev->cfg.Sof_output)
 801ab32:	7a63      	ldrb	r3, [r4, #9]
 801ab34:	3b00      	subs	r3, #0
 801ab36:	bf18      	it	ne
 801ab38:	2301      	movne	r3, #1
    gccfg.b.pwdn = 1;
 801ab3a:	011b      	lsls	r3, r3, #4
 801ab3c:	f043 032d 	orr.w	r3, r3, #45	@ 0x2d
 801ab40:	f363 4517 	bfi	r5, r3, #16, #8
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 801ab44:	68e3      	ldr	r3, [r4, #12]
    USB_OTG_BSP_mDelay(20);
 801ab46:	2014      	movs	r0, #20
    USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
 801ab48:	639d      	str	r5, [r3, #56]	@ 0x38
    USB_OTG_BSP_mDelay(20);
 801ab4a:	f7fc ff70 	bl	8017a2e <USB_OTG_BSP_mDelay>
  if(pdev->cfg.dma_enable == 1)
 801ab4e:	78e3      	ldrb	r3, [r4, #3]
 801ab50:	2b01      	cmp	r3, #1
 801ab52:	d0de      	beq.n	801ab12 <USB_OTG_CoreInit+0x42>
    
  }
  /* initialize OTG features */
#ifdef  USE_OTG_MODE
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801ab54:	68e2      	ldr	r2, [r4, #12]
 801ab56:	68d3      	ldr	r3, [r2, #12]
  usbcfg.b.hnpcap = 1;
  usbcfg.b.srpcap = 1;
 801ab58:	f3c3 2107 	ubfx	r1, r3, #8, #8
 801ab5c:	f041 0103 	orr.w	r1, r1, #3
 801ab60:	f361 230f 	bfi	r3, r1, #8, #8
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 801ab64:	60d3      	str	r3, [r2, #12]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 801ab66:	f06f 4380 	mvn.w	r3, #1073741824	@ 0x40000000
 801ab6a:	6153      	str	r3, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 801ab6c:	4b01      	ldr	r3, [pc, #4]	@ (801ab74 <USB_OTG_CoreInit+0xa4>)
 801ab6e:	6193      	str	r3, [r2, #24]
  USB_OTG_EnableCommonInt(pdev);
#endif
  return status;
}
 801ab70:	2000      	movs	r0, #0
 801ab72:	bd38      	pop	{r3, r4, r5, pc}
 801ab74:	d0000804 	.word	0xd0000804

0801ab78 <USB_OTG_EnableGlobalInt>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
 801ab78:	68c2      	ldr	r2, [r0, #12]
 801ab7a:	6893      	ldr	r3, [r2, #8]
 801ab7c:	f043 0301 	orr.w	r3, r3, #1
 801ab80:	6093      	str	r3, [r2, #8]
  return status;
}
 801ab82:	2000      	movs	r0, #0
 801ab84:	4770      	bx	lr

0801ab86 <USB_OTG_DisableGlobalInt>:
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GAHBCFG_TypeDef  ahbcfg;
  ahbcfg.d32 = 0;
  ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
 801ab86:	68c2      	ldr	r2, [r0, #12]
 801ab88:	6893      	ldr	r3, [r2, #8]
 801ab8a:	f023 0301 	bic.w	r3, r3, #1
 801ab8e:	6093      	str	r3, [r2, #8]
  return status;
}
 801ab90:	2000      	movs	r0, #0
 801ab92:	4770      	bx	lr

0801ab94 <USB_OTG_FlushTxFifo>:
* @param  pdev : Selected device
* @param  num : FO num
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
{
 801ab94:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  
  uint32_t count = 0;
  greset.d32 = 0;
 801ab96:	2300      	movs	r3, #0
 801ab98:	9301      	str	r3, [sp, #4]
  greset.b.txfflsh = 1;
 801ab9a:	9b01      	ldr	r3, [sp, #4]
 801ab9c:	f043 0320 	orr.w	r3, r3, #32
 801aba0:	9301      	str	r3, [sp, #4]
  greset.b.txfnum  = num;
 801aba2:	9b01      	ldr	r3, [sp, #4]
 801aba4:	f361 138a 	bfi	r3, r1, #6, #5
 801aba8:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801abaa:	68c2      	ldr	r2, [r0, #12]
 801abac:	9b01      	ldr	r3, [sp, #4]
 801abae:	6113      	str	r3, [r2, #16]
 801abb0:	4b07      	ldr	r3, [pc, #28]	@ (801abd0 <USB_OTG_FlushTxFifo+0x3c>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801abb2:	6911      	ldr	r1, [r2, #16]
 801abb4:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 801abb6:	3b01      	subs	r3, #1
 801abb8:	d002      	beq.n	801abc0 <USB_OTG_FlushTxFifo+0x2c>
    {
      break;
    }
  }
  while (greset.b.txfflsh == 1);
 801abba:	9901      	ldr	r1, [sp, #4]
 801abbc:	0689      	lsls	r1, r1, #26
 801abbe:	d4f8      	bmi.n	801abb2 <USB_OTG_FlushTxFifo+0x1e>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 801abc0:	2003      	movs	r0, #3
 801abc2:	f7fc ff31 	bl	8017a28 <USB_OTG_BSP_uDelay>
  return status;
}
 801abc6:	2000      	movs	r0, #0
 801abc8:	b003      	add	sp, #12
 801abca:	f85d fb04 	ldr.w	pc, [sp], #4
 801abce:	bf00      	nop
 801abd0:	00030d41 	.word	0x00030d41

0801abd4 <USB_OTG_FlushRxFifo>:
* @brief  USB_OTG_FlushRxFifo : Flush a Rx FIFO
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
{
 801abd4:	b507      	push	{r0, r1, r2, lr}
  USB_OTG_STS status = USB_OTG_OK;
  __IO USB_OTG_GRSTCTL_TypeDef  greset;
  uint32_t count = 0;
  
  greset.d32 = 0;
 801abd6:	2300      	movs	r3, #0
 801abd8:	9301      	str	r3, [sp, #4]
  greset.b.rxfflsh = 1;
 801abda:	9b01      	ldr	r3, [sp, #4]
 801abdc:	f043 0310 	orr.w	r3, r3, #16
 801abe0:	9301      	str	r3, [sp, #4]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
 801abe2:	68c2      	ldr	r2, [r0, #12]
 801abe4:	9b01      	ldr	r3, [sp, #4]
 801abe6:	6113      	str	r3, [r2, #16]
 801abe8:	4b07      	ldr	r3, [pc, #28]	@ (801ac08 <USB_OTG_FlushRxFifo+0x34>)
  do
  {
    greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
 801abea:	6911      	ldr	r1, [r2, #16]
 801abec:	9101      	str	r1, [sp, #4]
    if (++count > 200000)
 801abee:	3b01      	subs	r3, #1
 801abf0:	d002      	beq.n	801abf8 <USB_OTG_FlushRxFifo+0x24>
    {
      break;
    }
  }
  while (greset.b.rxfflsh == 1);
 801abf2:	9901      	ldr	r1, [sp, #4]
 801abf4:	06c9      	lsls	r1, r1, #27
 801abf6:	d4f8      	bmi.n	801abea <USB_OTG_FlushRxFifo+0x16>
  /* Wait for 3 PHY Clocks*/
  USB_OTG_BSP_uDelay(3);
 801abf8:	2003      	movs	r0, #3
 801abfa:	f7fc ff15 	bl	8017a28 <USB_OTG_BSP_uDelay>
  return status;
}
 801abfe:	2000      	movs	r0, #0
 801ac00:	b003      	add	sp, #12
 801ac02:	f85d fb04 	ldr.w	pc, [sp], #4
 801ac06:	bf00      	nop
 801ac08:	00030d41 	.word	0x00030d41

0801ac0c <USB_OTG_SetCurrentMode>:
USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
{
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_GUSBCFG_TypeDef  usbcfg;
  
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801ac0c:	68c0      	ldr	r0, [r0, #12]
{
 801ac0e:	b508      	push	{r3, lr}
  usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801ac10:	68c3      	ldr	r3, [r0, #12]
  
  usbcfg.b.force_host = 0;
 801ac12:	f3c3 6207 	ubfx	r2, r3, #24, #8
 801ac16:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
  usbcfg.b.force_dev = 0;
  
  if ( mode == HOST_MODE)
 801ac1a:	2901      	cmp	r1, #1
  usbcfg.b.force_host = 0;
 801ac1c:	f362 631f 	bfi	r3, r2, #24, #8
  if ( mode == HOST_MODE)
 801ac20:	d107      	bne.n	801ac32 <USB_OTG_SetCurrentMode+0x26>
  {
    usbcfg.b.force_host = 1;
 801ac22:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
  else if ( mode == DEVICE_MODE)
  {
    usbcfg.b.force_dev = 1;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
 801ac26:	60c3      	str	r3, [r0, #12]
  USB_OTG_BSP_mDelay(50);
 801ac28:	2032      	movs	r0, #50	@ 0x32
 801ac2a:	f7fc ff00 	bl	8017a2e <USB_OTG_BSP_mDelay>
  return status;
}
 801ac2e:	2000      	movs	r0, #0
 801ac30:	bd08      	pop	{r3, pc}
  else if ( mode == DEVICE_MODE)
 801ac32:	2900      	cmp	r1, #0
 801ac34:	d1f7      	bne.n	801ac26 <USB_OTG_SetCurrentMode+0x1a>
    usbcfg.b.force_dev = 1;
 801ac36:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801ac3a:	e7f4      	b.n	801ac26 <USB_OTG_SetCurrentMode+0x1a>

0801ac3c <USB_OTG_IsDeviceMode>:
* @param  pdev : Selected device
* @retval current mode
*/
uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 801ac3c:	68c3      	ldr	r3, [r0, #12]
 801ac3e:	6958      	ldr	r0, [r3, #20]
* @param  pdev : Selected device
* @retval num_in_ep
*/
uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) != HOST_MODE);
 801ac40:	43c0      	mvns	r0, r0
}
 801ac42:	f000 0001 	and.w	r0, r0, #1
 801ac46:	4770      	bx	lr

0801ac48 <USB_OTG_IsHostMode>:
  return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
 801ac48:	68c3      	ldr	r3, [r0, #12]
 801ac4a:	6958      	ldr	r0, [r3, #20]
* @retval num_in_ep
*/
uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_GetMode(pdev) == HOST_MODE);
}
 801ac4c:	f000 0001 	and.w	r0, r0, #1
 801ac50:	4770      	bx	lr

0801ac52 <USB_OTG_ReadCoreItr>:
* @retval Status
*/
uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v = 0;
  v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 801ac52:	68c3      	ldr	r3, [r0, #12]
 801ac54:	6958      	ldr	r0, [r3, #20]
  v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 801ac56:	699b      	ldr	r3, [r3, #24]
  return v;
}
 801ac58:	4018      	ands	r0, r3
 801ac5a:	4770      	bx	lr

0801ac5c <USB_OTG_IsEvenFrame>:
* @param  pdev : Selected device
* @retval Frame number
*/
uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
{
  return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
 801ac5c:	6943      	ldr	r3, [r0, #20]
 801ac5e:	6898      	ldr	r0, [r3, #8]
 801ac60:	43c0      	mvns	r0, r0
}
 801ac62:	f000 0001 	and.w	r0, r0, #1
 801ac66:	4770      	bx	lr

0801ac68 <USB_OTG_EnableHostInt>:
* @brief  USB_OTG_EnableHostInt: Enables the Host mode interrupts
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
{
 801ac68:	4602      	mov	r2, r0
  intmsk.d32 = 0;
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
  
  /* Clear any pending interrupts. */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 801ac6a:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 801ac6e:	68d3      	ldr	r3, [r2, #12]
  intmsk.d32 = 0;
 801ac70:	2000      	movs	r0, #0
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
 801ac72:	6198      	str	r0, [r3, #24]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
 801ac74:	6159      	str	r1, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 801ac76:	f06f 4180 	mvn.w	r1, #1073741824	@ 0x40000000
 801ac7a:	6159      	str	r1, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 801ac7c:	4906      	ldr	r1, [pc, #24]	@ (801ac98 <USB_OTG_EnableHostInt+0x30>)
 801ac7e:	6199      	str	r1, [r3, #24]
  
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 801ac80:	78d1      	ldrb	r1, [r2, #3]
    intmsk.b.rxstsqlvl  = 1;
  }  
  intmsk.b.portintr   = 1;
  intmsk.b.hcintr     = 1;
  intmsk.b.disconnect = 1;  
  intmsk.b.sofintr    = 1;  
 801ac82:	4a06      	ldr	r2, [pc, #24]	@ (801ac9c <USB_OTG_EnableHostInt+0x34>)
  if (pdev->cfg.dma_enable == 0)
 801ac84:	fab1 f181 	clz	r1, r1
 801ac88:	0949      	lsrs	r1, r1, #5
  intmsk.b.sofintr    = 1;  
 801ac8a:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
  intmsk.b.incomplisoout  = 1; 
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 801ac8e:	6999      	ldr	r1, [r3, #24]
 801ac90:	430a      	orrs	r2, r1
 801ac92:	619a      	str	r2, [r3, #24]
  return status;
}
 801ac94:	4770      	bx	lr
 801ac96:	bf00      	nop
 801ac98:	d0000804 	.word	0xd0000804
 801ac9c:	23200008 	.word	0x23200008

0801aca0 <USB_OTG_InitFSLSPClkSel>:
*/
void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
{
  USB_OTG_HCFG_TypeDef   hcfg;
  
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 801aca0:	6942      	ldr	r2, [r0, #20]
 801aca2:	6813      	ldr	r3, [r2, #0]
  hcfg.b.fslspclksel = freq;
 801aca4:	f361 0301 	bfi	r3, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 801aca8:	6013      	str	r3, [r2, #0]
}
 801acaa:	4770      	bx	lr

0801acac <USB_OTG_ReadHPRT0>:
*/
uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801acac:	f8d0 30cc 	ldr.w	r3, [r0, #204]	@ 0xcc
 801acb0:	6818      	ldr	r0, [r3, #0]
  hprt0.b.prtena = 0;
  hprt0.b.prtconndet = 0;
 801acb2:	f020 032e 	bic.w	r3, r0, #46	@ 0x2e
 801acb6:	f363 0007 	bfi	r0, r3, #0, #8
  hprt0.b.prtenchng = 0;
  hprt0.b.prtovrcurrchng = 0;
  return hprt0.d32;
}
 801acba:	4770      	bx	lr

0801acbc <USB_OTG_DriveVbus>:
{
 801acbc:	b538      	push	{r3, r4, r5, lr}
 801acbe:	4604      	mov	r4, r0
 801acc0:	460d      	mov	r5, r1
  USB_OTG_BSP_DriveVBUS(pdev, state);
 801acc2:	f7fc fed7 	bl	8017a74 <USB_OTG_BSP_DriveVBUS>
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 801acc6:	4620      	mov	r0, r4
 801acc8:	f7ff fff0 	bl	801acac <USB_OTG_ReadHPRT0>
  if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
 801accc:	04c2      	lsls	r2, r0, #19
 801acce:	d408      	bmi.n	801ace2 <USB_OTG_DriveVbus+0x26>
 801acd0:	2d01      	cmp	r5, #1
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801acd2:	bf02      	ittt	eq
 801acd4:	f8d4 30cc 	ldreq.w	r3, [r4, #204]	@ 0xcc
    hprt0.b.prtpwr = 1;
 801acd8:	f440 5080 	orreq.w	r0, r0, #4096	@ 0x1000
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801acdc:	6018      	streq	r0, [r3, #0]
  if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
 801acde:	04c3      	lsls	r3, r0, #19
 801ace0:	d505      	bpl.n	801acee <USB_OTG_DriveVbus+0x32>
 801ace2:	b925      	cbnz	r5, 801acee <USB_OTG_DriveVbus+0x32>
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801ace4:	f8d4 30cc 	ldr.w	r3, [r4, #204]	@ 0xcc
    hprt0.b.prtpwr = 0;
 801ace8:	f365 300c 	bfi	r0, r5, #12, #1
    USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801acec:	6018      	str	r0, [r3, #0]
}
 801acee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  USB_OTG_BSP_mDelay(200);
 801acf2:	20c8      	movs	r0, #200	@ 0xc8
 801acf4:	f7fc be9b 	b.w	8017a2e <USB_OTG_BSP_mDelay>

0801acf8 <USB_OTG_ReadHostAllChannels_intr>:
* @param  pdev : Selected device
* @retval Status
*/
uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
{
  return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
 801acf8:	6943      	ldr	r3, [r0, #20]
 801acfa:	6958      	ldr	r0, [r3, #20]
}
 801acfc:	4770      	bx	lr

0801acfe <USB_OTG_ResetPort>:
* @retval status
* @note : (1)The application must wait at least 10 ms (+ 10 ms security)
*   before clearing the reset bit.
*/
uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 801acfe:	b538      	push	{r3, r4, r5, lr}
 801ad00:	4605      	mov	r5, r0
  USB_OTG_HPRT0_TypeDef  hprt0;
  
  hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
 801ad02:	f7ff ffd3 	bl	801acac <USB_OTG_ReadHPRT0>
  hprt0.b.prtrst = 1;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801ad06:	f8d5 30cc 	ldr.w	r3, [r5, #204]	@ 0xcc
  hprt0.b.prtrst = 1;
 801ad0a:	f440 7480 	orr.w	r4, r0, #256	@ 0x100
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801ad0e:	601c      	str	r4, [r3, #0]
  USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
 801ad10:	200a      	movs	r0, #10
 801ad12:	f7fc fe8c 	bl	8017a2e <USB_OTG_BSP_mDelay>
  hprt0.b.prtrst = 0;
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801ad16:	f8d5 30cc 	ldr.w	r3, [r5, #204]	@ 0xcc
  hprt0.b.prtrst = 0;
 801ad1a:	f36f 2408 	bfc	r4, #8, #1
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
 801ad1e:	601c      	str	r4, [r3, #0]
  USB_OTG_BSP_mDelay (20);   
 801ad20:	2014      	movs	r0, #20
 801ad22:	f7fc fe84 	bl	8017a2e <USB_OTG_BSP_mDelay>
  return 1;
}
 801ad26:	2001      	movs	r0, #1
 801ad28:	bd38      	pop	{r3, r4, r5, pc}

0801ad2a <USB_OTG_CoreInitHost>:
{
 801ad2a:	b570      	push	{r4, r5, r6, lr}
 801ad2c:	4604      	mov	r4, r0
  USB_OTG_BSP_ConfigVBUS(pdev);
 801ad2e:	f7fc fe85 	bl	8017a3c <USB_OTG_BSP_ConfigVBUS>
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 801ad32:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
 801ad36:	2100      	movs	r1, #0
 801ad38:	6019      	str	r1, [r3, #0]
  if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
 801ad3a:	7a23      	ldrb	r3, [r4, #8]
 801ad3c:	2b01      	cmp	r3, #1
    USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); 
 801ad3e:	bf18      	it	ne
 801ad40:	2101      	movne	r1, #1
 801ad42:	4620      	mov	r0, r4
 801ad44:	f7ff ffac 	bl	801aca0 <USB_OTG_InitFSLSPClkSel>
  USB_OTG_ResetPort(pdev);
 801ad48:	f7ff ffd9 	bl	801acfe <USB_OTG_ResetPort>
  hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 801ad4c:	6962      	ldr	r2, [r4, #20]
 801ad4e:	6813      	ldr	r3, [r2, #0]
  hcfg.b.fslssupp = 0;
 801ad50:	f36f 0382 	bfc	r3, #2, #1
  USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
 801ad54:	6013      	str	r3, [r2, #0]
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
 801ad56:	7ae3      	ldrb	r3, [r4, #11]
 801ad58:	2b01      	cmp	r3, #1
 801ad5a:	68e3      	ldr	r3, [r4, #12]
 801ad5c:	d107      	bne.n	801ad6e <USB_OTG_CoreInitHost+0x44>
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 801ad5e:	2280      	movs	r2, #128	@ 0x80
 801ad60:	625a      	str	r2, [r3, #36]	@ 0x24
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
 801ad62:	f502 02c0 	add.w	r2, r2, #6291456	@ 0x600000
 801ad66:	629a      	str	r2, [r3, #40]	@ 0x28
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
 801ad68:	3260      	adds	r2, #96	@ 0x60
 801ad6a:	f8c3 2100 	str.w	r2, [r3, #256]	@ 0x100
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, (1 << 11), 0);
 801ad6e:	681a      	ldr	r2, [r3, #0]
 801ad70:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 801ad74:	601a      	str	r2, [r3, #0]
  USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
 801ad76:	2110      	movs	r1, #16
 801ad78:	4620      	mov	r0, r4
 801ad7a:	f7ff ff0b 	bl	801ab94 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 801ad7e:	4620      	mov	r0, r4
 801ad80:	f7ff ff28 	bl	801abd4 <USB_OTG_FlushRxFifo>
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801ad84:	4622      	mov	r2, r4
 801ad86:	2300      	movs	r3, #0
 801ad88:	f812 0b8c 	ldrb.w	r0, [r2], #140
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801ad8c:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
 801ad90:	461e      	mov	r6, r3
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801ad92:	4298      	cmp	r0, r3
 801ad94:	d804      	bhi.n	801ada0 <USB_OTG_CoreInitHost+0x76>
  USB_OTG_EnableHostInt(pdev);
 801ad96:	4620      	mov	r0, r4
 801ad98:	f7ff ff66 	bl	801ac68 <USB_OTG_EnableHostInt>
}
 801ad9c:	2000      	movs	r0, #0
 801ad9e:	bd70      	pop	{r4, r5, r6, pc}
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801ada0:	f852 1f04 	ldr.w	r1, [r2, #4]!
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801ada4:	3301      	adds	r3, #1
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
 801ada6:	608d      	str	r5, [r1, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINTMSK, 0 );
 801ada8:	60ce      	str	r6, [r1, #12]
  for (i = 0; i < pdev->cfg.host_channels; i++)
 801adaa:	e7f2      	b.n	801ad92 <USB_OTG_CoreInitHost+0x68>

0801adac <USB_OTG_HC_Init>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 801adac:	b5f0      	push	{r4, r5, r6, r7, lr}
  hcintmsk.d32 = 0;
  hcchar.d32 = 0;
  
  /* Clear old interrupt conditions for this host channel. */
  hcint.d32 = 0xFFFFFFFF;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 801adae:	eb00 0281 	add.w	r2, r0, r1, lsl #2
  if (pdev->cfg.dma_enable == 1)
  {
    hcintmsk.b.ahberr = 1;
  }
  
  switch (pdev->host.hc[hc_num].ep_type) 
 801adb2:	eb00 1541 	add.w	r5, r0, r1, lsl #5
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
 801adb6:	f8d2 4090 	ldr.w	r4, [r2, #144]	@ 0x90
 801adba:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801adbe:	60a2      	str	r2, [r4, #8]
  if (pdev->cfg.dma_enable == 1)
 801adc0:	78c2      	ldrb	r2, [r0, #3]
 801adc2:	1e57      	subs	r7, r2, #1
 801adc4:	427a      	negs	r2, r7
 801adc6:	417a      	adcs	r2, r7
  hcintmsk.d32 = 0;
 801adc8:	2300      	movs	r3, #0
  if (pdev->cfg.dma_enable == 1)
 801adca:	f362 0382 	bfi	r3, r2, #2, #1
  switch (pdev->host.hc[hc_num].ep_type) 
 801adce:	f895 2895 	ldrb.w	r2, [r5, #2197]	@ 0x895
    hcintmsk.b.xfercompl = 1;
    hcintmsk.b.stall = 1;
    hcintmsk.b.xacterr = 1;
    hcintmsk.b.datatglerr = 1;
    hcintmsk.b.nak = 1;  
    if (pdev->host.hc[hc_num].ep_is_in) 
 801add2:	f895 5892 	ldrb.w	r5, [r5, #2194]	@ 0x892
  switch (pdev->host.hc[hc_num].ep_type) 
 801add6:	014f      	lsls	r7, r1, #5
 801add8:	2a03      	cmp	r2, #3
 801adda:	d80d      	bhi.n	801adf8 <USB_OTG_HC_Init+0x4c>
 801addc:	e8df f002 	tbb	[pc, r2]
 801ade0:	4c025502 	.word	0x4c025502
    hcintmsk.b.xfercompl = 1;
 801ade4:	f443 6693 	orr.w	r6, r3, #1176	@ 0x498
 801ade8:	f046 0601 	orr.w	r6, r6, #1
 801adec:	f366 030f 	bfi	r3, r6, #0, #16
    if (pdev->host.hc[hc_num].ep_is_in) 
 801adf0:	2d00      	cmp	r5, #0
 801adf2:	d037      	beq.n	801ae64 <USB_OTG_HC_Init+0xb8>
    {
      hcintmsk.b.bblerr = 1;
 801adf4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
  
  
  /* Enable the top level host channel interrupt. */
  intr_enable = (1 << hc_num);
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 801adf8:	6946      	ldr	r6, [r0, #20]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINTMSK, hcintmsk.d32);
 801adfa:	60e3      	str	r3, [r4, #12]
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 801adfc:	f8d6 c018 	ldr.w	ip, [r6, #24]
  intr_enable = (1 << hc_num);
 801ae00:	2301      	movs	r3, #1
 801ae02:	408b      	lsls	r3, r1
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 801ae04:	ea43 030c 	orr.w	r3, r3, ip
  
  /* Make sure host channel interrupts are enabled. */
  gintmsk.b.hcintr = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 801ae08:	68c1      	ldr	r1, [r0, #12]
  USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
 801ae0a:	61b3      	str	r3, [r6, #24]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 801ae0c:	698b      	ldr	r3, [r1, #24]
  
  /* Program the HCCHAR register */
  hcchar.d32 = 0;
  hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
  hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
 801ae0e:	4438      	add	r0, r7
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
 801ae10:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 801ae14:	618b      	str	r3, [r1, #24]
  hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
  hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae16:	f890 1891 	ldrb.w	r1, [r0, #2193]	@ 0x891
 801ae1a:	f8b0 3896 	ldrh.w	r3, [r0, #2198]	@ 0x896
 801ae1e:	f001 010f 	and.w	r1, r1, #15
 801ae22:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801ae26:	ea43 23c1 	orr.w	r3, r3, r1, lsl #11
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 801ae2a:	f890 1893 	ldrb.w	r1, [r0, #2195]	@ 0x893
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae2e:	f005 0501 	and.w	r5, r5, #1
 801ae32:	ea43 33c5 	orr.w	r3, r3, r5, lsl #15
  hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
 801ae36:	1e8d      	subs	r5, r1, #2
 801ae38:	4269      	negs	r1, r5
 801ae3a:	4169      	adcs	r1, r5
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae3c:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
 801ae40:	f002 0103 	and.w	r1, r2, #3
 801ae44:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 801ae48:	f890 1890 	ldrb.w	r1, [r0, #2192]	@ 0x890
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 801ae4c:	1ed6      	subs	r6, r2, #3
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae4e:	f001 017f 	and.w	r1, r1, #127	@ 0x7f
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 801ae52:	4272      	negs	r2, r6
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae54:	ea43 5381 	orr.w	r3, r3, r1, lsl #22
  if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
 801ae58:	4172      	adcs	r2, r6
  hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
 801ae5a:	ea43 7342 	orr.w	r3, r3, r2, lsl #29
  {
    hcchar.b.oddfrm  = 1;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801ae5e:	6023      	str	r3, [r4, #0]
  return status;
}
 801ae60:	2000      	movs	r0, #0
 801ae62:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (pdev->host.hc[hc_num].do_ping) 
 801ae64:	19c6      	adds	r6, r0, r7
      hcintmsk.b.nyet = 1;
 801ae66:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
      if (pdev->host.hc[hc_num].do_ping) 
 801ae6a:	f896 6894 	ldrb.w	r6, [r6, #2196]	@ 0x894
 801ae6e:	2e00      	cmp	r6, #0
 801ae70:	d0c2      	beq.n	801adf8 <USB_OTG_HC_Init+0x4c>
        hcintmsk.b.ack = 1;
 801ae72:	f043 0320 	orr.w	r3, r3, #32
 801ae76:	e7bf      	b.n	801adf8 <USB_OTG_HC_Init+0x4c>
    hcintmsk.b.xfercompl = 1;
 801ae78:	f443 66d3 	orr.w	r6, r3, #1688	@ 0x698
 801ae7c:	f046 0601 	orr.w	r6, r6, #1
 801ae80:	f366 030f 	bfi	r3, r6, #0, #16
    if (pdev->host.hc[hc_num].ep_is_in) 
 801ae84:	2d00      	cmp	r5, #0
 801ae86:	d1b5      	bne.n	801adf4 <USB_OTG_HC_Init+0x48>
 801ae88:	e7b6      	b.n	801adf8 <USB_OTG_HC_Init+0x4c>
    hcintmsk.b.xfercompl = 1;
 801ae8a:	f443 7608 	orr.w	r6, r3, #544	@ 0x220
 801ae8e:	f046 0601 	orr.w	r6, r6, #1
 801ae92:	f366 030f 	bfi	r3, r6, #0, #16
    if (pdev->host.hc[hc_num].ep_is_in) 
 801ae96:	2d00      	cmp	r5, #0
 801ae98:	d0ae      	beq.n	801adf8 <USB_OTG_HC_Init+0x4c>
      hcintmsk.b.xacterr = 1;
 801ae9a:	f443 76c0 	orr.w	r6, r3, #384	@ 0x180
 801ae9e:	f366 030f 	bfi	r3, r6, #0, #16
 801aea2:	e7a9      	b.n	801adf8 <USB_OTG_HC_Init+0x4c>

0801aea4 <USB_OTG_HC_StartXfer>:
* @param  pdev : Selected device
* @param  hc_num : channel number
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
{
 801aea4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801aea8:	460a      	mov	r2, r1
  hctsiz.d32 = 0;
  hcchar.d32 = 0;
  intmsk.d32 = 0;
  
  /* Compute the expected number of packets associated to the transfer */
  if (pdev->host.hc[hc_num].xfer_len > 0)
 801aeaa:	014d      	lsls	r5, r1, #5
 801aeac:	eb00 1141 	add.w	r1, r0, r1, lsl #5
{
 801aeb0:	4604      	mov	r4, r0
  if (pdev->host.hc[hc_num].xfer_len > 0)
 801aeb2:	f8d1 08a0 	ldr.w	r0, [r1, #2208]	@ 0x8a0
 801aeb6:	2800      	cmp	r0, #0
 801aeb8:	d059      	beq.n	801af6e <USB_OTG_HC_StartXfer+0xca>
  {
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
      pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
 801aeba:	f8b1 3896 	ldrh.w	r3, [r1, #2198]	@ 0x896
 801aebe:	3801      	subs	r0, #1
 801aec0:	4418      	add	r0, r3
 801aec2:	fbb0 f0f3 	udiv	r0, r0, r3
    num_packets = (pdev->host.hc[hc_num].xfer_len + \
 801aec6:	b280      	uxth	r0, r0
    
    if (num_packets > max_hc_pkt_count)
 801aec8:	f5b0 7f80 	cmp.w	r0, #256	@ 0x100
 801aecc:	d904      	bls.n	801aed8 <USB_OTG_HC_StartXfer+0x34>
    {
      num_packets = max_hc_pkt_count;
      pdev->host.hc[hc_num].xfer_len = num_packets * \
 801aece:	021b      	lsls	r3, r3, #8
 801aed0:	f8c1 38a0 	str.w	r3, [r1, #2208]	@ 0x8a0
      num_packets = max_hc_pkt_count;
 801aed4:	f44f 7080 	mov.w	r0, #256	@ 0x100
  }
  else
  {
    num_packets = 1;
  }
  if (pdev->host.hc[hc_num].ep_is_in)
 801aed8:	1963      	adds	r3, r4, r5
 801aeda:	f893 9892 	ldrb.w	r9, [r3, #2194]	@ 0x892
 801aede:	f1b9 0f00 	cmp.w	r9, #0
 801aee2:	d004      	beq.n	801aeee <USB_OTG_HC_StartXfer+0x4a>
  {
    pdev->host.hc[hc_num].xfer_len = num_packets * \
      pdev->host.hc[hc_num].max_packet;
 801aee4:	f8b3 1896 	ldrh.w	r1, [r3, #2198]	@ 0x896
    pdev->host.hc[hc_num].xfer_len = num_packets * \
 801aee8:	4341      	muls	r1, r0
 801aeea:	f8c3 18a0 	str.w	r1, [r3, #2208]	@ 0x8a0
  }
  /* Initialize the HCTSIZn register */
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 801aeee:	1963      	adds	r3, r4, r5
  hctsiz.b.pktcnt = num_packets;
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 801aef0:	f102 0715 	add.w	r7, r2, #21
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 801aef4:	f8d3 18a0 	ldr.w	r1, [r3, #2208]	@ 0x8a0
  hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
 801aef8:	eb04 1647 	add.w	r6, r4, r7, lsl #5
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 801aefc:	f3c1 0312 	ubfx	r3, r1, #0, #19
 801af00:	f896 c5f8 	ldrb.w	ip, [r6, #1528]	@ 0x5f8
 801af04:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801af08:	eb04 0082 	add.w	r0, r4, r2, lsl #2
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 801af0c:	f00c 0c03 	and.w	ip, ip, #3
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801af10:	f8d0 8090 	ldr.w	r8, [r0, #144]	@ 0x90
  hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
 801af14:	ea43 734c 	orr.w	r3, r3, ip, lsl #29
 801af18:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801af1c:	f8c8 3010 	str.w	r3, [r8, #16]
  
  if (pdev->cfg.dma_enable == 1)
 801af20:	f894 a003 	ldrb.w	sl, [r4, #3]
 801af24:	f1ba 0f01 	cmp.w	sl, #1
  {
    USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
 801af28:	bf04      	itt	eq
 801af2a:	f8d6 35fc 	ldreq.w	r3, [r6, #1532]	@ 0x5fc
 801af2e:	f8c8 3014 	streq.w	r3, [r8, #20]
  }
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 801af32:	4620      	mov	r0, r4
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 801af34:	f8d8 6000 	ldr.w	r6, [r8]
  hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
 801af38:	f7ff fe90 	bl	801ac5c <USB_OTG_IsEvenFrame>
 801af3c:	0140      	lsls	r0, r0, #5
 801af3e:	f000 0020 	and.w	r0, r0, #32
 801af42:	f3c6 6304 	ubfx	r3, r6, #24, #5
 801af46:	f060 007f 	orn	r0, r0, #127	@ 0x7f
 801af4a:	4318      	orrs	r0, r3
 801af4c:	f360 661f 	bfi	r6, r0, #24, #8
  /* Set host channel enable */
  hcchar.b.chen = 1;
  hcchar.b.chdis = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
  
  if (pdev->cfg.dma_enable == 0) /* Slave mode */
 801af50:	ea59 0a0a 	orrs.w	sl, r9, sl
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801af54:	f8c8 6000 	str.w	r6, [r8]
  if (pdev->cfg.dma_enable == 0) /* Slave mode */
 801af58:	d11f      	bne.n	801af9a <USB_OTG_HC_StartXfer+0xf6>
  {  
    if((pdev->host.hc[hc_num].ep_is_in == 0) && 
 801af5a:	b1f1      	cbz	r1, 801af9a <USB_OTG_HC_StartXfer+0xf6>
       (pdev->host.hc[hc_num].xfer_len > 0))
    {
      switch(pdev->host.hc[hc_num].ep_type) 
 801af5c:	4425      	add	r5, r4
 801af5e:	f895 3895 	ldrb.w	r3, [r5, #2197]	@ 0x895
 801af62:	2b03      	cmp	r3, #3
 801af64:	d811      	bhi.n	801af8a <USB_OTG_HC_StartXfer+0xe6>
 801af66:	e8df f003 	tbb	[pc, r3]
 801af6a:	1b04      	.short	0x1b04
 801af6c:	1b04      	.short	0x1b04
    num_packets = 1;
 801af6e:	2001      	movs	r0, #1
 801af70:	e7b2      	b.n	801aed8 <USB_OTG_HC_StartXfer+0x34>
      {
        /* Non periodic transfer */
      case EP_TYPE_CTRL:
      case EP_TYPE_BULK:
        
        hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 801af72:	68e0      	ldr	r0, [r4, #12]
 801af74:	6ac5      	ldr	r5, [r0, #44]	@ 0x2c
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 801af76:	1ccb      	adds	r3, r1, #3
        
        /* check if there is enough space in FIFO space */
        if(len_words > hnptxsts.b.nptxfspcavail)
 801af78:	b2ad      	uxth	r5, r5
 801af7a:	f3c3 038f 	ubfx	r3, r3, #2, #16
 801af7e:	429d      	cmp	r5, r3
 801af80:	d203      	bcs.n	801af8a <USB_OTG_HC_StartXfer+0xe6>
        {
          /* need to process data in nptxfempty interrupt */
          intmsk.b.nptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 801af82:	6983      	ldr	r3, [r0, #24]
 801af84:	f043 0320 	orr.w	r3, r3, #32
        /* check if there is enough space in FIFO space */
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
        {
          /* need to process data in ptxfempty interrupt */
          intmsk.b.ptxfempty = 1;
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 801af88:	6183      	str	r3, [r0, #24]
      default:
        break;
      }
      
      /* Write packet into the Tx FIFO. */
      USB_OTG_WritePacket(pdev, 
 801af8a:	eb04 1747 	add.w	r7, r4, r7, lsl #5
 801af8e:	b28b      	uxth	r3, r1
 801af90:	4620      	mov	r0, r4
 801af92:	f8d7 15fc 	ldr.w	r1, [r7, #1532]	@ 0x5fc
 801af96:	f7ff fd1b 	bl	801a9d0 <USB_OTG_WritePacket>
                          pdev->host.hc[hc_num].xfer_buff , 
                          hc_num, pdev->host.hc[hc_num].xfer_len);
    }
  }
  return status;
}
 801af9a:	2000      	movs	r0, #0
 801af9c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 801afa0:	6963      	ldr	r3, [r4, #20]
 801afa2:	6918      	ldr	r0, [r3, #16]
        len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
 801afa4:	1ccb      	adds	r3, r1, #3
        if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
 801afa6:	b280      	uxth	r0, r0
 801afa8:	f3c3 038f 	ubfx	r3, r3, #2, #16
 801afac:	4298      	cmp	r0, r3
 801afae:	d2ec      	bcs.n	801af8a <USB_OTG_HC_StartXfer+0xe6>
          USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
 801afb0:	68e0      	ldr	r0, [r4, #12]
 801afb2:	6983      	ldr	r3, [r0, #24]
 801afb4:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 801afb8:	e7e6      	b.n	801af88 <USB_OTG_HC_StartXfer+0xe4>

0801afba <USB_OTG_HC_Halt>:
  USB_OTG_HPTXSTS_TypeDef             hptxsts;
  USB_OTG_HCCHAR_TypeDef              hcchar;
  
  nptxsts.d32 = 0;
  hptxsts.d32 = 0;
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 801afba:	eb00 0181 	add.w	r1, r0, r1, lsl #2
{
 801afbe:	b510      	push	{r4, lr}
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 801afc0:	f8d1 1090 	ldr.w	r1, [r1, #144]	@ 0x90
 801afc4:	680b      	ldr	r3, [r1, #0]
  hcchar.b.chen = 1;
  hcchar.b.chdis = 1;
 801afc6:	f3c3 6205 	ubfx	r2, r3, #24, #6
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 801afca:	461c      	mov	r4, r3
  hcchar.b.chdis = 1;
 801afcc:	f062 023f 	orn	r2, r2, #63	@ 0x3f
 801afd0:	f362 631f 	bfi	r3, r2, #24, #8
  
  /* Check for space in the request queue to issue the halt. */
  if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
 801afd4:	0362      	lsls	r2, r4, #13
 801afd6:	d409      	bmi.n	801afec <USB_OTG_HC_Halt+0x32>
  {
    nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 801afd8:	68c2      	ldr	r2, [r0, #12]
 801afda:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    if (nptxsts.b.nptxqspcavail == 0)
 801afdc:	f412 0f7f 	tst.w	r2, #16711680	@ 0xff0000
 801afe0:	d101      	bne.n	801afe6 <USB_OTG_HC_Halt+0x2c>
    {
      hcchar.b.chen = 0;
 801afe2:	f36f 73df 	bfc	r3, #31, #1
    if (hptxsts.b.ptxqspcavail == 0)
    {
      hcchar.b.chen = 0;
    }
  }
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801afe6:	600b      	str	r3, [r1, #0]
  return status;
}
 801afe8:	2000      	movs	r0, #0
 801afea:	bd10      	pop	{r4, pc}
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 801afec:	6942      	ldr	r2, [r0, #20]
 801afee:	6912      	ldr	r2, [r2, #16]
    if (hptxsts.b.ptxqspcavail == 0)
 801aff0:	e7f4      	b.n	801afdc <USB_OTG_HC_Halt+0x22>
	...

0801aff4 <USB_OTG_HC_DoPing>:
  USB_OTG_HCTSIZn_TypeDef   hctsiz;  
  
  hctsiz.d32 = 0;
  hctsiz.b.dopng = 1;
  hctsiz.b.pktcnt = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
 801aff4:	eb00 0081 	add.w	r0, r0, r1, lsl #2
 801aff8:	4b06      	ldr	r3, [pc, #24]	@ (801b014 <USB_OTG_HC_DoPing+0x20>)
 801affa:	f8d0 2090 	ldr.w	r2, [r0, #144]	@ 0x90
 801affe:	6113      	str	r3, [r2, #16]
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
 801b000:	6813      	ldr	r3, [r2, #0]
  hcchar.b.chen = 1;
  hcchar.b.chdis = 0;
 801b002:	f3c3 6105 	ubfx	r1, r3, #24, #6
 801b006:	f061 017f 	orn	r1, r1, #127	@ 0x7f
 801b00a:	f361 631f 	bfi	r3, r1, #24, #8
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
 801b00e:	6013      	str	r3, [r2, #0]
  return status;  
}
 801b010:	2000      	movs	r0, #0
 801b012:	4770      	bx	lr
 801b014:	80080000 	.word	0x80080000

0801b018 <USB_OTG_InitDevSpeed>:
*/
void USB_OTG_InitDevSpeed(USB_OTG_CORE_HANDLE *pdev , uint8_t speed)
{
  USB_OTG_DCFG_TypeDef   dcfg;
  
  dcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCFG);
 801b018:	6902      	ldr	r2, [r0, #16]
 801b01a:	6813      	ldr	r3, [r2, #0]
  dcfg.b.devspd = speed;
 801b01c:	f361 0301 	bfi	r3, r1, #0, #2
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCFG, dcfg.d32);
 801b020:	6013      	str	r3, [r2, #0]
}
 801b022:	4770      	bx	lr

0801b024 <USB_OTG_EnableDevInt>:
* @brief  USB_OTG_EnableDevInt : Enables the Device mode interrupts
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EnableDevInt(USB_OTG_CORE_HANDLE *pdev)
{
 801b024:	4602      	mov	r2, r0
  intmsk.d32 = 0;
  
  /* Disable all interrupts. */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
  /* Clear any pending interrupts */
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 801b026:	f06f 4180 	mvn.w	r1, #1073741824	@ 0x40000000
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 801b02a:	68d3      	ldr	r3, [r2, #12]
  intmsk.d32 = 0;
 801b02c:	2000      	movs	r0, #0
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, 0);
 801b02e:	6198      	str	r0, [r3, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 801b030:	6159      	str	r1, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, 0xBFFFFFFF);
 801b032:	6159      	str	r1, [r3, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32);
 801b034:	4906      	ldr	r1, [pc, #24]	@ (801b050 <USB_OTG_EnableDevInt+0x2c>)
 801b036:	6199      	str	r1, [r3, #24]
  /* Enable the common interrupts */
  USB_OTG_EnableCommonInt(pdev);
  
  if (pdev->cfg.dma_enable == 0)
 801b038:	78d1      	ldrb	r1, [r2, #3]
  intmsk.b.usbsuspend = 1;
  intmsk.b.usbreset   = 1;
  intmsk.b.enumdone   = 1;
  intmsk.b.inepintr   = 1;
  intmsk.b.outepintr  = 1;
  intmsk.b.sofintr    = 1; 
 801b03a:	4a06      	ldr	r2, [pc, #24]	@ (801b054 <USB_OTG_EnableDevInt+0x30>)
  if (pdev->cfg.dma_enable == 0)
 801b03c:	fab1 f181 	clz	r1, r1
 801b040:	0949      	lsrs	r1, r1, #5
  intmsk.b.sofintr    = 1; 
 801b042:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
  intmsk.b.incomplisoout    = 1;   
#ifdef VBUS_SENSING_ENABLED
  intmsk.b.sessreqintr    = 1; 
  intmsk.b.otgintr    = 1;    
#endif  
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
 801b046:	6999      	ldr	r1, [r3, #24]
 801b048:	430a      	orrs	r2, r1
 801b04a:	619a      	str	r2, [r3, #24]
  return status;
}
 801b04c:	4770      	bx	lr
 801b04e:	bf00      	nop
 801b050:	d0000804 	.word	0xd0000804
 801b054:	003c3808 	.word	0x003c3808

0801b058 <USB_OTG_CoreInitDev>:
{
 801b058:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 801b05a:	f8d0 310c 	ldr.w	r3, [r0, #268]	@ 0x10c
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 801b05e:	6902      	ldr	r2, [r0, #16]
  USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
 801b060:	2100      	movs	r1, #0
 801b062:	6019      	str	r1, [r3, #0]
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 801b064:	6813      	ldr	r3, [r2, #0]
  dcfg.b.perfrint = DCFG_FRAME_INTERVAL_80;
 801b066:	f361 23cc 	bfi	r3, r1, #11, #2
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32 );
 801b06a:	6013      	str	r3, [r2, #0]
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 801b06c:	7ac3      	ldrb	r3, [r0, #11]
 801b06e:	2b01      	cmp	r3, #1
{
 801b070:	4604      	mov	r4, r0
  if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID  )
 801b072:	d112      	bne.n	801b09a <USB_OTG_CoreInitDev+0x42>
    USB_OTG_InitDevSpeed (pdev , USB_OTG_SPEED_PARAM_FULL);
 801b074:	2103      	movs	r1, #3
 801b076:	f7ff ffcf 	bl	801b018 <USB_OTG_InitDevSpeed>
    USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
 801b07a:	68c3      	ldr	r3, [r0, #12]
 801b07c:	2280      	movs	r2, #128	@ 0x80
 801b07e:	625a      	str	r2, [r3, #36]	@ 0x24
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32 );
 801b080:	f502 0280 	add.w	r2, r2, #4194304	@ 0x400000
 801b084:	629a      	str	r2, [r3, #40]	@ 0x28
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[0], txfifosize.d32 );
 801b086:	f102 1240 	add.w	r2, r2, #4194368	@ 0x400040
 801b08a:	f8c3 2104 	str.w	r2, [r3, #260]	@ 0x104
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[1], txfifosize.d32 );
 801b08e:	f44f 72a0 	mov.w	r2, #320	@ 0x140
 801b092:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    USB_OTG_WRITE_REG32( &pdev->regs.GREGS->DIEPTXF[2], txfifosize.d32 );
 801b096:	f8c3 210c 	str.w	r2, [r3, #268]	@ 0x10c
  USB_OTG_FlushTxFifo(pdev , 0x10); /* all Tx FIFOs */
 801b09a:	2110      	movs	r1, #16
 801b09c:	4620      	mov	r0, r4
 801b09e:	f7ff fd79 	bl	801ab94 <USB_OTG_FlushTxFifo>
  USB_OTG_FlushRxFifo(pdev);
 801b0a2:	4620      	mov	r0, r4
 801b0a4:	f7ff fd96 	bl	801abd4 <USB_OTG_FlushRxFifo>
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 801b0a8:	6922      	ldr	r2, [r4, #16]
 801b0aa:	2300      	movs	r3, #0
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 801b0ac:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, 0 );
 801b0b0:	6113      	str	r3, [r2, #16]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, 0 );
 801b0b2:	6153      	str	r3, [r2, #20]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 801b0b4:	6191      	str	r1, [r2, #24]
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, 0 );
 801b0b6:	61d3      	str	r3, [r2, #28]
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b0b8:	7860      	ldrb	r0, [r4, #1]
 801b0ba:	f104 0514 	add.w	r5, r4, #20
 801b0be:	461e      	mov	r6, r3
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 801b0c0:	27ff      	movs	r7, #255	@ 0xff
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b0c2:	4298      	cmp	r0, r3
 801b0c4:	d814      	bhi.n	801b0f0 <USB_OTG_CoreInitDev+0x98>
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 801b0c6:	2300      	movs	r3, #0
 801b0c8:	f104 0550 	add.w	r5, r4, #80	@ 0x50
 801b0cc:	461e      	mov	r6, r3
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 801b0ce:	27ff      	movs	r7, #255	@ 0xff
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 801b0d0:	4298      	cmp	r0, r3
 801b0d2:	d81e      	bhi.n	801b112 <USB_OTG_CoreInitDev+0xba>
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPMSK, msk.d32, msk.d32);
 801b0d4:	6913      	ldr	r3, [r2, #16]
 801b0d6:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 801b0da:	6113      	str	r3, [r2, #16]
  if (pdev->cfg.dma_enable == 1)
 801b0dc:	78e3      	ldrb	r3, [r4, #3]
 801b0de:	2b01      	cmp	r3, #1
    USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DTHRCTL, dthrctl.d32);  
 801b0e0:	bf04      	itt	eq
 801b0e2:	4b14      	ldreq	r3, [pc, #80]	@ (801b134 <USB_OTG_CoreInitDev+0xdc>)
 801b0e4:	6313      	streq	r3, [r2, #48]	@ 0x30
  USB_OTG_EnableDevInt(pdev);
 801b0e6:	4620      	mov	r0, r4
 801b0e8:	f7ff ff9c 	bl	801b024 <USB_OTG_EnableDevInt>
}
 801b0ec:	2000      	movs	r0, #0
 801b0ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[i]->DIEPCTL);
 801b0f0:	f855 1f04 	ldr.w	r1, [r5, #4]!
 801b0f4:	f8d1 c000 	ldr.w	ip, [r1]
      depctl.d32 = 0;
 801b0f8:	f1bc 0f00 	cmp.w	ip, #0
 801b0fc:	bfac      	ite	ge
 801b0fe:	f04f 0c00 	movge.w	ip, #0
 801b102:	f04f 4c90 	movlt.w	ip, #1207959552	@ 0x48000000
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPCTL, depctl.d32);
 801b106:	f8c1 c000 	str.w	ip, [r1]
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b10a:	3301      	adds	r3, #1
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPTSIZ, 0);
 801b10c:	610e      	str	r6, [r1, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 801b10e:	608f      	str	r7, [r1, #8]
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b110:	e7d7      	b.n	801b0c2 <USB_OTG_CoreInitDev+0x6a>
    depctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[i]->DOEPCTL);
 801b112:	f855 1f04 	ldr.w	r1, [r5, #4]!
 801b116:	f8d1 c000 	ldr.w	ip, [r1]
      depctl.d32 = 0;
 801b11a:	f1bc 0f00 	cmp.w	ip, #0
 801b11e:	bfac      	ite	ge
 801b120:	f04f 0c00 	movge.w	ip, #0
 801b124:	f04f 4c90 	movlt.w	ip, #1207959552	@ 0x48000000
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPCTL, depctl.d32);
 801b128:	f8c1 c000 	str.w	ip, [r1]
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 801b12c:	3301      	adds	r3, #1
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPTSIZ, 0);
 801b12e:	610e      	str	r6, [r1, #16]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 801b130:	608f      	str	r7, [r1, #8]
  for (i = 0; i <  pdev->cfg.dev_endpoints; i++)
 801b132:	e7cd      	b.n	801b0d0 <USB_OTG_CoreInitDev+0x78>
 801b134:	00810103 	.word	0x00810103

0801b138 <USB_OTG_GetDeviceSpeed>:
{
  USB_OTG_DSTS_TypeDef  dsts;
  enum USB_OTG_SPEED speed = USB_SPEED_UNKNOWN;
  
  
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b138:	6903      	ldr	r3, [r0, #16]
 801b13a:	6898      	ldr	r0, [r3, #8]
  
  switch (dsts.b.enumspd)
 801b13c:	f3c0 0041 	ubfx	r0, r0, #1, #2
 801b140:	2802      	cmp	r0, #2
 801b142:	bf1d      	ittte	ne
 801b144:	f020 0002 	bicne.w	r0, r0, #2
 801b148:	f1c0 0003 	rsbne	r0, r0, #3
 801b14c:	b2c0      	uxtbne	r0, r0
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    speed = USB_SPEED_FULL;
    break;
    
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    speed = USB_SPEED_LOW;
 801b14e:	2001      	moveq	r0, #1
    break;
  }
  
  return speed;
}
 801b150:	4770      	bx	lr

0801b152 <USB_OTG_EP0Activate>:
  USB_OTG_DEPCTL_TypeDef  diepctl;
  USB_OTG_DCTL_TypeDef    dctl;
  
  dctl.d32 = 0;
  /* Read the Device Status and Endpoint 0 Control registers */
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b152:	6903      	ldr	r3, [r0, #16]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 801b154:	6981      	ldr	r1, [r0, #24]
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b156:	689a      	ldr	r2, [r3, #8]
  diepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL);
 801b158:	6808      	ldr	r0, [r1, #0]
  /* Set the MPS of the IN EP based on the enumeration speed */
  switch (dsts.b.enumspd)
 801b15a:	f3c2 0241 	ubfx	r2, r2, #1, #2
  {
  case DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ:
  case DSTS_ENUMSPD_FS_PHY_48MHZ:
    diepctl.b.mps = DEP0CTL_MPS_64;
 801b15e:	2a02      	cmp	r2, #2
 801b160:	bf0c      	ite	eq
 801b162:	2203      	moveq	r2, #3
 801b164:	2200      	movne	r2, #0
 801b166:	f362 000a 	bfi	r0, r2, #0, #11
    break;
  case DSTS_ENUMSPD_LS_PHY_6MHZ:
    diepctl.b.mps = DEP0CTL_MPS_8;
    break;
  }
  USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[0]->DIEPCTL, diepctl.d32);
 801b16a:	6008      	str	r0, [r1, #0]
  dctl.b.cgnpinnak = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, dctl.d32);
 801b16c:	685a      	ldr	r2, [r3, #4]
 801b16e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 801b172:	605a      	str	r2, [r3, #4]
  return status;
}
 801b174:	2000      	movs	r0, #0
 801b176:	4770      	bx	lr

0801b178 <USB_OTG_EPActivate>:
  depctl.d32 = 0;
  daintmsk.d32 = 0;
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b178:	780b      	ldrb	r3, [r1, #0]
{
 801b17a:	b570      	push	{r4, r5, r6, lr}
    daintmsk.ep.in = 1 << ep->num;
 801b17c:	2201      	movs	r2, #1
  if (ep->is_in == 1)
 801b17e:	784d      	ldrb	r5, [r1, #1]
    daintmsk.ep.in = 1 << ep->num;
 801b180:	409a      	lsls	r2, r3
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b182:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  if (ep->is_in == 1)
 801b186:	2d01      	cmp	r5, #1
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b188:	bf0c      	ite	eq
 801b18a:	699d      	ldreq	r5, [r3, #24]
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 801b18c:	6d5d      	ldrne	r5, [r3, #84]	@ 0x54
    daintmsk.ep.out = 1 << ep->num;
  }
  /* If the EP is already active don't change the EP Control
  * register. */
  depctl.d32 = USB_OTG_READ_REG32(addr);
 801b18e:	682e      	ldr	r6, [r5, #0]
  daintmsk.d32 = 0;
 801b190:	f04f 0400 	mov.w	r4, #0
    daintmsk.ep.in = 1 << ep->num;
 801b194:	b292      	uxth	r2, r2
 801b196:	bf0c      	ite	eq
 801b198:	f362 040f 	bfieq	r4, r2, #0, #16
    daintmsk.ep.out = 1 << ep->num;
 801b19c:	f362 441f 	bfine	r4, r2, #16, #16
  if (!depctl.b.usbactep)
 801b1a0:	0433      	lsls	r3, r6, #16
 801b1a2:	d414      	bmi.n	801b1ce <USB_OTG_EPActivate+0x56>
  {
    depctl.b.mps    = ep->maxpacket;
 801b1a4:	688b      	ldr	r3, [r1, #8]
 801b1a6:	78ca      	ldrb	r2, [r1, #3]
 801b1a8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801b1ac:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 801b1b0:	f002 0203 	and.w	r2, r2, #3
 801b1b4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 801b1b8:	ea43 4382 	orr.w	r3, r3, r2, lsl #18
 801b1bc:	88ca      	ldrh	r2, [r1, #6]
 801b1be:	f002 020f 	and.w	r2, r2, #15
 801b1c2:	ea43 5382 	orr.w	r3, r3, r2, lsl #22
 801b1c6:	4a05      	ldr	r2, [pc, #20]	@ (801b1dc <USB_OTG_EPActivate+0x64>)
 801b1c8:	4032      	ands	r2, r6
 801b1ca:	4313      	orrs	r3, r2
    depctl.b.eptype = ep->type;
    depctl.b.txfnum = ep->tx_fifo_num;
    depctl.b.setd0pid = 1;
    depctl.b.usbactep = 1;
    USB_OTG_WRITE_REG32(addr, depctl.d32);
 801b1cc:	602b      	str	r3, [r5, #0]
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, 0, daintmsk.d32);
  }
  else
#endif   
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, 0, daintmsk.d32);
 801b1ce:	6903      	ldr	r3, [r0, #16]
 801b1d0:	69da      	ldr	r2, [r3, #28]
 801b1d2:	4314      	orrs	r4, r2
 801b1d4:	61dc      	str	r4, [r3, #28]
  return status;
}
 801b1d6:	2000      	movs	r0, #0
 801b1d8:	bd70      	pop	{r4, r5, r6, pc}
 801b1da:	bf00      	nop
 801b1dc:	ec337800 	.word	0xec337800

0801b1e0 <USB_OTG_EPDeactivate>:
* @brief  USB_OTG_EPDeactivate : Deactivates an EP
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPDeactivate(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 801b1e0:	b530      	push	{r4, r5, lr}
  depctl.d32 = 0;
  daintmsk.d32 = 0;  
  /* Read DEPCTLn register */
  if (ep->is_in == 1)
  {
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b1e2:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1)
 801b1e4:	7849      	ldrb	r1, [r1, #1]
    daintmsk.ep.in = 1 << ep->num;
 801b1e6:	2201      	movs	r2, #1
 801b1e8:	409a      	lsls	r2, r3
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b1ea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  if (ep->is_in == 1)
 801b1ee:	2901      	cmp	r1, #1
{
 801b1f0:	4604      	mov	r4, r0
    addr = &pdev->regs.INEP_REGS[ep->num]->DIEPCTL;
 801b1f2:	bf0c      	ite	eq
 801b1f4:	699b      	ldreq	r3, [r3, #24]
  }
  else
  {
    addr = &pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL;
 801b1f6:	6d5b      	ldrne	r3, [r3, #84]	@ 0x54
  daintmsk.d32 = 0;  
 801b1f8:	f04f 0500 	mov.w	r5, #0
    daintmsk.ep.in = 1 << ep->num;
 801b1fc:	b292      	uxth	r2, r2
 801b1fe:	bf0c      	ite	eq
 801b200:	f362 050f 	bfieq	r5, r2, #0, #16
    daintmsk.ep.out = 1 << ep->num;
 801b204:	f362 451f 	bfine	r5, r2, #16, #16
  }
  depctl.b.usbactep = 0;
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 801b208:	2000      	movs	r0, #0
  {
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DEACHMSK, daintmsk.d32, 0);
  }
  else
#endif    
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 801b20a:	6922      	ldr	r2, [r4, #16]
  USB_OTG_WRITE_REG32(addr, depctl.d32);
 801b20c:	6018      	str	r0, [r3, #0]
    USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DAINTMSK, daintmsk.d32, 0);
 801b20e:	69d3      	ldr	r3, [r2, #28]
 801b210:	ea23 0305 	bic.w	r3, r3, r5
 801b214:	61d3      	str	r3, [r2, #28]
  return status;
}
 801b216:	bd30      	pop	{r4, r5, pc}

0801b218 <USB_OTG_EPStartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EPStartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 801b218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t fifoemptymsk = 0;  
  
  depctl.d32 = 0;
  deptsiz.d32 = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 801b21a:	784c      	ldrb	r4, [r1, #1]
  {
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 801b21c:	780a      	ldrb	r2, [r1, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 801b21e:	694b      	ldr	r3, [r1, #20]
      * exist ? 1 : 0)
      */
      deptsiz.b.xfersize = ep->xfer_len;
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
      
      if (ep->type == EP_TYPE_ISOC)
 801b220:	78ce      	ldrb	r6, [r1, #3]
  if (ep->is_in == 1)
 801b222:	2c01      	cmp	r4, #1
 801b224:	d14b      	bne.n	801b2be <USB_OTG_EPStartXfer+0xa6>
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPCTL));
 801b226:	eb00 0482 	add.w	r4, r0, r2, lsl #2
 801b22a:	69a7      	ldr	r7, [r4, #24]
 801b22c:	683c      	ldr	r4, [r7, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ));
 801b22e:	693d      	ldr	r5, [r7, #16]
    if (ep->xfer_len == 0)
 801b230:	f005 4e60 	and.w	lr, r5, #3758096384	@ 0xe0000000
 801b234:	b993      	cbnz	r3, 801b25c <USB_OTG_EPStartXfer+0x44>
      deptsiz.b.xfersize = 0;
 801b236:	f44e 2500 	orr.w	r5, lr, #524288	@ 0x80000
      {
        deptsiz.b.mc = 1;
      }       
    }
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPTSIZ, deptsiz.d32);
 801b23a:	613d      	str	r5, [r7, #16]
    
    if (pdev->cfg.dma_enable == 1)
 801b23c:	78c5      	ldrb	r5, [r0, #3]
 801b23e:	2d01      	cmp	r5, #1
 801b240:	d121      	bne.n	801b286 <USB_OTG_EPStartXfer+0x6e>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);
 801b242:	690d      	ldr	r5, [r1, #16]
 801b244:	617d      	str	r5, [r7, #20]
        }
      }
    }
    
    
    if (ep->type == EP_TYPE_ISOC)
 801b246:	2e01      	cmp	r6, #1
 801b248:	d12a      	bne.n	801b2a0 <USB_OTG_EPStartXfer+0x88>
    {
      dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b24a:	6905      	ldr	r5, [r0, #16]
 801b24c:	68ad      	ldr	r5, [r5, #8]
      
      if (((dsts.b.soffn)&0x1) == 0)
 801b24e:	05ed      	lsls	r5, r5, #23
      {
        depctl.b.setd1pid = 1;
 801b250:	bf54      	ite	pl
 801b252:	f044 5400 	orrpl.w	r4, r4, #536870912	@ 0x20000000
      }
      else
      {
        depctl.b.setd0pid = 1;
 801b256:	f044 5480 	orrmi.w	r4, r4, #268435456	@ 0x10000000
 801b25a:	e021      	b.n	801b2a0 <USB_OTG_EPStartXfer+0x88>
      deptsiz.b.pktcnt = (ep->xfer_len - 1 + ep->maxpacket) / ep->maxpacket;
 801b25c:	688d      	ldr	r5, [r1, #8]
 801b25e:	eb05 0c03 	add.w	ip, r5, r3
 801b262:	f10c 3cff 	add.w	ip, ip, #4294967295	@ 0xffffffff
 801b266:	fbbc fcf5 	udiv	ip, ip, r5
      deptsiz.b.xfersize = ep->xfer_len;
 801b26a:	4d2e      	ldr	r5, [pc, #184]	@ (801b324 <USB_OTG_EPStartXfer+0x10c>)
 801b26c:	ea05 4ccc 	and.w	ip, r5, ip, lsl #19
 801b270:	f3c3 0512 	ubfx	r5, r3, #0, #19
 801b274:	ea4c 0c05 	orr.w	ip, ip, r5
 801b278:	ea4c 050e 	orr.w	r5, ip, lr
      if (ep->type == EP_TYPE_ISOC)
 801b27c:	2e01      	cmp	r6, #1
        deptsiz.b.mc = 1;
 801b27e:	bf08      	it	eq
 801b280:	f366 755e 	bfieq	r5, r6, #29, #2
 801b284:	e7d9      	b.n	801b23a <USB_OTG_EPStartXfer+0x22>
      if (ep->type != EP_TYPE_ISOC)
 801b286:	2e01      	cmp	r6, #1
 801b288:	d0df      	beq.n	801b24a <USB_OTG_EPStartXfer+0x32>
        if (ep->xfer_len > 0)
 801b28a:	b14b      	cbz	r3, 801b2a0 <USB_OTG_EPStartXfer+0x88>
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b28c:	f8d0 c010 	ldr.w	ip, [r0, #16]
          fifoemptymsk = 1 << ep->num;
 801b290:	2501      	movs	r5, #1
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b292:	f8dc e034 	ldr.w	lr, [ip, #52]	@ 0x34
          fifoemptymsk = 1 << ep->num;
 801b296:	4095      	lsls	r5, r2
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b298:	ea45 050e 	orr.w	r5, r5, lr
 801b29c:	f8cc 5034 	str.w	r5, [ip, #52]	@ 0x34
      }
    } 
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
 801b2a0:	f3c4 6507 	ubfx	r5, r4, #24, #8
 801b2a4:	f065 057b 	orn	r5, r5, #123	@ 0x7b
 801b2a8:	f365 641f 	bfi	r4, r5, #24, #8
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
    
    if (ep->type == EP_TYPE_ISOC)
 801b2ac:	2e01      	cmp	r6, #1
    USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPCTL, depctl.d32);
 801b2ae:	603c      	str	r4, [r7, #0]
    if (ep->type == EP_TYPE_ISOC)
 801b2b0:	d103      	bne.n	801b2ba <USB_OTG_EPStartXfer+0xa2>
    {
      USB_OTG_WritePacket(pdev, ep->xfer_buff, ep->num, ep->xfer_len);   
 801b2b2:	68c9      	ldr	r1, [r1, #12]
 801b2b4:	b29b      	uxth	r3, r3
 801b2b6:	f7ff fb8b 	bl	801a9d0 <USB_OTG_WritePacket>
    depctl.b.cnak = 1;
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
  }
  return status;
}
 801b2ba:	2000      	movs	r0, #0
 801b2bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 801b2be:	eb00 0282 	add.w	r2, r0, r2, lsl #2
      deptsiz.b.xfersize = ep->maxpacket;
 801b2c2:	688f      	ldr	r7, [r1, #8]
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 801b2c4:	6d52      	ldr	r2, [r2, #84]	@ 0x54
      deptsiz.b.xfersize = ep->maxpacket;
 801b2c6:	f3c7 0c12 	ubfx	ip, r7, #0, #19
    depctl.d32  = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL));
 801b2ca:	6814      	ldr	r4, [r2, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ));
 801b2cc:	6915      	ldr	r5, [r2, #16]
    if (ep->xfer_len == 0)
 801b2ce:	b9c3      	cbnz	r3, 801b302 <USB_OTG_EPStartXfer+0xea>
      deptsiz.b.xfersize = ep->maxpacket;
 801b2d0:	f36c 0512 	bfi	r5, ip, #0, #19
      deptsiz.b.pktcnt = 1;
 801b2d4:	2301      	movs	r3, #1
 801b2d6:	f363 45dc 	bfi	r5, r3, #19, #10
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 801b2da:	6115      	str	r5, [r2, #16]
    if (pdev->cfg.dma_enable == 1)
 801b2dc:	78c3      	ldrb	r3, [r0, #3]
 801b2de:	2b01      	cmp	r3, #1
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 801b2e0:	bf04      	itt	eq
 801b2e2:	690b      	ldreq	r3, [r1, #16]
 801b2e4:	6153      	streq	r3, [r2, #20]
    if (ep->type == EP_TYPE_ISOC)
 801b2e6:	2e01      	cmp	r6, #1
 801b2e8:	d103      	bne.n	801b2f2 <USB_OTG_EPStartXfer+0xda>
      if (ep->even_odd_frame)
 801b2ea:	794b      	ldrb	r3, [r1, #5]
 801b2ec:	b1b3      	cbz	r3, 801b31c <USB_OTG_EPStartXfer+0x104>
        depctl.b.setd1pid = 1;
 801b2ee:	f044 5400 	orr.w	r4, r4, #536870912	@ 0x20000000
    depctl.b.cnak = 1;
 801b2f2:	f3c4 6307 	ubfx	r3, r4, #24, #8
 801b2f6:	f063 037b 	orn	r3, r3, #123	@ 0x7b
 801b2fa:	f363 641f 	bfi	r4, r3, #24, #8
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL, depctl.d32);
 801b2fe:	6014      	str	r4, [r2, #0]
 801b300:	e7db      	b.n	801b2ba <USB_OTG_EPStartXfer+0xa2>
      deptsiz.b.pktcnt = (ep->xfer_len + (ep->maxpacket - 1)) / ep->maxpacket;
 801b302:	443b      	add	r3, r7
 801b304:	3b01      	subs	r3, #1
 801b306:	fbb3 f3f7 	udiv	r3, r3, r7
 801b30a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b30e:	f363 45dc 	bfi	r5, r3, #19, #10
      deptsiz.b.xfersize = deptsiz.b.pktcnt * ep->maxpacket;
 801b312:	fb0c f303 	mul.w	r3, ip, r3
 801b316:	f363 0512 	bfi	r5, r3, #0, #19
 801b31a:	e7de      	b.n	801b2da <USB_OTG_EPStartXfer+0xc2>
        depctl.b.setd0pid = 1;
 801b31c:	f044 5480 	orr.w	r4, r4, #268435456	@ 0x10000000
 801b320:	e7e7      	b.n	801b2f2 <USB_OTG_EPStartXfer+0xda>
 801b322:	bf00      	nop
 801b324:	1ff80000 	.word	0x1ff80000

0801b328 <USB_OTG_EP0StartXfer>:
*         starts the xfer
* @param  pdev : Selected device
* @retval USB_OTG_STS : status
*/
USB_OTG_STS USB_OTG_EP0StartXfer(USB_OTG_CORE_HANDLE *pdev , USB_OTG_EP *ep)
{
 801b328:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t fifoemptymsk = 0;
  
  depctl.d32   = 0;
  deptsiz.d32  = 0;
  /* IN endpoint */
  if (ep->is_in == 1)
 801b32a:	784a      	ldrb	r2, [r1, #1]
  {
    in_regs = pdev->regs.INEP_REGS[0];
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
    /* Zero Length Packet? */
    if (ep->xfer_len == 0)
 801b32c:	694b      	ldr	r3, [r1, #20]
  if (ep->is_in == 1)
 801b32e:	2a01      	cmp	r2, #1
 801b330:	d133      	bne.n	801b39a <USB_OTG_EP0StartXfer+0x72>
    in_regs = pdev->regs.INEP_REGS[0];
 801b332:	6985      	ldr	r5, [r0, #24]
    depctl.d32  = USB_OTG_READ_REG32(&in_regs->DIEPCTL);
 801b334:	682c      	ldr	r4, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&in_regs->DIEPTSIZ);
 801b336:	692a      	ldr	r2, [r5, #16]
 801b338:	9200      	str	r2, [sp, #0]
    if (ep->xfer_len == 0)
 801b33a:	b13b      	cbz	r3, 801b34c <USB_OTG_EP0StartXfer+0x24>
      deptsiz.b.pktcnt = 1;
      
    }
    else
    {
      if (ep->xfer_len > ep->maxpacket)
 801b33c:	688a      	ldr	r2, [r1, #8]
 801b33e:	429a      	cmp	r2, r3
      {
        ep->xfer_len = ep->maxpacket;
 801b340:	bf3a      	itte	cc
 801b342:	614a      	strcc	r2, [r1, #20]
        deptsiz.b.xfersize = ep->maxpacket;
 801b344:	f002 037f 	andcc.w	r3, r2, #127	@ 0x7f
      }
      else
      {
        deptsiz.b.xfersize = ep->xfer_len;
 801b348:	f003 037f 	andcs.w	r3, r3, #127	@ 0x7f
      deptsiz.b.xfersize = 0;
 801b34c:	9a00      	ldr	r2, [sp, #0]
 801b34e:	f422 12c0 	bic.w	r2, r2, #1572864	@ 0x180000
 801b352:	f022 027f 	bic.w	r2, r2, #127	@ 0x7f
 801b356:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 801b35a:	431a      	orrs	r2, r3
      }
      deptsiz.b.pktcnt = 1;
    }
    USB_OTG_WRITE_REG32(&in_regs->DIEPTSIZ, deptsiz.d32);
 801b35c:	612a      	str	r2, [r5, #16]
      deptsiz.b.xfersize = 0;
 801b35e:	9200      	str	r2, [sp, #0]
    
    if (pdev->cfg.dma_enable == 1)
 801b360:	78c2      	ldrb	r2, [r0, #3]
 801b362:	2a01      	cmp	r2, #1
 801b364:	d105      	bne.n	801b372 <USB_OTG_EP0StartXfer+0x4a>
    {
      USB_OTG_WRITE_REG32(&pdev->regs.INEP_REGS[ep->num]->DIEPDMA, ep->dma_addr);  
 801b366:	780b      	ldrb	r3, [r1, #0]
 801b368:	690e      	ldr	r6, [r1, #16]
 801b36a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 801b36e:	699b      	ldr	r3, [r3, #24]
 801b370:	615e      	str	r6, [r3, #20]
    }
    
    /* EP enable, IN data in FIFO */
    depctl.b.cnak = 1;
 801b372:	f3c4 6307 	ubfx	r3, r4, #24, #8
 801b376:	f063 037b 	orn	r3, r3, #123	@ 0x7b
 801b37a:	f363 641f 	bfi	r4, r3, #24, #8
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32(&in_regs->DIEPCTL, depctl.d32);
 801b37e:	602c      	str	r4, [r5, #0]
    
    
    
    if (pdev->cfg.dma_enable == 0)
 801b380:	b942      	cbnz	r2, 801b394 <USB_OTG_EP0StartXfer+0x6c>
    {
      /* Enable the Tx FIFO Empty Interrupt for this EP */
      if (ep->xfer_len > 0)
 801b382:	694b      	ldr	r3, [r1, #20]
 801b384:	b133      	cbz	r3, 801b394 <USB_OTG_EP0StartXfer+0x6c>
      {
        {
          fifoemptymsk |= 1 << ep->num;
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b386:	6902      	ldr	r2, [r0, #16]
          fifoemptymsk |= 1 << ep->num;
 801b388:	7809      	ldrb	r1, [r1, #0]
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b38a:	6b50      	ldr	r0, [r2, #52]	@ 0x34
          fifoemptymsk |= 1 << ep->num;
 801b38c:	2301      	movs	r3, #1
 801b38e:	408b      	lsls	r3, r1
          USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, 0, fifoemptymsk);
 801b390:	4303      	orrs	r3, r0
 801b392:	6353      	str	r3, [r2, #52]	@ 0x34
    depctl.b.epena = 1;
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
    
  }
  return status;
}
 801b394:	2000      	movs	r0, #0
 801b396:	b002      	add	sp, #8
 801b398:	bd70      	pop	{r4, r5, r6, pc}
    depctl.d32  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 801b39a:	780a      	ldrb	r2, [r1, #0]
 801b39c:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 801b3a0:	6d55      	ldr	r5, [r2, #84]	@ 0x54
 801b3a2:	682c      	ldr	r4, [r5, #0]
    deptsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ);
 801b3a4:	692a      	ldr	r2, [r5, #16]
 801b3a6:	9200      	str	r2, [sp, #0]
      deptsiz.b.xfersize = ep->maxpacket;
 801b3a8:	688a      	ldr	r2, [r1, #8]
    if (ep->xfer_len == 0)
 801b3aa:	b103      	cbz	r3, 801b3ae <USB_OTG_EP0StartXfer+0x86>
      ep->xfer_len = ep->maxpacket;
 801b3ac:	614a      	str	r2, [r1, #20]
      deptsiz.b.xfersize = ep->maxpacket;
 801b3ae:	9b00      	ldr	r3, [sp, #0]
 801b3b0:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 801b3b4:	f423 13c0 	bic.w	r3, r3, #1572864	@ 0x180000
 801b3b8:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801b3bc:	f442 2200 	orr.w	r2, r2, #524288	@ 0x80000
 801b3c0:	431a      	orrs	r2, r3
    USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPTSIZ, deptsiz.d32);
 801b3c2:	612a      	str	r2, [r5, #16]
    if (pdev->cfg.dma_enable == 1)
 801b3c4:	78c3      	ldrb	r3, [r0, #3]
 801b3c6:	2b01      	cmp	r3, #1
      USB_OTG_WRITE_REG32(&pdev->regs.OUTEP_REGS[ep->num]->DOEPDMA, ep->dma_addr);
 801b3c8:	bf04      	itt	eq
 801b3ca:	690b      	ldreq	r3, [r1, #16]
 801b3cc:	616b      	streq	r3, [r5, #20]
    depctl.b.cnak = 1;
 801b3ce:	f3c4 6307 	ubfx	r3, r4, #24, #8
 801b3d2:	f063 037b 	orn	r3, r3, #123	@ 0x7b
 801b3d6:	f363 641f 	bfi	r4, r3, #24, #8
    USB_OTG_WRITE_REG32 (&(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL), depctl.d32);
 801b3da:	602c      	str	r4, [r5, #0]
 801b3dc:	e7da      	b.n	801b394 <USB_OTG_EP0StartXfer+0x6c>
	...

0801b3e0 <USB_OTG_EPSetStall>:
  USB_OTG_STS status = USB_OTG_OK;
  USB_OTG_DEPCTL_TypeDef  depctl;
  __IO uint32_t *depctl_addr;
  
  depctl.d32 = 0;
  if (ep->is_in == 1)
 801b3e0:	784b      	ldrb	r3, [r1, #1]
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b3e2:	780a      	ldrb	r2, [r1, #0]
  if (ep->is_in == 1)
 801b3e4:	2b01      	cmp	r3, #1
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b3e6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  if (ep->is_in == 1)
 801b3ea:	d111      	bne.n	801b410 <USB_OTG_EPSetStall+0x30>
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b3ec:	6980      	ldr	r0, [r0, #24]
    /* set the disable and stall bits */
    if (depctl.b.epena)
    {
      depctl.b.epdis = 1;
    }
    depctl.b.stall = 1;
 801b3ee:	490b      	ldr	r1, [pc, #44]	@ (801b41c <USB_OTG_EPSetStall+0x3c>)
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 801b3f0:	6802      	ldr	r2, [r0, #0]
    if (depctl.b.epena)
 801b3f2:	2a00      	cmp	r2, #0
      depctl.b.epdis = 1;
 801b3f4:	bfa8      	it	ge
 801b3f6:	f3c2 7380 	ubfxge	r3, r2, #30, #1
    depctl.b.stall = 1;
 801b3fa:	039b      	lsls	r3, r3, #14
 801b3fc:	ea01 4112 	and.w	r1, r1, r2, lsr #16
 801b400:	f043 0320 	orr.w	r3, r3, #32
 801b404:	430b      	orrs	r3, r1
 801b406:	f363 421f 	bfi	r2, r3, #16, #16
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 801b40a:	6002      	str	r2, [r0, #0]
    /* set the stall bit */
    depctl.b.stall = 1;
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
  }
  return status;
}
 801b40c:	2000      	movs	r0, #0
 801b40e:	4770      	bx	lr
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 801b410:	6d42      	ldr	r2, [r0, #84]	@ 0x54
    depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 801b412:	6813      	ldr	r3, [r2, #0]
    depctl.b.stall = 1;
 801b414:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
    USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 801b418:	6013      	str	r3, [r2, #0]
 801b41a:	e7f7      	b.n	801b40c <USB_OTG_EPSetStall+0x2c>
 801b41c:	ffffbfdf 	.word	0xffffbfdf

0801b420 <USB_OTG_EPClearStall>:
  
  depctl.d32 = 0;
  
  if (ep->is_in == 1)
  {
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b420:	780b      	ldrb	r3, [r1, #0]
  if (ep->is_in == 1)
 801b422:	784a      	ldrb	r2, [r1, #1]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
  }
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
  /* clear the stall bits */
  depctl.b.stall = 0;
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 801b424:	78c9      	ldrb	r1, [r1, #3]
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b426:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  if (ep->is_in == 1)
 801b42a:	2a01      	cmp	r2, #1
    depctl_addr = &(pdev->regs.INEP_REGS[ep->num]->DIEPCTL);
 801b42c:	bf0c      	ite	eq
 801b42e:	6982      	ldreq	r2, [r0, #24]
    depctl_addr = &(pdev->regs.OUTEP_REGS[ep->num]->DOEPCTL);
 801b430:	6d42      	ldrne	r2, [r0, #84]	@ 0x54
  depctl.d32 = USB_OTG_READ_REG32(depctl_addr);
 801b432:	6813      	ldr	r3, [r2, #0]
  if (ep->type == EP_TYPE_INTR || ep->type == EP_TYPE_BULK)
 801b434:	3902      	subs	r1, #2
 801b436:	2901      	cmp	r1, #1
  depctl.b.stall = 0;
 801b438:	f36f 5355 	bfc	r3, #21, #1
  {
    depctl.b.setd0pid = 1; /* DATA0 */
 801b43c:	bf8c      	ite	hi
 801b43e:	f3c3 7100 	ubfxhi	r1, r3, #28, #1
 801b442:	2101      	movls	r1, #1
 801b444:	f361 731c 	bfi	r3, r1, #28, #1
  }
  USB_OTG_WRITE_REG32(depctl_addr, depctl.d32);
 801b448:	6013      	str	r3, [r2, #0]
  return status;
}
 801b44a:	2000      	movs	r0, #0
 801b44c:	4770      	bx	lr

0801b44e <USB_OTG_ReadDevAllOutEp_itr>:
* @retval OUT endpoint interrupt bits
*/
uint32_t USB_OTG_ReadDevAllOutEp_itr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 801b44e:	6903      	ldr	r3, [r0, #16]
 801b450:	6998      	ldr	r0, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 801b452:	69db      	ldr	r3, [r3, #28]
 801b454:	4018      	ands	r0, r3
  return ((v & 0xffff0000) >> 16);
}
 801b456:	0c00      	lsrs	r0, r0, #16
 801b458:	4770      	bx	lr

0801b45a <USB_OTG_ReadDevOutEP_itr>:
* @retval Device OUT EP Interrupt register
*/
uint32_t USB_OTG_ReadDevOutEP_itr(USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
{
  uint32_t v;
  v  = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[epnum]->DOEPINT);
 801b45a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 801b45e:	6d4b      	ldr	r3, [r1, #84]	@ 0x54
 801b460:	689a      	ldr	r2, [r3, #8]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DOEPMSK);
 801b462:	6903      	ldr	r3, [r0, #16]
 801b464:	6958      	ldr	r0, [r3, #20]
  return v;
}
 801b466:	4010      	ands	r0, r2
 801b468:	4770      	bx	lr

0801b46a <USB_OTG_ReadDevAllInEPItr>:
* @retval int status register
*/
uint32_t USB_OTG_ReadDevAllInEPItr(USB_OTG_CORE_HANDLE *pdev)
{
  uint32_t v;
  v = USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINT);
 801b46a:	6903      	ldr	r3, [r0, #16]
 801b46c:	6998      	ldr	r0, [r3, #24]
  v &= USB_OTG_READ_REG32(&pdev->regs.DREGS->DAINTMSK);
 801b46e:	69db      	ldr	r3, [r3, #28]
 801b470:	4018      	ands	r0, r3
  return (v & 0xffff);
}
 801b472:	b280      	uxth	r0, r0
 801b474:	4770      	bx	lr
	...

0801b478 <USB_OTG_EP0_OutStart>:
  USB_OTG_DEP0XFRSIZ_TypeDef  doeptsize0;
  doeptsize0.d32 = 0;
  doeptsize0.b.supcnt = 3;
  doeptsize0.b.pktcnt = 1;
  doeptsize0.b.xfersize = 8 * 3;
  USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPTSIZ, doeptsize0.d32 );
 801b478:	6d43      	ldr	r3, [r0, #84]	@ 0x54
 801b47a:	4a06      	ldr	r2, [pc, #24]	@ (801b494 <USB_OTG_EP0_OutStart+0x1c>)
 801b47c:	611a      	str	r2, [r3, #16]
  
  if (pdev->cfg.dma_enable == 1)
 801b47e:	78c2      	ldrb	r2, [r0, #3]
 801b480:	2a01      	cmp	r2, #1
 801b482:	d106      	bne.n	801b492 <USB_OTG_EP0_OutStart+0x1a>
  {
    USB_OTG_DEPCTL_TypeDef  doepctl;
    doepctl.d32 = 0;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPDMA, 
 801b484:	f200 50cc 	addw	r0, r0, #1484	@ 0x5cc
 801b488:	6158      	str	r0, [r3, #20]
                        (uint32_t)&pdev->dev.setup_packet);
    
    /* EP enable */
    doepctl.d32 = USB_OTG_READ_REG32(&pdev->regs.OUTEP_REGS[0]->DOEPCTL);
 801b48a:	681a      	ldr	r2, [r3, #0]
    doepctl.b.epena = 1;
    doepctl.d32 = 0x80008000;
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[0]->DOEPCTL, doepctl.d32);
 801b48c:	f04f 2280 	mov.w	r2, #2147516416	@ 0x80008000
 801b490:	601a      	str	r2, [r3, #0]
  }
}
 801b492:	4770      	bx	lr
 801b494:	c0080018 	.word	0xc0080018

0801b498 <DCD_Init>:



void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
              USB_OTG_CORE_ID_TypeDef coreID)
{
 801b498:	b570      	push	{r4, r5, r6, lr}
 801b49a:	4604      	mov	r4, r0
  uint32_t i;
  USB_OTG_EP *ep;
  
  USB_OTG_SelectCore (pdev , coreID);
  
  pdev->dev.device_status = USB_OTG_DEFAULT;
 801b49c:	2501      	movs	r5, #1
  USB_OTG_SelectCore (pdev , coreID);
 801b49e:	f7ff fabb 	bl	801aa18 <USB_OTG_SelectCore>
  pdev->dev.device_address = 0;
 801b4a2:	2300      	movs	r3, #0
  
  /* Init ep structure */
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b4a4:	7860      	ldrb	r0, [r4, #1]
  pdev->dev.device_status = USB_OTG_DEFAULT;
 801b4a6:	f884 5112 	strb.w	r5, [r4, #274]	@ 0x112
  pdev->dev.device_address = 0;
 801b4aa:	f884 3114 	strb.w	r3, [r4, #276]	@ 0x114
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b4ae:	f504 728e 	add.w	r2, r4, #284	@ 0x11c
    /* Init ep structure */
    ep->is_in = 1;
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is actvated */
    ep->type = EP_TYPE_CTRL;
 801b4b2:	4619      	mov	r1, r3
    ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
 801b4b4:	2640      	movs	r6, #64	@ 0x40
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b4b6:	4298      	cmp	r0, r3
 801b4b8:	f102 0228 	add.w	r2, r2, #40	@ 0x28
 801b4bc:	d81a      	bhi.n	801b4f4 <DCD_Init+0x5c>
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b4be:	2200      	movs	r2, #0
 801b4c0:	f504 735d 	add.w	r3, r4, #884	@ 0x374
  {
    ep = &pdev->dev.out_ep[i];
    /* Init ep structure */
    ep->is_in = 0;
 801b4c4:	4611      	mov	r1, r2
    ep->num = i;
    ep->tx_fifo_num = i;
    /* Control until ep is activated */
    ep->type = EP_TYPE_CTRL;
    ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
 801b4c6:	2540      	movs	r5, #64	@ 0x40
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b4c8:	4290      	cmp	r0, r2
 801b4ca:	f103 0328 	add.w	r3, r3, #40	@ 0x28
 801b4ce:	d81f      	bhi.n	801b510 <DCD_Init+0x78>
    ep->xfer_buff = 0;
    ep->xfer_len = 0;
  }
  
  USB_OTG_DisableGlobalInt(pdev);
 801b4d0:	4620      	mov	r0, r4
 801b4d2:	f7ff fb58 	bl	801ab86 <USB_OTG_DisableGlobalInt>
  
  /*Init the Core (common init.) */
  USB_OTG_CoreInit(pdev);
 801b4d6:	4620      	mov	r0, r4
 801b4d8:	f7ff fafa 	bl	801aad0 <USB_OTG_CoreInit>


  /* Force Device Mode*/
  USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
 801b4dc:	2100      	movs	r1, #0
 801b4de:	4620      	mov	r0, r4
 801b4e0:	f7ff fb94 	bl	801ac0c <USB_OTG_SetCurrentMode>
  
  /* Init Device */
  USB_OTG_CoreInitDev(pdev);
 801b4e4:	4620      	mov	r0, r4
 801b4e6:	f7ff fdb7 	bl	801b058 <USB_OTG_CoreInitDev>
  
  
  /* Enable USB Global interrupt */
  USB_OTG_EnableGlobalInt(pdev);
 801b4ea:	4620      	mov	r0, r4
}
 801b4ec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  USB_OTG_EnableGlobalInt(pdev);
 801b4f0:	f7ff bb42 	b.w	801ab78 <USB_OTG_EnableGlobalInt>
    ep->num = i;
 801b4f4:	f802 3c28 	strb.w	r3, [r2, #-40]
    ep->tx_fifo_num = i;
 801b4f8:	f822 3c22 	strh.w	r3, [r2, #-34]
    ep->xfer_buff = 0;
 801b4fc:	e942 6108 	strd	r6, r1, [r2, #-32]
    ep->is_in = 1;
 801b500:	f802 5c27 	strb.w	r5, [r2, #-39]
    ep->type = EP_TYPE_CTRL;
 801b504:	f802 1c25 	strb.w	r1, [r2, #-37]
    ep->xfer_len = 0;
 801b508:	f842 1c14 	str.w	r1, [r2, #-20]
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b50c:	3301      	adds	r3, #1
 801b50e:	e7d2      	b.n	801b4b6 <DCD_Init+0x1e>
    ep->num = i;
 801b510:	f803 2c28 	strb.w	r2, [r3, #-40]
    ep->tx_fifo_num = i;
 801b514:	f823 2c22 	strh.w	r2, [r3, #-34]
    ep->xfer_buff = 0;
 801b518:	e943 5108 	strd	r5, r1, [r3, #-32]
    ep->is_in = 0;
 801b51c:	f803 1c27 	strb.w	r1, [r3, #-39]
    ep->type = EP_TYPE_CTRL;
 801b520:	f803 1c25 	strb.w	r1, [r3, #-37]
    ep->xfer_len = 0;
 801b524:	f843 1c14 	str.w	r1, [r3, #-20]
  for (i = 0; i < pdev->cfg.dev_endpoints; i++)
 801b528:	3201      	adds	r2, #1
 801b52a:	e7cd      	b.n	801b4c8 <DCD_Init+0x30>

0801b52c <DCD_EP_Open>:
*/
uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
                     uint8_t ep_addr,
                     uint16_t ep_mps,
                     uint8_t ep_type)
{
 801b52c:	b570      	push	{r4, r5, r6, lr}
  USB_OTG_EP *ep;
  
  if ((ep_addr & 0x80) == 0x80)
 801b52e:	b24e      	sxtb	r6, r1
 801b530:	f001 057f 	and.w	r5, r1, #127	@ 0x7f
 801b534:	2e00      	cmp	r6, #0
 801b536:	f04f 0428 	mov.w	r4, #40	@ 0x28
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b53a:	bfb9      	ittee	lt
 801b53c:	fb04 0405 	mlalt	r4, r4, r5, r0
 801b540:	f504 718e 	addlt.w	r1, r4, #284	@ 0x11c
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 801b544:	fb04 0101 	mlage	r1, r4, r1, r0
 801b548:	f501 715d 	addge.w	r1, r1, #884	@ 0x374
  ep->num   = ep_addr & 0x7F;
  
  ep->is_in = (0x80 & ep_addr) != 0;
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
  if (ep->is_in)
 801b54c:	2e00      	cmp	r6, #0
  {
    /* Assign a Tx FIFO */
    ep->tx_fifo_num = ep->num;
 801b54e:	bfb8      	it	lt
 801b550:	80cd      	strhlt	r5, [r1, #6]
  }
  /* Set initial data PID. */
  if (ep_type == USB_OTG_EP_BULK )
 801b552:	2b02      	cmp	r3, #2
  ep->type = ep_type;
 801b554:	70cb      	strb	r3, [r1, #3]
  ep->is_in = (0x80 & ep_addr) != 0;
 801b556:	ea4f 74d6 	mov.w	r4, r6, lsr #31
  {
    ep->data_pid_start = 0;
 801b55a:	bf08      	it	eq
 801b55c:	2300      	moveq	r3, #0
  ep->num   = ep_addr & 0x7F;
 801b55e:	700d      	strb	r5, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 801b560:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
 801b562:	608a      	str	r2, [r1, #8]
    ep->data_pid_start = 0;
 801b564:	bf08      	it	eq
 801b566:	710b      	strbeq	r3, [r1, #4]
  }
  USB_OTG_EPActivate(pdev , ep );
 801b568:	f7ff fe06 	bl	801b178 <USB_OTG_EPActivate>
  return 0;
}
 801b56c:	2000      	movs	r0, #0
 801b56e:	bd70      	pop	{r4, r5, r6, pc}

0801b570 <DCD_EP_Close>:
*/
uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
{
  USB_OTG_EP *ep;
  
  if ((ep_addr&0x80) == 0x80)
 801b570:	b24b      	sxtb	r3, r1
 801b572:	2b00      	cmp	r3, #0
{
 801b574:	b510      	push	{r4, lr}
 801b576:	f04f 0228 	mov.w	r2, #40	@ 0x28
  {
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b57a:	f001 047f 	and.w	r4, r1, #127	@ 0x7f
 801b57e:	bfb5      	itete	lt
 801b580:	fb02 0204 	mlalt	r2, r2, r4, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 801b584:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b588:	f502 718e 	addlt.w	r1, r2, #284	@ 0x11c
    ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 801b58c:	f501 715d 	addge.w	r1, r1, #884	@ 0x374
  }
  ep->num   = ep_addr & 0x7F;
  ep->is_in = (0x80 & ep_addr) != 0;
 801b590:	0fdb      	lsrs	r3, r3, #31
  ep->num   = ep_addr & 0x7F;
 801b592:	700c      	strb	r4, [r1, #0]
  ep->is_in = (0x80 & ep_addr) != 0;
 801b594:	704b      	strb	r3, [r1, #1]
  USB_OTG_EPDeactivate(pdev , ep );
 801b596:	f7ff fe23 	bl	801b1e0 <USB_OTG_EPDeactivate>
  return 0;
}
 801b59a:	2000      	movs	r0, #0
 801b59c:	bd10      	pop	{r4, pc}

0801b59e <DCD_EP_PrepareRx>:
*/
uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
                            uint8_t   ep_addr,
                            uint8_t *pbuf,                        
                            uint16_t  buf_len)
{
 801b59e:	b538      	push	{r3, r4, r5, lr}
 801b5a0:	f001 057f 	and.w	r5, r1, #127	@ 0x7f
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 801b5a4:	2428      	movs	r4, #40	@ 0x28
 801b5a6:	fb04 0105 	mla	r1, r4, r5, r0
  
  /*setup and start the Xfer */
  ep->xfer_buff = pbuf;  
 801b5aa:	fb04 0405 	mla	r4, r4, r5, r0
  ep = &pdev->dev.out_ep[ep_addr & 0x7F];
 801b5ae:	f501 715d 	add.w	r1, r1, #884	@ 0x374
  ep->xfer_len = buf_len;
 801b5b2:	f8c4 3388 	str.w	r3, [r4, #904]	@ 0x388
  ep->xfer_count = 0;
 801b5b6:	2300      	movs	r3, #0
  ep->xfer_buff = pbuf;  
 801b5b8:	f8c4 2380 	str.w	r2, [r4, #896]	@ 0x380
  ep->xfer_count = 0;
 801b5bc:	f8c4 338c 	str.w	r3, [r4, #908]	@ 0x38c
  ep->is_in = 0;
 801b5c0:	f884 3375 	strb.w	r3, [r4, #885]	@ 0x375
  ep->num = ep_addr & 0x7F;
 801b5c4:	f884 5374 	strb.w	r5, [r4, #884]	@ 0x374
  
  if (pdev->cfg.dma_enable == 1)
 801b5c8:	78c3      	ldrb	r3, [r0, #3]
 801b5ca:	2b01      	cmp	r3, #1
  {
    ep->dma_addr = (uint32_t)pbuf;  
 801b5cc:	bf08      	it	eq
 801b5ce:	f8c4 2384 	streq.w	r2, [r4, #900]	@ 0x384
  }
  
  if ( ep->num == 0 )
 801b5d2:	b91d      	cbnz	r5, 801b5dc <DCD_EP_PrepareRx+0x3e>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 801b5d4:	f7ff fea8 	bl	801b328 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 801b5d8:	2000      	movs	r0, #0
 801b5da:	bd38      	pop	{r3, r4, r5, pc}
    USB_OTG_EPStartXfer(pdev, ep );
 801b5dc:	f7ff fe1c 	bl	801b218 <USB_OTG_EPStartXfer>
 801b5e0:	e7fa      	b.n	801b5d8 <DCD_EP_PrepareRx+0x3a>

0801b5e2 <DCD_EP_Tx>:
*/
uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
                     uint8_t   ep_addr,
                     uint8_t   *pbuf,
                     uint32_t   buf_len)
{
 801b5e2:	b570      	push	{r4, r5, r6, lr}
 801b5e4:	f001 057f 	and.w	r5, r1, #127	@ 0x7f
  USB_OTG_EP *ep;
  
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b5e8:	2628      	movs	r6, #40	@ 0x28
  
  /* Setup and start the Transfer */
  ep->is_in = 1;
 801b5ea:	fb06 0405 	mla	r4, r6, r5, r0
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b5ee:	fb06 0105 	mla	r1, r6, r5, r0
  ep->num = ep_addr & 0x7F;  
  ep->xfer_buff = pbuf;
  ep->dma_addr = (uint32_t)pbuf;  
 801b5f2:	e9c4 224a 	strd	r2, r2, [r4, #296]	@ 0x128
  ep->is_in = 1;
 801b5f6:	2601      	movs	r6, #1
  ep->xfer_count = 0;
 801b5f8:	2200      	movs	r2, #0
  ep->xfer_len  = buf_len;
 801b5fa:	e9c4 324c 	strd	r3, r2, [r4, #304]	@ 0x130
  ep = &pdev->dev.in_ep[ep_addr & 0x7F];
 801b5fe:	f501 718e 	add.w	r1, r1, #284	@ 0x11c
  ep->is_in = 1;
 801b602:	f884 611d 	strb.w	r6, [r4, #285]	@ 0x11d
  ep->num = ep_addr & 0x7F;  
 801b606:	f884 511c 	strb.w	r5, [r4, #284]	@ 0x11c
  
  if ( ep->num == 0 )
 801b60a:	b91d      	cbnz	r5, 801b614 <DCD_EP_Tx+0x32>
  {
    USB_OTG_EP0StartXfer(pdev , ep);
 801b60c:	f7ff fe8c 	bl	801b328 <USB_OTG_EP0StartXfer>
  else
  {
    USB_OTG_EPStartXfer(pdev, ep );
  }
  return 0;
}
 801b610:	2000      	movs	r0, #0
 801b612:	bd70      	pop	{r4, r5, r6, pc}
    USB_OTG_EPStartXfer(pdev, ep );
 801b614:	f7ff fe00 	bl	801b218 <USB_OTG_EPStartXfer>
 801b618:	e7fa      	b.n	801b610 <DCD_EP_Tx+0x2e>

0801b61a <DCD_EP_Stall>:
* @retval : status
*/
uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
{
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 801b61a:	b24b      	sxtb	r3, r1
 801b61c:	2b00      	cmp	r3, #0
{
 801b61e:	b510      	push	{r4, lr}
 801b620:	f04f 0228 	mov.w	r2, #40	@ 0x28
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 801b624:	f001 047f 	and.w	r4, r1, #127	@ 0x7f
 801b628:	bfb5      	itete	lt
 801b62a:	fb02 0204 	mlalt	r2, r2, r4, r0
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 801b62e:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &pdev->dev.in_ep[epnum & 0x7F];
 801b632:	f502 718e 	addlt.w	r1, r2, #284	@ 0x11c
    ep = &pdev->dev.out_ep[epnum];
 801b636:	f501 715d 	addge.w	r1, r1, #884	@ 0x374
  }

  ep->is_stall = 1;
 801b63a:	2201      	movs	r2, #1
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 801b63c:	0fdb      	lsrs	r3, r3, #31
  ep->is_stall = 1;
 801b63e:	708a      	strb	r2, [r1, #2]
  ep->num   = epnum & 0x7F;
 801b640:	700c      	strb	r4, [r1, #0]
  ep->is_in = ((epnum & 0x80) == 0x80);
 801b642:	704b      	strb	r3, [r1, #1]
  
  USB_OTG_EPSetStall(pdev , ep);
 801b644:	f7ff fecc 	bl	801b3e0 <USB_OTG_EPSetStall>
  return (0);
}
 801b648:	2000      	movs	r0, #0
 801b64a:	bd10      	pop	{r4, pc}

0801b64c <DCD_EP_ClrStall>:
* @param pdev: device instance
* @param epnum: endpoint address
* @retval : status
*/
uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
 801b64c:	b538      	push	{r3, r4, r5, lr}
  USB_OTG_EP *ep;
  if ((0x80 & epnum) == 0x80)
 801b64e:	b24b      	sxtb	r3, r1
 801b650:	f001 057f 	and.w	r5, r1, #127	@ 0x7f
 801b654:	2b00      	cmp	r3, #0
 801b656:	f04f 0228 	mov.w	r2, #40	@ 0x28
  {
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
  }
  else
  {
    ep = &pdev->dev.out_ep[epnum];
 801b65a:	bfad      	iteet	ge
 801b65c:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &pdev->dev.in_ep[epnum & 0x7F];    
 801b660:	fb02 0205 	mlalt	r2, r2, r5, r0
 801b664:	f502 718e 	addlt.w	r1, r2, #284	@ 0x11c
    ep = &pdev->dev.out_ep[epnum];
 801b668:	f501 715d 	addge.w	r1, r1, #884	@ 0x374
  }
  
  ep->is_stall = 0;  
 801b66c:	2400      	movs	r4, #0
  ep->num   = epnum & 0x7F;
  ep->is_in = ((epnum & 0x80) == 0x80);
 801b66e:	0fdb      	lsrs	r3, r3, #31
  ep->is_stall = 0;  
 801b670:	708c      	strb	r4, [r1, #2]
  ep->num   = epnum & 0x7F;
 801b672:	700d      	strb	r5, [r1, #0]
  ep->is_in = ((epnum & 0x80) == 0x80);
 801b674:	704b      	strb	r3, [r1, #1]
  
  USB_OTG_EPClearStall(pdev , ep);
 801b676:	f7ff fed3 	bl	801b420 <USB_OTG_EPClearStall>
  return (0);
}
 801b67a:	4620      	mov	r0, r4
 801b67c:	bd38      	pop	{r3, r4, r5, pc}

0801b67e <DCD_EP_SetAddress>:
void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
{
  USB_OTG_DCFG_TypeDef  dcfg;
  dcfg.d32 = 0;
  dcfg.b.devaddr = address;
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 801b67e:	6902      	ldr	r2, [r0, #16]
  dcfg.d32 = 0;
 801b680:	2300      	movs	r3, #0
  dcfg.b.devaddr = address;
 801b682:	f361 130a 	bfi	r3, r1, #4, #7
  USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
 801b686:	6811      	ldr	r1, [r2, #0]
 801b688:	430b      	orrs	r3, r1
 801b68a:	6013      	str	r3, [r2, #0]
}
 801b68c:	4770      	bx	lr

0801b68e <DCD_DevConnect>:
  /* Connect device */
  dctl.b.sftdiscon  = 0;
  USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
  USB_OTG_BSP_mDelay(3);
#endif
}
 801b68e:	4770      	bx	lr

0801b690 <DCD_DevDisconnect>:
/**
* @brief  Disconnect device (disable internal pull-up)
* @param pdev: device instance
* @retval : None
*/
void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
 801b690:	4770      	bx	lr
	...

0801b694 <USBD_OTG_ISR_Handler>:
*         handles all USB Interrupts
* @param  pdev: device instance
* @retval status
*/
uint32_t USBD_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 801b694:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801b698:	b085      	sub	sp, #20
 801b69a:	4604      	mov	r4, r0
  USB_OTG_GINTSTS_TypeDef  gintr_status;
  uint32_t retval = 0;
  
  if (USB_OTG_IsDeviceMode(pdev)) /* ensure that we are in device mode */
 801b69c:	f7ff face 	bl	801ac3c <USB_OTG_IsDeviceMode>
 801b6a0:	b918      	cbnz	r0, 801b6aa <USBD_OTG_ISR_Handler+0x16>
  {
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
    if (!gintr_status.d32) /* avoid spurious interrupt */
    {
      return 0;
 801b6a2:	2000      	movs	r0, #0
      retval |= DCD_OTG_ISR(pdev);
    }   
#endif    
  }
  return retval;
}
 801b6a4:	b005      	add	sp, #20
 801b6a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    gintr_status.d32 = USB_OTG_ReadCoreItr(pdev);
 801b6aa:	4620      	mov	r0, r4
 801b6ac:	f7ff fad1 	bl	801ac52 <USB_OTG_ReadCoreItr>
    if (!gintr_status.d32) /* avoid spurious interrupt */
 801b6b0:	4606      	mov	r6, r0
 801b6b2:	2800      	cmp	r0, #0
 801b6b4:	d0f5      	beq.n	801b6a2 <USBD_OTG_ISR_Handler+0xe>
    if (gintr_status.b.outepintr)
 801b6b6:	f3c0 4307 	ubfx	r3, r0, #16, #8
 801b6ba:	f013 0008 	ands.w	r0, r3, #8
 801b6be:	9300      	str	r3, [sp, #0]
 801b6c0:	d00e      	beq.n	801b6e0 <USBD_OTG_ISR_Handler+0x4c>
  uint32_t epnum = 0;
  
  doepint.d32 = 0;
  
  /* Read in the device interrupt bits */
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 801b6c2:	4620      	mov	r0, r4
 801b6c4:	f7ff fec3 	bl	801b44e <USB_OTG_ReadDevAllOutEp_itr>
      if ( doepint.b.setup )
      {
        
        /* inform the upper layer that a setup packet is available */
        /* SETUP COMPLETE */
        USBD_DCD_INT_fops->SetupStage(pdev);
 801b6c8:	f8df a294 	ldr.w	sl, [pc, #660]	@ 801b960 <USBD_OTG_ISR_Handler+0x2cc>
  ep_intr = USB_OTG_ReadDevAllOutEp_itr(pdev);
 801b6cc:	4607      	mov	r7, r0
  while ( ep_intr )
 801b6ce:	f104 0b54 	add.w	fp, r4, #84	@ 0x54
 801b6d2:	46a1      	mov	r9, r4
  uint32_t epnum = 0;
 801b6d4:	f04f 0800 	mov.w	r8, #0
  while ( ep_intr )
 801b6d8:	2f00      	cmp	r7, #0
 801b6da:	f040 80f8 	bne.w	801b8ce <USBD_OTG_ISR_Handler+0x23a>
      retval |= DCD_HandleOutEP_ISR(pdev);
 801b6de:	2001      	movs	r0, #1
    if (gintr_status.b.inepint)
 801b6e0:	9b00      	ldr	r3, [sp, #0]
 801b6e2:	0759      	lsls	r1, r3, #29
 801b6e4:	d50d      	bpl.n	801b702 <USBD_OTG_ISR_Handler+0x6e>
  ep_intr = USB_OTG_ReadDevAllInEPItr(pdev);
 801b6e6:	4620      	mov	r0, r4
 801b6e8:	f7ff febf 	bl	801b46a <USB_OTG_ReadDevAllInEPItr>
 801b6ec:	f104 0818 	add.w	r8, r4, #24
 801b6f0:	4681      	mov	r9, r0
  while ( ep_intr )
 801b6f2:	4625      	mov	r5, r4
  uint32_t epnum = 0;
 801b6f4:	f04f 0a00 	mov.w	sl, #0
  while ( ep_intr )
 801b6f8:	f1b9 0f00 	cmp.w	r9, #0
 801b6fc:	f040 8134 	bne.w	801b968 <USBD_OTG_ISR_Handler+0x2d4>
      retval |= DCD_HandleInEP_ISR(pdev);
 801b700:	2001      	movs	r0, #1
    if (gintr_status.b.modemismatch)
 801b702:	07b7      	lsls	r7, r6, #30
      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b704:	bf42      	ittt	mi
 801b706:	68e3      	ldrmi	r3, [r4, #12]
 801b708:	2202      	movmi	r2, #2
 801b70a:	615a      	strmi	r2, [r3, #20]
    if (gintr_status.b.wkupintr)
 801b70c:	2e00      	cmp	r6, #0
    if (gintr_status.b.modemismatch)
 801b70e:	b2f5      	uxtb	r5, r6
    if (gintr_status.b.wkupintr)
 801b710:	da19      	bge.n	801b746 <USBD_OTG_ISR_Handler+0xb2>
  if(pdev->cfg.low_power)
 801b712:	7aa3      	ldrb	r3, [r4, #10]
 801b714:	b143      	cbz	r3, 801b728 <USBD_OTG_ISR_Handler+0x94>
    power.d32 = USB_OTG_READ_REG32(&pdev->regs.PCGCCTL);
 801b716:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
    power.b.stoppclk = 0;
 801b71a:	f023 0203 	bic.w	r2, r3, #3
 801b71e:	f362 0307 	bfi	r3, r2, #0, #8
    USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, power.d32);
 801b722:	f8d4 210c 	ldr.w	r2, [r4, #268]	@ 0x10c
 801b726:	6013      	str	r3, [r2, #0]
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, devctl.d32, 0);
 801b728:	6922      	ldr	r2, [r4, #16]
 801b72a:	6853      	ldr	r3, [r2, #4]
 801b72c:	f023 0301 	bic.w	r3, r3, #1
 801b730:	6053      	str	r3, [r2, #4]
  USBD_DCD_INT_fops->Resume (pdev);
 801b732:	4b8b      	ldr	r3, [pc, #556]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b734:	681b      	ldr	r3, [r3, #0]
 801b736:	4620      	mov	r0, r4
 801b738:	699b      	ldr	r3, [r3, #24]
 801b73a:	4798      	blx	r3
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b73c:	68e3      	ldr	r3, [r4, #12]
 801b73e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 801b742:	615a      	str	r2, [r3, #20]
      retval |= DCD_HandleResume_ISR(pdev);
 801b744:	2001      	movs	r0, #1
    if (gintr_status.b.usbsuspend)
 801b746:	0531      	lsls	r1, r6, #20
 801b748:	f3c6 2707 	ubfx	r7, r6, #8, #8
 801b74c:	d52d      	bpl.n	801b7aa <USBD_OTG_ISR_Handler+0x116>
  __IO uint8_t prev_status = 0;
 801b74e:	2300      	movs	r3, #0
 801b750:	f88d 300f 	strb.w	r3, [sp, #15]
  prev_status = pdev->dev.device_status;
 801b754:	f894 3112 	ldrb.w	r3, [r4, #274]	@ 0x112
 801b758:	f88d 300f 	strb.w	r3, [sp, #15]
  USBD_DCD_INT_fops->Suspend (pdev);      
 801b75c:	4b80      	ldr	r3, [pc, #512]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b75e:	681b      	ldr	r3, [r3, #0]
 801b760:	4620      	mov	r0, r4
 801b762:	695b      	ldr	r3, [r3, #20]
 801b764:	4798      	blx	r3
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b766:	6923      	ldr	r3, [r4, #16]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b768:	68e2      	ldr	r2, [r4, #12]
  dsts.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DSTS);
 801b76a:	689b      	ldr	r3, [r3, #8]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b76c:	f44f 6100 	mov.w	r1, #2048	@ 0x800
 801b770:	6151      	str	r1, [r2, #20]
  if((pdev->cfg.low_power) && (dsts.b.suspsts == 1)  && 
 801b772:	7aa2      	ldrb	r2, [r4, #10]
 801b774:	b1c2      	cbz	r2, 801b7a8 <USBD_OTG_ISR_Handler+0x114>
 801b776:	07da      	lsls	r2, r3, #31
 801b778:	d516      	bpl.n	801b7a8 <USBD_OTG_ISR_Handler+0x114>
 801b77a:	f894 3115 	ldrb.w	r3, [r4, #277]	@ 0x115
 801b77e:	2b01      	cmp	r3, #1
 801b780:	d112      	bne.n	801b7a8 <USBD_OTG_ISR_Handler+0x114>
    (prev_status  == USB_OTG_CONFIGURED))
 801b782:	f89d 300f 	ldrb.w	r3, [sp, #15]
    (pdev->dev.connection_status == 1) && 
 801b786:	2b03      	cmp	r3, #3
 801b788:	d10e      	bne.n	801b7a8 <USBD_OTG_ISR_Handler+0x114>
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);  
 801b78a:	f8d4 310c 	ldr.w	r3, [r4, #268]	@ 0x10c
 801b78e:	681a      	ldr	r2, [r3, #0]
 801b790:	f042 0201 	orr.w	r2, r2, #1
 801b794:	601a      	str	r2, [r3, #0]
    USB_OTG_MODIFY_REG32(pdev->regs.PCGCCTL, 0, power.d32);
 801b796:	681a      	ldr	r2, [r3, #0]
 801b798:	f042 0203 	orr.w	r2, r2, #3
 801b79c:	601a      	str	r2, [r3, #0]
    SCB->SCR |= (SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk);
 801b79e:	4a71      	ldr	r2, [pc, #452]	@ (801b964 <USBD_OTG_ISR_Handler+0x2d0>)
 801b7a0:	6913      	ldr	r3, [r2, #16]
 801b7a2:	f043 0306 	orr.w	r3, r3, #6
 801b7a6:	6113      	str	r3, [r2, #16]
      retval |= DCD_HandleUSBSuspend_ISR(pdev);
 801b7a8:	2001      	movs	r0, #1
    if (gintr_status.b.sofintr)
 801b7aa:	072b      	lsls	r3, r5, #28
 801b7ac:	d508      	bpl.n	801b7c0 <USBD_OTG_ISR_Handler+0x12c>
static uint32_t DCD_HandleSof_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  GINTSTS;
  
  
  USBD_DCD_INT_fops->SOF(pdev);
 801b7ae:	4b6c      	ldr	r3, [pc, #432]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b7b0:	681b      	ldr	r3, [r3, #0]
 801b7b2:	4620      	mov	r0, r4
 801b7b4:	68db      	ldr	r3, [r3, #12]
 801b7b6:	4798      	blx	r3
  
  /* Clear interrupt */
  GINTSTS.d32 = 0;
  GINTSTS.b.sofintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, GINTSTS.d32);
 801b7b8:	68e3      	ldr	r3, [r4, #12]
 801b7ba:	2208      	movs	r2, #8
 801b7bc:	615a      	str	r2, [r3, #20]
      retval |= DCD_HandleSof_ISR(pdev);
 801b7be:	2001      	movs	r0, #1
    if (gintr_status.b.rxstsqlvl)
 801b7c0:	06ee      	lsls	r6, r5, #27
 801b7c2:	d515      	bpl.n	801b7f0 <USBD_OTG_ISR_Handler+0x15c>
  USB_OTG_EP *ep;
  
  /* Disable the Rx Status Queue Level interrupt */
  int_mask.d32 = 0;
  int_mask.b.rxstsqlvl = 1;
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, int_mask.d32, 0);
 801b7c4:	68e3      	ldr	r3, [r4, #12]
 801b7c6:	699a      	ldr	r2, [r3, #24]
 801b7c8:	f022 0210 	bic.w	r2, r2, #16
 801b7cc:	619a      	str	r2, [r3, #24]
  
  /* Get the Status from the top of the FIFO */
  status.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRXSTSP );
 801b7ce:	6a1d      	ldr	r5, [r3, #32]
  
  ep = &pdev->dev.out_ep[status.b.epnum];
  
  switch (status.b.pktsts)
 801b7d0:	f3c5 4343 	ubfx	r3, r5, #17, #4
 801b7d4:	2b02      	cmp	r3, #2
  ep = &pdev->dev.out_ep[status.b.epnum];
 801b7d6:	f005 080f 	and.w	r8, r5, #15
  switch (status.b.pktsts)
 801b7da:	f000 815e 	beq.w	801ba9a <USBD_OTG_ISR_Handler+0x406>
 801b7de:	2b06      	cmp	r3, #6
 801b7e0:	f000 8176 	beq.w	801bad0 <USBD_OTG_ISR_Handler+0x43c>
  default:
    break;
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, int_mask.d32);
 801b7e4:	68e2      	ldr	r2, [r4, #12]
 801b7e6:	6993      	ldr	r3, [r2, #24]
 801b7e8:	f043 0310 	orr.w	r3, r3, #16
 801b7ec:	6193      	str	r3, [r2, #24]
      retval |= DCD_HandleRxStatusQueueLevel_ISR(pdev);
 801b7ee:	2001      	movs	r0, #1
    if (gintr_status.b.usbreset)
 801b7f0:	06fd      	lsls	r5, r7, #27
 801b7f2:	d532      	bpl.n	801b85a <USBD_OTG_ISR_Handler+0x1c6>
  dcfg.d32 = 0;
  gintsts.d32 = 0;
  
  /* Clear the Remote Wake-up Signaling */
  dctl.b.rmtwkupsig = 1;
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 801b7f4:	6922      	ldr	r2, [r4, #16]
 801b7f6:	6853      	ldr	r3, [r2, #4]
  doepmsk.d32 = 0;
 801b7f8:	2500      	movs	r5, #0
  USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DCTL, dctl.d32, 0 );
 801b7fa:	f023 0301 	bic.w	r3, r3, #1
 801b7fe:	6053      	str	r3, [r2, #4]
  
  /* Flush the Tx FIFO */
  USB_OTG_FlushTxFifo(pdev ,  0 );
 801b800:	4629      	mov	r1, r5
 801b802:	4620      	mov	r0, r4
 801b804:	f7ff f9c6 	bl	801ab94 <USB_OTG_FlushTxFifo>
  
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b808:	f894 c001 	ldrb.w	ip, [r4, #1]
  diepmsk.d32 = 0;
 801b80c:	462e      	mov	r6, r5
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b80e:	f104 0214 	add.w	r2, r4, #20
 801b812:	462b      	mov	r3, r5
  {
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 801b814:	20ff      	movs	r0, #255	@ 0xff
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801b816:	4563      	cmp	r3, ip
 801b818:	f0c0 816b 	bcc.w	801baf2 <USBD_OTG_ISR_Handler+0x45e>
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
  }
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINT, 0xFFFFFFFF );
 801b81c:	6923      	ldr	r3, [r4, #16]
 801b81e:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 801b822:	619a      	str	r2, [r3, #24]
  
  daintmsk.ep.in = 1;
  daintmsk.ep.out = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DAINTMSK, daintmsk.d32 );
 801b824:	f04f 1201 	mov.w	r2, #65537	@ 0x10001
 801b828:	61da      	str	r2, [r3, #28]
  
  doepmsk.b.setup = 1;
  doepmsk.b.xfercompl = 1;
 801b82a:	220b      	movs	r2, #11
 801b82c:	f362 0507 	bfi	r5, r2, #0, #8
  doepmsk.b.epdisabled = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED   
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOUTEP1MSK, doepmsk.d32 );
#endif
  diepmsk.b.xfercompl = 1;
 801b830:	f362 0607 	bfi	r6, r2, #0, #8
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DOEPMSK, doepmsk.d32 );
 801b834:	615d      	str	r5, [r3, #20]
  diepmsk.b.timeout = 1;
  diepmsk.b.epdisabled = 1;

  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DIEPMSK, diepmsk.d32 );
 801b836:	611e      	str	r6, [r3, #16]
#ifdef USB_OTG_HS_DEDICATED_EP1_ENABLED  
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DINEP1MSK, diepmsk.d32 );
#endif
  /* Reset Device Address */
  dcfg.d32 = USB_OTG_READ_REG32( &pdev->regs.DREGS->DCFG);
 801b838:	681a      	ldr	r2, [r3, #0]
  dcfg.b.devaddr = 0;
 801b83a:	f36f 120a 	bfc	r2, #4, #7
  USB_OTG_WRITE_REG32( &pdev->regs.DREGS->DCFG, dcfg.d32);
 801b83e:	601a      	str	r2, [r3, #0]
  
  
  /* setup EP0 to receive SETUP packets */
  USB_OTG_EP0_OutStart(pdev);
 801b840:	4620      	mov	r0, r4
 801b842:	f7ff fe19 	bl	801b478 <USB_OTG_EP0_OutStart>
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.usbreset = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b846:	68e3      	ldr	r3, [r4, #12]
 801b848:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 801b84c:	615a      	str	r2, [r3, #20]
  
  /*Reset internal state machine */
  USBD_DCD_INT_fops->Reset(pdev);
 801b84e:	4b44      	ldr	r3, [pc, #272]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b850:	681b      	ldr	r3, [r3, #0]
 801b852:	4620      	mov	r0, r4
 801b854:	691b      	ldr	r3, [r3, #16]
 801b856:	4798      	blx	r3
      retval |= DCD_HandleUsbReset_ISR(pdev);
 801b858:	2001      	movs	r0, #1
    if (gintr_status.b.enumdone)
 801b85a:	06b9      	lsls	r1, r7, #26
 801b85c:	d51b      	bpl.n	801b896 <USBD_OTG_ISR_Handler+0x202>
static uint32_t DCD_HandleEnumDone_ISR(USB_OTG_CORE_HANDLE *pdev)
{
  USB_OTG_GINTSTS_TypeDef  gintsts;
  USB_OTG_GUSBCFG_TypeDef  gusbcfg;
  
  USB_OTG_EP0Activate(pdev);
 801b85e:	4620      	mov	r0, r4
 801b860:	f7ff fc77 	bl	801b152 <USB_OTG_EP0Activate>
  
  /* Set USB turn-around time based on device speed and PHY interface. */
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801b864:	68e3      	ldr	r3, [r4, #12]
  
  /* Full or High speed */
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 801b866:	4620      	mov	r0, r4
  gusbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
 801b868:	68dd      	ldr	r5, [r3, #12]
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 801b86a:	f7ff fc65 	bl	801b138 <USB_OTG_GetDeviceSpeed>
 801b86e:	2803      	cmp	r0, #3
 801b870:	bf0b      	itete	eq
 801b872:	2309      	moveq	r3, #9
 801b874:	2305      	movne	r3, #5
 801b876:	f44f 7200 	moveq.w	r2, #512	@ 0x200
 801b87a:	2240      	movne	r2, #64	@ 0x40
  {
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
    gusbcfg.b.usbtrdtim = 9;
 801b87c:	f363 258d 	bfi	r5, r3, #10, #4
    pdev->cfg.speed            = USB_OTG_SPEED_FULL;
    pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;  
    gusbcfg.b.usbtrdtim = 5;
  }
  
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 801b880:	68e3      	ldr	r3, [r4, #12]
    pdev->cfg.mps              = USB_OTG_HS_MAX_PACKET_SIZE ;    
 801b882:	80a2      	strh	r2, [r4, #4]
  if ( USB_OTG_GetDeviceSpeed(pdev) == USB_SPEED_HIGH)
 801b884:	bf0c      	ite	eq
 801b886:	2100      	moveq	r1, #0
 801b888:	2101      	movne	r1, #1
  
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.enumdone = 1;
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 801b88a:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
    pdev->cfg.speed            = USB_OTG_SPEED_HIGH;
 801b88e:	70a1      	strb	r1, [r4, #2]
      retval |= DCD_HandleEnumDone_ISR(pdev);
 801b890:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, gusbcfg.d32);
 801b892:	60dd      	str	r5, [r3, #12]
  USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GINTSTS, gintsts.d32 );
 801b894:	615a      	str	r2, [r3, #20]
    if (gintr_status.b.incomplisoin)
 801b896:	9b00      	ldr	r3, [sp, #0]
 801b898:	06da      	lsls	r2, r3, #27
 801b89a:	d509      	bpl.n	801b8b0 <USBD_OTG_ISR_Handler+0x21c>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoINIncomplete (pdev); 
 801b89c:	4b30      	ldr	r3, [pc, #192]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b89e:	681b      	ldr	r3, [r3, #0]
 801b8a0:	4620      	mov	r0, r4
 801b8a2:	69db      	ldr	r3, [r3, #28]
 801b8a4:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoin = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b8a6:	68e3      	ldr	r3, [r4, #12]
 801b8a8:	f44f 1280 	mov.w	r2, #1048576	@ 0x100000
 801b8ac:	615a      	str	r2, [r3, #20]
      retval |= DCD_IsoINIncomplete_ISR(pdev);
 801b8ae:	2001      	movs	r0, #1
    if (gintr_status.b.incomplisoout)
 801b8b0:	9b00      	ldr	r3, [sp, #0]
 801b8b2:	069b      	lsls	r3, r3, #26
 801b8b4:	f57f aef6 	bpl.w	801b6a4 <USBD_OTG_ISR_Handler+0x10>
{
  USB_OTG_GINTSTS_TypeDef gintsts;  
  
  gintsts.d32 = 0;

  USBD_DCD_INT_fops->IsoOUTIncomplete (pdev); 
 801b8b8:	4b29      	ldr	r3, [pc, #164]	@ (801b960 <USBD_OTG_ISR_Handler+0x2cc>)
 801b8ba:	681b      	ldr	r3, [r3, #0]
 801b8bc:	4620      	mov	r0, r4
 801b8be:	6a1b      	ldr	r3, [r3, #32]
 801b8c0:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801b8c2:	68e3      	ldr	r3, [r4, #12]
 801b8c4:	f44f 1200 	mov.w	r2, #2097152	@ 0x200000
 801b8c8:	615a      	str	r2, [r3, #20]
      retval |= DCD_IsoOUTIncomplete_ISR(pdev);
 801b8ca:	2001      	movs	r0, #1
 801b8cc:	e6ea      	b.n	801b6a4 <USBD_OTG_ISR_Handler+0x10>
    if (ep_intr&0x1)
 801b8ce:	07fa      	lsls	r2, r7, #31
 801b8d0:	d53d      	bpl.n	801b94e <USBD_OTG_ISR_Handler+0x2ba>
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 801b8d2:	fa5f f188 	uxtb.w	r1, r8
 801b8d6:	4620      	mov	r0, r4
 801b8d8:	9101      	str	r1, [sp, #4]
 801b8da:	f7ff fdbe 	bl	801b45a <USB_OTG_ReadDevOutEP_itr>
      if ( doepint.b.xfercompl )
 801b8de:	f010 0f01 	tst.w	r0, #1
 801b8e2:	9901      	ldr	r1, [sp, #4]
      doepint.d32 = USB_OTG_ReadDevOutEP_itr(pdev, epnum);
 801b8e4:	4605      	mov	r5, r0
      if ( doepint.b.xfercompl )
 801b8e6:	d020      	beq.n	801b92a <USBD_OTG_ISR_Handler+0x296>
        CLEAR_OUT_EP_INTR(epnum, xfercompl);
 801b8e8:	f8db 2000 	ldr.w	r2, [fp]
 801b8ec:	2501      	movs	r5, #1
 801b8ee:	6095      	str	r5, [r2, #8]
        if (pdev->cfg.dma_enable == 1)
 801b8f0:	78e0      	ldrb	r0, [r4, #3]
 801b8f2:	42a8      	cmp	r0, r5
 801b8f4:	d107      	bne.n	801b906 <USBD_OTG_ISR_Handler+0x272>
          deptsiz.d32 = USB_OTG_READ_REG32(&(pdev->regs.OUTEP_REGS[epnum]->DOEPTSIZ));
 801b8f6:	6910      	ldr	r0, [r2, #16]
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 801b8f8:	f8d9 237c 	ldr.w	r2, [r9, #892]	@ 0x37c
            deptsiz.b.xfersize;
 801b8fc:	f3c0 0012 	ubfx	r0, r0, #0, #19
          pdev->dev.out_ep[epnum].xfer_count = pdev->dev.out_ep[epnum].maxpacket - \
 801b900:	1a12      	subs	r2, r2, r0
 801b902:	f8c9 238c 	str.w	r2, [r9, #908]	@ 0x38c
        USBD_DCD_INT_fops->DataOutStage(pdev , epnum);
 801b906:	f8da 2000 	ldr.w	r2, [sl]
 801b90a:	4620      	mov	r0, r4
 801b90c:	6812      	ldr	r2, [r2, #0]
 801b90e:	4790      	blx	r2
        if (pdev->cfg.dma_enable == 1)
 801b910:	78e2      	ldrb	r2, [r4, #3]
 801b912:	2a01      	cmp	r2, #1
 801b914:	d109      	bne.n	801b92a <USBD_OTG_ISR_Handler+0x296>
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_OUT))
 801b916:	f1b8 0f00 	cmp.w	r8, #0
 801b91a:	d106      	bne.n	801b92a <USBD_OTG_ISR_Handler+0x296>
 801b91c:	f894 2111 	ldrb.w	r2, [r4, #273]	@ 0x111
 801b920:	2a05      	cmp	r2, #5
 801b922:	d102      	bne.n	801b92a <USBD_OTG_ISR_Handler+0x296>
            USB_OTG_EP0_OutStart(pdev);
 801b924:	4620      	mov	r0, r4
 801b926:	f7ff fda7 	bl	801b478 <USB_OTG_EP0_OutStart>
      if ( doepint.b.epdisabled )
 801b92a:	07ab      	lsls	r3, r5, #30
        CLEAR_OUT_EP_INTR(epnum, epdisabled);
 801b92c:	bf41      	itttt	mi
 801b92e:	f8db 2000 	ldrmi.w	r2, [fp]
 801b932:	2502      	movmi	r5, #2
 801b934:	462b      	movmi	r3, r5
 801b936:	6093      	strmi	r3, [r2, #8]
      if ( doepint.b.setup )
 801b938:	0728      	lsls	r0, r5, #28
 801b93a:	d508      	bpl.n	801b94e <USBD_OTG_ISR_Handler+0x2ba>
        USBD_DCD_INT_fops->SetupStage(pdev);
 801b93c:	f8da 2000 	ldr.w	r2, [sl]
 801b940:	4620      	mov	r0, r4
 801b942:	6892      	ldr	r2, [r2, #8]
 801b944:	4790      	blx	r2
        CLEAR_OUT_EP_INTR(epnum, setup);
 801b946:	f8db 2000 	ldr.w	r2, [fp]
 801b94a:	2308      	movs	r3, #8
 801b94c:	6093      	str	r3, [r2, #8]
    epnum++;
 801b94e:	f108 0801 	add.w	r8, r8, #1
    ep_intr >>= 1;
 801b952:	087f      	lsrs	r7, r7, #1
 801b954:	f10b 0b04 	add.w	fp, fp, #4
 801b958:	f109 0928 	add.w	r9, r9, #40	@ 0x28
 801b95c:	e6bc      	b.n	801b6d8 <USBD_OTG_ISR_Handler+0x44>
 801b95e:	bf00      	nop
 801b960:	2000001c 	.word	0x2000001c
 801b964:	e000ed00 	.word	0xe000ed00
    if (ep_intr&0x1) /* In ITR */
 801b968:	f019 0f01 	tst.w	r9, #1
 801b96c:	f000 808d 	beq.w	801ba8a <USBD_OTG_ISR_Handler+0x3f6>
* @retval status
*/
static uint32_t DCD_ReadDevInEP (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
{
  uint32_t v, msk, emp;
  msk = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPMSK);
 801b970:	6923      	ldr	r3, [r4, #16]
 801b972:	fa5f fb8a 	uxtb.w	fp, sl
 801b976:	6919      	ldr	r1, [r3, #16]
  emp = USB_OTG_READ_REG32(&pdev->regs.DREGS->DIEPEMPMSK);
 801b978:	6b5f      	ldr	r7, [r3, #52]	@ 0x34
  msk |= ((emp >> epnum) & 0x1) << 7;
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 801b97a:	eb04 028b 	add.w	r2, r4, fp, lsl #2
  msk |= ((emp >> epnum) & 0x1) << 7;
 801b97e:	fa27 f70b 	lsr.w	r7, r7, fp
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 801b982:	6992      	ldr	r2, [r2, #24]
  msk |= ((emp >> epnum) & 0x1) << 7;
 801b984:	01ff      	lsls	r7, r7, #7
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 801b986:	6892      	ldr	r2, [r2, #8]
  msk |= ((emp >> epnum) & 0x1) << 7;
 801b988:	b2ff      	uxtb	r7, r7
 801b98a:	430f      	orrs	r7, r1
  v = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DIEPINT) & msk;
 801b98c:	4017      	ands	r7, r2
      if ( diepint.b.xfercompl )
 801b98e:	07fa      	lsls	r2, r7, #31
 801b990:	d51d      	bpl.n	801b9ce <USBD_OTG_ISR_Handler+0x33a>
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 801b992:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
        fifoemptymsk = 0x1 << epnum;
 801b994:	2001      	movs	r0, #1
 801b996:	fa00 f10a 	lsl.w	r1, r0, sl
        USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 801b99a:	ea22 0201 	bic.w	r2, r2, r1
 801b99e:	635a      	str	r2, [r3, #52]	@ 0x34
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 801b9a0:	f8d8 3000 	ldr.w	r3, [r8]
 801b9a4:	6098      	str	r0, [r3, #8]
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 801b9a6:	4b56      	ldr	r3, [pc, #344]	@ (801bb00 <USBD_OTG_ISR_Handler+0x46c>)
 801b9a8:	681b      	ldr	r3, [r3, #0]
        CLEAR_IN_EP_INTR(epnum, xfercompl);
 801b9aa:	4607      	mov	r7, r0
        USBD_DCD_INT_fops->DataInStage(pdev , epnum);
 801b9ac:	685b      	ldr	r3, [r3, #4]
 801b9ae:	4659      	mov	r1, fp
 801b9b0:	4620      	mov	r0, r4
 801b9b2:	4798      	blx	r3
        if (pdev->cfg.dma_enable == 1)
 801b9b4:	78e3      	ldrb	r3, [r4, #3]
 801b9b6:	42bb      	cmp	r3, r7
 801b9b8:	d109      	bne.n	801b9ce <USBD_OTG_ISR_Handler+0x33a>
          if((epnum == 0) && (pdev->dev.device_state == USB_OTG_EP0_STATUS_IN))
 801b9ba:	f1ba 0f00 	cmp.w	sl, #0
 801b9be:	d106      	bne.n	801b9ce <USBD_OTG_ISR_Handler+0x33a>
 801b9c0:	f894 3111 	ldrb.w	r3, [r4, #273]	@ 0x111
 801b9c4:	2b04      	cmp	r3, #4
 801b9c6:	d102      	bne.n	801b9ce <USBD_OTG_ISR_Handler+0x33a>
            USB_OTG_EP0_OutStart(pdev);
 801b9c8:	4620      	mov	r0, r4
 801b9ca:	f7ff fd55 	bl	801b478 <USB_OTG_EP0_OutStart>
      if ( diepint.b.timeout )
 801b9ce:	073b      	lsls	r3, r7, #28
        CLEAR_IN_EP_INTR(epnum, timeout);
 801b9d0:	bf42      	ittt	mi
 801b9d2:	f8d8 3000 	ldrmi.w	r3, [r8]
 801b9d6:	2708      	movmi	r7, #8
 801b9d8:	609f      	strmi	r7, [r3, #8]
      if (diepint.b.intktxfemp)
 801b9da:	06f8      	lsls	r0, r7, #27
        CLEAR_IN_EP_INTR(epnum, intktxfemp);
 801b9dc:	bf42      	ittt	mi
 801b9de:	f8d8 3000 	ldrmi.w	r3, [r8]
 801b9e2:	2710      	movmi	r7, #16
 801b9e4:	609f      	strmi	r7, [r3, #8]
      if (diepint.b.inepnakeff)
 801b9e6:	0679      	lsls	r1, r7, #25
        CLEAR_IN_EP_INTR(epnum, inepnakeff);
 801b9e8:	bf42      	ittt	mi
 801b9ea:	f8d8 3000 	ldrmi.w	r3, [r8]
 801b9ee:	2740      	movmi	r7, #64	@ 0x40
 801b9f0:	609f      	strmi	r7, [r3, #8]
      if ( diepint.b.epdisabled )
 801b9f2:	07ba      	lsls	r2, r7, #30
        CLEAR_IN_EP_INTR(epnum, epdisabled);
 801b9f4:	bf42      	ittt	mi
 801b9f6:	f8d8 3000 	ldrmi.w	r3, [r8]
 801b9fa:	2702      	movmi	r7, #2
 801b9fc:	609f      	strmi	r7, [r3, #8]
      if (diepint.b.emptyintr)
 801b9fe:	063b      	lsls	r3, r7, #24
 801ba00:	d543      	bpl.n	801ba8a <USBD_OTG_ISR_Handler+0x3f6>
  len = ep->xfer_len - ep->xfer_count;
 801ba02:	e9d5 324c 	ldrd	r3, r2, [r5, #304]	@ 0x130
 801ba06:	1a9b      	subs	r3, r3, r2
  len32b = (len + 3) / 4;
 801ba08:	f8d5 2124 	ldr.w	r2, [r5, #292]	@ 0x124
 801ba0c:	4293      	cmp	r3, r2
 801ba0e:	bf28      	it	cs
 801ba10:	4613      	movcs	r3, r2
 801ba12:	3303      	adds	r3, #3
 801ba14:	089b      	lsrs	r3, r3, #2
 801ba16:	9301      	str	r3, [sp, #4]
  txstatus.d32 = USB_OTG_READ_REG32( &pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 801ba18:	f8d8 3000 	ldr.w	r3, [r8]
 801ba1c:	699b      	ldr	r3, [r3, #24]
          ep->xfer_count < ep->xfer_len &&
 801ba1e:	9a01      	ldr	r2, [sp, #4]
  while  (txstatus.b.txfspcavail > len32b &&
 801ba20:	b29b      	uxth	r3, r3
          ep->xfer_count < ep->xfer_len &&
 801ba22:	4293      	cmp	r3, r2
 801ba24:	d92d      	bls.n	801ba82 <USBD_OTG_ISR_Handler+0x3ee>
 801ba26:	e9d5 734c 	ldrd	r7, r3, [r5, #304]	@ 0x130
  while  (txstatus.b.txfspcavail > len32b &&
 801ba2a:	429f      	cmp	r7, r3
 801ba2c:	d929      	bls.n	801ba82 <USBD_OTG_ISR_Handler+0x3ee>
    len = ep->xfer_len - ep->xfer_count;
 801ba2e:	1aff      	subs	r7, r7, r3
 801ba30:	f8d5 3124 	ldr.w	r3, [r5, #292]	@ 0x124
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 801ba34:	f8d5 1128 	ldr.w	r1, [r5, #296]	@ 0x128
 801ba38:	429f      	cmp	r7, r3
 801ba3a:	bf28      	it	cs
 801ba3c:	461f      	movcs	r7, r3
    len32b = (len + 3) / 4;
 801ba3e:	1cfb      	adds	r3, r7, #3
 801ba40:	089b      	lsrs	r3, r3, #2
 801ba42:	9301      	str	r3, [sp, #4]
    USB_OTG_WritePacket (pdev , ep->xfer_buff, epnum, len);
 801ba44:	465a      	mov	r2, fp
 801ba46:	b2bb      	uxth	r3, r7
 801ba48:	4620      	mov	r0, r4
 801ba4a:	f7fe ffc1 	bl	801a9d0 <USB_OTG_WritePacket>
    ep->xfer_buff  += len;
 801ba4e:	f8d5 3128 	ldr.w	r3, [r5, #296]	@ 0x128
    if( ep->xfer_count >= ep->xfer_len){
 801ba52:	f8d5 2130 	ldr.w	r2, [r5, #304]	@ 0x130
    ep->xfer_buff  += len;
 801ba56:	443b      	add	r3, r7
 801ba58:	f8c5 3128 	str.w	r3, [r5, #296]	@ 0x128
    ep->xfer_count += len;
 801ba5c:	f8d5 3134 	ldr.w	r3, [r5, #308]	@ 0x134
 801ba60:	441f      	add	r7, r3
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 801ba62:	f8d8 3000 	ldr.w	r3, [r8]
    ep->xfer_count += len;
 801ba66:	f8c5 7134 	str.w	r7, [r5, #308]	@ 0x134
    if( ep->xfer_count >= ep->xfer_len){
 801ba6a:	4297      	cmp	r7, r2
    txstatus.d32 = USB_OTG_READ_REG32(&pdev->regs.INEP_REGS[epnum]->DTXFSTS);
 801ba6c:	699b      	ldr	r3, [r3, #24]
    if( ep->xfer_count >= ep->xfer_len){
 801ba6e:	d3d6      	bcc.n	801ba1e <USBD_OTG_ISR_Handler+0x38a>
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 801ba70:	6921      	ldr	r1, [r4, #16]
      uint32_t fifoemptymsk = 1 << ep->num;
 801ba72:	f895 011c 	ldrb.w	r0, [r5, #284]	@ 0x11c
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 801ba76:	6b4b      	ldr	r3, [r1, #52]	@ 0x34
      uint32_t fifoemptymsk = 1 << ep->num;
 801ba78:	2201      	movs	r2, #1
 801ba7a:	4082      	lsls	r2, r0
      USB_OTG_MODIFY_REG32(&pdev->regs.DREGS->DIEPEMPMSK, fifoemptymsk, 0);
 801ba7c:	ea23 0302 	bic.w	r3, r3, r2
 801ba80:	634b      	str	r3, [r1, #52]	@ 0x34
        CLEAR_IN_EP_INTR(epnum, emptyintr);
 801ba82:	f8d8 3000 	ldr.w	r3, [r8]
 801ba86:	2280      	movs	r2, #128	@ 0x80
 801ba88:	609a      	str	r2, [r3, #8]
    epnum++;
 801ba8a:	f10a 0a01 	add.w	sl, sl, #1
    ep_intr >>= 1;
 801ba8e:	ea4f 0959 	mov.w	r9, r9, lsr #1
 801ba92:	f108 0804 	add.w	r8, r8, #4
 801ba96:	3528      	adds	r5, #40	@ 0x28
 801ba98:	e62e      	b.n	801b6f8 <USBD_OTG_ISR_Handler+0x64>
    if (status.b.bcnt)
 801ba9a:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 801ba9e:	422b      	tst	r3, r5
 801baa0:	f43f aea0 	beq.w	801b7e4 <USBD_OTG_ISR_Handler+0x150>
      USB_OTG_ReadPacket(pdev,ep->xfer_buff, status.b.bcnt);
 801baa4:	2628      	movs	r6, #40	@ 0x28
 801baa6:	fb06 4608 	mla	r6, r6, r8, r4
 801baaa:	f3c5 150a 	ubfx	r5, r5, #4, #11
 801baae:	f8d6 1380 	ldr.w	r1, [r6, #896]	@ 0x380
 801bab2:	462a      	mov	r2, r5
 801bab4:	4620      	mov	r0, r4
 801bab6:	f7fe ff9e 	bl	801a9f6 <USB_OTG_ReadPacket>
      ep->xfer_buff += status.b.bcnt;
 801baba:	f8d6 3380 	ldr.w	r3, [r6, #896]	@ 0x380
 801babe:	442b      	add	r3, r5
 801bac0:	f8c6 3380 	str.w	r3, [r6, #896]	@ 0x380
      ep->xfer_count += status.b.bcnt;
 801bac4:	f8d6 338c 	ldr.w	r3, [r6, #908]	@ 0x38c
 801bac8:	442b      	add	r3, r5
 801baca:	f8c6 338c 	str.w	r3, [r6, #908]	@ 0x38c
 801bace:	e689      	b.n	801b7e4 <USBD_OTG_ISR_Handler+0x150>
    USB_OTG_ReadPacket(pdev , pdev->dev.setup_packet, 8);
 801bad0:	2208      	movs	r2, #8
 801bad2:	f204 51cc 	addw	r1, r4, #1484	@ 0x5cc
 801bad6:	4620      	mov	r0, r4
 801bad8:	f7fe ff8d 	bl	801a9f6 <USB_OTG_ReadPacket>
    ep->xfer_count += status.b.bcnt;
 801badc:	2328      	movs	r3, #40	@ 0x28
 801bade:	fb03 4808 	mla	r8, r3, r8, r4
 801bae2:	f3c5 150a 	ubfx	r5, r5, #4, #11
 801bae6:	f8d8 338c 	ldr.w	r3, [r8, #908]	@ 0x38c
 801baea:	442b      	add	r3, r5
 801baec:	f8c8 338c 	str.w	r3, [r8, #908]	@ 0x38c
    break;
 801baf0:	e678      	b.n	801b7e4 <USBD_OTG_ISR_Handler+0x150>
    USB_OTG_WRITE_REG32( &pdev->regs.INEP_REGS[i]->DIEPINT, 0xFF);
 801baf2:	f852 1f04 	ldr.w	r1, [r2, #4]!
 801baf6:	6088      	str	r0, [r1, #8]
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 801baf8:	6bd1      	ldr	r1, [r2, #60]	@ 0x3c
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801bafa:	3301      	adds	r3, #1
    USB_OTG_WRITE_REG32( &pdev->regs.OUTEP_REGS[i]->DOEPINT, 0xFF);
 801bafc:	6088      	str	r0, [r1, #8]
  for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
 801bafe:	e68a      	b.n	801b816 <USBD_OTG_ISR_Handler+0x182>
 801bb00:	2000001c 	.word	0x2000001c

0801bb04 <HCD_Init>:
  */
uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
                  USB_OTG_CORE_ID_TypeDef coreID)
{
  uint8_t i = 0;
  pdev->host.ConnSts = 0;
 801bb04:	2300      	movs	r3, #0
{
 801bb06:	b510      	push	{r4, lr}
  
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
  {
  pdev->host.ErrCnt[i]  = 0;
 801bb08:	461a      	mov	r2, r3
{
 801bb0a:	4604      	mov	r4, r0
  pdev->host.ConnSts = 0;
 801bb0c:	f8c0 37f4 	str.w	r3, [r0, #2036]	@ 0x7f4
  pdev->host.ErrCnt[i]  = 0;
 801bb10:	eb04 0083 	add.w	r0, r4, r3, lsl #2
 801bb14:	f8c0 27f8 	str.w	r2, [r0, #2040]	@ 0x7f8
  pdev->host.XferCnt[i]   = 0;
 801bb18:	f8c0 2834 	str.w	r2, [r0, #2100]	@ 0x834
  pdev->host.HC_Status[i]   = HC_IDLE;
 801bb1c:	18e0      	adds	r0, r4, r3
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 801bb1e:	3301      	adds	r3, #1
 801bb20:	2b0f      	cmp	r3, #15
  pdev->host.HC_Status[i]   = HC_IDLE;
 801bb22:	f880 2870 	strb.w	r2, [r0, #2160]	@ 0x870
  for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
 801bb26:	d1f3      	bne.n	801bb10 <HCD_Init+0xc>
  }
  pdev->host.hc[0].max_packet  = 8; 
 801bb28:	2308      	movs	r3, #8
 801bb2a:	f8a4 3896 	strh.w	r3, [r4, #2198]	@ 0x896

  USB_OTG_SelectCore(pdev, coreID);
 801bb2e:	4620      	mov	r0, r4
 801bb30:	f7fe ff72 	bl	801aa18 <USB_OTG_SelectCore>
#ifndef DUAL_ROLE_MODE_ENABLED
  USB_OTG_DisableGlobalInt(pdev);
 801bb34:	4620      	mov	r0, r4
 801bb36:	f7ff f826 	bl	801ab86 <USB_OTG_DisableGlobalInt>
  USB_OTG_CoreInit(pdev);
 801bb3a:	4620      	mov	r0, r4
 801bb3c:	f7fe ffc8 	bl	801aad0 <USB_OTG_CoreInit>

  /* Force Host Mode*/
  USB_OTG_SetCurrentMode(pdev , HOST_MODE);
 801bb40:	2101      	movs	r1, #1
 801bb42:	4620      	mov	r0, r4
 801bb44:	f7ff f862 	bl	801ac0c <USB_OTG_SetCurrentMode>
  USB_OTG_CoreInitHost(pdev);
 801bb48:	4620      	mov	r0, r4
 801bb4a:	f7ff f8ee 	bl	801ad2a <USB_OTG_CoreInitHost>
  USB_OTG_EnableGlobalInt(pdev);
 801bb4e:	4620      	mov	r0, r4
 801bb50:	f7ff f812 	bl	801ab78 <USB_OTG_EnableGlobalInt>
#endif
   
  return 0;
}
 801bb54:	2000      	movs	r0, #0
 801bb56:	bd10      	pop	{r4, pc}

0801bb58 <HCD_GetCurrentSpeed>:
  */

uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
{    
    USB_OTG_HPRT0_TypeDef  HPRT0;
    HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801bb58:	f8d0 30cc 	ldr.w	r3, [r0, #204]	@ 0xcc
 801bb5c:	6818      	ldr	r0, [r3, #0]
    
    return HPRT0.b.prtspd;
}
 801bb5e:	f3c0 4041 	ubfx	r0, r0, #17, #2
 801bb62:	4770      	bx	lr

0801bb64 <HCD_ResetPort>:
  *         Issues the reset command to device
  * @param  pdev : Selected device
  * @retval Status
  */
uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
{
 801bb64:	b508      	push	{r3, lr}
  interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
  which indicates that the bus is stable again after the electrical debounce 
  caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
  */
  
  USB_OTG_ResetPort(pdev); 
 801bb66:	f7ff f8ca 	bl	801acfe <USB_OTG_ResetPort>
  return 0;
}
 801bb6a:	2000      	movs	r0, #0
 801bb6c:	bd08      	pop	{r3, pc}

0801bb6e <HCD_IsDeviceConnected>:
  * @retval Device connection status. 1 -> connected and 0 -> disconnected
  * 
  */
uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
{
  return (pdev->host.ConnSts);
 801bb6e:	f8d0 07f4 	ldr.w	r0, [r0, #2036]	@ 0x7f4
}
 801bb72:	4770      	bx	lr

0801bb74 <HCD_GetCurrentFrame>:
  * @retval Frame number
  * 
  */
uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
{
 return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
 801bb74:	6943      	ldr	r3, [r0, #20]
 801bb76:	6898      	ldr	r0, [r3, #8]
}
 801bb78:	b280      	uxth	r0, r0
 801bb7a:	4770      	bx	lr

0801bb7c <HCD_GetURB_State>:
  * @retval URB_STATE
  * 
  */
URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
{
  return pdev->host.URB_State[ch_num] ;
 801bb7c:	4408      	add	r0, r1
 801bb7e:	f890 087f 	ldrb.w	r0, [r0, #2175]	@ 0x87f
}
 801bb82:	4770      	bx	lr

0801bb84 <HCD_SubmitRequest>:
  * @param  pdev: Selected device
  * @param  hc_num: Channel number 
  * @retval status
  */
uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
{
 801bb84:	b538      	push	{r3, r4, r5, lr}
  
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
 801bb86:	1845      	adds	r5, r0, r1
  pdev->host.hc[hc_num].xfer_count = 0 ;
 801bb88:	eb00 1341 	add.w	r3, r0, r1, lsl #5
  pdev->host.URB_State[hc_num] =   URB_IDLE;  
 801bb8c:	2400      	movs	r4, #0
 801bb8e:	f885 487f 	strb.w	r4, [r5, #2175]	@ 0x87f
  pdev->host.hc[hc_num].xfer_count = 0 ;
 801bb92:	f8c3 48a4 	str.w	r4, [r3, #2212]	@ 0x8a4
  return USB_OTG_HC_StartXfer(pdev, hc_num);
 801bb96:	f7ff f985 	bl	801aea4 <USB_OTG_HC_StartXfer>
}
 801bb9a:	bd38      	pop	{r3, r4, r5, pc}

0801bb9c <USBH_OTG_ISR_Handler>:
* @param  pdev: Selected device
* @retval status 
*/

uint32_t USBH_OTG_ISR_Handler (USB_OTG_CORE_HANDLE *pdev)
{
 801bb9c:	b500      	push	{lr}
 801bb9e:	b085      	sub	sp, #20
 801bba0:	9001      	str	r0, [sp, #4]
  USB_OTG_GINTSTS_TypeDef  gintsts;
  uint32_t retval = 0;
 801bba2:	2300      	movs	r3, #0
 801bba4:	9303      	str	r3, [sp, #12]
  
  gintsts.d32 = 0;
 801bba6:	2300      	movs	r3, #0
 801bba8:	9302      	str	r3, [sp, #8]
  
  /* Check if HOST Mode */
  if (USB_OTG_IsHostMode(pdev))
 801bbaa:	9801      	ldr	r0, [sp, #4]
 801bbac:	f7ff f84c 	bl	801ac48 <USB_OTG_IsHostMode>
 801bbb0:	4603      	mov	r3, r0
 801bbb2:	2b00      	cmp	r3, #0
 801bbb4:	d079      	beq.n	801bcaa <USBH_OTG_ISR_Handler+0x10e>
  {
    gintsts.d32 = USB_OTG_ReadCoreItr(pdev);
 801bbb6:	9801      	ldr	r0, [sp, #4]
 801bbb8:	f7ff f84b 	bl	801ac52 <USB_OTG_ReadCoreItr>
 801bbbc:	4603      	mov	r3, r0
 801bbbe:	9302      	str	r3, [sp, #8]
    if (!gintsts.d32)
 801bbc0:	9b02      	ldr	r3, [sp, #8]
 801bbc2:	2b00      	cmp	r3, #0
 801bbc4:	d101      	bne.n	801bbca <USBH_OTG_ISR_Handler+0x2e>
    {
      return 0;
 801bbc6:	2300      	movs	r3, #0
 801bbc8:	e070      	b.n	801bcac <USBH_OTG_ISR_Handler+0x110>
    }
    
    if (gintsts.b.sofintr)
 801bbca:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801bbce:	f003 0308 	and.w	r3, r3, #8
 801bbd2:	b2db      	uxtb	r3, r3
 801bbd4:	2b00      	cmp	r3, #0
 801bbd6:	d006      	beq.n	801bbe6 <USBH_OTG_ISR_Handler+0x4a>
    {
      retval |= USB_OTG_USBH_handle_sof_ISR (pdev);
 801bbd8:	9801      	ldr	r0, [sp, #4]
 801bbda:	f000 f8b3 	bl	801bd44 <USB_OTG_USBH_handle_sof_ISR>
 801bbde:	4602      	mov	r2, r0
 801bbe0:	9b03      	ldr	r3, [sp, #12]
 801bbe2:	4313      	orrs	r3, r2
 801bbe4:	9303      	str	r3, [sp, #12]
    }
    
    if (gintsts.b.rxstsqlvl)
 801bbe6:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801bbea:	f003 0310 	and.w	r3, r3, #16
 801bbee:	b2db      	uxtb	r3, r3
 801bbf0:	2b00      	cmp	r3, #0
 801bbf2:	d006      	beq.n	801bc02 <USBH_OTG_ISR_Handler+0x66>
    {
      retval |= USB_OTG_USBH_handle_rx_qlvl_ISR (pdev);
 801bbf4:	9801      	ldr	r0, [sp, #4]
 801bbf6:	f001 f8fe 	bl	801cdf6 <USB_OTG_USBH_handle_rx_qlvl_ISR>
 801bbfa:	4602      	mov	r2, r0
 801bbfc:	9b03      	ldr	r3, [sp, #12]
 801bbfe:	4313      	orrs	r3, r2
 801bc00:	9303      	str	r3, [sp, #12]
    }
    
    if (gintsts.b.nptxfempty)
 801bc02:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801bc06:	f003 0320 	and.w	r3, r3, #32
 801bc0a:	b2db      	uxtb	r3, r3
 801bc0c:	2b00      	cmp	r3, #0
 801bc0e:	d006      	beq.n	801bc1e <USBH_OTG_ISR_Handler+0x82>
    {
      retval |= USB_OTG_USBH_handle_nptxfempty_ISR (pdev);
 801bc10:	9801      	ldr	r0, [sp, #4]
 801bc12:	f000 f8cf 	bl	801bdb4 <USB_OTG_USBH_handle_nptxfempty_ISR>
 801bc16:	4602      	mov	r2, r0
 801bc18:	9b03      	ldr	r3, [sp, #12]
 801bc1a:	4313      	orrs	r3, r2
 801bc1c:	9303      	str	r3, [sp, #12]
    }
    
    if (gintsts.b.ptxfempty)
 801bc1e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801bc22:	f003 0304 	and.w	r3, r3, #4
 801bc26:	b2db      	uxtb	r3, r3
 801bc28:	2b00      	cmp	r3, #0
 801bc2a:	d006      	beq.n	801bc3a <USBH_OTG_ISR_Handler+0x9e>
    {
      retval |= USB_OTG_USBH_handle_ptxfempty_ISR (pdev);
 801bc2c:	9801      	ldr	r0, [sp, #4]
 801bc2e:	f000 f99e 	bl	801bf6e <USB_OTG_USBH_handle_ptxfempty_ISR>
 801bc32:	4602      	mov	r2, r0
 801bc34:	9b03      	ldr	r3, [sp, #12]
 801bc36:	4313      	orrs	r3, r2
 801bc38:	9303      	str	r3, [sp, #12]
    }    
    
    if (gintsts.b.hcintr)
 801bc3a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801bc3e:	f003 0302 	and.w	r3, r3, #2
 801bc42:	b2db      	uxtb	r3, r3
 801bc44:	2b00      	cmp	r3, #0
 801bc46:	d006      	beq.n	801bc56 <USBH_OTG_ISR_Handler+0xba>
    {
      retval |= USB_OTG_USBH_handle_hc_ISR (pdev);
 801bc48:	9801      	ldr	r0, [sp, #4]
 801bc4a:	f000 f833 	bl	801bcb4 <USB_OTG_USBH_handle_hc_ISR>
 801bc4e:	4602      	mov	r2, r0
 801bc50:	9b03      	ldr	r3, [sp, #12]
 801bc52:	4313      	orrs	r3, r2
 801bc54:	9303      	str	r3, [sp, #12]
    }
    
    if (gintsts.b.portintr)
 801bc56:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801bc5a:	f003 0301 	and.w	r3, r3, #1
 801bc5e:	b2db      	uxtb	r3, r3
 801bc60:	2b00      	cmp	r3, #0
 801bc62:	d006      	beq.n	801bc72 <USBH_OTG_ISR_Handler+0xd6>
    {
      retval |= USB_OTG_USBH_handle_port_ISR (pdev);
 801bc64:	9801      	ldr	r0, [sp, #4]
 801bc66:	f000 fa5f 	bl	801c128 <USB_OTG_USBH_handle_port_ISR>
 801bc6a:	4602      	mov	r2, r0
 801bc6c:	9b03      	ldr	r3, [sp, #12]
 801bc6e:	4313      	orrs	r3, r2
 801bc70:	9303      	str	r3, [sp, #12]
    }
    
    if (gintsts.b.disconnect)
 801bc72:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801bc76:	f003 0320 	and.w	r3, r3, #32
 801bc7a:	b2db      	uxtb	r3, r3
 801bc7c:	2b00      	cmp	r3, #0
 801bc7e:	d006      	beq.n	801bc8e <USBH_OTG_ISR_Handler+0xf2>
    {
      retval |= USB_OTG_USBH_handle_Disconnect_ISR (pdev);  
 801bc80:	9801      	ldr	r0, [sp, #4]
 801bc82:	f000 f87b 	bl	801bd7c <USB_OTG_USBH_handle_Disconnect_ISR>
 801bc86:	4602      	mov	r2, r0
 801bc88:	9b03      	ldr	r3, [sp, #12]
 801bc8a:	4313      	orrs	r3, r2
 801bc8c:	9303      	str	r3, [sp, #12]
      
    }
    
    if (gintsts.b.incomplisoout)
 801bc8e:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801bc92:	f003 0320 	and.w	r3, r3, #32
 801bc96:	b2db      	uxtb	r3, r3
 801bc98:	2b00      	cmp	r3, #0
 801bc9a:	d006      	beq.n	801bcaa <USBH_OTG_ISR_Handler+0x10e>
    {
      retval |= USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (pdev);
 801bc9c:	9801      	ldr	r0, [sp, #4]
 801bc9e:	f001 f999 	bl	801cfd4 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>
 801bca2:	4602      	mov	r2, r0
 801bca4:	9b03      	ldr	r3, [sp, #12]
 801bca6:	4313      	orrs	r3, r2
 801bca8:	9303      	str	r3, [sp, #12]
    }
    
    
  }
  return retval;
 801bcaa:	9b03      	ldr	r3, [sp, #12]
}
 801bcac:	4618      	mov	r0, r3
 801bcae:	b005      	add	sp, #20
 801bcb0:	f85d fb04 	ldr.w	pc, [sp], #4

0801bcb4 <USB_OTG_USBH_handle_hc_ISR>:
*         This function indicates that one or more host channels has a pending
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_hc_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801bcb4:	b500      	push	{lr}
 801bcb6:	b087      	sub	sp, #28
 801bcb8:	9001      	str	r0, [sp, #4]
  USB_OTG_HAINT_TypeDef        haint;
  USB_OTG_HCCHAR_TypeDef       hcchar;
  uint32_t i = 0;
 801bcba:	2300      	movs	r3, #0
 801bcbc:	9305      	str	r3, [sp, #20]
  uint32_t retval = 0;
 801bcbe:	2300      	movs	r3, #0
 801bcc0:	9304      	str	r3, [sp, #16]
  
  /* Clear appropriate bits in HCINTn to clear the interrupt bit in
  * GINTSTS */
  
  haint.d32 = USB_OTG_ReadHostAllChannels_intr(pdev);
 801bcc2:	9801      	ldr	r0, [sp, #4]
 801bcc4:	f7ff f818 	bl	801acf8 <USB_OTG_ReadHostAllChannels_intr>
 801bcc8:	4603      	mov	r3, r0
 801bcca:	9303      	str	r3, [sp, #12]
  
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 801bccc:	2300      	movs	r3, #0
 801bcce:	9305      	str	r3, [sp, #20]
 801bcd0:	e02c      	b.n	801bd2c <USB_OTG_USBH_handle_hc_ISR+0x78>
  {
    if (haint.b.chint & (1 << i))
 801bcd2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801bcd6:	461a      	mov	r2, r3
 801bcd8:	9b05      	ldr	r3, [sp, #20]
 801bcda:	fa42 f303 	asr.w	r3, r2, r3
 801bcde:	f003 0301 	and.w	r3, r3, #1
 801bce2:	2b00      	cmp	r3, #0
 801bce4:	d01f      	beq.n	801bd26 <USB_OTG_USBH_handle_hc_ISR+0x72>
    {
      hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
 801bce6:	9a01      	ldr	r2, [sp, #4]
 801bce8:	9b05      	ldr	r3, [sp, #20]
 801bcea:	3322      	adds	r3, #34	@ 0x22
 801bcec:	009b      	lsls	r3, r3, #2
 801bcee:	4413      	add	r3, r2
 801bcf0:	689b      	ldr	r3, [r3, #8]
 801bcf2:	681b      	ldr	r3, [r3, #0]
 801bcf4:	9302      	str	r3, [sp, #8]
      
      if (hcchar.b.epdir)
 801bcf6:	f89d 3009 	ldrb.w	r3, [sp, #9]
 801bcfa:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801bcfe:	b2db      	uxtb	r3, r3
 801bd00:	2b00      	cmp	r3, #0
 801bd02:	d008      	beq.n	801bd16 <USB_OTG_USBH_handle_hc_ISR+0x62>
      {
        retval |= USB_OTG_USBH_handle_hc_n_In_ISR (pdev, i);
 801bd04:	9905      	ldr	r1, [sp, #20]
 801bd06:	9801      	ldr	r0, [sp, #4]
 801bd08:	f000 fd8f 	bl	801c82a <USB_OTG_USBH_handle_hc_n_In_ISR>
 801bd0c:	4602      	mov	r2, r0
 801bd0e:	9b04      	ldr	r3, [sp, #16]
 801bd10:	4313      	orrs	r3, r2
 801bd12:	9304      	str	r3, [sp, #16]
 801bd14:	e007      	b.n	801bd26 <USB_OTG_USBH_handle_hc_ISR+0x72>
      }
      else
      {
        retval |=  USB_OTG_USBH_handle_hc_n_Out_ISR (pdev, i);
 801bd16:	9905      	ldr	r1, [sp, #20]
 801bd18:	9801      	ldr	r0, [sp, #4]
 801bd1a:	f000 facd 	bl	801c2b8 <USB_OTG_USBH_handle_hc_n_Out_ISR>
 801bd1e:	4602      	mov	r2, r0
 801bd20:	9b04      	ldr	r3, [sp, #16]
 801bd22:	4313      	orrs	r3, r2
 801bd24:	9304      	str	r3, [sp, #16]
  for (i = 0; i < pdev->cfg.host_channels ; i++)
 801bd26:	9b05      	ldr	r3, [sp, #20]
 801bd28:	3301      	adds	r3, #1
 801bd2a:	9305      	str	r3, [sp, #20]
 801bd2c:	9b01      	ldr	r3, [sp, #4]
 801bd2e:	781b      	ldrb	r3, [r3, #0]
 801bd30:	461a      	mov	r2, r3
 801bd32:	9b05      	ldr	r3, [sp, #20]
 801bd34:	4293      	cmp	r3, r2
 801bd36:	d3cc      	bcc.n	801bcd2 <USB_OTG_USBH_handle_hc_ISR+0x1e>
      }
    }
  }
  
  return retval;
 801bd38:	9b04      	ldr	r3, [sp, #16]
}
 801bd3a:	4618      	mov	r0, r3
 801bd3c:	b007      	add	sp, #28
 801bd3e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0801bd44 <USB_OTG_USBH_handle_sof_ISR>:
*         Handles the start-of-frame interrupt in host mode.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_sof_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801bd44:	b500      	push	{lr}
 801bd46:	b085      	sub	sp, #20
 801bd48:	9001      	str	r0, [sp, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  gintsts.d32 = 0;
 801bd4a:	2300      	movs	r3, #0
 801bd4c:	9303      	str	r3, [sp, #12]
  
  USBH_HCD_INT_fops->SOF(pdev);
 801bd4e:	4b0a      	ldr	r3, [pc, #40]	@ (801bd78 <USB_OTG_USBH_handle_sof_ISR+0x34>)
 801bd50:	681b      	ldr	r3, [r3, #0]
 801bd52:	681b      	ldr	r3, [r3, #0]
 801bd54:	9801      	ldr	r0, [sp, #4]
 801bd56:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.sofintr = 1;
 801bd58:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801bd5c:	f043 0308 	orr.w	r3, r3, #8
 801bd60:	f88d 300c 	strb.w	r3, [sp, #12]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801bd64:	9b01      	ldr	r3, [sp, #4]
 801bd66:	68db      	ldr	r3, [r3, #12]
 801bd68:	9a03      	ldr	r2, [sp, #12]
 801bd6a:	615a      	str	r2, [r3, #20]
  
  return 1;
 801bd6c:	2301      	movs	r3, #1
}
 801bd6e:	4618      	mov	r0, r3
 801bd70:	b005      	add	sp, #20
 801bd72:	f85d fb04 	ldr.w	pc, [sp], #4
 801bd76:	bf00      	nop
 801bd78:	2000004c 	.word	0x2000004c

0801bd7c <USB_OTG_USBH_handle_Disconnect_ISR>:
*         Handles disconnect event.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_Disconnect_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801bd7c:	b500      	push	{lr}
 801bd7e:	b085      	sub	sp, #20
 801bd80:	9001      	str	r0, [sp, #4]
  USB_OTG_GINTSTS_TypeDef      gintsts;
  
  gintsts.d32 = 0;
 801bd82:	2300      	movs	r3, #0
 801bd84:	9303      	str	r3, [sp, #12]
  
  USBH_HCD_INT_fops->DevDisconnected(pdev);
 801bd86:	4b0a      	ldr	r3, [pc, #40]	@ (801bdb0 <USB_OTG_USBH_handle_Disconnect_ISR+0x34>)
 801bd88:	681b      	ldr	r3, [r3, #0]
 801bd8a:	689b      	ldr	r3, [r3, #8]
 801bd8c:	9801      	ldr	r0, [sp, #4]
 801bd8e:	4798      	blx	r3
  
  /* Clear interrupt */
  gintsts.b.disconnect = 1;
 801bd90:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801bd94:	f043 0320 	orr.w	r3, r3, #32
 801bd98:	f88d 300f 	strb.w	r3, [sp, #15]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801bd9c:	9b01      	ldr	r3, [sp, #4]
 801bd9e:	68db      	ldr	r3, [r3, #12]
 801bda0:	9a03      	ldr	r2, [sp, #12]
 801bda2:	615a      	str	r2, [r3, #20]
  
  return 1;
 801bda4:	2301      	movs	r3, #1
}
 801bda6:	4618      	mov	r0, r3
 801bda8:	b005      	add	sp, #20
 801bdaa:	f85d fb04 	ldr.w	pc, [sp], #4
 801bdae:	bf00      	nop
 801bdb0:	2000004c 	.word	0x2000004c

0801bdb4 <USB_OTG_USBH_handle_nptxfempty_ISR>:
*         Handles non periodic tx fifo empty.
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_nptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801bdb4:	b500      	push	{lr}
 801bdb6:	b089      	sub	sp, #36	@ 0x24
 801bdb8:	9001      	str	r0, [sp, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HNPTXSTS_TypeDef     hnptxsts; 
  uint16_t                     len_words , len; 
  
  hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 801bdba:	9b01      	ldr	r3, [sp, #4]
 801bdbc:	68db      	ldr	r3, [r3, #12]
 801bdbe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801bdc0:	9303      	str	r3, [sp, #12]
  
  len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
 801bdc2:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801bdc6:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bdca:	b2db      	uxtb	r3, r3
 801bdcc:	9a01      	ldr	r2, [sp, #4]
 801bdce:	015b      	lsls	r3, r3, #5
 801bdd0:	4413      	add	r3, r2
 801bdd2:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bdd6:	681b      	ldr	r3, [r3, #0]
 801bdd8:	3303      	adds	r3, #3
 801bdda:	089b      	lsrs	r3, r3, #2
 801bddc:	f8ad 301e 	strh.w	r3, [sp, #30]
  
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 801bde0:	e0ac      	b.n	801bf3c <USB_OTG_USBH_handle_nptxfempty_ISR+0x188>
         (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len != 0))
  {
    
    len = hnptxsts.b.nptxfspcavail * 4;
 801bde2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801bde6:	009b      	lsls	r3, r3, #2
 801bde8:	f8ad 301c 	strh.w	r3, [sp, #28]
    
    if (len > pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len)
 801bdec:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 801bdf0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801bdf4:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bdf8:	b2db      	uxtb	r3, r3
 801bdfa:	9901      	ldr	r1, [sp, #4]
 801bdfc:	015b      	lsls	r3, r3, #5
 801bdfe:	440b      	add	r3, r1
 801be00:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801be04:	681b      	ldr	r3, [r3, #0]
 801be06:	429a      	cmp	r2, r3
 801be08:	d91d      	bls.n	801be46 <USB_OTG_USBH_handle_nptxfempty_ISR+0x92>
    {
      /* Last packet */
      len = pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len;
 801be0a:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801be0e:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801be12:	b2db      	uxtb	r3, r3
 801be14:	9a01      	ldr	r2, [sp, #4]
 801be16:	015b      	lsls	r3, r3, #5
 801be18:	4413      	add	r3, r2
 801be1a:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801be1e:	681b      	ldr	r3, [r3, #0]
 801be20:	f8ad 301c 	strh.w	r3, [sp, #28]
      
      intmsk.d32 = 0;
 801be24:	2300      	movs	r3, #0
 801be26:	9306      	str	r3, [sp, #24]
      intmsk.b.nptxfempty = 1;
 801be28:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801be2c:	f043 0320 	orr.w	r3, r3, #32
 801be30:	f88d 3018 	strb.w	r3, [sp, #24]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);       
 801be34:	9b01      	ldr	r3, [sp, #4]
 801be36:	68db      	ldr	r3, [r3, #12]
 801be38:	6999      	ldr	r1, [r3, #24]
 801be3a:	9b06      	ldr	r3, [sp, #24]
 801be3c:	43da      	mvns	r2, r3
 801be3e:	9b01      	ldr	r3, [sp, #4]
 801be40:	68db      	ldr	r3, [r3, #12]
 801be42:	400a      	ands	r2, r1
 801be44:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len + 3) / 4;
 801be46:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801be4a:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801be4e:	b2db      	uxtb	r3, r3
 801be50:	9a01      	ldr	r2, [sp, #4]
 801be52:	015b      	lsls	r3, r3, #5
 801be54:	4413      	add	r3, r2
 801be56:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801be5a:	681b      	ldr	r3, [r3, #0]
 801be5c:	3303      	adds	r3, #3
 801be5e:	089b      	lsrs	r3, r3, #2
 801be60:	f8ad 301e 	strh.w	r3, [sp, #30]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff, hnptxsts.b.nptxqtop.chnum, len);
 801be64:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801be68:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801be6c:	b2db      	uxtb	r3, r3
 801be6e:	9a01      	ldr	r2, [sp, #4]
 801be70:	3315      	adds	r3, #21
 801be72:	015b      	lsls	r3, r3, #5
 801be74:	4413      	add	r3, r2
 801be76:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801be7a:	6819      	ldr	r1, [r3, #0]
 801be7c:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801be80:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801be84:	b2db      	uxtb	r3, r3
 801be86:	461a      	mov	r2, r3
 801be88:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 801be8c:	9801      	ldr	r0, [sp, #4]
 801be8e:	f7fe fd9f 	bl	801a9d0 <USB_OTG_WritePacket>
    
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_buff  += len;
 801be92:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801be96:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801be9a:	b2db      	uxtb	r3, r3
 801be9c:	9a01      	ldr	r2, [sp, #4]
 801be9e:	3315      	adds	r3, #21
 801bea0:	015b      	lsls	r3, r3, #5
 801bea2:	4413      	add	r3, r2
 801bea4:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801bea8:	681a      	ldr	r2, [r3, #0]
 801beaa:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 801beae:	f89d 1010 	ldrb.w	r1, [sp, #16]
 801beb2:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801beb6:	b2c9      	uxtb	r1, r1
 801beb8:	4608      	mov	r0, r1
 801beba:	441a      	add	r2, r3
 801bebc:	9901      	ldr	r1, [sp, #4]
 801bebe:	f100 0315 	add.w	r3, r0, #21
 801bec2:	015b      	lsls	r3, r3, #5
 801bec4:	440b      	add	r3, r1
 801bec6:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801beca:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len   -= len;
 801becc:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801bed0:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bed4:	b2db      	uxtb	r3, r3
 801bed6:	9a01      	ldr	r2, [sp, #4]
 801bed8:	015b      	lsls	r3, r3, #5
 801beda:	4413      	add	r3, r2
 801bedc:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bee0:	681a      	ldr	r2, [r3, #0]
 801bee2:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 801bee6:	f89d 1010 	ldrb.w	r1, [sp, #16]
 801beea:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801beee:	b2c9      	uxtb	r1, r1
 801bef0:	4608      	mov	r0, r1
 801bef2:	1ad2      	subs	r2, r2, r3
 801bef4:	9901      	ldr	r1, [sp, #4]
 801bef6:	0143      	lsls	r3, r0, #5
 801bef8:	440b      	add	r3, r1
 801befa:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801befe:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_count  += len; 
 801bf00:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801bf04:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bf08:	b2db      	uxtb	r3, r3
 801bf0a:	9a01      	ldr	r2, [sp, #4]
 801bf0c:	015b      	lsls	r3, r3, #5
 801bf0e:	4413      	add	r3, r2
 801bf10:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801bf14:	681a      	ldr	r2, [r3, #0]
 801bf16:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 801bf1a:	f89d 1010 	ldrb.w	r1, [sp, #16]
 801bf1e:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801bf22:	b2c9      	uxtb	r1, r1
 801bf24:	4608      	mov	r0, r1
 801bf26:	441a      	add	r2, r3
 801bf28:	9901      	ldr	r1, [sp, #4]
 801bf2a:	0143      	lsls	r3, r0, #5
 801bf2c:	440b      	add	r3, r1
 801bf2e:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801bf32:	601a      	str	r2, [r3, #0]
    
    hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
 801bf34:	9b01      	ldr	r3, [sp, #4]
 801bf36:	68db      	ldr	r3, [r3, #12]
 801bf38:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 801bf3a:	9303      	str	r3, [sp, #12]
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 801bf3c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801bf40:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 801bf44:	429a      	cmp	r2, r3
 801bf46:	d20d      	bcs.n	801bf64 <USB_OTG_USBH_handle_nptxfempty_ISR+0x1b0>
         (pdev->host.hc[hnptxsts.b.nptxqtop.chnum].xfer_len != 0))
 801bf48:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801bf4c:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bf50:	b2db      	uxtb	r3, r3
 801bf52:	9a01      	ldr	r2, [sp, #4]
 801bf54:	015b      	lsls	r3, r3, #5
 801bf56:	4413      	add	r3, r2
 801bf58:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bf5c:	681b      	ldr	r3, [r3, #0]
  while ((hnptxsts.b.nptxfspcavail > len_words)&&
 801bf5e:	2b00      	cmp	r3, #0
 801bf60:	f47f af3f 	bne.w	801bde2 <USB_OTG_USBH_handle_nptxfempty_ISR+0x2e>
  }  
  
  return 1;
 801bf64:	2301      	movs	r3, #1
}
 801bf66:	4618      	mov	r0, r3
 801bf68:	b009      	add	sp, #36	@ 0x24
 801bf6a:	f85d fb04 	ldr.w	pc, [sp], #4

0801bf6e <USB_OTG_USBH_handle_ptxfempty_ISR>:
*         Handles periodic tx fifo empty
* @param  pdev: Selected device
* @retval status 
*/
static uint32_t USB_OTG_USBH_handle_ptxfempty_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801bf6e:	b500      	push	{lr}
 801bf70:	b087      	sub	sp, #28
 801bf72:	9001      	str	r0, [sp, #4]
  USB_OTG_GINTMSK_TypeDef      intmsk;
  USB_OTG_HPTXSTS_TypeDef      hptxsts; 
  uint16_t                     len_words , len; 
  
  hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 801bf74:	9b01      	ldr	r3, [sp, #4]
 801bf76:	695b      	ldr	r3, [r3, #20]
 801bf78:	691b      	ldr	r3, [r3, #16]
 801bf7a:	9302      	str	r3, [sp, #8]
  
  len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
 801bf7c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801bf80:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bf84:	b2db      	uxtb	r3, r3
 801bf86:	9a01      	ldr	r2, [sp, #4]
 801bf88:	015b      	lsls	r3, r3, #5
 801bf8a:	4413      	add	r3, r2
 801bf8c:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bf90:	681b      	ldr	r3, [r3, #0]
 801bf92:	3303      	adds	r3, #3
 801bf94:	089b      	lsrs	r3, r3, #2
 801bf96:	f8ad 3016 	strh.w	r3, [sp, #22]
  
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 801bf9a:	e0ac      	b.n	801c0f6 <USB_OTG_USBH_handle_ptxfempty_ISR+0x188>
         (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len != 0))    
  {
    
    len = hptxsts.b.ptxfspcavail * 4;
 801bf9c:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 801bfa0:	009b      	lsls	r3, r3, #2
 801bfa2:	f8ad 3014 	strh.w	r3, [sp, #20]
    
    if (len > pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len)
 801bfa6:	f8bd 2014 	ldrh.w	r2, [sp, #20]
 801bfaa:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801bfae:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bfb2:	b2db      	uxtb	r3, r3
 801bfb4:	9901      	ldr	r1, [sp, #4]
 801bfb6:	015b      	lsls	r3, r3, #5
 801bfb8:	440b      	add	r3, r1
 801bfba:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bfbe:	681b      	ldr	r3, [r3, #0]
 801bfc0:	429a      	cmp	r2, r3
 801bfc2:	d91d      	bls.n	801c000 <USB_OTG_USBH_handle_ptxfempty_ISR+0x92>
    {
      len = pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len;
 801bfc4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801bfc8:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801bfcc:	b2db      	uxtb	r3, r3
 801bfce:	9a01      	ldr	r2, [sp, #4]
 801bfd0:	015b      	lsls	r3, r3, #5
 801bfd2:	4413      	add	r3, r2
 801bfd4:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801bfd8:	681b      	ldr	r3, [r3, #0]
 801bfda:	f8ad 3014 	strh.w	r3, [sp, #20]
      /* Last packet */
      intmsk.d32 = 0;
 801bfde:	2300      	movs	r3, #0
 801bfe0:	9304      	str	r3, [sp, #16]
      intmsk.b.ptxfempty = 1;
 801bfe2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 801bfe6:	f043 0304 	orr.w	r3, r3, #4
 801bfea:	f88d 3013 	strb.w	r3, [sp, #19]
      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0); 
 801bfee:	9b01      	ldr	r3, [sp, #4]
 801bff0:	68db      	ldr	r3, [r3, #12]
 801bff2:	6999      	ldr	r1, [r3, #24]
 801bff4:	9b04      	ldr	r3, [sp, #16]
 801bff6:	43da      	mvns	r2, r3
 801bff8:	9b01      	ldr	r3, [sp, #4]
 801bffa:	68db      	ldr	r3, [r3, #12]
 801bffc:	400a      	ands	r2, r1
 801bffe:	619a      	str	r2, [r3, #24]
    }
    
    len_words = (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len + 3) / 4;
 801c000:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c004:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c008:	b2db      	uxtb	r3, r3
 801c00a:	9a01      	ldr	r2, [sp, #4]
 801c00c:	015b      	lsls	r3, r3, #5
 801c00e:	4413      	add	r3, r2
 801c010:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801c014:	681b      	ldr	r3, [r3, #0]
 801c016:	3303      	adds	r3, #3
 801c018:	089b      	lsrs	r3, r3, #2
 801c01a:	f8ad 3016 	strh.w	r3, [sp, #22]
    
    USB_OTG_WritePacket (pdev , pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff, hptxsts.b.ptxqtop.chnum, len);
 801c01e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c022:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c026:	b2db      	uxtb	r3, r3
 801c028:	9a01      	ldr	r2, [sp, #4]
 801c02a:	3315      	adds	r3, #21
 801c02c:	015b      	lsls	r3, r3, #5
 801c02e:	4413      	add	r3, r2
 801c030:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801c034:	6819      	ldr	r1, [r3, #0]
 801c036:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c03a:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c03e:	b2db      	uxtb	r3, r3
 801c040:	461a      	mov	r2, r3
 801c042:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801c046:	9801      	ldr	r0, [sp, #4]
 801c048:	f7fe fcc2 	bl	801a9d0 <USB_OTG_WritePacket>
    
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_buff  += len;
 801c04c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c050:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c054:	b2db      	uxtb	r3, r3
 801c056:	9a01      	ldr	r2, [sp, #4]
 801c058:	3315      	adds	r3, #21
 801c05a:	015b      	lsls	r3, r3, #5
 801c05c:	4413      	add	r3, r2
 801c05e:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801c062:	681a      	ldr	r2, [r3, #0]
 801c064:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801c068:	f89d 100c 	ldrb.w	r1, [sp, #12]
 801c06c:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801c070:	b2c9      	uxtb	r1, r1
 801c072:	4608      	mov	r0, r1
 801c074:	441a      	add	r2, r3
 801c076:	9901      	ldr	r1, [sp, #4]
 801c078:	f100 0315 	add.w	r3, r0, #21
 801c07c:	015b      	lsls	r3, r3, #5
 801c07e:	440b      	add	r3, r1
 801c080:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801c084:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len   -= len;
 801c086:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c08a:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c08e:	b2db      	uxtb	r3, r3
 801c090:	9a01      	ldr	r2, [sp, #4]
 801c092:	015b      	lsls	r3, r3, #5
 801c094:	4413      	add	r3, r2
 801c096:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801c09a:	681a      	ldr	r2, [r3, #0]
 801c09c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801c0a0:	f89d 100c 	ldrb.w	r1, [sp, #12]
 801c0a4:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801c0a8:	b2c9      	uxtb	r1, r1
 801c0aa:	4608      	mov	r0, r1
 801c0ac:	1ad2      	subs	r2, r2, r3
 801c0ae:	9901      	ldr	r1, [sp, #4]
 801c0b0:	0143      	lsls	r3, r0, #5
 801c0b2:	440b      	add	r3, r1
 801c0b4:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801c0b8:	601a      	str	r2, [r3, #0]
    pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_count  += len; 
 801c0ba:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c0be:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c0c2:	b2db      	uxtb	r3, r3
 801c0c4:	9a01      	ldr	r2, [sp, #4]
 801c0c6:	015b      	lsls	r3, r3, #5
 801c0c8:	4413      	add	r3, r2
 801c0ca:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801c0ce:	681a      	ldr	r2, [r3, #0]
 801c0d0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 801c0d4:	f89d 100c 	ldrb.w	r1, [sp, #12]
 801c0d8:	f3c1 01c3 	ubfx	r1, r1, #3, #4
 801c0dc:	b2c9      	uxtb	r1, r1
 801c0de:	4608      	mov	r0, r1
 801c0e0:	441a      	add	r2, r3
 801c0e2:	9901      	ldr	r1, [sp, #4]
 801c0e4:	0143      	lsls	r3, r0, #5
 801c0e6:	440b      	add	r3, r1
 801c0e8:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801c0ec:	601a      	str	r2, [r3, #0]
    
    hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
 801c0ee:	9b01      	ldr	r3, [sp, #4]
 801c0f0:	695b      	ldr	r3, [r3, #20]
 801c0f2:	691b      	ldr	r3, [r3, #16]
 801c0f4:	9302      	str	r3, [sp, #8]
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 801c0f6:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 801c0fa:	f8bd 2016 	ldrh.w	r2, [sp, #22]
 801c0fe:	429a      	cmp	r2, r3
 801c100:	d20d      	bcs.n	801c11e <USB_OTG_USBH_handle_ptxfempty_ISR+0x1b0>
         (pdev->host.hc[hptxsts.b.ptxqtop.chnum].xfer_len != 0))    
 801c102:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c106:	f3c3 03c3 	ubfx	r3, r3, #3, #4
 801c10a:	b2db      	uxtb	r3, r3
 801c10c:	9a01      	ldr	r2, [sp, #4]
 801c10e:	015b      	lsls	r3, r3, #5
 801c110:	4413      	add	r3, r2
 801c112:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801c116:	681b      	ldr	r3, [r3, #0]
  while ((hptxsts.b.ptxfspcavail > len_words)&&
 801c118:	2b00      	cmp	r3, #0
 801c11a:	f47f af3f 	bne.w	801bf9c <USB_OTG_USBH_handle_ptxfempty_ISR+0x2e>
  }  
  
  return 1;
 801c11e:	2301      	movs	r3, #1
}
 801c120:	4618      	mov	r0, r3
 801c122:	b007      	add	sp, #28
 801c124:	f85d fb04 	ldr.w	pc, [sp], #4

0801c128 <USB_OTG_USBH_handle_port_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_port_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801c128:	b500      	push	{lr}
 801c12a:	b089      	sub	sp, #36	@ 0x24
 801c12c:	9001      	str	r0, [sp, #4]
  USB_OTG_HPRT0_TypeDef  hprt0;
  USB_OTG_HPRT0_TypeDef  hprt0_dup;
  USB_OTG_HCFG_TypeDef   hcfg;    
  uint32_t do_reset = 0;
 801c12e:	2300      	movs	r3, #0
 801c130:	9307      	str	r3, [sp, #28]
  uint32_t retval = 0;
 801c132:	2300      	movs	r3, #0
 801c134:	9306      	str	r3, [sp, #24]
  
  hcfg.d32 = 0;
 801c136:	2300      	movs	r3, #0
 801c138:	9303      	str	r3, [sp, #12]
  hprt0.d32 = 0;
 801c13a:	2300      	movs	r3, #0
 801c13c:	9305      	str	r3, [sp, #20]
  hprt0_dup.d32 = 0;
 801c13e:	2300      	movs	r3, #0
 801c140:	9304      	str	r3, [sp, #16]
  
  hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801c142:	9b01      	ldr	r3, [sp, #4]
 801c144:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 801c148:	681b      	ldr	r3, [r3, #0]
 801c14a:	9305      	str	r3, [sp, #20]
  hprt0_dup.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
 801c14c:	9b01      	ldr	r3, [sp, #4]
 801c14e:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 801c152:	681b      	ldr	r3, [r3, #0]
 801c154:	9304      	str	r3, [sp, #16]
  
  /* Clear the interrupt bits in GINTSTS */
  
  hprt0_dup.b.prtena = 0;
 801c156:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c15a:	f36f 0382 	bfc	r3, #2, #1
 801c15e:	f88d 3010 	strb.w	r3, [sp, #16]
  hprt0_dup.b.prtconndet = 0;
 801c162:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c166:	f36f 0341 	bfc	r3, #1, #1
 801c16a:	f88d 3010 	strb.w	r3, [sp, #16]
  hprt0_dup.b.prtenchng = 0;
 801c16e:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c172:	f36f 03c3 	bfc	r3, #3, #1
 801c176:	f88d 3010 	strb.w	r3, [sp, #16]
  hprt0_dup.b.prtovrcurrchng = 0;
 801c17a:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c17e:	f36f 1345 	bfc	r3, #5, #1
 801c182:	f88d 3010 	strb.w	r3, [sp, #16]
  
  /* Port Connect Detected */
  if (hprt0.b.prtconndet)
 801c186:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801c18a:	f003 0302 	and.w	r3, r3, #2
 801c18e:	b2db      	uxtb	r3, r3
 801c190:	2b00      	cmp	r3, #0
 801c192:	d00e      	beq.n	801c1b2 <USB_OTG_USBH_handle_port_ISR+0x8a>
  {

    hprt0_dup.b.prtconndet = 1;
 801c194:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c198:	f043 0302 	orr.w	r3, r3, #2
 801c19c:	f88d 3010 	strb.w	r3, [sp, #16]
    USBH_HCD_INT_fops->DevConnected(pdev);
 801c1a0:	4b44      	ldr	r3, [pc, #272]	@ (801c2b4 <USB_OTG_USBH_handle_port_ISR+0x18c>)
 801c1a2:	681b      	ldr	r3, [r3, #0]
 801c1a4:	685b      	ldr	r3, [r3, #4]
 801c1a6:	9801      	ldr	r0, [sp, #4]
 801c1a8:	4798      	blx	r3
    retval |= 1;
 801c1aa:	9b06      	ldr	r3, [sp, #24]
 801c1ac:	f043 0301 	orr.w	r3, r3, #1
 801c1b0:	9306      	str	r3, [sp, #24]
  }
  
  /* Port Enable Changed */
  if (hprt0.b.prtenchng)
 801c1b2:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801c1b6:	f003 0308 	and.w	r3, r3, #8
 801c1ba:	b2db      	uxtb	r3, r3
 801c1bc:	2b00      	cmp	r3, #0
 801c1be:	d058      	beq.n	801c272 <USB_OTG_USBH_handle_port_ISR+0x14a>
  {
    hprt0_dup.b.prtenchng = 1;
 801c1c0:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c1c4:	f043 0308 	orr.w	r3, r3, #8
 801c1c8:	f88d 3010 	strb.w	r3, [sp, #16]
    
    if (hprt0.b.prtena == 1)
 801c1cc:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801c1d0:	f003 0304 	and.w	r3, r3, #4
 801c1d4:	b2db      	uxtb	r3, r3
 801c1d6:	2b00      	cmp	r3, #0
 801c1d8:	d04b      	beq.n	801c272 <USB_OTG_USBH_handle_port_ISR+0x14a>
    {
      
      USBH_HCD_INT_fops->DevConnected(pdev);
 801c1da:	4b36      	ldr	r3, [pc, #216]	@ (801c2b4 <USB_OTG_USBH_handle_port_ISR+0x18c>)
 801c1dc:	681b      	ldr	r3, [r3, #0]
 801c1de:	685b      	ldr	r3, [r3, #4]
 801c1e0:	9801      	ldr	r0, [sp, #4]
 801c1e2:	4798      	blx	r3
      
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 801c1e4:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801c1e8:	f003 0306 	and.w	r3, r3, #6
 801c1ec:	b2db      	uxtb	r3, r3
 801c1ee:	2b04      	cmp	r3, #4
 801c1f0:	d006      	beq.n	801c200 <USB_OTG_USBH_handle_port_ISR+0xd8>
          (hprt0.b.prtspd == HPRT0_PRTSPD_FULL_SPEED))
 801c1f2:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801c1f6:	f003 0306 	and.w	r3, r3, #6
 801c1fa:	b2db      	uxtb	r3, r3
      if ((hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED) ||
 801c1fc:	2b02      	cmp	r3, #2
 801c1fe:	d134      	bne.n	801c26a <USB_OTG_USBH_handle_port_ISR+0x142>
      {
        
        hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
 801c200:	9b01      	ldr	r3, [sp, #4]
 801c202:	695b      	ldr	r3, [r3, #20]
 801c204:	681b      	ldr	r3, [r3, #0]
 801c206:	9303      	str	r3, [sp, #12]
        
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 801c208:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801c20c:	f003 0306 	and.w	r3, r3, #6
 801c210:	b2db      	uxtb	r3, r3
 801c212:	2b04      	cmp	r3, #4
 801c214:	d116      	bne.n	801c244 <USB_OTG_USBH_handle_port_ISR+0x11c>
        {
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 6000 );
 801c216:	9b01      	ldr	r3, [sp, #4]
 801c218:	695b      	ldr	r3, [r3, #20]
 801c21a:	f241 7270 	movw	r2, #6000	@ 0x1770
 801c21e:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_6_MHZ)
 801c220:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c224:	f003 0303 	and.w	r3, r3, #3
 801c228:	b2db      	uxtb	r3, r3
 801c22a:	2b02      	cmp	r3, #2
 801c22c:	d020      	beq.n	801c270 <USB_OTG_USBH_handle_port_ISR+0x148>
          {
            if(pdev->cfg.phy_itface  == USB_OTG_EMBEDDED_PHY)
 801c22e:	9b01      	ldr	r3, [sp, #4]
 801c230:	7a1b      	ldrb	r3, [r3, #8]
 801c232:	2b02      	cmp	r3, #2
 801c234:	d103      	bne.n	801c23e <USB_OTG_USBH_handle_port_ISR+0x116>
            {
              USB_OTG_InitFSLSPClkSel(pdev ,HCFG_6_MHZ );
 801c236:	2102      	movs	r1, #2
 801c238:	9801      	ldr	r0, [sp, #4]
 801c23a:	f7fe fd31 	bl	801aca0 <USB_OTG_InitFSLSPClkSel>
            }
            do_reset = 1;
 801c23e:	2301      	movs	r3, #1
 801c240:	9307      	str	r3, [sp, #28]
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 801c242:	e015      	b.n	801c270 <USB_OTG_USBH_handle_port_ISR+0x148>
          }
        }
        else
        {
          
          USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HFIR, 48000 );            
 801c244:	9b01      	ldr	r3, [sp, #4]
 801c246:	695b      	ldr	r3, [r3, #20]
 801c248:	f64b 3280 	movw	r2, #48000	@ 0xbb80
 801c24c:	605a      	str	r2, [r3, #4]
          if (hcfg.b.fslspclksel != HCFG_48_MHZ)
 801c24e:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c252:	f003 0303 	and.w	r3, r3, #3
 801c256:	b2db      	uxtb	r3, r3
 801c258:	2b01      	cmp	r3, #1
 801c25a:	d009      	beq.n	801c270 <USB_OTG_USBH_handle_port_ISR+0x148>
          {
            USB_OTG_InitFSLSPClkSel(pdev ,HCFG_48_MHZ );
 801c25c:	2101      	movs	r1, #1
 801c25e:	9801      	ldr	r0, [sp, #4]
 801c260:	f7fe fd1e 	bl	801aca0 <USB_OTG_InitFSLSPClkSel>
            do_reset = 1;
 801c264:	2301      	movs	r3, #1
 801c266:	9307      	str	r3, [sp, #28]
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 801c268:	e002      	b.n	801c270 <USB_OTG_USBH_handle_port_ISR+0x148>
          }
        }
      }
      else
      {
        do_reset = 1;
 801c26a:	2301      	movs	r3, #1
 801c26c:	9307      	str	r3, [sp, #28]
 801c26e:	e000      	b.n	801c272 <USB_OTG_USBH_handle_port_ISR+0x14a>
        if (hprt0.b.prtspd == HPRT0_PRTSPD_LOW_SPEED)
 801c270:	bf00      	nop
      }
    }
  }
  /* Overcurrent Change Interrupt */
  if (hprt0.b.prtovrcurrchng)
 801c272:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801c276:	f003 0320 	and.w	r3, r3, #32
 801c27a:	b2db      	uxtb	r3, r3
 801c27c:	2b00      	cmp	r3, #0
 801c27e:	d009      	beq.n	801c294 <USB_OTG_USBH_handle_port_ISR+0x16c>
  {
    hprt0_dup.b.prtovrcurrchng = 1;
 801c280:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801c284:	f043 0320 	orr.w	r3, r3, #32
 801c288:	f88d 3010 	strb.w	r3, [sp, #16]
    retval |= 1;
 801c28c:	9b06      	ldr	r3, [sp, #24]
 801c28e:	f043 0301 	orr.w	r3, r3, #1
 801c292:	9306      	str	r3, [sp, #24]
  }
  if (do_reset)
 801c294:	9b07      	ldr	r3, [sp, #28]
 801c296:	2b00      	cmp	r3, #0
 801c298:	d002      	beq.n	801c2a0 <USB_OTG_USBH_handle_port_ISR+0x178>
  {
    USB_OTG_ResetPort(pdev);
 801c29a:	9801      	ldr	r0, [sp, #4]
 801c29c:	f7fe fd2f 	bl	801acfe <USB_OTG_ResetPort>
  }
  /* Clear Port Interrupts */
  USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0_dup.d32);
 801c2a0:	9b01      	ldr	r3, [sp, #4]
 801c2a2:	f8d3 30cc 	ldr.w	r3, [r3, #204]	@ 0xcc
 801c2a6:	9a04      	ldr	r2, [sp, #16]
 801c2a8:	601a      	str	r2, [r3, #0]
  
  return retval;
 801c2aa:	9b06      	ldr	r3, [sp, #24]
}
 801c2ac:	4618      	mov	r0, r3
 801c2ae:	b009      	add	sp, #36	@ 0x24
 801c2b0:	f85d fb04 	ldr.w	pc, [sp], #4
 801c2b4:	2000004c 	.word	0x2000004c

0801c2b8 <USB_OTG_USBH_handle_hc_n_Out_ISR>:
* @param  pdev: Selected device
* @param  hc_num: Channel number
* @retval status 
*/
uint32_t USB_OTG_USBH_handle_hc_n_Out_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 801c2b8:	b500      	push	{lr}
 801c2ba:	b09b      	sub	sp, #108	@ 0x6c
 801c2bc:	9001      	str	r0, [sp, #4]
 801c2be:	9100      	str	r1, [sp, #0]
  USB_OTG_HCINTn_TypeDef     hcint;
  USB_OTG_HCINTMSK_TypeDef  hcintmsk;
  USB_OTG_HC_REGS *hcreg;
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  
  hcreg = pdev->regs.HC_REGS[num];
 801c2c0:	9a01      	ldr	r2, [sp, #4]
 801c2c2:	9b00      	ldr	r3, [sp, #0]
 801c2c4:	3322      	adds	r3, #34	@ 0x22
 801c2c6:	009b      	lsls	r3, r3, #2
 801c2c8:	4413      	add	r3, r2
 801c2ca:	689b      	ldr	r3, [r3, #8]
 801c2cc:	9319      	str	r3, [sp, #100]	@ 0x64
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 801c2ce:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c2d0:	689b      	ldr	r3, [r3, #8]
 801c2d2:	9318      	str	r3, [sp, #96]	@ 0x60
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
 801c2d4:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c2d6:	68db      	ldr	r3, [r3, #12]
 801c2d8:	9317      	str	r3, [sp, #92]	@ 0x5c
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 801c2da:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 801c2dc:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 801c2de:	4013      	ands	r3, r2
 801c2e0:	9318      	str	r3, [sp, #96]	@ 0x60
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 801c2e2:	9a01      	ldr	r2, [sp, #4]
 801c2e4:	9b00      	ldr	r3, [sp, #0]
 801c2e6:	3322      	adds	r3, #34	@ 0x22
 801c2e8:	009b      	lsls	r3, r3, #2
 801c2ea:	4413      	add	r3, r2
 801c2ec:	689b      	ldr	r3, [r3, #8]
 801c2ee:	681b      	ldr	r3, [r3, #0]
 801c2f0:	9316      	str	r3, [sp, #88]	@ 0x58
  
  if (hcint.b.ahberr)
 801c2f2:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c2f6:	f003 0304 	and.w	r3, r3, #4
 801c2fa:	b2db      	uxtb	r3, r3
 801c2fc:	2b00      	cmp	r3, #0
 801c2fe:	d021      	beq.n	801c344 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x8c>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 801c300:	2300      	movs	r3, #0
 801c302:	9315      	str	r3, [sp, #84]	@ 0x54
 801c304:	f89d 3054 	ldrb.w	r3, [sp, #84]	@ 0x54
 801c308:	f043 0304 	orr.w	r3, r3, #4
 801c30c:	f88d 3054 	strb.w	r3, [sp, #84]	@ 0x54
 801c310:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 801c312:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c314:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c316:	9a01      	ldr	r2, [sp, #4]
 801c318:	9b00      	ldr	r3, [sp, #0]
 801c31a:	3322      	adds	r3, #34	@ 0x22
 801c31c:	009b      	lsls	r3, r3, #2
 801c31e:	4413      	add	r3, r2
 801c320:	689b      	ldr	r3, [r3, #8]
 801c322:	68db      	ldr	r3, [r3, #12]
 801c324:	9314      	str	r3, [sp, #80]	@ 0x50
 801c326:	f89d 3050 	ldrb.w	r3, [sp, #80]	@ 0x50
 801c32a:	f043 0302 	orr.w	r3, r3, #2
 801c32e:	f88d 3050 	strb.w	r3, [sp, #80]	@ 0x50
 801c332:	9a01      	ldr	r2, [sp, #4]
 801c334:	9b00      	ldr	r3, [sp, #0]
 801c336:	3322      	adds	r3, #34	@ 0x22
 801c338:	009b      	lsls	r3, r3, #2
 801c33a:	4413      	add	r3, r2
 801c33c:	689b      	ldr	r3, [r3, #8]
 801c33e:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 801c340:	60da      	str	r2, [r3, #12]
 801c342:	e26d      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  } 
  else if (hcint.b.ack)
 801c344:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c348:	f003 0320 	and.w	r3, r3, #32
 801c34c:	b2db      	uxtb	r3, r3
 801c34e:	2b00      	cmp	r3, #0
 801c350:	d00b      	beq.n	801c36a <USB_OTG_USBH_handle_hc_n_Out_ISR+0xb2>
  {
    CLEAR_HC_INT(hcreg , ack);
 801c352:	2300      	movs	r3, #0
 801c354:	9313      	str	r3, [sp, #76]	@ 0x4c
 801c356:	f89d 304c 	ldrb.w	r3, [sp, #76]	@ 0x4c
 801c35a:	f043 0320 	orr.w	r3, r3, #32
 801c35e:	f88d 304c 	strb.w	r3, [sp, #76]	@ 0x4c
 801c362:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 801c364:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c366:	609a      	str	r2, [r3, #8]
 801c368:	e25a      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  else if (hcint.b.frmovrun)
 801c36a:	f89d 3061 	ldrb.w	r3, [sp, #97]	@ 0x61
 801c36e:	f003 0302 	and.w	r3, r3, #2
 801c372:	b2db      	uxtb	r3, r3
 801c374:	2b00      	cmp	r3, #0
 801c376:	d027      	beq.n	801c3c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x110>
  {
    UNMASK_HOST_INT_CHH (num);
 801c378:	9a01      	ldr	r2, [sp, #4]
 801c37a:	9b00      	ldr	r3, [sp, #0]
 801c37c:	3322      	adds	r3, #34	@ 0x22
 801c37e:	009b      	lsls	r3, r3, #2
 801c380:	4413      	add	r3, r2
 801c382:	689b      	ldr	r3, [r3, #8]
 801c384:	68db      	ldr	r3, [r3, #12]
 801c386:	9312      	str	r3, [sp, #72]	@ 0x48
 801c388:	f89d 3048 	ldrb.w	r3, [sp, #72]	@ 0x48
 801c38c:	f043 0302 	orr.w	r3, r3, #2
 801c390:	f88d 3048 	strb.w	r3, [sp, #72]	@ 0x48
 801c394:	9a01      	ldr	r2, [sp, #4]
 801c396:	9b00      	ldr	r3, [sp, #0]
 801c398:	3322      	adds	r3, #34	@ 0x22
 801c39a:	009b      	lsls	r3, r3, #2
 801c39c:	4413      	add	r3, r2
 801c39e:	689b      	ldr	r3, [r3, #8]
 801c3a0:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 801c3a2:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c3a4:	9b00      	ldr	r3, [sp, #0]
 801c3a6:	b2db      	uxtb	r3, r3
 801c3a8:	4619      	mov	r1, r3
 801c3aa:	9801      	ldr	r0, [sp, #4]
 801c3ac:	f7fe fe05 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 801c3b0:	2300      	movs	r3, #0
 801c3b2:	9311      	str	r3, [sp, #68]	@ 0x44
 801c3b4:	f89d 3045 	ldrb.w	r3, [sp, #69]	@ 0x45
 801c3b8:	f043 0302 	orr.w	r3, r3, #2
 801c3bc:	f88d 3045 	strb.w	r3, [sp, #69]	@ 0x45
 801c3c0:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 801c3c2:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c3c4:	609a      	str	r2, [r3, #8]
 801c3c6:	e22b      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  else if (hcint.b.xfercompl)
 801c3c8:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c3cc:	f003 0301 	and.w	r3, r3, #1
 801c3d0:	b2db      	uxtb	r3, r3
 801c3d2:	2b00      	cmp	r3, #0
 801c3d4:	d036      	beq.n	801c444 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x18c>
  {
    pdev->host.ErrCnt[num] = 0;
 801c3d6:	9a01      	ldr	r2, [sp, #4]
 801c3d8:	9b00      	ldr	r3, [sp, #0]
 801c3da:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c3de:	009b      	lsls	r3, r3, #2
 801c3e0:	4413      	add	r3, r2
 801c3e2:	2200      	movs	r2, #0
 801c3e4:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c3e6:	9a01      	ldr	r2, [sp, #4]
 801c3e8:	9b00      	ldr	r3, [sp, #0]
 801c3ea:	3322      	adds	r3, #34	@ 0x22
 801c3ec:	009b      	lsls	r3, r3, #2
 801c3ee:	4413      	add	r3, r2
 801c3f0:	689b      	ldr	r3, [r3, #8]
 801c3f2:	68db      	ldr	r3, [r3, #12]
 801c3f4:	9310      	str	r3, [sp, #64]	@ 0x40
 801c3f6:	f89d 3040 	ldrb.w	r3, [sp, #64]	@ 0x40
 801c3fa:	f043 0302 	orr.w	r3, r3, #2
 801c3fe:	f88d 3040 	strb.w	r3, [sp, #64]	@ 0x40
 801c402:	9a01      	ldr	r2, [sp, #4]
 801c404:	9b00      	ldr	r3, [sp, #0]
 801c406:	3322      	adds	r3, #34	@ 0x22
 801c408:	009b      	lsls	r3, r3, #2
 801c40a:	4413      	add	r3, r2
 801c40c:	689b      	ldr	r3, [r3, #8]
 801c40e:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 801c410:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c412:	9b00      	ldr	r3, [sp, #0]
 801c414:	b2db      	uxtb	r3, r3
 801c416:	4619      	mov	r1, r3
 801c418:	9801      	ldr	r0, [sp, #4]
 801c41a:	f7fe fdce 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xfercompl);
 801c41e:	2300      	movs	r3, #0
 801c420:	930f      	str	r3, [sp, #60]	@ 0x3c
 801c422:	f89d 303c 	ldrb.w	r3, [sp, #60]	@ 0x3c
 801c426:	f043 0301 	orr.w	r3, r3, #1
 801c42a:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
 801c42e:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 801c430:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c432:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XFRC;            
 801c434:	9a01      	ldr	r2, [sp, #4]
 801c436:	9b00      	ldr	r3, [sp, #0]
 801c438:	4413      	add	r3, r2
 801c43a:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c43e:	2201      	movs	r2, #1
 801c440:	701a      	strb	r2, [r3, #0]
 801c442:	e1ed      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  
  else if (hcint.b.stall)
 801c444:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c448:	f003 0308 	and.w	r3, r3, #8
 801c44c:	b2db      	uxtb	r3, r3
 801c44e:	2b00      	cmp	r3, #0
 801c450:	d02e      	beq.n	801c4b0 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x1f8>
  {
    CLEAR_HC_INT(hcreg , stall);
 801c452:	2300      	movs	r3, #0
 801c454:	930e      	str	r3, [sp, #56]	@ 0x38
 801c456:	f89d 3038 	ldrb.w	r3, [sp, #56]	@ 0x38
 801c45a:	f043 0308 	orr.w	r3, r3, #8
 801c45e:	f88d 3038 	strb.w	r3, [sp, #56]	@ 0x38
 801c462:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 801c464:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c466:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c468:	9a01      	ldr	r2, [sp, #4]
 801c46a:	9b00      	ldr	r3, [sp, #0]
 801c46c:	3322      	adds	r3, #34	@ 0x22
 801c46e:	009b      	lsls	r3, r3, #2
 801c470:	4413      	add	r3, r2
 801c472:	689b      	ldr	r3, [r3, #8]
 801c474:	68db      	ldr	r3, [r3, #12]
 801c476:	930d      	str	r3, [sp, #52]	@ 0x34
 801c478:	f89d 3034 	ldrb.w	r3, [sp, #52]	@ 0x34
 801c47c:	f043 0302 	orr.w	r3, r3, #2
 801c480:	f88d 3034 	strb.w	r3, [sp, #52]	@ 0x34
 801c484:	9a01      	ldr	r2, [sp, #4]
 801c486:	9b00      	ldr	r3, [sp, #0]
 801c488:	3322      	adds	r3, #34	@ 0x22
 801c48a:	009b      	lsls	r3, r3, #2
 801c48c:	4413      	add	r3, r2
 801c48e:	689b      	ldr	r3, [r3, #8]
 801c490:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 801c492:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c494:	9b00      	ldr	r3, [sp, #0]
 801c496:	b2db      	uxtb	r3, r3
 801c498:	4619      	mov	r1, r3
 801c49a:	9801      	ldr	r0, [sp, #4]
 801c49c:	f7fe fd8d 	bl	801afba <USB_OTG_HC_Halt>
    pdev->host.HC_Status[num] = HC_STALL;      
 801c4a0:	9a01      	ldr	r2, [sp, #4]
 801c4a2:	9b00      	ldr	r3, [sp, #0]
 801c4a4:	4413      	add	r3, r2
 801c4a6:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c4aa:	2205      	movs	r2, #5
 801c4ac:	701a      	strb	r2, [r3, #0]
 801c4ae:	e1b7      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  
  else if (hcint.b.nak)
 801c4b0:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c4b4:	f003 0310 	and.w	r3, r3, #16
 801c4b8:	b2db      	uxtb	r3, r3
 801c4ba:	2b00      	cmp	r3, #0
 801c4bc:	d036      	beq.n	801c52c <USB_OTG_USBH_handle_hc_n_Out_ISR+0x274>
  {
    pdev->host.ErrCnt[num] = 0;
 801c4be:	9a01      	ldr	r2, [sp, #4]
 801c4c0:	9b00      	ldr	r3, [sp, #0]
 801c4c2:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c4c6:	009b      	lsls	r3, r3, #2
 801c4c8:	4413      	add	r3, r2
 801c4ca:	2200      	movs	r2, #0
 801c4cc:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c4ce:	9a01      	ldr	r2, [sp, #4]
 801c4d0:	9b00      	ldr	r3, [sp, #0]
 801c4d2:	3322      	adds	r3, #34	@ 0x22
 801c4d4:	009b      	lsls	r3, r3, #2
 801c4d6:	4413      	add	r3, r2
 801c4d8:	689b      	ldr	r3, [r3, #8]
 801c4da:	68db      	ldr	r3, [r3, #12]
 801c4dc:	930c      	str	r3, [sp, #48]	@ 0x30
 801c4de:	f89d 3030 	ldrb.w	r3, [sp, #48]	@ 0x30
 801c4e2:	f043 0302 	orr.w	r3, r3, #2
 801c4e6:	f88d 3030 	strb.w	r3, [sp, #48]	@ 0x30
 801c4ea:	9a01      	ldr	r2, [sp, #4]
 801c4ec:	9b00      	ldr	r3, [sp, #0]
 801c4ee:	3322      	adds	r3, #34	@ 0x22
 801c4f0:	009b      	lsls	r3, r3, #2
 801c4f2:	4413      	add	r3, r2
 801c4f4:	689b      	ldr	r3, [r3, #8]
 801c4f6:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 801c4f8:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c4fa:	9b00      	ldr	r3, [sp, #0]
 801c4fc:	b2db      	uxtb	r3, r3
 801c4fe:	4619      	mov	r1, r3
 801c500:	9801      	ldr	r0, [sp, #4]
 801c502:	f7fe fd5a 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);
 801c506:	2300      	movs	r3, #0
 801c508:	930b      	str	r3, [sp, #44]	@ 0x2c
 801c50a:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 801c50e:	f043 0310 	orr.w	r3, r3, #16
 801c512:	f88d 302c 	strb.w	r3, [sp, #44]	@ 0x2c
 801c516:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 801c518:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c51a:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NAK;      
 801c51c:	9a01      	ldr	r2, [sp, #4]
 801c51e:	9b00      	ldr	r3, [sp, #0]
 801c520:	4413      	add	r3, r2
 801c522:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c526:	2203      	movs	r2, #3
 801c528:	701a      	strb	r2, [r3, #0]
 801c52a:	e179      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  
  else if (hcint.b.xacterr)
 801c52c:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c530:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801c534:	b2db      	uxtb	r3, r3
 801c536:	2b00      	cmp	r3, #0
 801c538:	d03d      	beq.n	801c5b6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x2fe>
  {
    UNMASK_HOST_INT_CHH (num);
 801c53a:	9a01      	ldr	r2, [sp, #4]
 801c53c:	9b00      	ldr	r3, [sp, #0]
 801c53e:	3322      	adds	r3, #34	@ 0x22
 801c540:	009b      	lsls	r3, r3, #2
 801c542:	4413      	add	r3, r2
 801c544:	689b      	ldr	r3, [r3, #8]
 801c546:	68db      	ldr	r3, [r3, #12]
 801c548:	930a      	str	r3, [sp, #40]	@ 0x28
 801c54a:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 801c54e:	f043 0302 	orr.w	r3, r3, #2
 801c552:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
 801c556:	9a01      	ldr	r2, [sp, #4]
 801c558:	9b00      	ldr	r3, [sp, #0]
 801c55a:	3322      	adds	r3, #34	@ 0x22
 801c55c:	009b      	lsls	r3, r3, #2
 801c55e:	4413      	add	r3, r2
 801c560:	689b      	ldr	r3, [r3, #8]
 801c562:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801c564:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c566:	9b00      	ldr	r3, [sp, #0]
 801c568:	b2db      	uxtb	r3, r3
 801c56a:	4619      	mov	r1, r3
 801c56c:	9801      	ldr	r0, [sp, #4]
 801c56e:	f7fe fd24 	bl	801afba <USB_OTG_HC_Halt>
    pdev->host.ErrCnt[num] ++;
 801c572:	9a01      	ldr	r2, [sp, #4]
 801c574:	9b00      	ldr	r3, [sp, #0]
 801c576:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c57a:	009b      	lsls	r3, r3, #2
 801c57c:	4413      	add	r3, r2
 801c57e:	689b      	ldr	r3, [r3, #8]
 801c580:	1c5a      	adds	r2, r3, #1
 801c582:	9901      	ldr	r1, [sp, #4]
 801c584:	9b00      	ldr	r3, [sp, #0]
 801c586:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c58a:	009b      	lsls	r3, r3, #2
 801c58c:	440b      	add	r3, r1
 801c58e:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XACTERR;
 801c590:	9a01      	ldr	r2, [sp, #4]
 801c592:	9b00      	ldr	r3, [sp, #0]
 801c594:	4413      	add	r3, r2
 801c596:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c59a:	2206      	movs	r2, #6
 801c59c:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , xacterr);
 801c59e:	2300      	movs	r3, #0
 801c5a0:	9309      	str	r3, [sp, #36]	@ 0x24
 801c5a2:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 801c5a6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801c5aa:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
 801c5ae:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801c5b0:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c5b2:	609a      	str	r2, [r3, #8]
 801c5b4:	e134      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  else if (hcint.b.nyet)
 801c5b6:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c5ba:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 801c5be:	b2db      	uxtb	r3, r3
 801c5c0:	2b00      	cmp	r3, #0
 801c5c2:	d036      	beq.n	801c632 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x37a>
  {
    pdev->host.ErrCnt[num] = 0;
 801c5c4:	9a01      	ldr	r2, [sp, #4]
 801c5c6:	9b00      	ldr	r3, [sp, #0]
 801c5c8:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c5cc:	009b      	lsls	r3, r3, #2
 801c5ce:	4413      	add	r3, r2
 801c5d0:	2200      	movs	r2, #0
 801c5d2:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c5d4:	9a01      	ldr	r2, [sp, #4]
 801c5d6:	9b00      	ldr	r3, [sp, #0]
 801c5d8:	3322      	adds	r3, #34	@ 0x22
 801c5da:	009b      	lsls	r3, r3, #2
 801c5dc:	4413      	add	r3, r2
 801c5de:	689b      	ldr	r3, [r3, #8]
 801c5e0:	68db      	ldr	r3, [r3, #12]
 801c5e2:	9308      	str	r3, [sp, #32]
 801c5e4:	f89d 3020 	ldrb.w	r3, [sp, #32]
 801c5e8:	f043 0302 	orr.w	r3, r3, #2
 801c5ec:	f88d 3020 	strb.w	r3, [sp, #32]
 801c5f0:	9a01      	ldr	r2, [sp, #4]
 801c5f2:	9b00      	ldr	r3, [sp, #0]
 801c5f4:	3322      	adds	r3, #34	@ 0x22
 801c5f6:	009b      	lsls	r3, r3, #2
 801c5f8:	4413      	add	r3, r2
 801c5fa:	689b      	ldr	r3, [r3, #8]
 801c5fc:	9a08      	ldr	r2, [sp, #32]
 801c5fe:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c600:	9b00      	ldr	r3, [sp, #0]
 801c602:	b2db      	uxtb	r3, r3
 801c604:	4619      	mov	r1, r3
 801c606:	9801      	ldr	r0, [sp, #4]
 801c608:	f7fe fcd7 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nyet);
 801c60c:	2300      	movs	r3, #0
 801c60e:	9307      	str	r3, [sp, #28]
 801c610:	f89d 301c 	ldrb.w	r3, [sp, #28]
 801c614:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801c618:	f88d 301c 	strb.w	r3, [sp, #28]
 801c61c:	9a07      	ldr	r2, [sp, #28]
 801c61e:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c620:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_NYET;    
 801c622:	9a01      	ldr	r2, [sp, #4]
 801c624:	9b00      	ldr	r3, [sp, #0]
 801c626:	4413      	add	r3, r2
 801c628:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c62c:	2204      	movs	r2, #4
 801c62e:	701a      	strb	r2, [r3, #0]
 801c630:	e0f6      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }
  else if (hcint.b.datatglerr)
 801c632:	f89d 3061 	ldrb.w	r3, [sp, #97]	@ 0x61
 801c636:	f003 0304 	and.w	r3, r3, #4
 801c63a:	b2db      	uxtb	r3, r3
 801c63c:	2b00      	cmp	r3, #0
 801c63e:	d039      	beq.n	801c6b4 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x3fc>
  {
    
    UNMASK_HOST_INT_CHH (num);
 801c640:	9a01      	ldr	r2, [sp, #4]
 801c642:	9b00      	ldr	r3, [sp, #0]
 801c644:	3322      	adds	r3, #34	@ 0x22
 801c646:	009b      	lsls	r3, r3, #2
 801c648:	4413      	add	r3, r2
 801c64a:	689b      	ldr	r3, [r3, #8]
 801c64c:	68db      	ldr	r3, [r3, #12]
 801c64e:	9306      	str	r3, [sp, #24]
 801c650:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801c654:	f043 0302 	orr.w	r3, r3, #2
 801c658:	f88d 3018 	strb.w	r3, [sp, #24]
 801c65c:	9a01      	ldr	r2, [sp, #4]
 801c65e:	9b00      	ldr	r3, [sp, #0]
 801c660:	3322      	adds	r3, #34	@ 0x22
 801c662:	009b      	lsls	r3, r3, #2
 801c664:	4413      	add	r3, r2
 801c666:	689b      	ldr	r3, [r3, #8]
 801c668:	9a06      	ldr	r2, [sp, #24]
 801c66a:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c66c:	9b00      	ldr	r3, [sp, #0]
 801c66e:	b2db      	uxtb	r3, r3
 801c670:	4619      	mov	r1, r3
 801c672:	9801      	ldr	r0, [sp, #4]
 801c674:	f7fe fca1 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 801c678:	2300      	movs	r3, #0
 801c67a:	9305      	str	r3, [sp, #20]
 801c67c:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801c680:	f043 0310 	orr.w	r3, r3, #16
 801c684:	f88d 3014 	strb.w	r3, [sp, #20]
 801c688:	9a05      	ldr	r2, [sp, #20]
 801c68a:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c68c:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR;
 801c68e:	9a01      	ldr	r2, [sp, #4]
 801c690:	9b00      	ldr	r3, [sp, #0]
 801c692:	4413      	add	r3, r2
 801c694:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c698:	2208      	movs	r2, #8
 801c69a:	701a      	strb	r2, [r3, #0]
    
    CLEAR_HC_INT(hcreg , datatglerr);
 801c69c:	2300      	movs	r3, #0
 801c69e:	9304      	str	r3, [sp, #16]
 801c6a0:	f89d 3011 	ldrb.w	r3, [sp, #17]
 801c6a4:	f043 0304 	orr.w	r3, r3, #4
 801c6a8:	f88d 3011 	strb.w	r3, [sp, #17]
 801c6ac:	9a04      	ldr	r2, [sp, #16]
 801c6ae:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c6b0:	609a      	str	r2, [r3, #8]
 801c6b2:	e0b5      	b.n	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  }  
  else if (hcint.b.chhltd)
 801c6b4:	f89d 3060 	ldrb.w	r3, [sp, #96]	@ 0x60
 801c6b8:	f003 0302 	and.w	r3, r3, #2
 801c6bc:	b2db      	uxtb	r3, r3
 801c6be:	2b00      	cmp	r3, #0
 801c6c0:	f000 80ae 	beq.w	801c820 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x568>
  {
    MASK_HOST_INT_CHH (num);
 801c6c4:	9a01      	ldr	r2, [sp, #4]
 801c6c6:	9b00      	ldr	r3, [sp, #0]
 801c6c8:	3322      	adds	r3, #34	@ 0x22
 801c6ca:	009b      	lsls	r3, r3, #2
 801c6cc:	4413      	add	r3, r2
 801c6ce:	689b      	ldr	r3, [r3, #8]
 801c6d0:	68db      	ldr	r3, [r3, #12]
 801c6d2:	9303      	str	r3, [sp, #12]
 801c6d4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801c6d8:	f36f 0341 	bfc	r3, #1, #1
 801c6dc:	f88d 300c 	strb.w	r3, [sp, #12]
 801c6e0:	9a01      	ldr	r2, [sp, #4]
 801c6e2:	9b00      	ldr	r3, [sp, #0]
 801c6e4:	3322      	adds	r3, #34	@ 0x22
 801c6e6:	009b      	lsls	r3, r3, #2
 801c6e8:	4413      	add	r3, r2
 801c6ea:	689b      	ldr	r3, [r3, #8]
 801c6ec:	9a03      	ldr	r2, [sp, #12]
 801c6ee:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 801c6f0:	9a01      	ldr	r2, [sp, #4]
 801c6f2:	9b00      	ldr	r3, [sp, #0]
 801c6f4:	4413      	add	r3, r2
 801c6f6:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c6fa:	781b      	ldrb	r3, [r3, #0]
 801c6fc:	b2db      	uxtb	r3, r3
 801c6fe:	2b01      	cmp	r3, #1
 801c700:	d120      	bne.n	801c744 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x48c>
    {
      pdev->host.URB_State[num] = URB_DONE;  
 801c702:	9a01      	ldr	r2, [sp, #4]
 801c704:	9b00      	ldr	r3, [sp, #0]
 801c706:	4413      	add	r3, r2
 801c708:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801c70c:	2201      	movs	r2, #1
 801c70e:	701a      	strb	r2, [r3, #0]
      
      if (hcchar.b.eptype == EP_TYPE_BULK)
 801c710:	f89d 305a 	ldrb.w	r3, [sp, #90]	@ 0x5a
 801c714:	f003 030c 	and.w	r3, r3, #12
 801c718:	b2db      	uxtb	r3, r3
 801c71a:	2b08      	cmp	r3, #8
 801c71c:	d175      	bne.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
      {
        pdev->host.hc[num].toggle_out ^= 1; 
 801c71e:	9a01      	ldr	r2, [sp, #4]
 801c720:	9b00      	ldr	r3, [sp, #0]
 801c722:	3345      	adds	r3, #69	@ 0x45
 801c724:	015b      	lsls	r3, r3, #5
 801c726:	4413      	add	r3, r2
 801c728:	3309      	adds	r3, #9
 801c72a:	781b      	ldrb	r3, [r3, #0]
 801c72c:	f083 0301 	eor.w	r3, r3, #1
 801c730:	b2d9      	uxtb	r1, r3
 801c732:	9a01      	ldr	r2, [sp, #4]
 801c734:	9b00      	ldr	r3, [sp, #0]
 801c736:	3345      	adds	r3, #69	@ 0x45
 801c738:	015b      	lsls	r3, r3, #5
 801c73a:	4413      	add	r3, r2
 801c73c:	3309      	adds	r3, #9
 801c73e:	460a      	mov	r2, r1
 801c740:	701a      	strb	r2, [r3, #0]
 801c742:	e062      	b.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
      }
    }
    else if(pdev->host.HC_Status[num] == HC_NAK)
 801c744:	9a01      	ldr	r2, [sp, #4]
 801c746:	9b00      	ldr	r3, [sp, #0]
 801c748:	4413      	add	r3, r2
 801c74a:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c74e:	781b      	ldrb	r3, [r3, #0]
 801c750:	b2db      	uxtb	r3, r3
 801c752:	2b03      	cmp	r3, #3
 801c754:	d107      	bne.n	801c766 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4ae>
    {
      pdev->host.URB_State[num] = URB_NOTREADY;      
 801c756:	9a01      	ldr	r2, [sp, #4]
 801c758:	9b00      	ldr	r3, [sp, #0]
 801c75a:	4413      	add	r3, r2
 801c75c:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801c760:	2202      	movs	r2, #2
 801c762:	701a      	strb	r2, [r3, #0]
 801c764:	e051      	b.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
    }    
    else if(pdev->host.HC_Status[num] == HC_NYET)
 801c766:	9a01      	ldr	r2, [sp, #4]
 801c768:	9b00      	ldr	r3, [sp, #0]
 801c76a:	4413      	add	r3, r2
 801c76c:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c770:	781b      	ldrb	r3, [r3, #0]
 801c772:	b2db      	uxtb	r3, r3
 801c774:	2b04      	cmp	r3, #4
 801c776:	d116      	bne.n	801c7a6 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4ee>
    {
      if(pdev->host.hc[num].do_ping == 1)
 801c778:	9a01      	ldr	r2, [sp, #4]
 801c77a:	9b00      	ldr	r3, [sp, #0]
 801c77c:	015b      	lsls	r3, r3, #5
 801c77e:	4413      	add	r3, r2
 801c780:	f603 0394 	addw	r3, r3, #2196	@ 0x894
 801c784:	781b      	ldrb	r3, [r3, #0]
 801c786:	2b01      	cmp	r3, #1
 801c788:	d105      	bne.n	801c796 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x4de>
      {
        USB_OTG_HC_DoPing(pdev, num);
 801c78a:	9b00      	ldr	r3, [sp, #0]
 801c78c:	b2db      	uxtb	r3, r3
 801c78e:	4619      	mov	r1, r3
 801c790:	9801      	ldr	r0, [sp, #4]
 801c792:	f7fe fc2f 	bl	801aff4 <USB_OTG_HC_DoPing>
      }
      pdev->host.URB_State[num] = URB_NOTREADY;      
 801c796:	9a01      	ldr	r2, [sp, #4]
 801c798:	9b00      	ldr	r3, [sp, #0]
 801c79a:	4413      	add	r3, r2
 801c79c:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801c7a0:	2202      	movs	r2, #2
 801c7a2:	701a      	strb	r2, [r3, #0]
 801c7a4:	e031      	b.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
    }      
    else if(pdev->host.HC_Status[num] == HC_STALL)
 801c7a6:	9a01      	ldr	r2, [sp, #4]
 801c7a8:	9b00      	ldr	r3, [sp, #0]
 801c7aa:	4413      	add	r3, r2
 801c7ac:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c7b0:	781b      	ldrb	r3, [r3, #0]
 801c7b2:	b2db      	uxtb	r3, r3
 801c7b4:	2b05      	cmp	r3, #5
 801c7b6:	d107      	bne.n	801c7c8 <USB_OTG_USBH_handle_hc_n_Out_ISR+0x510>
    {
      pdev->host.URB_State[num] = URB_STALL;      
 801c7b8:	9a01      	ldr	r2, [sp, #4]
 801c7ba:	9b00      	ldr	r3, [sp, #0]
 801c7bc:	4413      	add	r3, r2
 801c7be:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801c7c2:	2204      	movs	r2, #4
 801c7c4:	701a      	strb	r2, [r3, #0]
 801c7c6:	e020      	b.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
    }  
    else if(pdev->host.HC_Status[num] == HC_XACTERR)
 801c7c8:	9a01      	ldr	r2, [sp, #4]
 801c7ca:	9b00      	ldr	r3, [sp, #0]
 801c7cc:	4413      	add	r3, r2
 801c7ce:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c7d2:	781b      	ldrb	r3, [r3, #0]
 801c7d4:	b2db      	uxtb	r3, r3
 801c7d6:	2b06      	cmp	r3, #6
 801c7d8:	d117      	bne.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
    {
      if (pdev->host.ErrCnt[num] == 3)
 801c7da:	9a01      	ldr	r2, [sp, #4]
 801c7dc:	9b00      	ldr	r3, [sp, #0]
 801c7de:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c7e2:	009b      	lsls	r3, r3, #2
 801c7e4:	4413      	add	r3, r2
 801c7e6:	689b      	ldr	r3, [r3, #8]
 801c7e8:	2b03      	cmp	r3, #3
 801c7ea:	d10e      	bne.n	801c80a <USB_OTG_USBH_handle_hc_n_Out_ISR+0x552>
      {
        pdev->host.URB_State[num] = URB_ERROR;  
 801c7ec:	9a01      	ldr	r2, [sp, #4]
 801c7ee:	9b00      	ldr	r3, [sp, #0]
 801c7f0:	4413      	add	r3, r2
 801c7f2:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801c7f6:	2203      	movs	r2, #3
 801c7f8:	701a      	strb	r2, [r3, #0]
        pdev->host.ErrCnt[num] = 0;
 801c7fa:	9a01      	ldr	r2, [sp, #4]
 801c7fc:	9b00      	ldr	r3, [sp, #0]
 801c7fe:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801c802:	009b      	lsls	r3, r3, #2
 801c804:	4413      	add	r3, r2
 801c806:	2200      	movs	r2, #0
 801c808:	609a      	str	r2, [r3, #8]
      }
    }
    CLEAR_HC_INT(hcreg , chhltd);    
 801c80a:	2300      	movs	r3, #0
 801c80c:	9302      	str	r3, [sp, #8]
 801c80e:	f89d 3008 	ldrb.w	r3, [sp, #8]
 801c812:	f043 0302 	orr.w	r3, r3, #2
 801c816:	f88d 3008 	strb.w	r3, [sp, #8]
 801c81a:	9a02      	ldr	r2, [sp, #8]
 801c81c:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c81e:	609a      	str	r2, [r3, #8]
  }
  
  
  return 1;
 801c820:	2301      	movs	r3, #1
}
 801c822:	4618      	mov	r0, r3
 801c824:	b01b      	add	sp, #108	@ 0x6c
 801c826:	f85d fb04 	ldr.w	pc, [sp], #4

0801c82a <USB_OTG_USBH_handle_hc_n_In_ISR>:
* @param  pdev: Selected device
* @param  hc_num: Channel number
* @retval status 
*/
uint32_t USB_OTG_USBH_handle_hc_n_In_ISR (USB_OTG_CORE_HANDLE *pdev , uint32_t num)
{
 801c82a:	b500      	push	{lr}
 801c82c:	b09d      	sub	sp, #116	@ 0x74
 801c82e:	9001      	str	r0, [sp, #4]
 801c830:	9100      	str	r1, [sp, #0]
  USB_OTG_HCCHAR_TypeDef     hcchar; 
  USB_OTG_HCTSIZn_TypeDef  hctsiz;
  USB_OTG_HC_REGS *hcreg;
  
  
  hcreg = pdev->regs.HC_REGS[num];
 801c832:	9a01      	ldr	r2, [sp, #4]
 801c834:	9b00      	ldr	r3, [sp, #0]
 801c836:	3322      	adds	r3, #34	@ 0x22
 801c838:	009b      	lsls	r3, r3, #2
 801c83a:	4413      	add	r3, r2
 801c83c:	689b      	ldr	r3, [r3, #8]
 801c83e:	931b      	str	r3, [sp, #108]	@ 0x6c
  hcint.d32 = USB_OTG_READ_REG32(&hcreg->HCINT);
 801c840:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c842:	689b      	ldr	r3, [r3, #8]
 801c844:	931a      	str	r3, [sp, #104]	@ 0x68
  hcintmsk.d32 = USB_OTG_READ_REG32(&hcreg->HCINTMSK);
 801c846:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c848:	68db      	ldr	r3, [r3, #12]
 801c84a:	9319      	str	r3, [sp, #100]	@ 0x64
  hcint.d32 = hcint.d32 & hcintmsk.d32;
 801c84c:	9a1a      	ldr	r2, [sp, #104]	@ 0x68
 801c84e:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 801c850:	4013      	ands	r3, r2
 801c852:	931a      	str	r3, [sp, #104]	@ 0x68
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCCHAR);
 801c854:	9a01      	ldr	r2, [sp, #4]
 801c856:	9b00      	ldr	r3, [sp, #0]
 801c858:	3322      	adds	r3, #34	@ 0x22
 801c85a:	009b      	lsls	r3, r3, #2
 801c85c:	4413      	add	r3, r2
 801c85e:	689b      	ldr	r3, [r3, #8]
 801c860:	681b      	ldr	r3, [r3, #0]
 801c862:	9318      	str	r3, [sp, #96]	@ 0x60
  hcintmsk.d32 = 0;
 801c864:	2300      	movs	r3, #0
 801c866:	9319      	str	r3, [sp, #100]	@ 0x64
  
  
  if (hcint.b.ahberr)
 801c868:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801c86c:	f003 0304 	and.w	r3, r3, #4
 801c870:	b2db      	uxtb	r3, r3
 801c872:	2b00      	cmp	r3, #0
 801c874:	d021      	beq.n	801c8ba <USB_OTG_USBH_handle_hc_n_In_ISR+0x90>
  {
    CLEAR_HC_INT(hcreg ,ahberr);
 801c876:	2300      	movs	r3, #0
 801c878:	9316      	str	r3, [sp, #88]	@ 0x58
 801c87a:	f89d 3058 	ldrb.w	r3, [sp, #88]	@ 0x58
 801c87e:	f043 0304 	orr.w	r3, r3, #4
 801c882:	f88d 3058 	strb.w	r3, [sp, #88]	@ 0x58
 801c886:	9a16      	ldr	r2, [sp, #88]	@ 0x58
 801c888:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c88a:	609a      	str	r2, [r3, #8]
    UNMASK_HOST_INT_CHH (num);
 801c88c:	9a01      	ldr	r2, [sp, #4]
 801c88e:	9b00      	ldr	r3, [sp, #0]
 801c890:	3322      	adds	r3, #34	@ 0x22
 801c892:	009b      	lsls	r3, r3, #2
 801c894:	4413      	add	r3, r2
 801c896:	689b      	ldr	r3, [r3, #8]
 801c898:	68db      	ldr	r3, [r3, #12]
 801c89a:	9315      	str	r3, [sp, #84]	@ 0x54
 801c89c:	f89d 3054 	ldrb.w	r3, [sp, #84]	@ 0x54
 801c8a0:	f043 0302 	orr.w	r3, r3, #2
 801c8a4:	f88d 3054 	strb.w	r3, [sp, #84]	@ 0x54
 801c8a8:	9a01      	ldr	r2, [sp, #4]
 801c8aa:	9b00      	ldr	r3, [sp, #0]
 801c8ac:	3322      	adds	r3, #34	@ 0x22
 801c8ae:	009b      	lsls	r3, r3, #2
 801c8b0:	4413      	add	r3, r2
 801c8b2:	689b      	ldr	r3, [r3, #8]
 801c8b4:	9a15      	ldr	r2, [sp, #84]	@ 0x54
 801c8b6:	60da      	str	r2, [r3, #12]
 801c8b8:	e099      	b.n	801c9ee <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c4>
  }  
  else if (hcint.b.ack)
 801c8ba:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801c8be:	f003 0320 	and.w	r3, r3, #32
 801c8c2:	b2db      	uxtb	r3, r3
 801c8c4:	2b00      	cmp	r3, #0
 801c8c6:	d00b      	beq.n	801c8e0 <USB_OTG_USBH_handle_hc_n_In_ISR+0xb6>
  {
    CLEAR_HC_INT(hcreg ,ack);
 801c8c8:	2300      	movs	r3, #0
 801c8ca:	9314      	str	r3, [sp, #80]	@ 0x50
 801c8cc:	f89d 3050 	ldrb.w	r3, [sp, #80]	@ 0x50
 801c8d0:	f043 0320 	orr.w	r3, r3, #32
 801c8d4:	f88d 3050 	strb.w	r3, [sp, #80]	@ 0x50
 801c8d8:	9a14      	ldr	r2, [sp, #80]	@ 0x50
 801c8da:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c8dc:	609a      	str	r2, [r3, #8]
 801c8de:	e086      	b.n	801c9ee <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c4>
  }
  
  else if (hcint.b.stall)  
 801c8e0:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801c8e4:	f003 0308 	and.w	r3, r3, #8
 801c8e8:	b2db      	uxtb	r3, r3
 801c8ea:	2b00      	cmp	r3, #0
 801c8ec:	d03f      	beq.n	801c96e <USB_OTG_USBH_handle_hc_n_In_ISR+0x144>
  {
    UNMASK_HOST_INT_CHH (num);
 801c8ee:	9a01      	ldr	r2, [sp, #4]
 801c8f0:	9b00      	ldr	r3, [sp, #0]
 801c8f2:	3322      	adds	r3, #34	@ 0x22
 801c8f4:	009b      	lsls	r3, r3, #2
 801c8f6:	4413      	add	r3, r2
 801c8f8:	689b      	ldr	r3, [r3, #8]
 801c8fa:	68db      	ldr	r3, [r3, #12]
 801c8fc:	9313      	str	r3, [sp, #76]	@ 0x4c
 801c8fe:	f89d 304c 	ldrb.w	r3, [sp, #76]	@ 0x4c
 801c902:	f043 0302 	orr.w	r3, r3, #2
 801c906:	f88d 304c 	strb.w	r3, [sp, #76]	@ 0x4c
 801c90a:	9a01      	ldr	r2, [sp, #4]
 801c90c:	9b00      	ldr	r3, [sp, #0]
 801c90e:	3322      	adds	r3, #34	@ 0x22
 801c910:	009b      	lsls	r3, r3, #2
 801c912:	4413      	add	r3, r2
 801c914:	689b      	ldr	r3, [r3, #8]
 801c916:	9a13      	ldr	r2, [sp, #76]	@ 0x4c
 801c918:	60da      	str	r2, [r3, #12]
    pdev->host.HC_Status[num] = HC_STALL; 
 801c91a:	9a01      	ldr	r2, [sp, #4]
 801c91c:	9b00      	ldr	r3, [sp, #0]
 801c91e:	4413      	add	r3, r2
 801c920:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c924:	2205      	movs	r2, #5
 801c926:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , nak);   /* Clear the NAK Condition */
 801c928:	2300      	movs	r3, #0
 801c92a:	9312      	str	r3, [sp, #72]	@ 0x48
 801c92c:	f89d 3048 	ldrb.w	r3, [sp, #72]	@ 0x48
 801c930:	f043 0310 	orr.w	r3, r3, #16
 801c934:	f88d 3048 	strb.w	r3, [sp, #72]	@ 0x48
 801c938:	9a12      	ldr	r2, [sp, #72]	@ 0x48
 801c93a:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c93c:	609a      	str	r2, [r3, #8]
    CLEAR_HC_INT(hcreg , stall); /* Clear the STALL Condition */
 801c93e:	2300      	movs	r3, #0
 801c940:	9311      	str	r3, [sp, #68]	@ 0x44
 801c942:	f89d 3044 	ldrb.w	r3, [sp, #68]	@ 0x44
 801c946:	f043 0308 	orr.w	r3, r3, #8
 801c94a:	f88d 3044 	strb.w	r3, [sp, #68]	@ 0x44
 801c94e:	9a11      	ldr	r2, [sp, #68]	@ 0x44
 801c950:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c952:	609a      	str	r2, [r3, #8]
    hcint.b.nak = 0;           /* NOTE: When there is a 'stall', reset also nak, 
 801c954:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801c958:	f36f 1304 	bfc	r3, #4, #1
 801c95c:	f88d 3068 	strb.w	r3, [sp, #104]	@ 0x68
                                  else, the pdev->host.HC_Status = HC_STALL
    will be overwritten by 'nak' in code below */
    USB_OTG_HC_Halt(pdev, num);    
 801c960:	9b00      	ldr	r3, [sp, #0]
 801c962:	b2db      	uxtb	r3, r3
 801c964:	4619      	mov	r1, r3
 801c966:	9801      	ldr	r0, [sp, #4]
 801c968:	f7fe fb27 	bl	801afba <USB_OTG_HC_Halt>
 801c96c:	e03f      	b.n	801c9ee <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c4>
  }
  else if (hcint.b.datatglerr)
 801c96e:	f89d 3069 	ldrb.w	r3, [sp, #105]	@ 0x69
 801c972:	f003 0304 	and.w	r3, r3, #4
 801c976:	b2db      	uxtb	r3, r3
 801c978:	2b00      	cmp	r3, #0
 801c97a:	d038      	beq.n	801c9ee <USB_OTG_USBH_handle_hc_n_In_ISR+0x1c4>
  {
    
    UNMASK_HOST_INT_CHH (num);
 801c97c:	9a01      	ldr	r2, [sp, #4]
 801c97e:	9b00      	ldr	r3, [sp, #0]
 801c980:	3322      	adds	r3, #34	@ 0x22
 801c982:	009b      	lsls	r3, r3, #2
 801c984:	4413      	add	r3, r2
 801c986:	689b      	ldr	r3, [r3, #8]
 801c988:	68db      	ldr	r3, [r3, #12]
 801c98a:	9310      	str	r3, [sp, #64]	@ 0x40
 801c98c:	f89d 3040 	ldrb.w	r3, [sp, #64]	@ 0x40
 801c990:	f043 0302 	orr.w	r3, r3, #2
 801c994:	f88d 3040 	strb.w	r3, [sp, #64]	@ 0x40
 801c998:	9a01      	ldr	r2, [sp, #4]
 801c99a:	9b00      	ldr	r3, [sp, #0]
 801c99c:	3322      	adds	r3, #34	@ 0x22
 801c99e:	009b      	lsls	r3, r3, #2
 801c9a0:	4413      	add	r3, r2
 801c9a2:	689b      	ldr	r3, [r3, #8]
 801c9a4:	9a10      	ldr	r2, [sp, #64]	@ 0x40
 801c9a6:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801c9a8:	9b00      	ldr	r3, [sp, #0]
 801c9aa:	b2db      	uxtb	r3, r3
 801c9ac:	4619      	mov	r1, r3
 801c9ae:	9801      	ldr	r0, [sp, #4]
 801c9b0:	f7fe fb03 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , nak);   
 801c9b4:	2300      	movs	r3, #0
 801c9b6:	930f      	str	r3, [sp, #60]	@ 0x3c
 801c9b8:	f89d 303c 	ldrb.w	r3, [sp, #60]	@ 0x3c
 801c9bc:	f043 0310 	orr.w	r3, r3, #16
 801c9c0:	f88d 303c 	strb.w	r3, [sp, #60]	@ 0x3c
 801c9c4:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 801c9c6:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c9c8:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_DATATGLERR; 
 801c9ca:	9a01      	ldr	r2, [sp, #4]
 801c9cc:	9b00      	ldr	r3, [sp, #0]
 801c9ce:	4413      	add	r3, r2
 801c9d0:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801c9d4:	2208      	movs	r2, #8
 801c9d6:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , datatglerr);
 801c9d8:	2300      	movs	r3, #0
 801c9da:	930e      	str	r3, [sp, #56]	@ 0x38
 801c9dc:	f89d 3039 	ldrb.w	r3, [sp, #57]	@ 0x39
 801c9e0:	f043 0304 	orr.w	r3, r3, #4
 801c9e4:	f88d 3039 	strb.w	r3, [sp, #57]	@ 0x39
 801c9e8:	9a0e      	ldr	r2, [sp, #56]	@ 0x38
 801c9ea:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801c9ec:	609a      	str	r2, [r3, #8]
  }    
  
  if (hcint.b.frmovrun)
 801c9ee:	f89d 3069 	ldrb.w	r3, [sp, #105]	@ 0x69
 801c9f2:	f003 0302 	and.w	r3, r3, #2
 801c9f6:	b2db      	uxtb	r3, r3
 801c9f8:	2b00      	cmp	r3, #0
 801c9fa:	d027      	beq.n	801ca4c <USB_OTG_USBH_handle_hc_n_In_ISR+0x222>
  {
    UNMASK_HOST_INT_CHH (num);
 801c9fc:	9a01      	ldr	r2, [sp, #4]
 801c9fe:	9b00      	ldr	r3, [sp, #0]
 801ca00:	3322      	adds	r3, #34	@ 0x22
 801ca02:	009b      	lsls	r3, r3, #2
 801ca04:	4413      	add	r3, r2
 801ca06:	689b      	ldr	r3, [r3, #8]
 801ca08:	68db      	ldr	r3, [r3, #12]
 801ca0a:	930d      	str	r3, [sp, #52]	@ 0x34
 801ca0c:	f89d 3034 	ldrb.w	r3, [sp, #52]	@ 0x34
 801ca10:	f043 0302 	orr.w	r3, r3, #2
 801ca14:	f88d 3034 	strb.w	r3, [sp, #52]	@ 0x34
 801ca18:	9a01      	ldr	r2, [sp, #4]
 801ca1a:	9b00      	ldr	r3, [sp, #0]
 801ca1c:	3322      	adds	r3, #34	@ 0x22
 801ca1e:	009b      	lsls	r3, r3, #2
 801ca20:	4413      	add	r3, r2
 801ca22:	689b      	ldr	r3, [r3, #8]
 801ca24:	9a0d      	ldr	r2, [sp, #52]	@ 0x34
 801ca26:	60da      	str	r2, [r3, #12]
    USB_OTG_HC_Halt(pdev, num);
 801ca28:	9b00      	ldr	r3, [sp, #0]
 801ca2a:	b2db      	uxtb	r3, r3
 801ca2c:	4619      	mov	r1, r3
 801ca2e:	9801      	ldr	r0, [sp, #4]
 801ca30:	f7fe fac3 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg ,frmovrun);
 801ca34:	2300      	movs	r3, #0
 801ca36:	930c      	str	r3, [sp, #48]	@ 0x30
 801ca38:	f89d 3031 	ldrb.w	r3, [sp, #49]	@ 0x31
 801ca3c:	f043 0302 	orr.w	r3, r3, #2
 801ca40:	f88d 3031 	strb.w	r3, [sp, #49]	@ 0x31
 801ca44:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 801ca46:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801ca48:	609a      	str	r2, [r3, #8]
 801ca4a:	e1cf      	b.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
  }
  
  else if (hcint.b.xfercompl)
 801ca4c:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801ca50:	f003 0301 	and.w	r3, r3, #1
 801ca54:	b2db      	uxtb	r3, r3
 801ca56:	2b00      	cmp	r3, #0
 801ca58:	f000 809e 	beq.w	801cb98 <USB_OTG_USBH_handle_hc_n_In_ISR+0x36e>
  {
    
    if (pdev->cfg.dma_enable == 1)
 801ca5c:	9b01      	ldr	r3, [sp, #4]
 801ca5e:	78db      	ldrb	r3, [r3, #3]
 801ca60:	2b01      	cmp	r3, #1
 801ca62:	d119      	bne.n	801ca98 <USB_OTG_USBH_handle_hc_n_In_ISR+0x26e>
    {
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[num]->HCTSIZ);
 801ca64:	9a01      	ldr	r2, [sp, #4]
 801ca66:	9b00      	ldr	r3, [sp, #0]
 801ca68:	3322      	adds	r3, #34	@ 0x22
 801ca6a:	009b      	lsls	r3, r3, #2
 801ca6c:	4413      	add	r3, r2
 801ca6e:	689b      	ldr	r3, [r3, #8]
 801ca70:	691b      	ldr	r3, [r3, #16]
 801ca72:	9317      	str	r3, [sp, #92]	@ 0x5c
      pdev->host.XferCnt[num] =  pdev->host.hc[num].xfer_len - hctsiz.b.xfersize;
 801ca74:	9a01      	ldr	r2, [sp, #4]
 801ca76:	9b00      	ldr	r3, [sp, #0]
 801ca78:	015b      	lsls	r3, r3, #5
 801ca7a:	4413      	add	r3, r2
 801ca7c:	f503 630a 	add.w	r3, r3, #2208	@ 0x8a0
 801ca80:	681b      	ldr	r3, [r3, #0]
 801ca82:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 801ca84:	f3c2 0212 	ubfx	r2, r2, #0, #19
 801ca88:	1a9a      	subs	r2, r3, r2
 801ca8a:	9901      	ldr	r1, [sp, #4]
 801ca8c:	9b00      	ldr	r3, [sp, #0]
 801ca8e:	f503 7303 	add.w	r3, r3, #524	@ 0x20c
 801ca92:	009b      	lsls	r3, r3, #2
 801ca94:	440b      	add	r3, r1
 801ca96:	605a      	str	r2, [r3, #4]
    }
    
    pdev->host.HC_Status[num] = HC_XFRC;     
 801ca98:	9a01      	ldr	r2, [sp, #4]
 801ca9a:	9b00      	ldr	r3, [sp, #0]
 801ca9c:	4413      	add	r3, r2
 801ca9e:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801caa2:	2201      	movs	r2, #1
 801caa4:	701a      	strb	r2, [r3, #0]
    pdev->host.ErrCnt [num]= 0;
 801caa6:	9a01      	ldr	r2, [sp, #4]
 801caa8:	9b00      	ldr	r3, [sp, #0]
 801caaa:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801caae:	009b      	lsls	r3, r3, #2
 801cab0:	4413      	add	r3, r2
 801cab2:	2200      	movs	r2, #0
 801cab4:	609a      	str	r2, [r3, #8]
    CLEAR_HC_INT(hcreg , xfercompl);
 801cab6:	2300      	movs	r3, #0
 801cab8:	930b      	str	r3, [sp, #44]	@ 0x2c
 801caba:	f89d 302c 	ldrb.w	r3, [sp, #44]	@ 0x2c
 801cabe:	f043 0301 	orr.w	r3, r3, #1
 801cac2:	f88d 302c 	strb.w	r3, [sp, #44]	@ 0x2c
 801cac6:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 801cac8:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801caca:	609a      	str	r2, [r3, #8]
    
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 801cacc:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cad0:	f003 030c 	and.w	r3, r3, #12
 801cad4:	b2db      	uxtb	r3, r3
 801cad6:	2b00      	cmp	r3, #0
 801cad8:	d006      	beq.n	801cae8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x2be>
        (hcchar.b.eptype == EP_TYPE_BULK))
 801cada:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cade:	f003 030c 	and.w	r3, r3, #12
 801cae2:	b2db      	uxtb	r3, r3
    if ((hcchar.b.eptype == EP_TYPE_CTRL)||
 801cae4:	2b08      	cmp	r3, #8
 801cae6:	d139      	bne.n	801cb5c <USB_OTG_USBH_handle_hc_n_In_ISR+0x332>
    {
      UNMASK_HOST_INT_CHH (num);
 801cae8:	9a01      	ldr	r2, [sp, #4]
 801caea:	9b00      	ldr	r3, [sp, #0]
 801caec:	3322      	adds	r3, #34	@ 0x22
 801caee:	009b      	lsls	r3, r3, #2
 801caf0:	4413      	add	r3, r2
 801caf2:	689b      	ldr	r3, [r3, #8]
 801caf4:	68db      	ldr	r3, [r3, #12]
 801caf6:	930a      	str	r3, [sp, #40]	@ 0x28
 801caf8:	f89d 3028 	ldrb.w	r3, [sp, #40]	@ 0x28
 801cafc:	f043 0302 	orr.w	r3, r3, #2
 801cb00:	f88d 3028 	strb.w	r3, [sp, #40]	@ 0x28
 801cb04:	9a01      	ldr	r2, [sp, #4]
 801cb06:	9b00      	ldr	r3, [sp, #0]
 801cb08:	3322      	adds	r3, #34	@ 0x22
 801cb0a:	009b      	lsls	r3, r3, #2
 801cb0c:	4413      	add	r3, r2
 801cb0e:	689b      	ldr	r3, [r3, #8]
 801cb10:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801cb12:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 801cb14:	9b00      	ldr	r3, [sp, #0]
 801cb16:	b2db      	uxtb	r3, r3
 801cb18:	4619      	mov	r1, r3
 801cb1a:	9801      	ldr	r0, [sp, #4]
 801cb1c:	f7fe fa4d 	bl	801afba <USB_OTG_HC_Halt>
      CLEAR_HC_INT(hcreg , nak); 
 801cb20:	2300      	movs	r3, #0
 801cb22:	9309      	str	r3, [sp, #36]	@ 0x24
 801cb24:	f89d 3024 	ldrb.w	r3, [sp, #36]	@ 0x24
 801cb28:	f043 0310 	orr.w	r3, r3, #16
 801cb2c:	f88d 3024 	strb.w	r3, [sp, #36]	@ 0x24
 801cb30:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 801cb32:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801cb34:	609a      	str	r2, [r3, #8]
      pdev->host.hc[num].toggle_in ^= 1;
 801cb36:	9a01      	ldr	r2, [sp, #4]
 801cb38:	9b00      	ldr	r3, [sp, #0]
 801cb3a:	3345      	adds	r3, #69	@ 0x45
 801cb3c:	015b      	lsls	r3, r3, #5
 801cb3e:	4413      	add	r3, r2
 801cb40:	3308      	adds	r3, #8
 801cb42:	781b      	ldrb	r3, [r3, #0]
 801cb44:	f083 0301 	eor.w	r3, r3, #1
 801cb48:	b2d9      	uxtb	r1, r3
 801cb4a:	9a01      	ldr	r2, [sp, #4]
 801cb4c:	9b00      	ldr	r3, [sp, #0]
 801cb4e:	3345      	adds	r3, #69	@ 0x45
 801cb50:	015b      	lsls	r3, r3, #5
 801cb52:	4413      	add	r3, r2
 801cb54:	3308      	adds	r3, #8
 801cb56:	460a      	mov	r2, r1
 801cb58:	701a      	strb	r2, [r3, #0]
 801cb5a:	e147      	b.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
      
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 801cb5c:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cb60:	f003 030c 	and.w	r3, r3, #12
 801cb64:	b2db      	uxtb	r3, r3
 801cb66:	2b0c      	cmp	r3, #12
 801cb68:	f040 8140 	bne.w	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
    {
      hcchar.b.oddfrm  = 1;
 801cb6c:	f89d 3063 	ldrb.w	r3, [sp, #99]	@ 0x63
 801cb70:	f043 0320 	orr.w	r3, r3, #32
 801cb74:	f88d 3063 	strb.w	r3, [sp, #99]	@ 0x63
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 801cb78:	9a01      	ldr	r2, [sp, #4]
 801cb7a:	9b00      	ldr	r3, [sp, #0]
 801cb7c:	3322      	adds	r3, #34	@ 0x22
 801cb7e:	009b      	lsls	r3, r3, #2
 801cb80:	4413      	add	r3, r2
 801cb82:	689b      	ldr	r3, [r3, #8]
 801cb84:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 801cb86:	601a      	str	r2, [r3, #0]
      pdev->host.URB_State[num] = URB_DONE;  
 801cb88:	9a01      	ldr	r2, [sp, #4]
 801cb8a:	9b00      	ldr	r3, [sp, #0]
 801cb8c:	4413      	add	r3, r2
 801cb8e:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801cb92:	2201      	movs	r2, #1
 801cb94:	701a      	strb	r2, [r3, #0]
 801cb96:	e129      	b.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
    }
    
  }
  else if (hcint.b.chhltd)
 801cb98:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801cb9c:	f003 0302 	and.w	r3, r3, #2
 801cba0:	b2db      	uxtb	r3, r3
 801cba2:	2b00      	cmp	r3, #0
 801cba4:	d07e      	beq.n	801cca4 <USB_OTG_USBH_handle_hc_n_In_ISR+0x47a>
  {
    MASK_HOST_INT_CHH (num);
 801cba6:	9a01      	ldr	r2, [sp, #4]
 801cba8:	9b00      	ldr	r3, [sp, #0]
 801cbaa:	3322      	adds	r3, #34	@ 0x22
 801cbac:	009b      	lsls	r3, r3, #2
 801cbae:	4413      	add	r3, r2
 801cbb0:	689b      	ldr	r3, [r3, #8]
 801cbb2:	68db      	ldr	r3, [r3, #12]
 801cbb4:	9308      	str	r3, [sp, #32]
 801cbb6:	f89d 3020 	ldrb.w	r3, [sp, #32]
 801cbba:	f36f 0341 	bfc	r3, #1, #1
 801cbbe:	f88d 3020 	strb.w	r3, [sp, #32]
 801cbc2:	9a01      	ldr	r2, [sp, #4]
 801cbc4:	9b00      	ldr	r3, [sp, #0]
 801cbc6:	3322      	adds	r3, #34	@ 0x22
 801cbc8:	009b      	lsls	r3, r3, #2
 801cbca:	4413      	add	r3, r2
 801cbcc:	689b      	ldr	r3, [r3, #8]
 801cbce:	9a08      	ldr	r2, [sp, #32]
 801cbd0:	60da      	str	r2, [r3, #12]
    
    if(pdev->host.HC_Status[num] == HC_XFRC)
 801cbd2:	9a01      	ldr	r2, [sp, #4]
 801cbd4:	9b00      	ldr	r3, [sp, #0]
 801cbd6:	4413      	add	r3, r2
 801cbd8:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cbdc:	781b      	ldrb	r3, [r3, #0]
 801cbde:	b2db      	uxtb	r3, r3
 801cbe0:	2b01      	cmp	r3, #1
 801cbe2:	d107      	bne.n	801cbf4 <USB_OTG_USBH_handle_hc_n_In_ISR+0x3ca>
    {
      pdev->host.URB_State[num] = URB_DONE;      
 801cbe4:	9a01      	ldr	r2, [sp, #4]
 801cbe6:	9b00      	ldr	r3, [sp, #0]
 801cbe8:	4413      	add	r3, r2
 801cbea:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801cbee:	2201      	movs	r2, #1
 801cbf0:	701a      	strb	r2, [r3, #0]
 801cbf2:	e04b      	b.n	801cc8c <USB_OTG_USBH_handle_hc_n_In_ISR+0x462>
    }
    
    else if (pdev->host.HC_Status[num] == HC_STALL) 
 801cbf4:	9a01      	ldr	r2, [sp, #4]
 801cbf6:	9b00      	ldr	r3, [sp, #0]
 801cbf8:	4413      	add	r3, r2
 801cbfa:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cbfe:	781b      	ldrb	r3, [r3, #0]
 801cc00:	b2db      	uxtb	r3, r3
 801cc02:	2b05      	cmp	r3, #5
 801cc04:	d107      	bne.n	801cc16 <USB_OTG_USBH_handle_hc_n_In_ISR+0x3ec>
    {
      pdev->host.URB_State[num] = URB_STALL;
 801cc06:	9a01      	ldr	r2, [sp, #4]
 801cc08:	9b00      	ldr	r3, [sp, #0]
 801cc0a:	4413      	add	r3, r2
 801cc0c:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801cc10:	2204      	movs	r2, #4
 801cc12:	701a      	strb	r2, [r3, #0]
 801cc14:	e03a      	b.n	801cc8c <USB_OTG_USBH_handle_hc_n_In_ISR+0x462>
    }   
    
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 801cc16:	9a01      	ldr	r2, [sp, #4]
 801cc18:	9b00      	ldr	r3, [sp, #0]
 801cc1a:	4413      	add	r3, r2
 801cc1c:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cc20:	781b      	ldrb	r3, [r3, #0]
 801cc22:	b2db      	uxtb	r3, r3
 801cc24:	2b06      	cmp	r3, #6
 801cc26:	d008      	beq.n	801cc3a <USB_OTG_USBH_handle_hc_n_In_ISR+0x410>
            (pdev->host.HC_Status[num] == HC_DATATGLERR))
 801cc28:	9a01      	ldr	r2, [sp, #4]
 801cc2a:	9b00      	ldr	r3, [sp, #0]
 801cc2c:	4413      	add	r3, r2
 801cc2e:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cc32:	781b      	ldrb	r3, [r3, #0]
 801cc34:	b2db      	uxtb	r3, r3
    else if((pdev->host.HC_Status[num] == HC_XACTERR) ||
 801cc36:	2b08      	cmp	r3, #8
 801cc38:	d10f      	bne.n	801cc5a <USB_OTG_USBH_handle_hc_n_In_ISR+0x430>
    {
      pdev->host.ErrCnt[num] = 0;
 801cc3a:	9a01      	ldr	r2, [sp, #4]
 801cc3c:	9b00      	ldr	r3, [sp, #0]
 801cc3e:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801cc42:	009b      	lsls	r3, r3, #2
 801cc44:	4413      	add	r3, r2
 801cc46:	2200      	movs	r2, #0
 801cc48:	609a      	str	r2, [r3, #8]
      pdev->host.URB_State[num] = URB_ERROR;  
 801cc4a:	9a01      	ldr	r2, [sp, #4]
 801cc4c:	9b00      	ldr	r3, [sp, #0]
 801cc4e:	4413      	add	r3, r2
 801cc50:	f603 037f 	addw	r3, r3, #2175	@ 0x87f
 801cc54:	2203      	movs	r2, #3
 801cc56:	701a      	strb	r2, [r3, #0]
 801cc58:	e018      	b.n	801cc8c <USB_OTG_USBH_handle_hc_n_In_ISR+0x462>
      
    }
    else if(hcchar.b.eptype == EP_TYPE_INTR)
 801cc5a:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cc5e:	f003 030c 	and.w	r3, r3, #12
 801cc62:	b2db      	uxtb	r3, r3
 801cc64:	2b0c      	cmp	r3, #12
 801cc66:	d111      	bne.n	801cc8c <USB_OTG_USBH_handle_hc_n_In_ISR+0x462>
    {
      pdev->host.hc[num].toggle_in ^= 1;
 801cc68:	9a01      	ldr	r2, [sp, #4]
 801cc6a:	9b00      	ldr	r3, [sp, #0]
 801cc6c:	3345      	adds	r3, #69	@ 0x45
 801cc6e:	015b      	lsls	r3, r3, #5
 801cc70:	4413      	add	r3, r2
 801cc72:	3308      	adds	r3, #8
 801cc74:	781b      	ldrb	r3, [r3, #0]
 801cc76:	f083 0301 	eor.w	r3, r3, #1
 801cc7a:	b2d9      	uxtb	r1, r3
 801cc7c:	9a01      	ldr	r2, [sp, #4]
 801cc7e:	9b00      	ldr	r3, [sp, #0]
 801cc80:	3345      	adds	r3, #69	@ 0x45
 801cc82:	015b      	lsls	r3, r3, #5
 801cc84:	4413      	add	r3, r2
 801cc86:	3308      	adds	r3, #8
 801cc88:	460a      	mov	r2, r1
 801cc8a:	701a      	strb	r2, [r3, #0]
    }
    
    CLEAR_HC_INT(hcreg , chhltd);    
 801cc8c:	2300      	movs	r3, #0
 801cc8e:	9307      	str	r3, [sp, #28]
 801cc90:	f89d 301c 	ldrb.w	r3, [sp, #28]
 801cc94:	f043 0302 	orr.w	r3, r3, #2
 801cc98:	f88d 301c 	strb.w	r3, [sp, #28]
 801cc9c:	9a07      	ldr	r2, [sp, #28]
 801cc9e:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801cca0:	609a      	str	r2, [r3, #8]
 801cca2:	e0a3      	b.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
    
  }    
  else if (hcint.b.xacterr)
 801cca4:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801cca8:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 801ccac:	b2db      	uxtb	r3, r3
 801ccae:	2b00      	cmp	r3, #0
 801ccb0:	d03d      	beq.n	801cd2e <USB_OTG_USBH_handle_hc_n_In_ISR+0x504>
  {
    UNMASK_HOST_INT_CHH (num);
 801ccb2:	9a01      	ldr	r2, [sp, #4]
 801ccb4:	9b00      	ldr	r3, [sp, #0]
 801ccb6:	3322      	adds	r3, #34	@ 0x22
 801ccb8:	009b      	lsls	r3, r3, #2
 801ccba:	4413      	add	r3, r2
 801ccbc:	689b      	ldr	r3, [r3, #8]
 801ccbe:	68db      	ldr	r3, [r3, #12]
 801ccc0:	9306      	str	r3, [sp, #24]
 801ccc2:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801ccc6:	f043 0302 	orr.w	r3, r3, #2
 801ccca:	f88d 3018 	strb.w	r3, [sp, #24]
 801ccce:	9a01      	ldr	r2, [sp, #4]
 801ccd0:	9b00      	ldr	r3, [sp, #0]
 801ccd2:	3322      	adds	r3, #34	@ 0x22
 801ccd4:	009b      	lsls	r3, r3, #2
 801ccd6:	4413      	add	r3, r2
 801ccd8:	689b      	ldr	r3, [r3, #8]
 801ccda:	9a06      	ldr	r2, [sp, #24]
 801ccdc:	60da      	str	r2, [r3, #12]
    pdev->host.ErrCnt[num] ++;
 801ccde:	9a01      	ldr	r2, [sp, #4]
 801cce0:	9b00      	ldr	r3, [sp, #0]
 801cce2:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801cce6:	009b      	lsls	r3, r3, #2
 801cce8:	4413      	add	r3, r2
 801ccea:	689b      	ldr	r3, [r3, #8]
 801ccec:	1c5a      	adds	r2, r3, #1
 801ccee:	9901      	ldr	r1, [sp, #4]
 801ccf0:	9b00      	ldr	r3, [sp, #0]
 801ccf2:	f503 73fe 	add.w	r3, r3, #508	@ 0x1fc
 801ccf6:	009b      	lsls	r3, r3, #2
 801ccf8:	440b      	add	r3, r1
 801ccfa:	609a      	str	r2, [r3, #8]
    pdev->host.HC_Status[num] = HC_XACTERR;
 801ccfc:	9a01      	ldr	r2, [sp, #4]
 801ccfe:	9b00      	ldr	r3, [sp, #0]
 801cd00:	4413      	add	r3, r2
 801cd02:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cd06:	2206      	movs	r2, #6
 801cd08:	701a      	strb	r2, [r3, #0]
    USB_OTG_HC_Halt(pdev, num);
 801cd0a:	9b00      	ldr	r3, [sp, #0]
 801cd0c:	b2db      	uxtb	r3, r3
 801cd0e:	4619      	mov	r1, r3
 801cd10:	9801      	ldr	r0, [sp, #4]
 801cd12:	f7fe f952 	bl	801afba <USB_OTG_HC_Halt>
    CLEAR_HC_INT(hcreg , xacterr);    
 801cd16:	2300      	movs	r3, #0
 801cd18:	9305      	str	r3, [sp, #20]
 801cd1a:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801cd1e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801cd22:	f88d 3014 	strb.w	r3, [sp, #20]
 801cd26:	9a05      	ldr	r2, [sp, #20]
 801cd28:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801cd2a:	609a      	str	r2, [r3, #8]
 801cd2c:	e05e      	b.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
    
  }
  else if (hcint.b.nak)  
 801cd2e:	f89d 3068 	ldrb.w	r3, [sp, #104]	@ 0x68
 801cd32:	f003 0310 	and.w	r3, r3, #16
 801cd36:	b2db      	uxtb	r3, r3
 801cd38:	2b00      	cmp	r3, #0
 801cd3a:	d057      	beq.n	801cdec <USB_OTG_USBH_handle_hc_n_In_ISR+0x5c2>
  {  
    if(hcchar.b.eptype == EP_TYPE_INTR)
 801cd3c:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cd40:	f003 030c 	and.w	r3, r3, #12
 801cd44:	b2db      	uxtb	r3, r3
 801cd46:	2b0c      	cmp	r3, #12
 801cd48:	d11c      	bne.n	801cd84 <USB_OTG_USBH_handle_hc_n_In_ISR+0x55a>
    {
      UNMASK_HOST_INT_CHH (num);
 801cd4a:	9a01      	ldr	r2, [sp, #4]
 801cd4c:	9b00      	ldr	r3, [sp, #0]
 801cd4e:	3322      	adds	r3, #34	@ 0x22
 801cd50:	009b      	lsls	r3, r3, #2
 801cd52:	4413      	add	r3, r2
 801cd54:	689b      	ldr	r3, [r3, #8]
 801cd56:	68db      	ldr	r3, [r3, #12]
 801cd58:	9304      	str	r3, [sp, #16]
 801cd5a:	f89d 3010 	ldrb.w	r3, [sp, #16]
 801cd5e:	f043 0302 	orr.w	r3, r3, #2
 801cd62:	f88d 3010 	strb.w	r3, [sp, #16]
 801cd66:	9a01      	ldr	r2, [sp, #4]
 801cd68:	9b00      	ldr	r3, [sp, #0]
 801cd6a:	3322      	adds	r3, #34	@ 0x22
 801cd6c:	009b      	lsls	r3, r3, #2
 801cd6e:	4413      	add	r3, r2
 801cd70:	689b      	ldr	r3, [r3, #8]
 801cd72:	9a04      	ldr	r2, [sp, #16]
 801cd74:	60da      	str	r2, [r3, #12]
      USB_OTG_HC_Halt(pdev, num);
 801cd76:	9b00      	ldr	r3, [sp, #0]
 801cd78:	b2db      	uxtb	r3, r3
 801cd7a:	4619      	mov	r1, r3
 801cd7c:	9801      	ldr	r0, [sp, #4]
 801cd7e:	f7fe f91c 	bl	801afba <USB_OTG_HC_Halt>
 801cd82:	e021      	b.n	801cdc8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x59e>
    }
    else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 801cd84:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cd88:	f003 030c 	and.w	r3, r3, #12
 801cd8c:	b2db      	uxtb	r3, r3
 801cd8e:	2b00      	cmp	r3, #0
 801cd90:	d006      	beq.n	801cda0 <USB_OTG_USBH_handle_hc_n_In_ISR+0x576>
              (hcchar.b.eptype == EP_TYPE_BULK))
 801cd92:	f89d 3062 	ldrb.w	r3, [sp, #98]	@ 0x62
 801cd96:	f003 030c 	and.w	r3, r3, #12
 801cd9a:	b2db      	uxtb	r3, r3
    else if  ((hcchar.b.eptype == EP_TYPE_CTRL)||
 801cd9c:	2b08      	cmp	r3, #8
 801cd9e:	d113      	bne.n	801cdc8 <USB_OTG_USBH_handle_hc_n_In_ISR+0x59e>
    {
      /* re-activate the channel  */
      hcchar.b.chen = 1;
 801cda0:	f89d 3063 	ldrb.w	r3, [sp, #99]	@ 0x63
 801cda4:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801cda8:	f88d 3063 	strb.w	r3, [sp, #99]	@ 0x63
      hcchar.b.chdis = 0;
 801cdac:	f89d 3063 	ldrb.w	r3, [sp, #99]	@ 0x63
 801cdb0:	f36f 1386 	bfc	r3, #6, #1
 801cdb4:	f88d 3063 	strb.w	r3, [sp, #99]	@ 0x63
      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[num]->HCCHAR, hcchar.d32); 
 801cdb8:	9a01      	ldr	r2, [sp, #4]
 801cdba:	9b00      	ldr	r3, [sp, #0]
 801cdbc:	3322      	adds	r3, #34	@ 0x22
 801cdbe:	009b      	lsls	r3, r3, #2
 801cdc0:	4413      	add	r3, r2
 801cdc2:	689b      	ldr	r3, [r3, #8]
 801cdc4:	9a18      	ldr	r2, [sp, #96]	@ 0x60
 801cdc6:	601a      	str	r2, [r3, #0]
    }
    pdev->host.HC_Status[num] = HC_NAK;
 801cdc8:	9a01      	ldr	r2, [sp, #4]
 801cdca:	9b00      	ldr	r3, [sp, #0]
 801cdcc:	4413      	add	r3, r2
 801cdce:	f503 6307 	add.w	r3, r3, #2160	@ 0x870
 801cdd2:	2203      	movs	r2, #3
 801cdd4:	701a      	strb	r2, [r3, #0]
    CLEAR_HC_INT(hcreg , nak);   
 801cdd6:	2300      	movs	r3, #0
 801cdd8:	9303      	str	r3, [sp, #12]
 801cdda:	f89d 300c 	ldrb.w	r3, [sp, #12]
 801cdde:	f043 0310 	orr.w	r3, r3, #16
 801cde2:	f88d 300c 	strb.w	r3, [sp, #12]
 801cde6:	9a03      	ldr	r2, [sp, #12]
 801cde8:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 801cdea:	609a      	str	r2, [r3, #8]
  }
  
  
  return 1;
 801cdec:	2301      	movs	r3, #1
  
}
 801cdee:	4618      	mov	r0, r3
 801cdf0:	b01d      	add	sp, #116	@ 0x74
 801cdf2:	f85d fb04 	ldr.w	pc, [sp], #4

0801cdf6 <USB_OTG_USBH_handle_rx_qlvl_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_rx_qlvl_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801cdf6:	b500      	push	{lr}
 801cdf8:	b089      	sub	sp, #36	@ 0x24
 801cdfa:	9001      	str	r0, [sp, #4]
  USB_OTG_GRXFSTS_TypeDef       grxsts;
  USB_OTG_GINTMSK_TypeDef       intmsk;
  USB_OTG_HCTSIZn_TypeDef       hctsiz; 
  USB_OTG_HCCHAR_TypeDef        hcchar;
  __IO uint8_t                  channelnum =0;  
 801cdfc:	2300      	movs	r3, #0
 801cdfe:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t                      count;    
  
  /* Disable the Rx Status Queue Level interrupt */
  intmsk.d32 = 0;
 801ce02:	2300      	movs	r3, #0
 801ce04:	9305      	str	r3, [sp, #20]
  intmsk.b.rxstsqlvl = 1;
 801ce06:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801ce0a:	f043 0310 	orr.w	r3, r3, #16
 801ce0e:	f88d 3014 	strb.w	r3, [sp, #20]
  USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, intmsk.d32, 0);
 801ce12:	9b01      	ldr	r3, [sp, #4]
 801ce14:	68db      	ldr	r3, [r3, #12]
 801ce16:	6999      	ldr	r1, [r3, #24]
 801ce18:	9b05      	ldr	r3, [sp, #20]
 801ce1a:	43da      	mvns	r2, r3
 801ce1c:	9b01      	ldr	r3, [sp, #4]
 801ce1e:	68db      	ldr	r3, [r3, #12]
 801ce20:	400a      	ands	r2, r1
 801ce22:	619a      	str	r2, [r3, #24]
  
  grxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRXSTSP);
 801ce24:	9b01      	ldr	r3, [sp, #4]
 801ce26:	68db      	ldr	r3, [r3, #12]
 801ce28:	6a1b      	ldr	r3, [r3, #32]
 801ce2a:	9306      	str	r3, [sp, #24]
  channelnum = grxsts.b.chnum;  
 801ce2c:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801ce30:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801ce34:	b2db      	uxtb	r3, r3
 801ce36:	f88d 300b 	strb.w	r3, [sp, #11]
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR);
 801ce3a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801ce3e:	b2db      	uxtb	r3, r3
 801ce40:	9a01      	ldr	r2, [sp, #4]
 801ce42:	3322      	adds	r3, #34	@ 0x22
 801ce44:	009b      	lsls	r3, r3, #2
 801ce46:	4413      	add	r3, r2
 801ce48:	689b      	ldr	r3, [r3, #8]
 801ce4a:	681b      	ldr	r3, [r3, #0]
 801ce4c:	9303      	str	r3, [sp, #12]
  
  switch (grxsts.b.pktsts)
 801ce4e:	f89d 301a 	ldrb.w	r3, [sp, #26]
 801ce52:	f3c3 0343 	ubfx	r3, r3, #1, #4
 801ce56:	b2db      	uxtb	r3, r3
 801ce58:	2b02      	cmp	r3, #2
 801ce5a:	f040 80a5 	bne.w	801cfa8 <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b2>
  {
  case GRXSTS_PKTSTS_IN:
    /* Read the data into the host buffer. */
    if ((grxsts.b.bcnt > 0) && (pdev->host.hc[channelnum].xfer_buff != (void  *)0))
 801ce5e:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 801ce62:	f647 73f0 	movw	r3, #32752	@ 0x7ff0
 801ce66:	4013      	ands	r3, r2
 801ce68:	b29b      	uxth	r3, r3
 801ce6a:	2b00      	cmp	r3, #0
 801ce6c:	f000 809e 	beq.w	801cfac <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b6>
 801ce70:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801ce74:	b2db      	uxtb	r3, r3
 801ce76:	9a01      	ldr	r2, [sp, #4]
 801ce78:	3315      	adds	r3, #21
 801ce7a:	015b      	lsls	r3, r3, #5
 801ce7c:	4413      	add	r3, r2
 801ce7e:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801ce82:	681b      	ldr	r3, [r3, #0]
 801ce84:	2b00      	cmp	r3, #0
 801ce86:	f000 8091 	beq.w	801cfac <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b6>
    {  
      
      USB_OTG_ReadPacket(pdev, pdev->host.hc[channelnum].xfer_buff, grxsts.b.bcnt);
 801ce8a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801ce8e:	b2db      	uxtb	r3, r3
 801ce90:	9a01      	ldr	r2, [sp, #4]
 801ce92:	3315      	adds	r3, #21
 801ce94:	015b      	lsls	r3, r3, #5
 801ce96:	4413      	add	r3, r2
 801ce98:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801ce9c:	6819      	ldr	r1, [r3, #0]
 801ce9e:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 801cea2:	f3c3 130a 	ubfx	r3, r3, #4, #11
 801cea6:	b29b      	uxth	r3, r3
 801cea8:	461a      	mov	r2, r3
 801ceaa:	9801      	ldr	r0, [sp, #4]
 801ceac:	f7fd fda3 	bl	801a9f6 <USB_OTG_ReadPacket>
      /*manage multiple Xfer */
      pdev->host.hc[grxsts.b.chnum].xfer_buff += grxsts.b.bcnt;           
 801ceb0:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801ceb4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801ceb8:	b2db      	uxtb	r3, r3
 801ceba:	9a01      	ldr	r2, [sp, #4]
 801cebc:	3315      	adds	r3, #21
 801cebe:	015b      	lsls	r3, r3, #5
 801cec0:	4413      	add	r3, r2
 801cec2:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801cec6:	681b      	ldr	r3, [r3, #0]
 801cec8:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 801cecc:	f3c2 120a 	ubfx	r2, r2, #4, #11
 801ced0:	b292      	uxth	r2, r2
 801ced2:	4611      	mov	r1, r2
 801ced4:	f89d 2018 	ldrb.w	r2, [sp, #24]
 801ced8:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801cedc:	b2d2      	uxtb	r2, r2
 801cede:	4610      	mov	r0, r2
 801cee0:	185a      	adds	r2, r3, r1
 801cee2:	9901      	ldr	r1, [sp, #4]
 801cee4:	f100 0315 	add.w	r3, r0, #21
 801cee8:	015b      	lsls	r3, r3, #5
 801ceea:	440b      	add	r3, r1
 801ceec:	f203 53fc 	addw	r3, r3, #1532	@ 0x5fc
 801cef0:	601a      	str	r2, [r3, #0]
      pdev->host.hc[grxsts.b.chnum].xfer_count  += grxsts.b.bcnt;
 801cef2:	f89d 3018 	ldrb.w	r3, [sp, #24]
 801cef6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801cefa:	b2db      	uxtb	r3, r3
 801cefc:	9a01      	ldr	r2, [sp, #4]
 801cefe:	015b      	lsls	r3, r3, #5
 801cf00:	4413      	add	r3, r2
 801cf02:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801cf06:	681b      	ldr	r3, [r3, #0]
 801cf08:	f8bd 2018 	ldrh.w	r2, [sp, #24]
 801cf0c:	f3c2 120a 	ubfx	r2, r2, #4, #11
 801cf10:	b292      	uxth	r2, r2
 801cf12:	4611      	mov	r1, r2
 801cf14:	f89d 2018 	ldrb.w	r2, [sp, #24]
 801cf18:	f3c2 0203 	ubfx	r2, r2, #0, #4
 801cf1c:	b2d2      	uxtb	r2, r2
 801cf1e:	4610      	mov	r0, r2
 801cf20:	185a      	adds	r2, r3, r1
 801cf22:	9901      	ldr	r1, [sp, #4]
 801cf24:	0143      	lsls	r3, r0, #5
 801cf26:	440b      	add	r3, r1
 801cf28:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801cf2c:	601a      	str	r2, [r3, #0]
      
      
      count = pdev->host.hc[channelnum].xfer_count;
 801cf2e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cf32:	b2db      	uxtb	r3, r3
 801cf34:	9a01      	ldr	r2, [sp, #4]
 801cf36:	015b      	lsls	r3, r3, #5
 801cf38:	4413      	add	r3, r2
 801cf3a:	f603 03a4 	addw	r3, r3, #2212	@ 0x8a4
 801cf3e:	681b      	ldr	r3, [r3, #0]
 801cf40:	9307      	str	r3, [sp, #28]
      pdev->host.XferCnt[channelnum]  = count;
 801cf42:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cf46:	b2db      	uxtb	r3, r3
 801cf48:	9a01      	ldr	r2, [sp, #4]
 801cf4a:	f503 7303 	add.w	r3, r3, #524	@ 0x20c
 801cf4e:	009b      	lsls	r3, r3, #2
 801cf50:	4413      	add	r3, r2
 801cf52:	9a07      	ldr	r2, [sp, #28]
 801cf54:	605a      	str	r2, [r3, #4]
      
      hctsiz.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[channelnum]->HCTSIZ);
 801cf56:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cf5a:	b2db      	uxtb	r3, r3
 801cf5c:	9a01      	ldr	r2, [sp, #4]
 801cf5e:	3322      	adds	r3, #34	@ 0x22
 801cf60:	009b      	lsls	r3, r3, #2
 801cf62:	4413      	add	r3, r2
 801cf64:	689b      	ldr	r3, [r3, #8]
 801cf66:	691b      	ldr	r3, [r3, #16]
 801cf68:	9304      	str	r3, [sp, #16]
      if(hctsiz.b.pktcnt > 0)
 801cf6a:	f8bd 2012 	ldrh.w	r2, [sp, #18]
 801cf6e:	f641 73f8 	movw	r3, #8184	@ 0x1ff8
 801cf72:	4013      	ands	r3, r2
 801cf74:	b29b      	uxth	r3, r3
 801cf76:	2b00      	cmp	r3, #0
 801cf78:	d018      	beq.n	801cfac <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b6>
      {
        /* re-activate the channel when more packets are expected */
        hcchar.b.chen = 1;
 801cf7a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801cf7e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801cf82:	f88d 300f 	strb.w	r3, [sp, #15]
        hcchar.b.chdis = 0;
 801cf86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801cf8a:	f36f 1386 	bfc	r3, #6, #1
 801cf8e:	f88d 300f 	strb.w	r3, [sp, #15]
        USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[channelnum]->HCCHAR, hcchar.d32);
 801cf92:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cf96:	b2db      	uxtb	r3, r3
 801cf98:	9a01      	ldr	r2, [sp, #4]
 801cf9a:	3322      	adds	r3, #34	@ 0x22
 801cf9c:	009b      	lsls	r3, r3, #2
 801cf9e:	4413      	add	r3, r2
 801cfa0:	689b      	ldr	r3, [r3, #8]
 801cfa2:	9a03      	ldr	r2, [sp, #12]
 801cfa4:	601a      	str	r2, [r3, #0]
      }
    }
    break;
 801cfa6:	e001      	b.n	801cfac <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b6>
  case GRXSTS_PKTSTS_IN_XFER_COMP:
    
  case GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
  case GRXSTS_PKTSTS_CH_HALTED:
  default:
    break;
 801cfa8:	bf00      	nop
 801cfaa:	e000      	b.n	801cfae <USB_OTG_USBH_handle_rx_qlvl_ISR+0x1b8>
    break;
 801cfac:	bf00      	nop
  }
  
  /* Enable the Rx Status Queue Level interrupt */
  intmsk.b.rxstsqlvl = 1;
 801cfae:	f89d 3014 	ldrb.w	r3, [sp, #20]
 801cfb2:	f043 0310 	orr.w	r3, r3, #16
 801cfb6:	f88d 3014 	strb.w	r3, [sp, #20]
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);
 801cfba:	9b01      	ldr	r3, [sp, #4]
 801cfbc:	68db      	ldr	r3, [r3, #12]
 801cfbe:	6999      	ldr	r1, [r3, #24]
 801cfc0:	9a05      	ldr	r2, [sp, #20]
 801cfc2:	9b01      	ldr	r3, [sp, #4]
 801cfc4:	68db      	ldr	r3, [r3, #12]
 801cfc6:	430a      	orrs	r2, r1
 801cfc8:	619a      	str	r2, [r3, #24]
  return 1;
 801cfca:	2301      	movs	r3, #1
}
 801cfcc:	4618      	mov	r0, r3
 801cfce:	b009      	add	sp, #36	@ 0x24
 801cfd0:	f85d fb04 	ldr.w	pc, [sp], #4

0801cfd4 <USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR>:
*/
#if defined ( __ICCARM__ ) /*!< IAR Compiler */
#pragma optimize = none
#endif /* __CC_ARM */
static uint32_t USB_OTG_USBH_handle_IncompletePeriodicXfer_ISR (USB_OTG_CORE_HANDLE *pdev)
{
 801cfd4:	b084      	sub	sp, #16
 801cfd6:	9001      	str	r0, [sp, #4]
  USB_OTG_HCCHAR_TypeDef        hcchar; 
  
  
  
  
  hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[0]->HCCHAR);
 801cfd8:	9b01      	ldr	r3, [sp, #4]
 801cfda:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801cfde:	681b      	ldr	r3, [r3, #0]
 801cfe0:	9302      	str	r3, [sp, #8]
  hcchar.b.chen = 1;
 801cfe2:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cfe6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801cfea:	f88d 300b 	strb.w	r3, [sp, #11]
  hcchar.b.chdis = 1;
 801cfee:	f89d 300b 	ldrb.w	r3, [sp, #11]
 801cff2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801cff6:	f88d 300b 	strb.w	r3, [sp, #11]
  USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[0]->HCCHAR, hcchar.d32);  
 801cffa:	9b01      	ldr	r3, [sp, #4]
 801cffc:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 801d000:	9a02      	ldr	r2, [sp, #8]
 801d002:	601a      	str	r2, [r3, #0]
  
  gintsts.d32 = 0;
 801d004:	2300      	movs	r3, #0
 801d006:	9303      	str	r3, [sp, #12]
  /* Clear interrupt */
  gintsts.b.incomplisoout = 1;
 801d008:	f89d 300e 	ldrb.w	r3, [sp, #14]
 801d00c:	f043 0320 	orr.w	r3, r3, #32
 801d010:	f88d 300e 	strb.w	r3, [sp, #14]
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801d014:	9b01      	ldr	r3, [sp, #4]
 801d016:	68db      	ldr	r3, [r3, #12]
 801d018:	9a03      	ldr	r2, [sp, #12]
 801d01a:	615a      	str	r2, [r3, #20]
  
  return 1;
 801d01c:	2301      	movs	r3, #1
}
 801d01e:	4618      	mov	r0, r3
 801d020:	b004      	add	sp, #16
 801d022:	4770      	bx	lr

0801d024 <STM32_USBO_OTG_ISR_Handler>:
  /* OTG interrupts */
  gintmsk_common.b.sessreqintr = 1;
  gintmsk_common.b.conidstschng = 1;
  gintmsk_common.b.otgintr = 1;
  
  gintsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 801d024:	68c2      	ldr	r2, [r0, #12]
{
 801d026:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  gintsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
 801d02a:	6955      	ldr	r5, [r2, #20]
  gintmsk.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
 801d02c:	6993      	ldr	r3, [r2, #24]
  return ((gintsts.d32 & gintmsk.d32 ) & gintmsk_common.d32);
 801d02e:	401d      	ands	r5, r3
 801d030:	4b3d      	ldr	r3, [pc, #244]	@ (801d128 <STM32_USBO_OTG_ISR_Handler+0x104>)
  if (gintsts.d32 == 0)
 801d032:	401d      	ands	r5, r3
{
 801d034:	4604      	mov	r4, r0
  if (gintsts.d32 == 0)
 801d036:	d074      	beq.n	801d122 <STM32_USBO_OTG_ISR_Handler+0xfe>
  if (gintsts.b.otgintr)
 801d038:	f015 03ff 	ands.w	r3, r5, #255	@ 0xff
 801d03c:	d065      	beq.n	801d10a <STM32_USBO_OTG_ISR_Handler+0xe6>
  
  
  gotgint.d32 = 0;
  gotgctl.d32 = 0;
  
  gotgint.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGINT);
 801d03e:	6856      	ldr	r6, [r2, #4]
  gotgctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGCTL);
 801d040:	6813      	ldr	r3, [r2, #0]
  
  if (gotgint.b.sesenddet)
 801d042:	0771      	lsls	r1, r6, #29
  gotgint.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGINT);
 801d044:	4637      	mov	r7, r6
  if (gotgint.b.sesenddet)
 801d046:	d506      	bpl.n	801d056 <STM32_USBO_OTG_ISR_Handler+0x32>
  {
    gotgctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGCTL);
 801d048:	6813      	ldr	r3, [r2, #0]
    
    
    if (USB_OTG_IsDeviceMode(pdev))
 801d04a:	f7fd fdf7 	bl	801ac3c <USB_OTG_IsDeviceMode>
 801d04e:	b910      	cbnz	r0, 801d056 <STM32_USBO_OTG_ISR_Handler+0x32>
    {

    }
    else if (USB_OTG_IsHostMode(pdev))
 801d050:	4620      	mov	r0, r4
 801d052:	f7fd fdf9 	bl	801ac48 <USB_OTG_IsHostMode>

    }
  }

  /* ----> SRP SUCCESS or FAILURE INTERRUPT <---- */
  if (gotgint.b.sesreqsucstschng)
 801d056:	05f2      	lsls	r2, r6, #23
 801d058:	f3c6 2807 	ubfx	r8, r6, #8, #8
 801d05c:	d50b      	bpl.n	801d076 <STM32_USBO_OTG_ISR_Handler+0x52>
  {
    gotgctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGCTL);
 801d05e:	68e3      	ldr	r3, [r4, #12]
 801d060:	681b      	ldr	r3, [r3, #0]
    if (gotgctl.b.sesreqscs) /* Session request success                                          */
 801d062:	07db      	lsls	r3, r3, #31
    {
      if (USB_OTG_IsDeviceMode(pdev))
 801d064:	4620      	mov	r0, r4
    if (gotgctl.b.sesreqscs) /* Session request success                                          */
 801d066:	d54d      	bpl.n	801d104 <STM32_USBO_OTG_ISR_Handler+0xe0>
      if (USB_OTG_IsDeviceMode(pdev))
 801d068:	f7fd fde8 	bl	801ac3c <USB_OTG_IsDeviceMode>

      }
      /* Clear Session Request */
      gotgctl.d32 = 0;
      gotgctl.b.sesreq = 1;
      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
 801d06c:	68e2      	ldr	r2, [r4, #12]
 801d06e:	6813      	ldr	r3, [r2, #0]
 801d070:	f023 0302 	bic.w	r3, r3, #2
 801d074:	6013      	str	r3, [r2, #0]

      }
    }
  }
  /* ----> HNP SUCCESS or FAILURE INTERRUPT <---- */
  if (gotgint.b.hstnegsucstschng)
 801d076:	f018 0f02 	tst.w	r8, #2
 801d07a:	d008      	beq.n	801d08e <STM32_USBO_OTG_ISR_Handler+0x6a>
  {
    gotgctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGCTL);
 801d07c:	68e3      	ldr	r3, [r4, #12]
 801d07e:	681b      	ldr	r3, [r3, #0]

    if (gotgctl.b.hstnegscs)                                    /* Host negotiation success                                         */
 801d080:	05df      	lsls	r7, r3, #23
 801d082:	d502      	bpl.n	801d08a <STM32_USBO_OTG_ISR_Handler+0x66>
    {
      if (USB_OTG_IsHostMode(pdev))                              /* The core AUTOMATICALLY sets the Host mode                        */
 801d084:	4620      	mov	r0, r4
 801d086:	f7fd fddf 	bl	801ac48 <USB_OTG_IsHostMode>
    }
    else                                                        /* Host negotiation failure */
    {

    }
    gotgint.b.hstnegsucstschng = 1;                             /* Ack "Host Negotiation Success Status Change" interrupt.          */
 801d08a:	f446 7700 	orr.w	r7, r6, #512	@ 0x200
  }
  /* ----> HOST NEGOTIATION DETECTED INTERRUPT <---- */
  if (gotgint.b.hstnegdet)
 801d08e:	03b0      	lsls	r0, r6, #14
 801d090:	f3c6 4807 	ubfx	r8, r6, #16, #8
 801d094:	d502      	bpl.n	801d09c <STM32_USBO_OTG_ISR_Handler+0x78>
  {
    if (USB_OTG_IsDeviceMode(pdev))                              /* The core AUTOMATICALLY sets the Host mode                        */
 801d096:	4620      	mov	r0, r4
 801d098:	f7fd fdd0 	bl	801ac3c <USB_OTG_IsDeviceMode>

    }
  }
  if (gotgint.b.adevtoutchng)
  {}
  if (gotgint.b.debdone)
 801d09c:	f018 0f08 	tst.w	r8, #8
 801d0a0:	d002      	beq.n	801d0a8 <STM32_USBO_OTG_ISR_Handler+0x84>
  {
    USB_OTG_ResetPort(pdev);
 801d0a2:	4620      	mov	r0, r4
 801d0a4:	f7fd fe2b 	bl	801acfe <USB_OTG_ResetPort>
  }
  /* Clear OTG INT */
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GOTGINT, gotgint.d32);
 801d0a8:	68e3      	ldr	r3, [r4, #12]
    retval |= USB_OTG_HandleOTG_ISR(pdev);
 801d0aa:	2001      	movs	r0, #1
  USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GOTGINT, gotgint.d32);
 801d0ac:	605f      	str	r7, [r3, #4]
  if (gintsts.b.conidstschng)
 801d0ae:	00e9      	lsls	r1, r5, #3
 801d0b0:	ea4f 6615 	mov.w	r6, r5, lsr #24
 801d0b4:	d518      	bpl.n	801d0e8 <STM32_USBO_OTG_ISR_Handler+0xc4>
  gintsts.d32 = 0 ;
  gintmsk.d32 = 0 ;
  gotgctl.d32 = 0 ;
  gintmsk.b.sofintr = 1;
  
  USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, gintmsk.d32, 0);
 801d0b6:	68e3      	ldr	r3, [r4, #12]
 801d0b8:	699a      	ldr	r2, [r3, #24]
 801d0ba:	f022 0208 	bic.w	r2, r2, #8
 801d0be:	619a      	str	r2, [r3, #24]
  gotgctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GOTGCTL);
 801d0c0:	681b      	ldr	r3, [r3, #0]
  
  /* B-Device connector (Device Mode) */
  if (gotgctl.b.conidsts)
 801d0c2:	03da      	lsls	r2, r3, #15
  {
    USB_OTG_DisableGlobalInt(pdev);
 801d0c4:	4620      	mov	r0, r4
  if (gotgctl.b.conidsts)
 801d0c6:	d522      	bpl.n	801d10e <STM32_USBO_OTG_ISR_Handler+0xea>
    USB_OTG_DisableGlobalInt(pdev);
 801d0c8:	f7fd fd5d 	bl	801ab86 <USB_OTG_DisableGlobalInt>
    USB_OTG_CoreInitDev(pdev);
 801d0cc:	4620      	mov	r0, r4
 801d0ce:	f7fd ffc3 	bl	801b058 <USB_OTG_CoreInitDev>
    USB_OTG_EnableGlobalInt(pdev);
 801d0d2:	4620      	mov	r0, r4
 801d0d4:	f7fd fd50 	bl	801ab78 <USB_OTG_EnableGlobalInt>
    pdev->otg.OTG_State = B_PERIPHERAL;
 801d0d8:	2304      	movs	r3, #4
 801d0da:	f884 3a90 	strb.w	r3, [r4, #2704]	@ 0xa90
    USB_OTG_EnableGlobalInt(pdev);
    pdev->otg.OTG_State = A_HOST;
  }
  /* Set flag and clear interrupt */
  gintsts.b.conidstschng = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801d0de:	68e3      	ldr	r3, [r4, #12]
 801d0e0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 801d0e4:	615a      	str	r2, [r3, #20]
    retval |= USB_OTG_HandleConnectorIDStatusChange_ISR(pdev);
 801d0e6:	2001      	movs	r0, #1
  if (gintsts.b.sessreqintr)
 801d0e8:	0673      	lsls	r3, r6, #25
 801d0ea:	d509      	bpl.n	801d100 <STM32_USBO_OTG_ISR_Handler+0xdc>


  gotgctl.d32 = 0;
  gintsts.d32 = 0;

  gotgctl.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GOTGCTL );
 801d0ec:	68e3      	ldr	r3, [r4, #12]
  if (USB_OTG_IsDeviceMode(pdev) && (gotgctl.b.bsesvld))
 801d0ee:	4620      	mov	r0, r4
  gotgctl.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GOTGCTL );
 801d0f0:	681b      	ldr	r3, [r3, #0]
  if (USB_OTG_IsDeviceMode(pdev) && (gotgctl.b.bsesvld))
 801d0f2:	f7fd fda3 	bl	801ac3c <USB_OTG_IsDeviceMode>
    
  }
  /* Clear interrupt */
  gintsts.d32 = 0;
  gintsts.b.sessreqintr = 1;
  USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GINTSTS, gintsts.d32);
 801d0f6:	68e3      	ldr	r3, [r4, #12]
 801d0f8:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 801d0fc:	615a      	str	r2, [r3, #20]
    retval |= USB_OTG_HandleSessionRequest_ISR(pdev);
 801d0fe:	2001      	movs	r0, #1
}
 801d100:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (USB_OTG_IsDeviceMode(pdev))
 801d104:	f7fd fd9a 	bl	801ac3c <USB_OTG_IsDeviceMode>
 801d108:	e7b5      	b.n	801d076 <STM32_USBO_OTG_ISR_Handler+0x52>
  uint32_t retval = 0;
 801d10a:	4618      	mov	r0, r3
 801d10c:	e7cf      	b.n	801d0ae <STM32_USBO_OTG_ISR_Handler+0x8a>
    USB_OTG_DisableGlobalInt(pdev);
 801d10e:	f7fd fd3a 	bl	801ab86 <USB_OTG_DisableGlobalInt>
    USB_OTG_CoreInitHost(pdev);
 801d112:	4620      	mov	r0, r4
 801d114:	f7fd fe09 	bl	801ad2a <USB_OTG_CoreInitHost>
    USB_OTG_EnableGlobalInt(pdev);
 801d118:	4620      	mov	r0, r4
 801d11a:	f7fd fd2d 	bl	801ab78 <USB_OTG_EnableGlobalInt>
 801d11e:	2301      	movs	r3, #1
 801d120:	e7db      	b.n	801d0da <STM32_USBO_OTG_ISR_Handler+0xb6>
    return 0;
 801d122:	4628      	mov	r0, r5
 801d124:	e7ec      	b.n	801d100 <STM32_USBO_OTG_ISR_Handler+0xdc>
 801d126:	bf00      	nop
 801d128:	50000004 	.word	0x50000004

0801d12c <APP_LCD_ExtPort_SerDataShift.part.0>:
  }
  return 0; // no error
#elif defined(MIOS32_FAMILY_STM32F4xx)
  int i;
  if( lsb_first ) {
    for(i=0; i<8; ++i, data >>= 1) {
 801d12c:	4b0c      	ldr	r3, [pc, #48]	@ (801d160 <APP_LCD_ExtPort_SerDataShift.part.0+0x34>)
inline static s32 APP_LCD_ExtPort_SerDataShift(u8 data, u8 lsb_first) {
 801d12e:	b510      	push	{r4, lr}
 801d130:	2108      	movs	r1, #8
 801d132:	f44f 5400 	mov.w	r4, #8192	@ 0x2000
      MIOS32_SYS_STM_PINSET(GPIOC, GPIO_Pin_13, data & 1); // J10B.D8 = ser
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // J10B.D9 = 0 (Clk)
 801d136:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
      MIOS32_SYS_STM_PINSET(GPIOC, GPIO_Pin_13, data & 1); // J10B.D8 = ser
 801d13a:	f010 0f01 	tst.w	r0, #1
 801d13e:	bf14      	ite	ne
 801d140:	831c      	strhne	r4, [r3, #24]
 801d142:	835c      	strheq	r4, [r3, #26]
    for(i=0; i<8; ++i, data >>= 1) {
 801d144:	3901      	subs	r1, #1
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // J10B.D9 = 0 (Clk)
 801d146:	835a      	strh	r2, [r3, #26]
    for(i=0; i<8; ++i, data >>= 1) {
 801d148:	ea4f 0050 	mov.w	r0, r0, lsr #1
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d14c:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d14e:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d150:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d152:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // J10B.D9 = 1 (Clk)
 801d154:	831a      	strh	r2, [r3, #24]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // stretch
 801d156:	831a      	strh	r2, [r3, #24]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // stretch
 801d158:	831a      	strh	r2, [r3, #24]
    for(i=0; i<8; ++i, data >>= 1) {
 801d15a:	d1ee      	bne.n	801d13a <APP_LCD_ExtPort_SerDataShift.part.0+0xe>
  return 0; // no error
#else
# warning "APP_LCD_ExtPort_SerDataShift not adapted for this MIOS32_FAMILY"
  return -1;
#endif
}
 801d15c:	bd10      	pop	{r4, pc}
 801d15e:	bf00      	nop
 801d160:	40020800 	.word	0x40020800

0801d164 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0>:
    for(i=0; i<8; ++i, data <<= 1) {
 801d164:	4b0c      	ldr	r3, [pc, #48]	@ (801d198 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0+0x34>)
inline static s32 APP_LCD_ExtPort_SerDataShift(u8 data, u8 lsb_first) {
 801d166:	b510      	push	{r4, lr}
 801d168:	2108      	movs	r1, #8
 801d16a:	f44f 5400 	mov.w	r4, #8192	@ 0x2000
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // J10B.D9 = 0 (Clk)
 801d16e:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
      MIOS32_SYS_STM_PINSET(GPIOC, GPIO_Pin_13, data & 0x80); // J10B.D8 = ser
 801d172:	f010 0f80 	tst.w	r0, #128	@ 0x80
 801d176:	bf14      	ite	ne
 801d178:	831c      	strhne	r4, [r3, #24]
 801d17a:	835c      	strheq	r4, [r3, #26]
    for(i=0; i<8; ++i, data <<= 1) {
 801d17c:	0040      	lsls	r0, r0, #1
 801d17e:	3901      	subs	r1, #1
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // J10B.D9 = 0 (Clk)
 801d180:	835a      	strh	r2, [r3, #26]
    for(i=0; i<8; ++i, data <<= 1) {
 801d182:	b2c0      	uxtb	r0, r0
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d184:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d186:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d188:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_0(GPIOC, GPIO_Pin_14); // stretch
 801d18a:	835a      	strh	r2, [r3, #26]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // J10B.D9 = 1 (Clk)
 801d18c:	831a      	strh	r2, [r3, #24]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // stretch
 801d18e:	831a      	strh	r2, [r3, #24]
      MIOS32_SYS_STM_PINSET_1(GPIOC, GPIO_Pin_14); // stretch
 801d190:	831a      	strh	r2, [r3, #24]
    for(i=0; i<8; ++i, data <<= 1) {
 801d192:	d1ee      	bne.n	801d172 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0+0xe>
}
 801d194:	bd10      	pop	{r4, pc}
 801d196:	bf00      	nop
 801d198:	40020800 	.word	0x40020800

0801d19c <APP_LCD_ExtPort_PinSet.isra.0>:
  return MIOS32_BOARD_J10_PinSet(pin + 8, value);
 801d19c:	3008      	adds	r0, #8
 801d19e:	b2c0      	uxtb	r0, r0
 801d1a0:	f7f9 bf6e 	b.w	8017080 <MIOS32_BOARD_J10_PinSet>

0801d1a4 <APP_LCD_ExtPort_UpdateSRs.isra.0>:

// pulse the RC line after a serial data shift
inline static s32 APP_LCD_ExtPort_UpdateSRs(void) {
 801d1a4:	b508      	push	{r3, lr}
#if defined(MIOS32_FAMILY_STM32F10x)
  APP_LCD_ExtPort_PinSet(2, 0); // J5C.A10
  APP_LCD_ExtPort_PinSet(2, 1); // J5C.A10
  return 0; // no error
#elif defined(MIOS32_FAMILY_STM32F4xx)
  APP_LCD_ExtPort_PinSet(2, 0); // J10B.D10
 801d1a6:	2100      	movs	r1, #0
 801d1a8:	2002      	movs	r0, #2
 801d1aa:	f7ff fff7 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
  return 0; // no error
#else
# warning "APP_LCD_ExtPort_UpdateSRs not adapted for this MIOS32_FAMILY"
  return -1;
#endif
}
 801d1ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  APP_LCD_ExtPort_PinSet(2, 1); // J10B.D10
 801d1b2:	2101      	movs	r1, #1
 801d1b4:	2002      	movs	r0, #2
 801d1b6:	f7ff bff1 	b.w	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	...

0801d1bc <APP_LCD_GLCD_CS_Set.isra.0>:

/////////////////////////////////////////////////////////////////////////////
// Sets the CS line of GLCDs with parallel port depending on X cursor position
// if "all" flag is set, commands are sent to all segments
/////////////////////////////////////////////////////////////////////////////
static s32 APP_LCD_GLCD_CS_Set(u8 all)
 801d1bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
  // determine polarity of CS pins
  u8 level_active = (mios32_lcd_parameters.lcd_type == MIOS32_LCD_TYPE_GLCD_KS0108) ? 1 : 0;
 801d1be:	4b14      	ldr	r3, [pc, #80]	@ (801d210 <APP_LCD_GLCD_CS_Set.isra.0+0x54>)
 801d1c0:	781b      	ldrb	r3, [r3, #0]
 801d1c2:	f1a3 0181 	sub.w	r1, r3, #129	@ 0x81
 801d1c6:	424f      	negs	r7, r1
 801d1c8:	414f      	adcs	r7, r1
  u8 level_nonactive = level_active ? 0 : 1;
#if SED1520_POLLIN_WINTEK_WD_G1203T
  u8 segment_width = (mios32_lcd_parameters.lcd_type == MIOS32_LCD_TYPE_GLCD_SED1520) ? 61 : 64;
 801d1ca:	2b86      	cmp	r3, #134	@ 0x86
 801d1cc:	bf14      	ite	ne
 801d1ce:	2240      	movne	r2, #64	@ 0x40
 801d1d0:	223d      	moveq	r2, #61	@ 0x3d
#else
  u8 segment_width = 64; // should be valid for KS0108 and SED1320 (although sometimes the controllers provide more columns)
#endif

  int cs;
  if( all ) {
 801d1d2:	4604      	mov	r4, r0
 801d1d4:	b140      	cbz	r0, 801d1e8 <APP_LCD_GLCD_CS_Set.isra.0+0x2c>
    // set all chip select lines
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
 801d1d6:	2400      	movs	r4, #0
      APP_LCD_ExtPort_PinSet(cs, level_active);
 801d1d8:	b2e0      	uxtb	r0, r4
 801d1da:	4639      	mov	r1, r7
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
 801d1dc:	3401      	adds	r4, #1
      APP_LCD_ExtPort_PinSet(cs, level_active);
 801d1de:	f7ff ffdd 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
 801d1e2:	2c08      	cmp	r4, #8
 801d1e4:	d1f8      	bne.n	801d1d8 <APP_LCD_GLCD_CS_Set.isra.0+0x1c>
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
      APP_LCD_ExtPort_PinSet(cs, (cs == sel_cs) ? level_active : level_nonactive);
  }

  return 0; // no error
}
 801d1e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  u8 level_nonactive = level_active ? 0 : 1;
 801d1e8:	f1b3 0581 	subs.w	r5, r3, #129	@ 0x81
    u8 sel_cs = mios32_lcd_x / segment_width;
 801d1ec:	4b09      	ldr	r3, [pc, #36]	@ (801d214 <APP_LCD_GLCD_CS_Set.isra.0+0x58>)
  u8 level_nonactive = level_active ? 0 : 1;
 801d1ee:	bf18      	it	ne
 801d1f0:	2501      	movne	r5, #1
    u8 sel_cs = mios32_lcd_x / segment_width;
 801d1f2:	881e      	ldrh	r6, [r3, #0]
 801d1f4:	fbb6 f6f2 	udiv	r6, r6, r2
      APP_LCD_ExtPort_PinSet(cs, (cs == sel_cs) ? level_active : level_nonactive);
 801d1f8:	b2f6      	uxtb	r6, r6
 801d1fa:	42a6      	cmp	r6, r4
 801d1fc:	bf0c      	ite	eq
 801d1fe:	4639      	moveq	r1, r7
 801d200:	4629      	movne	r1, r5
 801d202:	b2e0      	uxtb	r0, r4
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
 801d204:	3401      	adds	r4, #1
      APP_LCD_ExtPort_PinSet(cs, (cs == sel_cs) ? level_active : level_nonactive);
 801d206:	f7ff ffc9 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
    for(cs=0; cs<APP_LCD_NUM_EXT_PINS; ++cs)
 801d20a:	2c08      	cmp	r4, #8
 801d20c:	d1f5      	bne.n	801d1fa <APP_LCD_GLCD_CS_Set.isra.0+0x3e>
 801d20e:	e7ea      	b.n	801d1e6 <APP_LCD_GLCD_CS_Set.isra.0+0x2a>
 801d210:	2000314a 	.word	0x2000314a
 801d214:	2000313e 	.word	0x2000313e

0801d218 <APP_LCD_E_Set>:

/////////////////////////////////////////////////////////////////////////////
// Sets the E (enable) line depending on mios32_lcd_device
/////////////////////////////////////////////////////////////////////////////
static s32 APP_LCD_E_Set(u8 value)
{
 801d218:	b570      	push	{r4, r5, r6, lr}
  if( mios32_lcd_device < 2 ) {
 801d21a:	4b1c      	ldr	r3, [pc, #112]	@ (801d28c <APP_LCD_E_Set+0x74>)
{
 801d21c:	4604      	mov	r4, r0
  if( mios32_lcd_device < 2 ) {
 801d21e:	7818      	ldrb	r0, [r3, #0]
 801d220:	2801      	cmp	r0, #1
 801d222:	d804      	bhi.n	801d22e <APP_LCD_E_Set+0x16>
    return MIOS32_BOARD_J15_E_Set(mios32_lcd_device, value);
 801d224:	4621      	mov	r1, r4
    // update serial shift registers
    APP_LCD_ExtPort_UpdateSRs();
  }

  return 0; // no error
}
 801d226:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return MIOS32_BOARD_J15_E_Set(mios32_lcd_device, value);
 801d22a:	f7fa b813 	b.w	8017254 <MIOS32_BOARD_J15_E_Set>
  int num_additional_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y - 2;
 801d22e:	4a18      	ldr	r2, [pc, #96]	@ (801d290 <APP_LCD_E_Set+0x78>)
 801d230:	7853      	ldrb	r3, [r2, #1]
 801d232:	7892      	ldrb	r2, [r2, #2]
 801d234:	fb13 f302 	smulbb	r3, r3, r2
  if( num_additional_lcds < 0 )
 801d238:	3b02      	subs	r3, #2
 801d23a:	d423      	bmi.n	801d284 <APP_LCD_E_Set+0x6c>
  if( num_additional_lcds <= APP_LCD_NUM_EXT_PINS ) {
 801d23c:	2b08      	cmp	r3, #8
 801d23e:	f1a0 0002 	sub.w	r0, r0, #2
 801d242:	dc05      	bgt.n	801d250 <APP_LCD_E_Set+0x38>
    APP_LCD_ExtPort_PinSet(mios32_lcd_device - 2, value);
 801d244:	4621      	mov	r1, r4
 801d246:	b2c0      	uxtb	r0, r0
 801d248:	f7ff ffa8 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
  return 0; // no error
 801d24c:	2000      	movs	r0, #0
}
 801d24e:	bd70      	pop	{r4, r5, r6, pc}
    if( num_additional_lcds >= (MAX_LCDS-2) )
 801d250:	2b3e      	cmp	r3, #62	@ 0x3e
 801d252:	bfa8      	it	ge
 801d254:	233e      	movge	r3, #62	@ 0x3e
    int num_shifts = num_additional_lcds / 8;
 801d256:	10dd      	asrs	r5, r3, #3
    if( num_additional_lcds % 8 )
 801d258:	075b      	lsls	r3, r3, #29
      ++num_shifts;
 801d25a:	bf18      	it	ne
 801d25c:	3501      	addne	r5, #1
    int selected_lcd_sr = selected_lcd / 8;
 801d25e:	10c6      	asrs	r6, r0, #3
    u8 selected_lcd_mask = value ? (1 << (selected_lcd % 8)) : 0;
 801d260:	b124      	cbz	r4, 801d26c <APP_LCD_E_Set+0x54>
 801d262:	f000 0007 	and.w	r0, r0, #7
 801d266:	2401      	movs	r4, #1
 801d268:	4084      	lsls	r4, r0
 801d26a:	b2e4      	uxtb	r4, r4
    for(i=num_shifts-1; i>=0; --i) {
 801d26c:	3d01      	subs	r5, #1
  if( lsb_first ) {
 801d26e:	42ae      	cmp	r6, r5
 801d270:	bf0c      	ite	eq
 801d272:	4620      	moveq	r0, r4
 801d274:	2000      	movne	r0, #0
 801d276:	f7ff ff59 	bl	801d12c <APP_LCD_ExtPort_SerDataShift.part.0>
    for(i=num_shifts-1; i>=0; --i) {
 801d27a:	3d01      	subs	r5, #1
 801d27c:	d2f7      	bcs.n	801d26e <APP_LCD_E_Set+0x56>
    APP_LCD_ExtPort_UpdateSRs();
 801d27e:	f7ff ff91 	bl	801d1a4 <APP_LCD_ExtPort_UpdateSRs.isra.0>
 801d282:	e7e3      	b.n	801d24c <APP_LCD_E_Set+0x34>
    return -2; // E line not configured
 801d284:	f06f 0001 	mvn.w	r0, #1
 801d288:	e7e1      	b.n	801d24e <APP_LCD_E_Set+0x36>
 801d28a:	bf00      	nop
 801d28c:	20003148 	.word	0x20003148
 801d290:	2000314a 	.word	0x2000314a

0801d294 <APP_LCD_PollUnbusy>:

/////////////////////////////////////////////////////////////////////////////
// Polls for unbusy depending on mios32_lcd_device
/////////////////////////////////////////////////////////////////////////////
static s32 APP_LCD_PollUnbusy(u32 time_out)
{
 801d294:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if( mios32_lcd_device < 2 ) {
 801d296:	4b1f      	ldr	r3, [pc, #124]	@ (801d314 <APP_LCD_PollUnbusy+0x80>)
{
 801d298:	4604      	mov	r4, r0
  if( mios32_lcd_device < 2 ) {
 801d29a:	7818      	ldrb	r0, [r3, #0]
 801d29c:	2801      	cmp	r0, #1
 801d29e:	d804      	bhi.n	801d2aa <APP_LCD_PollUnbusy+0x16>
    return MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, time_out);
 801d2a0:	4621      	mov	r1, r4
  // timeout?
  if( poll_ctr == 0 )
    return -2; // timeout error

  return 0; // no error
}
 801d2a2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    return MIOS32_BOARD_J15_PollUnbusy(mios32_lcd_device, time_out);
 801d2a6:	f7f9 bff5 	b.w	8017294 <MIOS32_BOARD_J15_PollUnbusy>
  if( mios32_lcd_device >= MAX_LCDS )
 801d2aa:	283f      	cmp	r0, #63	@ 0x3f
 801d2ac:	d902      	bls.n	801d2b4 <APP_LCD_PollUnbusy+0x20>
    return -1; // LCD not supported
 801d2ae:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 801d2b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  MIOS32_BOARD_J15_RS_Set(0);
 801d2b4:	2000      	movs	r0, #0
 801d2b6:	f7f9 ffb5 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
  MIOS32_BOARD_J15_D7InPullUpEnable(1);
 801d2ba:	2001      	movs	r0, #1
 801d2bc:	f7f9 ffe8 	bl	8017290 <MIOS32_BOARD_J15_D7InPullUpEnable>
  MIOS32_BOARD_J15_RW_Set(1);
 801d2c0:	2001      	movs	r0, #1
 801d2c2:	f7f9 ffbb 	bl	801723c <MIOS32_BOARD_J15_RW_Set>
  if( APP_LCD_E_Set(1) < 0 )
 801d2c6:	2001      	movs	r0, #1
 801d2c8:	f7ff ffa6 	bl	801d218 <APP_LCD_E_Set>
 801d2cc:	2800      	cmp	r0, #0
 801d2ce:	dbee      	blt.n	801d2ae <APP_LCD_PollUnbusy+0x1a>
  u32 repeat_ctr = 0;
 801d2d0:	2700      	movs	r7, #0
    APP_LCD_E_Set(1);
 801d2d2:	2001      	movs	r0, #1
 801d2d4:	f7ff ffa0 	bl	801d218 <APP_LCD_E_Set>
 801d2d8:	250a      	movs	r5, #10
      MIOS32_BOARD_J15_RW_Set(1);
 801d2da:	2001      	movs	r0, #1
 801d2dc:	f7f9 ffae 	bl	801723c <MIOS32_BOARD_J15_RW_Set>
    for(delay_ctr=0; delay_ctr<10; ++delay_ctr)
 801d2e0:	3d01      	subs	r5, #1
 801d2e2:	d1fa      	bne.n	801d2da <APP_LCD_PollUnbusy+0x46>
    u32 busy = MIOS32_BOARD_J15_GetD7In();
 801d2e4:	f7f9 ffcc 	bl	8017280 <MIOS32_BOARD_J15_GetD7In>
 801d2e8:	4606      	mov	r6, r0
    APP_LCD_E_Set(0);
 801d2ea:	4628      	mov	r0, r5
 801d2ec:	f7ff ff94 	bl	801d218 <APP_LCD_E_Set>
    if( !busy && ++repeat_ctr >= 2)
 801d2f0:	b90e      	cbnz	r6, 801d2f6 <APP_LCD_PollUnbusy+0x62>
 801d2f2:	b917      	cbnz	r7, 801d2fa <APP_LCD_PollUnbusy+0x66>
 801d2f4:	2701      	movs	r7, #1
  for(poll_ctr=time_out; poll_ctr>0; --poll_ctr) {
 801d2f6:	3c01      	subs	r4, #1
 801d2f8:	d1eb      	bne.n	801d2d2 <APP_LCD_PollUnbusy+0x3e>
  MIOS32_BOARD_J15_D7InPullUpEnable(0);
 801d2fa:	2000      	movs	r0, #0
 801d2fc:	f7f9 ffc8 	bl	8017290 <MIOS32_BOARD_J15_D7InPullUpEnable>
  MIOS32_BOARD_J15_RW_Set(0);
 801d300:	2000      	movs	r0, #0
 801d302:	f7f9 ff9b 	bl	801723c <MIOS32_BOARD_J15_RW_Set>
  return 0; // no error
 801d306:	2c00      	cmp	r4, #0
 801d308:	bf0c      	ite	eq
 801d30a:	f06f 0001 	mvneq.w	r0, #1
 801d30e:	2000      	movne	r0, #0
 801d310:	e7cf      	b.n	801d2b2 <APP_LCD_PollUnbusy+0x1e>
 801d312:	bf00      	nop
 801d314:	20003148 	.word	0x20003148

0801d318 <APP_LCD_ExtPort_Init.isra.0>:
inline static s32 APP_LCD_ExtPort_Init(void) {
 801d318:	b510      	push	{r4, lr}
 801d31a:	2408      	movs	r4, #8
    MIOS32_BOARD_J10_PinInit(pin + 8, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 801d31c:	4620      	mov	r0, r4
  for(pin=0; pin<APP_LCD_NUM_EXT_PINS; ++pin) {
 801d31e:	3401      	adds	r4, #1
    MIOS32_BOARD_J10_PinInit(pin + 8, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 801d320:	2105      	movs	r1, #5
  for(pin=0; pin<APP_LCD_NUM_EXT_PINS; ++pin) {
 801d322:	b2e4      	uxtb	r4, r4
    MIOS32_BOARD_J10_PinInit(pin + 8, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 801d324:	f7f9 fe8a 	bl	801703c <MIOS32_BOARD_J10_PinInit>
  for(pin=0; pin<APP_LCD_NUM_EXT_PINS; ++pin) {
 801d328:	2c10      	cmp	r4, #16
 801d32a:	d1f7      	bne.n	801d31c <APP_LCD_ExtPort_Init.isra.0+0x4>
}
 801d32c:	bd10      	pop	{r4, pc}
	...

0801d330 <APP_LCD_SERGLCD_CS_Init.isra.0>:
static s32 APP_LCD_SERGLCD_CS_Init(void)
 801d330:	b510      	push	{r4, lr}
  int num_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y;
 801d332:	4b0a      	ldr	r3, [pc, #40]	@ (801d35c <APP_LCD_SERGLCD_CS_Init.isra.0+0x2c>)
 801d334:	785c      	ldrb	r4, [r3, #1]
 801d336:	789b      	ldrb	r3, [r3, #2]
 801d338:	fb14 f403 	smulbb	r4, r4, r3
  if( num_lcds > 8 ) {
 801d33c:	2c08      	cmp	r4, #8
 801d33e:	dd01      	ble.n	801d344 <APP_LCD_SERGLCD_CS_Init.isra.0+0x14>
    APP_LCD_ExtPort_Init();
 801d340:	f7ff ffea 	bl	801d318 <APP_LCD_ExtPort_Init.isra.0>
  display_available |= (1 << num_lcds)-1;
 801d344:	4a06      	ldr	r2, [pc, #24]	@ (801d360 <APP_LCD_SERGLCD_CS_Init.isra.0+0x30>)
 801d346:	2301      	movs	r3, #1
 801d348:	e9d2 0100 	ldrd	r0, r1, [r2]
 801d34c:	40a3      	lsls	r3, r4
 801d34e:	3b01      	subs	r3, #1
 801d350:	4318      	orrs	r0, r3
 801d352:	ea41 71e3 	orr.w	r1, r1, r3, asr #31
 801d356:	e9c2 0100 	strd	r0, r1, [r2]
}
 801d35a:	bd10      	pop	{r4, pc}
 801d35c:	2000314a 	.word	0x2000314a
 801d360:	200044f0 	.word	0x200044f0

0801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>:
static s32 APP_LCD_SERGLCD_CS_Set(u8 value, u8 all)
 801d364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if( lcd_alt_pinning ) {
 801d368:	4b46      	ldr	r3, [pc, #280]	@ (801d484 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x120>)
 801d36a:	781d      	ldrb	r5, [r3, #0]
static s32 APP_LCD_SERGLCD_CS_Set(u8 value, u8 all)
 801d36c:	4604      	mov	r4, r0
  if( lcd_alt_pinning ) {
 801d36e:	b30d      	cbz	r5, 801d3b4 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x50>
    if( all ) {
 801d370:	b188      	cbz	r0, 801d396 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x32>
  return MIOS32_BOARD_J10_PinSet(pin + 12, value); // J10B.D12..D15
 801d372:	2100      	movs	r1, #0
 801d374:	200c      	movs	r0, #12
 801d376:	f7f9 fe83 	bl	8017080 <MIOS32_BOARD_J10_PinSet>
 801d37a:	2100      	movs	r1, #0
 801d37c:	200d      	movs	r0, #13
 801d37e:	f7f9 fe7f 	bl	8017080 <MIOS32_BOARD_J10_PinSet>
 801d382:	2100      	movs	r1, #0
 801d384:	200e      	movs	r0, #14
 801d386:	f7f9 fe7b 	bl	8017080 <MIOS32_BOARD_J10_PinSet>
}
 801d38a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  return MIOS32_BOARD_J10_PinSet(pin + 12, value); // J10B.D12..D15
 801d38e:	2100      	movs	r1, #0
 801d390:	200f      	movs	r0, #15
 801d392:	f7f9 be75 	b.w	8017080 <MIOS32_BOARD_J10_PinSet>
	APP_LCD_ExtPort_AltPinCsSet(cs, (cs == mios32_lcd_device) ? level_active : level_nonactive);
 801d396:	4d3c      	ldr	r5, [pc, #240]	@ (801d488 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x124>)
 801d398:	7829      	ldrb	r1, [r5, #0]
  return MIOS32_BOARD_J10_PinSet(pin + 12, value); // J10B.D12..D15
 801d39a:	f104 000c 	add.w	r0, r4, #12
 801d39e:	1b09      	subs	r1, r1, r4
 801d3a0:	bf18      	it	ne
 801d3a2:	2101      	movne	r1, #1
 801d3a4:	b2c0      	uxtb	r0, r0
      for(cs=0; cs<4; ++cs)
 801d3a6:	3401      	adds	r4, #1
  return MIOS32_BOARD_J10_PinSet(pin + 12, value); // J10B.D12..D15
 801d3a8:	f7f9 fe6a 	bl	8017080 <MIOS32_BOARD_J10_PinSet>
      for(cs=0; cs<4; ++cs)
 801d3ac:	2c04      	cmp	r4, #4
 801d3ae:	d1f3      	bne.n	801d398 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x34>
}
 801d3b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    int num_additional_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y - 8;
 801d3b4:	4b35      	ldr	r3, [pc, #212]	@ (801d48c <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x128>)
      if( prev_glcd_selection != 0xff ) {
 801d3b6:	4a36      	ldr	r2, [pc, #216]	@ (801d490 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x12c>)
    int num_additional_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y - 8;
 801d3b8:	785e      	ldrb	r6, [r3, #1]
 801d3ba:	789b      	ldrb	r3, [r3, #2]
      if( prev_glcd_selection != 0xff ) {
 801d3bc:	7811      	ldrb	r1, [r2, #0]
    int num_additional_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y - 8;
 801d3be:	fb16 f603 	smulbb	r6, r6, r3
 801d3c2:	f1a6 0708 	sub.w	r7, r6, #8
    if( num_additional_lcds >= (MAX_LCDS-8) )
 801d3c6:	2f38      	cmp	r7, #56	@ 0x38
 801d3c8:	bfa8      	it	ge
 801d3ca:	2738      	movge	r7, #56	@ 0x38
    if( all ) {
 801d3cc:	b1f0      	cbz	r0, 801d40c <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0xa8>
      if( prev_glcd_selection != 0xff ) {
 801d3ce:	29ff      	cmp	r1, #255	@ 0xff
 801d3d0:	d0ee      	beq.n	801d3b0 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x4c>
	prev_glcd_selection = 0xff;
 801d3d2:	23ff      	movs	r3, #255	@ 0xff
	MIOS32_BOARD_J15_DataSet(value ? 0x00 : 0xff);
 801d3d4:	4628      	mov	r0, r5
	prev_glcd_selection = 0xff;
 801d3d6:	7013      	strb	r3, [r2, #0]
	MIOS32_BOARD_J15_DataSet(value ? 0x00 : 0xff);
 801d3d8:	f7f9 fecc 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
	if( num_additional_lcds <= APP_LCD_NUM_EXT_PINS ) {
 801d3dc:	2e10      	cmp	r6, #16
 801d3de:	dd12      	ble.n	801d406 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0xa2>
	  int num_shifts = num_additional_lcds / 8;
 801d3e0:	10fc      	asrs	r4, r7, #3
	  if( num_additional_lcds % 8 )
 801d3e2:	077a      	lsls	r2, r7, #29
	    ++num_shifts;
 801d3e4:	bf18      	it	ne
 801d3e6:	3401      	addne	r4, #1
	  for(i=num_shifts-1; i>=0; --i) {
 801d3e8:	3c01      	subs	r4, #1
  if( lsb_first ) {
 801d3ea:	2000      	movs	r0, #0
 801d3ec:	f7ff fe9e 	bl	801d12c <APP_LCD_ExtPort_SerDataShift.part.0>
	  for(i=num_shifts-1; i>=0; --i) {
 801d3f0:	3c01      	subs	r4, #1
 801d3f2:	d2fa      	bcs.n	801d3ea <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x86>
}
 801d3f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	  APP_LCD_ExtPort_UpdateSRs();
 801d3f8:	f7ff bed4 	b.w	801d1a4 <APP_LCD_ExtPort_UpdateSRs.isra.0>
	    APP_LCD_ExtPort_PinSet(i, value ? 0 : 1);
 801d3fc:	b2e8      	uxtb	r0, r5
 801d3fe:	2100      	movs	r1, #0
 801d400:	f7ff fecc 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	  for(i=0; i<num_additional_lcds; ++i)
 801d404:	3501      	adds	r5, #1
 801d406:	42af      	cmp	r7, r5
 801d408:	dcf8      	bgt.n	801d3fc <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x98>
 801d40a:	e7d1      	b.n	801d3b0 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x4c>
      if( prev_glcd_selection != mios32_lcd_device ) {
 801d40c:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 801d488 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x124>
 801d410:	f898 3000 	ldrb.w	r3, [r8]
 801d414:	4299      	cmp	r1, r3
 801d416:	d0cb      	beq.n	801d3b0 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x4c>
	u32 mask = value ? ~(1 << mios32_lcd_device) : 0xffffffff;
 801d418:	2501      	movs	r5, #1
 801d41a:	409d      	lsls	r5, r3
 801d41c:	43ed      	mvns	r5, r5
	MIOS32_BOARD_J15_DataSet(mask);
 801d41e:	b2e8      	uxtb	r0, r5
	prev_glcd_selection = mios32_lcd_device;
 801d420:	7013      	strb	r3, [r2, #0]
	MIOS32_BOARD_J15_DataSet(mask);
 801d422:	f7f9 fea7 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
	if( num_additional_lcds <= APP_LCD_NUM_EXT_PINS ) {
 801d426:	2e10      	cmp	r6, #16
 801d428:	dc0c      	bgt.n	801d444 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0xe0>
	  for(i=0; i<num_additional_lcds; ++i)
 801d42a:	42a7      	cmp	r7, r4
 801d42c:	ddc0      	ble.n	801d3b0 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x4c>
	    APP_LCD_ExtPort_PinSet(i, (mask >> (8+i)) & 1);
 801d42e:	f104 0108 	add.w	r1, r4, #8
 801d432:	fa25 f101 	lsr.w	r1, r5, r1
 801d436:	b2e0      	uxtb	r0, r4
 801d438:	f001 0101 	and.w	r1, r1, #1
 801d43c:	f7ff feae 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	  for(i=0; i<num_additional_lcds; ++i)
 801d440:	3401      	adds	r4, #1
 801d442:	e7f2      	b.n	801d42a <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0xc6>
	  int selected_lcd = mios32_lcd_device - 8;
 801d444:	f898 1000 	ldrb.w	r1, [r8]
	  if( num_additional_lcds % 8 )
 801d448:	077b      	lsls	r3, r7, #29
	  int num_shifts = num_additional_lcds / 8;
 801d44a:	ea4f 04e7 	mov.w	r4, r7, asr #3
	  int selected_lcd = mios32_lcd_device - 8;
 801d44e:	f1a1 0308 	sub.w	r3, r1, #8
	  int selected_lcd_sr = selected_lcd / 8;
 801d452:	461a      	mov	r2, r3
	    ++num_shifts;
 801d454:	bf18      	it	ne
 801d456:	3401      	addne	r4, #1
	  u8 selected_lcd_mask = value ? ~(1 << (selected_lcd % 8)) : 0xff;
 801d458:	2501      	movs	r5, #1
	  int selected_lcd_sr = selected_lcd / 8;
 801d45a:	2b00      	cmp	r3, #0
	  u8 selected_lcd_mask = value ? ~(1 << (selected_lcd % 8)) : 0xff;
 801d45c:	f003 0307 	and.w	r3, r3, #7
 801d460:	fa05 f503 	lsl.w	r5, r5, r3
	  int selected_lcd_sr = selected_lcd / 8;
 801d464:	bfb8      	it	lt
 801d466:	f101 32ff 	addlt.w	r2, r1, #4294967295	@ 0xffffffff
	  u8 selected_lcd_mask = value ? ~(1 << (selected_lcd % 8)) : 0xff;
 801d46a:	43ed      	mvns	r5, r5
	  int selected_lcd_sr = selected_lcd / 8;
 801d46c:	10d6      	asrs	r6, r2, #3
	  u8 selected_lcd_mask = value ? ~(1 << (selected_lcd % 8)) : 0xff;
 801d46e:	b2ed      	uxtb	r5, r5
	  for(i=num_shifts-1; i>=0; --i) {
 801d470:	3c01      	subs	r4, #1
  if( lsb_first ) {
 801d472:	42a6      	cmp	r6, r4
 801d474:	bf0c      	ite	eq
 801d476:	4628      	moveq	r0, r5
 801d478:	20ff      	movne	r0, #255	@ 0xff
 801d47a:	f7ff fe57 	bl	801d12c <APP_LCD_ExtPort_SerDataShift.part.0>
	  for(i=num_shifts-1; i>=0; --i) {
 801d47e:	3c01      	subs	r4, #1
 801d480:	d2f7      	bcs.n	801d472 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x10e>
 801d482:	e7b7      	b.n	801d3f4 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0+0x90>
 801d484:	200044e9 	.word	0x200044e9
 801d488:	20003148 	.word	0x20003148
 801d48c:	2000314a 	.word	0x2000314a
 801d490:	2000005c 	.word	0x2000005c

0801d494 <APP_LCD_Cmd>:
// Sends command byte to LCD
// IN: command byte in <cmd>
// OUT: returns < 0 if display not available or timed out
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Cmd(u8 cmd)
{
 801d494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if( lcd_testmode )
 801d496:	4b3d      	ldr	r3, [pc, #244]	@ (801d58c <APP_LCD_Cmd+0xf8>)
 801d498:	781b      	ldrb	r3, [r3, #0]
{
 801d49a:	4604      	mov	r4, r0
  if( lcd_testmode )
 801d49c:	2b00      	cmp	r3, #0
 801d49e:	d172      	bne.n	801d586 <APP_LCD_Cmd+0xf2>
    return -1; // direct access disabled in testmode

  // check if if display already has been disabled
  if( !(display_available & (1ULL << mios32_lcd_device)) )
 801d4a0:	4e3b      	ldr	r6, [pc, #236]	@ (801d590 <APP_LCD_Cmd+0xfc>)
 801d4a2:	4d3c      	ldr	r5, [pc, #240]	@ (801d594 <APP_LCD_Cmd+0x100>)
 801d4a4:	7832      	ldrb	r2, [r6, #0]
 801d4a6:	e9d5 3700 	ldrd	r3, r7, [r5]
 801d4aa:	f1c2 0020 	rsb	r0, r2, #32
 801d4ae:	f1a2 0120 	sub.w	r1, r2, #32
 801d4b2:	40d3      	lsrs	r3, r2
 801d4b4:	fa07 f000 	lsl.w	r0, r7, r0
 801d4b8:	4303      	orrs	r3, r0
 801d4ba:	fa27 f101 	lsr.w	r1, r7, r1
 801d4be:	430b      	orrs	r3, r1
 801d4c0:	07db      	lsls	r3, r3, #31
 801d4c2:	d560      	bpl.n	801d586 <APP_LCD_Cmd+0xf2>
    return -1;

  switch( mios32_lcd_parameters.lcd_type ) {
 801d4c4:	4b34      	ldr	r3, [pc, #208]	@ (801d598 <APP_LCD_Cmd+0x104>)
 801d4c6:	781b      	ldrb	r3, [r3, #0]
 801d4c8:	3b81      	subs	r3, #129	@ 0x81
 801d4ca:	2b05      	cmp	r3, #5
 801d4cc:	d83e      	bhi.n	801d54c <APP_LCD_Cmd+0xb8>
 801d4ce:	e8df f003 	tbb	[pc, r3]
 801d4d2:	0303      	.short	0x0303
 801d4d4:	0327271c 	.word	0x0327271c
  case MIOS32_LCD_TYPE_GLCD_KS0108:
  case MIOS32_LCD_TYPE_GLCD_KS0108_INVCS:
  case MIOS32_LCD_TYPE_GLCD_SED1520: {

    // due to historical reasons currently only two devices provided, they are spreaded over multiple CS lines
    if( mios32_lcd_device >= 2 )
 801d4d8:	2a01      	cmp	r2, #1
 801d4da:	d854      	bhi.n	801d586 <APP_LCD_Cmd+0xf2>
      return -1;

    // determine chip select line(s)
    APP_LCD_GLCD_CS_Set(0); // select display depending on current X position
 801d4dc:	2000      	movs	r0, #0
 801d4de:	f7ff fe6d 	bl	801d1bc <APP_LCD_GLCD_CS_Set.isra.0>

    // wait until LCD unbusy, exit on error (timeout)
    if( APP_LCD_PollUnbusy(10000) < 0 ) {
 801d4e2:	f242 7010 	movw	r0, #10000	@ 0x2710
 801d4e6:	f7ff fed5 	bl	801d294 <APP_LCD_PollUnbusy>
#endif
      //return -2; // timeout
    }

    // select all displays
    APP_LCD_GLCD_CS_Set(1);
 801d4ea:	2001      	movs	r0, #1
 801d4ec:	f7ff fe66 	bl	801d1bc <APP_LCD_GLCD_CS_Set.isra.0>
#endif
      return -2; // timeout
    }

    // write command
    MIOS32_BOARD_J15_DataSet(cmd);
 801d4f0:	4620      	mov	r0, r4
 801d4f2:	f7f9 fe3f 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
    MIOS32_BOARD_J15_RS_Set(0);
 801d4f6:	2000      	movs	r0, #0
 801d4f8:	f7f9 fe94 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    APP_LCD_E_Set(1);
 801d4fc:	2001      	movs	r0, #1
 801d4fe:	f7ff fe8b 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801d502:	2000      	movs	r0, #0
 801d504:	f7ff fe88 	bl	801d218 <APP_LCD_E_Set>

    return 0; // no error
 801d508:	e008      	b.n	801d51c <APP_LCD_Cmd+0x88>
    APP_LCD_SERGLCD_CS_Set(1, 1);
 801d50a:	2001      	movs	r0, #1
 801d50c:	f7ff ff2a 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
    MIOS32_BOARD_J15_RS_Set(0); // RS pin used to control A0
 801d510:	2000      	movs	r0, #0
 801d512:	f7f9 fe87 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    MIOS32_BOARD_J15_SerDataShift(cmd);
 801d516:	4620      	mov	r0, r4
 801d518:	f7f9 fe50 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
    return 0; // no error
 801d51c:	2000      	movs	r0, #0
 801d51e:	e00e      	b.n	801d53e <APP_LCD_Cmd+0xaa>
    APP_LCD_SERGLCD_CS_Set(1, 1);
 801d520:	2001      	movs	r0, #1
 801d522:	f7ff ff1f 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
    if( lcd_alt_pinning ) {
 801d526:	4b1d      	ldr	r3, [pc, #116]	@ (801d59c <APP_LCD_Cmd+0x108>)
 801d528:	7818      	ldrb	r0, [r3, #0]
 801d52a:	b148      	cbz	r0, 801d540 <APP_LCD_Cmd+0xac>
      APP_LCD_ExtPort_PinSet(2, 0); // DC
 801d52c:	2002      	movs	r0, #2
 801d52e:	2100      	movs	r1, #0
 801d530:	f7ff fe34 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
      APP_LCD_ExtPort_SerDataShift(cmd, 0);
 801d534:	4620      	mov	r0, r4
 801d536:	f7ff fe15 	bl	801d164 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0>
  }
  }

  return -3; // not supported
 801d53a:	f06f 0002 	mvn.w	r0, #2
}
 801d53e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      MIOS32_BOARD_J15_RS_Set(0); // RS pin used to control DC
 801d540:	f7f9 fe70 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
      MIOS32_BOARD_J15_SerDataShift(cmd);
 801d544:	4620      	mov	r0, r4
 801d546:	f7f9 fe39 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
 801d54a:	e7f6      	b.n	801d53a <APP_LCD_Cmd+0xa6>
    if( APP_LCD_PollUnbusy(10000) < 0 ) {
 801d54c:	f242 7010 	movw	r0, #10000	@ 0x2710
 801d550:	f7ff fea0 	bl	801d294 <APP_LCD_PollUnbusy>
 801d554:	2800      	cmp	r0, #0
 801d556:	dacb      	bge.n	801d4f0 <APP_LCD_Cmd+0x5c>
      display_available &= ~(1ULL << mios32_lcd_device);
 801d558:	7831      	ldrb	r1, [r6, #0]
 801d55a:	2201      	movs	r2, #1
 801d55c:	f1a1 0320 	sub.w	r3, r1, #32
 801d560:	f1c1 0020 	rsb	r0, r1, #32
 801d564:	fa22 f000 	lsr.w	r0, r2, r0
 801d568:	fa02 f303 	lsl.w	r3, r2, r3
 801d56c:	4303      	orrs	r3, r0
 801d56e:	408a      	lsls	r2, r1
 801d570:	e9d5 0100 	ldrd	r0, r1, [r5]
 801d574:	ea20 0002 	bic.w	r0, r0, r2
 801d578:	ea21 0103 	bic.w	r1, r1, r3
 801d57c:	e9c5 0100 	strd	r0, r1, [r5]
      return -2; // timeout
 801d580:	f06f 0001 	mvn.w	r0, #1
 801d584:	e7db      	b.n	801d53e <APP_LCD_Cmd+0xaa>
    return -1; // direct access disabled in testmode
 801d586:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801d58a:	e7d8      	b.n	801d53e <APP_LCD_Cmd+0xaa>
 801d58c:	200044ea 	.word	0x200044ea
 801d590:	20003148 	.word	0x20003148
 801d594:	200044f0 	.word	0x200044f0
 801d598:	2000314a 	.word	0x2000314a
 801d59c:	200044e9 	.word	0x200044e9

0801d5a0 <APP_LCD_Init>:
{
 801d5a0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if( lcd_testmode )
 801d5a4:	4bc4      	ldr	r3, [pc, #784]	@ (801d8b8 <APP_LCD_Init+0x318>)
 801d5a6:	781b      	ldrb	r3, [r3, #0]
 801d5a8:	b123      	cbz	r3, 801d5b4 <APP_LCD_Init+0x14>
    return -1; // direct access disabled in testmode
 801d5aa:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 801d5ae:	b002      	add	sp, #8
 801d5b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if( mode != 0 )
 801d5b4:	2800      	cmp	r0, #0
 801d5b6:	d1f8      	bne.n	801d5aa <APP_LCD_Init+0xa>
  if( mios32_lcd_device >= MAX_LCDS )
 801d5b8:	4fc0      	ldr	r7, [pc, #768]	@ (801d8bc <APP_LCD_Init+0x31c>)
 801d5ba:	783d      	ldrb	r5, [r7, #0]
 801d5bc:	2d3f      	cmp	r5, #63	@ 0x3f
 801d5be:	d902      	bls.n	801d5c6 <APP_LCD_Init+0x26>
    return -2; // unsupported LCD device number
 801d5c0:	f06f 0001 	mvn.w	r0, #1
 801d5c4:	e7f3      	b.n	801d5ae <APP_LCD_Init+0xe>
  display_available |= (1ULL << mios32_lcd_device);
 801d5c6:	2201      	movs	r2, #1
 801d5c8:	4cbd      	ldr	r4, [pc, #756]	@ (801d8c0 <APP_LCD_Init+0x320>)
  switch( mios32_lcd_parameters.lcd_type ) {
 801d5ca:	f8df 82f8 	ldr.w	r8, [pc, #760]	@ 801d8c4 <APP_LCD_Init+0x324>
  display_available |= (1ULL << mios32_lcd_device);
 801d5ce:	f1a5 0320 	sub.w	r3, r5, #32
 801d5d2:	f1c5 0120 	rsb	r1, r5, #32
 801d5d6:	fa22 f101 	lsr.w	r1, r2, r1
 801d5da:	fa02 f303 	lsl.w	r3, r2, r3
 801d5de:	430b      	orrs	r3, r1
 801d5e0:	e9d4 0100 	ldrd	r0, r1, [r4]
  switch( mios32_lcd_parameters.lcd_type ) {
 801d5e4:	f898 6000 	ldrb.w	r6, [r8]
  display_available |= (1ULL << mios32_lcd_device);
 801d5e8:	40aa      	lsls	r2, r5
 801d5ea:	4319      	orrs	r1, r3
 801d5ec:	4310      	orrs	r0, r2
  switch( mios32_lcd_parameters.lcd_type ) {
 801d5ee:	f1a6 0381 	sub.w	r3, r6, #129	@ 0x81
  display_available |= (1ULL << mios32_lcd_device);
 801d5f2:	e9c4 0100 	strd	r0, r1, [r4]
  switch( mios32_lcd_parameters.lcd_type ) {
 801d5f6:	2b05      	cmp	r3, #5
 801d5f8:	f200 80e8 	bhi.w	801d7cc <APP_LCD_Init+0x22c>
 801d5fc:	e8df f003 	tbb	[pc, r3]
 801d600:	68320303 	.word	0x68320303
 801d604:	2468      	.short	0x2468
    if( mios32_lcd_device < 2 ) { // only two E lines available
 801d606:	2d01      	cmp	r5, #1
 801d608:	d80c      	bhi.n	801d624 <APP_LCD_Init+0x84>
      if( MIOS32_BOARD_J15_PortInit(1) < 0 )
 801d60a:	2001      	movs	r0, #1
 801d60c:	f7f9 fd56 	bl	80170bc <MIOS32_BOARD_J15_PortInit>
 801d610:	2800      	cmp	r0, #0
 801d612:	dbd5      	blt.n	801d5c0 <APP_LCD_Init+0x20>
      APP_LCD_ExtPort_Init();
 801d614:	f7ff fe80 	bl	801d318 <APP_LCD_ExtPort_Init.isra.0>
      APP_LCD_Cmd(0x3e + 1);
 801d618:	203f      	movs	r0, #63	@ 0x3f
      APP_LCD_Cmd(0xae + 1);
 801d61a:	f7ff ff3b 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xc0 + 0);
 801d61e:	20c0      	movs	r0, #192	@ 0xc0
    APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 801d620:	f7ff ff38 	bl	801d494 <APP_LCD_Cmd>
  return (display_available & (1ULL << mios32_lcd_device)) ? 0 : -1; // return -1 if display not available
 801d624:	e9d4 0400 	ldrd	r0, r4, [r4]
 801d628:	7839      	ldrb	r1, [r7, #0]
 801d62a:	f1c1 0220 	rsb	r2, r1, #32
 801d62e:	f1a1 0320 	sub.w	r3, r1, #32
 801d632:	40c8      	lsrs	r0, r1
 801d634:	fa04 f202 	lsl.w	r2, r4, r2
 801d638:	4310      	orrs	r0, r2
 801d63a:	fa24 f303 	lsr.w	r3, r4, r3
 801d63e:	4318      	orrs	r0, r3
 801d640:	f000 0001 	and.w	r0, r0, #1
 801d644:	3801      	subs	r0, #1
 801d646:	e7b2      	b.n	801d5ae <APP_LCD_Init+0xe>
    if( mios32_lcd_device < 2 ) { // only two E lines available
 801d648:	2d01      	cmp	r5, #1
 801d64a:	d8eb      	bhi.n	801d624 <APP_LCD_Init+0x84>
      if( MIOS32_BOARD_J15_PortInit(1) < 0 )
 801d64c:	2001      	movs	r0, #1
 801d64e:	f7f9 fd35 	bl	80170bc <MIOS32_BOARD_J15_PortInit>
 801d652:	2800      	cmp	r0, #0
 801d654:	dbb4      	blt.n	801d5c0 <APP_LCD_Init+0x20>
      APP_LCD_ExtPort_Init();
 801d656:	f7ff fe5f 	bl	801d318 <APP_LCD_ExtPort_Init.isra.0>
      APP_LCD_Cmd(0xe2);
 801d65a:	20e2      	movs	r0, #226	@ 0xe2
 801d65c:	f7ff ff1a 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xae + 1);
 801d660:	20af      	movs	r0, #175	@ 0xaf
 801d662:	e7da      	b.n	801d61a <APP_LCD_Init+0x7a>
    if( mios32_lcd_device == 0 ) {
 801d664:	2d00      	cmp	r5, #0
 801d666:	d1dd      	bne.n	801d624 <APP_LCD_Init+0x84>
      if( MIOS32_BOARD_J15_PortInit(0) < 0 )
 801d668:	4628      	mov	r0, r5
 801d66a:	f7f9 fd27 	bl	80170bc <MIOS32_BOARD_J15_PortInit>
 801d66e:	2800      	cmp	r0, #0
 801d670:	dba6      	blt.n	801d5c0 <APP_LCD_Init+0x20>
      display_available |= 0xff;
 801d672:	6823      	ldr	r3, [r4, #0]
 801d674:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 801d678:	6023      	str	r3, [r4, #0]
      APP_LCD_SERGLCD_CS_Init(); // will also enhance display_available depending on total number of LCDs
 801d67a:	f7ff fe59 	bl	801d330 <APP_LCD_SERGLCD_CS_Init.isra.0>
      APP_LCD_Cmd(0x40); //2 - Display start line = 0
 801d67e:	2040      	movs	r0, #64	@ 0x40
 801d680:	f7ff ff08 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xA1); //8 - ADC Normal mode = 0 
 801d684:	20a1      	movs	r0, #161	@ 0xa1
 801d686:	f7ff ff05 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xC0); //15 - COMS normal = 1/65  duty
 801d68a:	20c0      	movs	r0, #192	@ 0xc0
 801d68c:	f7ff ff02 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xA6); //9 - Display  = normal  
 801d690:	20a6      	movs	r0, #166	@ 0xa6
 801d692:	f7ff feff 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xA2); //11 - 1/65 duty 1/9 bias for 65x132 display
 801d696:	20a2      	movs	r0, #162	@ 0xa2
 801d698:	f7ff fefc 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x2F); //16  - Power control set = B.,R,F all ON
 801d69c:	202f      	movs	r0, #47	@ 0x2f
 801d69e:	f7ff fef9 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xF8); //20-1 - select Booster ratio set
 801d6a2:	20f8      	movs	r0, #248	@ 0xf8
 801d6a4:	f7ff fef6 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x00); //20-2 - Booster ratio register (must be preceeded by 20-1)
 801d6a8:	4628      	mov	r0, r5
 801d6aa:	f7ff fef3 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x27); //17 - VO volt reg set 
 801d6ae:	2027      	movs	r0, #39	@ 0x27
 801d6b0:	f7ff fef0 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x81); //18-1 - Elect vol control - contrast
 801d6b4:	2081      	movs	r0, #129	@ 0x81
 801d6b6:	f7ff feed 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x10); //18-2 - Contrast level dec 16
 801d6ba:	2010      	movs	r0, #16
 801d6bc:	f7ff feea 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xAC); //19-1 - Static Indicator - set off
 801d6c0:	20ac      	movs	r0, #172	@ 0xac
 801d6c2:	f7ff fee7 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x00); //19-2 - No Indicator
 801d6c6:	4628      	mov	r0, r5
 801d6c8:	f7ff fee4 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xAF); //20 - Display ON
 801d6cc:	20af      	movs	r0, #175	@ 0xaf
 801d6ce:	e7a7      	b.n	801d620 <APP_LCD_Init+0x80>
    if( mios32_lcd_device == 0 ) {
 801d6d0:	2d00      	cmp	r5, #0
 801d6d2:	d1a7      	bne.n	801d624 <APP_LCD_Init+0x84>
      if( lcd_alt_pinning ) {
 801d6d4:	4b7c      	ldr	r3, [pc, #496]	@ (801d8c8 <APP_LCD_Init+0x328>)
 801d6d6:	781b      	ldrb	r3, [r3, #0]
 801d6d8:	2b00      	cmp	r3, #0
 801d6da:	d05d      	beq.n	801d798 <APP_LCD_Init+0x1f8>
	APP_LCD_ExtPort_Init();
 801d6dc:	f7ff fe1c 	bl	801d318 <APP_LCD_ExtPort_Init.isra.0>
    MIOS32_BOARD_J10_PinInit(pin + 12, MIOS32_BOARD_PIN_MODE_OUTPUT_PP);
 801d6e0:	2105      	movs	r1, #5
 801d6e2:	200c      	movs	r0, #12
 801d6e4:	f7f9 fcaa 	bl	801703c <MIOS32_BOARD_J10_PinInit>
 801d6e8:	2105      	movs	r1, #5
 801d6ea:	200d      	movs	r0, #13
 801d6ec:	f7f9 fca6 	bl	801703c <MIOS32_BOARD_J10_PinInit>
 801d6f0:	2105      	movs	r1, #5
 801d6f2:	200e      	movs	r0, #14
 801d6f4:	f7f9 fca2 	bl	801703c <MIOS32_BOARD_J10_PinInit>
 801d6f8:	2105      	movs	r1, #5
 801d6fa:	200f      	movs	r0, #15
 801d6fc:	f7f9 fc9e 	bl	801703c <MIOS32_BOARD_J10_PinInit>
	APP_LCD_ExtPort_PinSet(3, 0); // reset
 801d700:	4629      	mov	r1, r5
 801d702:	2003      	movs	r0, #3
 801d704:	f7ff fd4a 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	MIOS32_DELAY_Wait_uS(100);
 801d708:	2064      	movs	r0, #100	@ 0x64
 801d70a:	f7f9 fe5b 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
	APP_LCD_ExtPort_PinSet(3, 1);
 801d70e:	2101      	movs	r1, #1
 801d710:	2003      	movs	r0, #3
 801d712:	f7ff fd43 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	display_available |= 0x0f;
 801d716:	6823      	ldr	r3, [r4, #0]
 801d718:	f043 030f 	orr.w	r3, r3, #15
 801d71c:	6023      	str	r3, [r4, #0]
      APP_LCD_Cmd(0xa8); // Set MUX Ratio
 801d71e:	20a8      	movs	r0, #168	@ 0xa8
 801d720:	f7ff feb8 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x3f);
 801d724:	203f      	movs	r0, #63	@ 0x3f
 801d726:	f7ff feb5 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xd3); // Set Display Offset
 801d72a:	20d3      	movs	r0, #211	@ 0xd3
 801d72c:	f7ff feb2 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x00);
 801d730:	2000      	movs	r0, #0
 801d732:	f7ff feaf 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x40); // Set Display Start Line
 801d736:	2040      	movs	r0, #64	@ 0x40
 801d738:	f7ff feac 	bl	801d494 <APP_LCD_Cmd>
      if( !rotated ) {
 801d73c:	2e85      	cmp	r6, #133	@ 0x85
 801d73e:	d040      	beq.n	801d7c2 <APP_LCD_Init+0x222>
	APP_LCD_Cmd(0xa0); // Set Segment re-map
 801d740:	20a0      	movs	r0, #160	@ 0xa0
 801d742:	f7ff fea7 	bl	801d494 <APP_LCD_Cmd>
	APP_LCD_Cmd(0xc0); // Set COM Output Scan Direction
 801d746:	20c0      	movs	r0, #192	@ 0xc0
	APP_LCD_Cmd(0xc8); // Set COM Output Scan Direction: rotated
 801d748:	f7ff fea4 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xda); // Set COM Pins hardware configuration
 801d74c:	20da      	movs	r0, #218	@ 0xda
 801d74e:	f7ff fea1 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x12);
 801d752:	2012      	movs	r0, #18
 801d754:	f7ff fe9e 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x81); // Set Contrast Control
 801d758:	2081      	movs	r0, #129	@ 0x81
 801d75a:	f7ff fe9b 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x7f); // middle
 801d75e:	207f      	movs	r0, #127	@ 0x7f
 801d760:	f7ff fe98 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xa4); // Disable Entiere Display On
 801d764:	20a4      	movs	r0, #164	@ 0xa4
 801d766:	f7ff fe95 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xa6); // Set Normal Display
 801d76a:	20a6      	movs	r0, #166	@ 0xa6
 801d76c:	f7ff fe92 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xd5); // Set OSC Frequency
 801d770:	20d5      	movs	r0, #213	@ 0xd5
 801d772:	f7ff fe8f 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x80);
 801d776:	2080      	movs	r0, #128	@ 0x80
 801d778:	f7ff fe8c 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x8d); // Enable charge pump regulator
 801d77c:	208d      	movs	r0, #141	@ 0x8d
 801d77e:	f7ff fe89 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x14);
 801d782:	2014      	movs	r0, #20
 801d784:	f7ff fe86 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0xaf); // Display On
 801d788:	20af      	movs	r0, #175	@ 0xaf
 801d78a:	f7ff fe83 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x20); // Enable Page mode
 801d78e:	2020      	movs	r0, #32
 801d790:	f7ff fe80 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x02);
 801d794:	2002      	movs	r0, #2
 801d796:	e743      	b.n	801d620 <APP_LCD_Init+0x80>
	if( MIOS32_BOARD_J15_PortInit(0) < 0 )
 801d798:	4628      	mov	r0, r5
 801d79a:	f7f9 fc8f 	bl	80170bc <MIOS32_BOARD_J15_PortInit>
 801d79e:	2800      	cmp	r0, #0
 801d7a0:	f6ff af0e 	blt.w	801d5c0 <APP_LCD_Init+0x20>
	display_available |= 0xff;
 801d7a4:	6823      	ldr	r3, [r4, #0]
 801d7a6:	f043 03ff 	orr.w	r3, r3, #255	@ 0xff
 801d7aa:	6023      	str	r3, [r4, #0]
	APP_LCD_SERGLCD_CS_Init(); // will also enhance display_available depending on total number of LCDs
 801d7ac:	f7ff fdc0 	bl	801d330 <APP_LCD_SERGLCD_CS_Init.isra.0>
 801d7b0:	f44f 75fa 	mov.w	r5, #500	@ 0x1f4
	    MIOS32_DELAY_Wait_uS(1000);
 801d7b4:	f44f 707a 	mov.w	r0, #1000	@ 0x3e8
 801d7b8:	f7f9 fe04 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
	  for(i=0; i<500; ++i)
 801d7bc:	3d01      	subs	r5, #1
 801d7be:	d1f9      	bne.n	801d7b4 <APP_LCD_Init+0x214>
 801d7c0:	e7ad      	b.n	801d71e <APP_LCD_Init+0x17e>
	APP_LCD_Cmd(0xa1); // Set Segment re-map: rotated
 801d7c2:	20a1      	movs	r0, #161	@ 0xa1
 801d7c4:	f7ff fe66 	bl	801d494 <APP_LCD_Cmd>
	APP_LCD_Cmd(0xc8); // Set COM Output Scan Direction: rotated
 801d7c8:	20c8      	movs	r0, #200	@ 0xc8
 801d7ca:	e7bd      	b.n	801d748 <APP_LCD_Init+0x1a8>
    if( mios32_lcd_parameters.lcd_type == MIOS32_LCD_TYPE_CLCD_DOG ||
 801d7cc:	3e01      	subs	r6, #1
 801d7ce:	2e01      	cmp	r6, #1
 801d7d0:	d870      	bhi.n	801d8b4 <APP_LCD_Init+0x314>
      if( MIOS32_BOARD_J15_PortInit(0) < 0 )
 801d7d2:	2000      	movs	r0, #0
      if( MIOS32_BOARD_J15_PortInit(1) < 0 )
 801d7d4:	f7f9 fc72 	bl	80170bc <MIOS32_BOARD_J15_PortInit>
 801d7d8:	2800      	cmp	r0, #0
 801d7da:	f6ff aef1 	blt.w	801d5c0 <APP_LCD_Init+0x20>
    int num_lcds = mios32_lcd_parameters.num_x * mios32_lcd_parameters.num_y;
 801d7de:	f898 3001 	ldrb.w	r3, [r8, #1]
 801d7e2:	f898 2002 	ldrb.w	r2, [r8, #2]
 801d7e6:	fb13 f302 	smulbb	r3, r3, r2
    if( num_lcds >= 2 ) {
 801d7ea:	2b01      	cmp	r3, #1
 801d7ec:	dd01      	ble.n	801d7f2 <APP_LCD_Init+0x252>
      APP_LCD_ExtPort_Init();
 801d7ee:	f7ff fd93 	bl	801d318 <APP_LCD_ExtPort_Init.isra.0>
    MIOS32_BOARD_J15_DataSet(0x38);
 801d7f2:	2038      	movs	r0, #56	@ 0x38
 801d7f4:	f7f9 fcbe 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
    MIOS32_BOARD_J15_RS_Set(0);
 801d7f8:	2000      	movs	r0, #0
 801d7fa:	f7f9 fd13 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    MIOS32_BOARD_J15_RW_Set(0);
 801d7fe:	2000      	movs	r0, #0
 801d800:	f7f9 fd1c 	bl	801723c <MIOS32_BOARD_J15_RW_Set>
    APP_LCD_E_Set(1);
 801d804:	2001      	movs	r0, #1
 801d806:	f7ff fd07 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801d80a:	2000      	movs	r0, #0
 801d80c:	f7ff fd04 	bl	801d218 <APP_LCD_E_Set>
    MIOS32_DELAY_Wait_uS(5000); // according to the hitachi datasheet, this command takes 37 uS - take 1 mS to be at the secure side
 801d810:	f241 3088 	movw	r0, #5000	@ 0x1388
 801d814:	f7f9 fdd6 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
    APP_LCD_E_Set(1);
 801d818:	2001      	movs	r0, #1
 801d81a:	f7ff fcfd 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801d81e:	2000      	movs	r0, #0
 801d820:	f7ff fcfa 	bl	801d218 <APP_LCD_E_Set>
    MIOS32_DELAY_Wait_uS(500); // and now only 500 uS anymore
 801d824:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 801d828:	f7f9 fdcc 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
    APP_LCD_E_Set(1);
 801d82c:	2001      	movs	r0, #1
 801d82e:	f7ff fcf3 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801d832:	2000      	movs	r0, #0
 801d834:	f7ff fcf0 	bl	801d218 <APP_LCD_E_Set>
    MIOS32_DELAY_Wait_uS(500);
 801d838:	f44f 70fa 	mov.w	r0, #500	@ 0x1f4
 801d83c:	f7f9 fdc2 	bl	80173c4 <MIOS32_DELAY_Wait_uS>
    APP_LCD_Cmd(0x08); // Display Off
 801d840:	2008      	movs	r0, #8
 801d842:	f7ff fe27 	bl	801d494 <APP_LCD_Cmd>
    if( !(display_available & (1ULL << mios32_lcd_device)) )
 801d846:	e9d4 3500 	ldrd	r3, r5, [r4]
 801d84a:	7838      	ldrb	r0, [r7, #0]
 801d84c:	f1c0 0120 	rsb	r1, r0, #32
 801d850:	f1a0 0220 	sub.w	r2, r0, #32
 801d854:	40c3      	lsrs	r3, r0
 801d856:	fa05 f101 	lsl.w	r1, r5, r1
 801d85a:	430b      	orrs	r3, r1
 801d85c:	fa25 f202 	lsr.w	r2, r5, r2
 801d860:	4313      	orrs	r3, r2
 801d862:	07db      	lsls	r3, r3, #31
 801d864:	f57f aea1 	bpl.w	801d5aa <APP_LCD_Init+0xa>
    APP_LCD_Cmd(0x0c); // Display On
 801d868:	200c      	movs	r0, #12
 801d86a:	f7ff fe13 	bl	801d494 <APP_LCD_Cmd>
    APP_LCD_Cmd(0x06); // Entry Mode
 801d86e:	2006      	movs	r0, #6
 801d870:	f7ff fe10 	bl	801d494 <APP_LCD_Cmd>
    APP_LCD_Cmd(0x01); // Clear Display
 801d874:	2001      	movs	r0, #1
 801d876:	f7ff fe0d 	bl	801d494 <APP_LCD_Cmd>
    if( mios32_lcd_parameters.lcd_type == MIOS32_LCD_TYPE_CLCD_DOG ) {
 801d87a:	f898 3000 	ldrb.w	r3, [r8]
 801d87e:	2b01      	cmp	r3, #1
 801d880:	d113      	bne.n	801d8aa <APP_LCD_Init+0x30a>
      APP_LCD_Cmd(0x39); // 8bit interface, switch to instruction table 1
 801d882:	2039      	movs	r0, #57	@ 0x39
 801d884:	f7ff fe06 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x1d); // BS: 1/4, 3 line LCD
 801d888:	201d      	movs	r0, #29
 801d88a:	f7ff fe03 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x50); // Booster off, set contrast C5/C4
 801d88e:	2050      	movs	r0, #80	@ 0x50
 801d890:	f7ff fe00 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x6c); // set Voltage follower and amplifier
 801d894:	206c      	movs	r0, #108	@ 0x6c
 801d896:	f7ff fdfd 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x7c); // set contrast C3/C2/C1
 801d89a:	207c      	movs	r0, #124	@ 0x7c
 801d89c:	f7ff fdfa 	bl	801d494 <APP_LCD_Cmd>
      u8 cursor_map[] = {0x00, 0x10, 0x20, 0x30}; // offset line 0/1/2/3
 801d8a0:	4b0a      	ldr	r3, [pc, #40]	@ (801d8cc <APP_LCD_Init+0x32c>)
 801d8a2:	9301      	str	r3, [sp, #4]
      MIOS32_LCD_CursorMapSet(cursor_map);
 801d8a4:	a801      	add	r0, sp, #4
 801d8a6:	f7f6 ff03 	bl	80146b0 <MIOS32_LCD_CursorMapSet>
    APP_LCD_Cmd(0x38); // experience from PIC based MIOS: without these lines
 801d8aa:	2038      	movs	r0, #56	@ 0x38
 801d8ac:	f7ff fdf2 	bl	801d494 <APP_LCD_Cmd>
    APP_LCD_Cmd(0x0c); // the LCD won't work correctly after a second APP_LCD_Init
 801d8b0:	200c      	movs	r0, #12
 801d8b2:	e6b5      	b.n	801d620 <APP_LCD_Init+0x80>
      if( MIOS32_BOARD_J15_PortInit(1) < 0 )
 801d8b4:	2001      	movs	r0, #1
 801d8b6:	e78d      	b.n	801d7d4 <APP_LCD_Init+0x234>
 801d8b8:	200044ea 	.word	0x200044ea
 801d8bc:	20003148 	.word	0x20003148
 801d8c0:	200044f0 	.word	0x200044f0
 801d8c4:	2000314a 	.word	0x2000314a
 801d8c8:	200044e9 	.word	0x200044e9
 801d8cc:	30201000 	.word	0x30201000

0801d8d0 <APP_LCD_Data>:
{
 801d8d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if( lcd_testmode )
 801d8d4:	4b6b      	ldr	r3, [pc, #428]	@ (801da84 <APP_LCD_Data+0x1b4>)
 801d8d6:	781b      	ldrb	r3, [r3, #0]
{
 801d8d8:	4606      	mov	r6, r0
  if( lcd_testmode )
 801d8da:	2b00      	cmp	r3, #0
 801d8dc:	f040 80cf 	bne.w	801da7e <APP_LCD_Data+0x1ae>
  if( !(display_available & (1ULL << mios32_lcd_device)) )
 801d8e0:	f8df 81a4 	ldr.w	r8, [pc, #420]	@ 801da88 <APP_LCD_Data+0x1b8>
 801d8e4:	4c69      	ldr	r4, [pc, #420]	@ (801da8c <APP_LCD_Data+0x1bc>)
 801d8e6:	f898 2000 	ldrb.w	r2, [r8]
 801d8ea:	e9d4 3500 	ldrd	r3, r5, [r4]
 801d8ee:	f1c2 0020 	rsb	r0, r2, #32
 801d8f2:	f1a2 0120 	sub.w	r1, r2, #32
 801d8f6:	40d3      	lsrs	r3, r2
 801d8f8:	fa05 f000 	lsl.w	r0, r5, r0
 801d8fc:	fa25 f101 	lsr.w	r1, r5, r1
 801d900:	4303      	orrs	r3, r0
 801d902:	430b      	orrs	r3, r1
 801d904:	07d9      	lsls	r1, r3, #31
 801d906:	f140 80ba 	bpl.w	801da7e <APP_LCD_Data+0x1ae>
  switch( mios32_lcd_parameters.lcd_type ) {
 801d90a:	4d61      	ldr	r5, [pc, #388]	@ (801da90 <APP_LCD_Data+0x1c0>)
 801d90c:	782b      	ldrb	r3, [r5, #0]
 801d90e:	3b81      	subs	r3, #129	@ 0x81
 801d910:	2b05      	cmp	r3, #5
 801d912:	f200 80a0 	bhi.w	801da56 <APP_LCD_Data+0x186>
 801d916:	e8df f003 	tbb	[pc, r3]
 801d91a:	0303      	.short	0x0303
 801d91c:	0377775c 	.word	0x0377775c
    if( mios32_lcd_device >= 2 )
 801d920:	2a01      	cmp	r2, #1
 801d922:	f200 80ac 	bhi.w	801da7e <APP_LCD_Data+0x1ae>
    if( mios32_lcd_x >= mios32_lcd_parameters.width || mios32_lcd_y >= mios32_lcd_parameters.height )
 801d926:	4f5b      	ldr	r7, [pc, #364]	@ (801da94 <APP_LCD_Data+0x1c4>)
 801d928:	88aa      	ldrh	r2, [r5, #4]
 801d92a:	883b      	ldrh	r3, [r7, #0]
 801d92c:	429a      	cmp	r2, r3
 801d92e:	f240 80a6 	bls.w	801da7e <APP_LCD_Data+0x1ae>
 801d932:	4b59      	ldr	r3, [pc, #356]	@ (801da98 <APP_LCD_Data+0x1c8>)
 801d934:	88ea      	ldrh	r2, [r5, #6]
 801d936:	881b      	ldrh	r3, [r3, #0]
 801d938:	429a      	cmp	r2, r3
 801d93a:	f240 80a0 	bls.w	801da7e <APP_LCD_Data+0x1ae>
    APP_LCD_GLCD_CS_Set(0); // select display depending on current X position
 801d93e:	2000      	movs	r0, #0
 801d940:	f7ff fc3c 	bl	801d1bc <APP_LCD_GLCD_CS_Set.isra.0>
    if( APP_LCD_PollUnbusy(2500) < 0 ) {
 801d944:	f640 10c4 	movw	r0, #2500	@ 0x9c4
 801d948:	f7ff fca4 	bl	801d294 <APP_LCD_PollUnbusy>
 801d94c:	2800      	cmp	r0, #0
 801d94e:	da19      	bge.n	801d984 <APP_LCD_Data+0xb4>
      display_available &= ~(1ULL << mios32_lcd_device);
 801d950:	f898 0000 	ldrb.w	r0, [r8]
 801d954:	2201      	movs	r2, #1
 801d956:	f1a0 0320 	sub.w	r3, r0, #32
 801d95a:	f1c0 0120 	rsb	r1, r0, #32
 801d95e:	fa02 f303 	lsl.w	r3, r2, r3
 801d962:	fa22 f101 	lsr.w	r1, r2, r1
 801d966:	fa02 f000 	lsl.w	r0, r2, r0
 801d96a:	4319      	orrs	r1, r3
 801d96c:	e9d4 2300 	ldrd	r2, r3, [r4]
 801d970:	ea22 0200 	bic.w	r2, r2, r0
 801d974:	ea23 0301 	bic.w	r3, r3, r1
 801d978:	e9c4 2300 	strd	r2, r3, [r4]
      return -2; // timeout
 801d97c:	f06f 0001 	mvn.w	r0, #1
}
 801d980:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MIOS32_BOARD_J15_DataSet(data);
 801d984:	4630      	mov	r0, r6
 801d986:	f7f9 fbf5 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
    MIOS32_BOARD_J15_RS_Set(1);
 801d98a:	2001      	movs	r0, #1
 801d98c:	f7f9 fc4a 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    APP_LCD_E_Set(1);
 801d990:	2001      	movs	r0, #1
 801d992:	f7ff fc41 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801d996:	2000      	movs	r0, #0
 801d998:	f7ff fc3e 	bl	801d218 <APP_LCD_E_Set>
    if( mios32_lcd_parameters.lcd_type == MIOS32_LCD_TYPE_GLCD_SED1520 ) {
 801d99c:	782b      	ldrb	r3, [r5, #0]
 801d99e:	2b86      	cmp	r3, #134	@ 0x86
 801d9a0:	d10c      	bne.n	801d9bc <APP_LCD_Data+0xec>
      if( (++mios32_lcd_x % 61) == 0 )
 801d9a2:	8838      	ldrh	r0, [r7, #0]
 801d9a4:	3001      	adds	r0, #1
 801d9a6:	b280      	uxth	r0, r0
 801d9a8:	233d      	movs	r3, #61	@ 0x3d
 801d9aa:	8038      	strh	r0, [r7, #0]
 801d9ac:	fbb0 f2f3 	udiv	r2, r0, r3
 801d9b0:	fb03 0012 	mls	r0, r3, r2, r0
 801d9b4:	b280      	uxth	r0, r0
 801d9b6:	b140      	cbz	r0, 801d9ca <APP_LCD_Data+0xfa>
    return 0; // no error
 801d9b8:	2000      	movs	r0, #0
 801d9ba:	e7e1      	b.n	801d980 <APP_LCD_Data+0xb0>
      if( (++mios32_lcd_x % 64) == 0 )
 801d9bc:	883b      	ldrh	r3, [r7, #0]
 801d9be:	3301      	adds	r3, #1
 801d9c0:	b29b      	uxth	r3, r3
 801d9c2:	803b      	strh	r3, [r7, #0]
 801d9c4:	069b      	lsls	r3, r3, #26
 801d9c6:	d1f7      	bne.n	801d9b8 <APP_LCD_Data+0xe8>
	return APP_LCD_Cmd(0x40 + 0);
 801d9c8:	2040      	movs	r0, #64	@ 0x40
}
 801d9ca:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      return APP_LCD_Cmd(0x00); // Set lower nibble to 0
 801d9ce:	f7ff bd61 	b.w	801d494 <APP_LCD_Cmd>
    APP_LCD_SERGLCD_CS_Set(1, 0);
 801d9d2:	2000      	movs	r0, #0
 801d9d4:	f7ff fcc6 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
    MIOS32_BOARD_J15_RS_Set(1); // RS pin used to control A0
 801d9d8:	2001      	movs	r0, #1
 801d9da:	f7f9 fc23 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    MIOS32_BOARD_J15_SerDataShift(data);
 801d9de:	4630      	mov	r0, r6
 801d9e0:	f7f9 fbec 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
    ++mios32_lcd_x;
 801d9e4:	4a2b      	ldr	r2, [pc, #172]	@ (801da94 <APP_LCD_Data+0x1c4>)
 801d9e6:	8813      	ldrh	r3, [r2, #0]
 801d9e8:	3301      	adds	r3, #1
 801d9ea:	b29b      	uxth	r3, r3
 801d9ec:	8013      	strh	r3, [r2, #0]
    if( (mios32_lcd_x % mios32_lcd_parameters.width) == 0 ) {
 801d9ee:	88aa      	ldrh	r2, [r5, #4]
 801d9f0:	fbb3 f1f2 	udiv	r1, r3, r2
 801d9f4:	fb02 3311 	mls	r3, r2, r1, r3
 801d9f8:	b29c      	uxth	r4, r3
 801d9fa:	2c00      	cmp	r4, #0
 801d9fc:	d1dc      	bne.n	801d9b8 <APP_LCD_Data+0xe8>
      APP_LCD_Cmd(0x10); // Set upper nibble to 0
 801d9fe:	2010      	movs	r0, #16
 801da00:	f7ff fd48 	bl	801d494 <APP_LCD_Cmd>
      return APP_LCD_Cmd(0x00); // Set lower nibble to 0
 801da04:	4620      	mov	r0, r4
 801da06:	e7e0      	b.n	801d9ca <APP_LCD_Data+0xfa>
    APP_LCD_SERGLCD_CS_Set(1, 0);
 801da08:	2000      	movs	r0, #0
 801da0a:	f7ff fcab 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
    if( lcd_alt_pinning ) {
 801da0e:	4b23      	ldr	r3, [pc, #140]	@ (801da9c <APP_LCD_Data+0x1cc>)
 801da10:	781b      	ldrb	r3, [r3, #0]
 801da12:	b1cb      	cbz	r3, 801da48 <APP_LCD_Data+0x178>
      APP_LCD_ExtPort_PinSet(2, 1); // DC
 801da14:	2002      	movs	r0, #2
 801da16:	2101      	movs	r1, #1
 801da18:	f7ff fbc0 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
      APP_LCD_ExtPort_SerDataShift(data, 0);
 801da1c:	4630      	mov	r0, r6
 801da1e:	f7ff fba1 	bl	801d164 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0>
    ++mios32_lcd_x;
 801da22:	4b1c      	ldr	r3, [pc, #112]	@ (801da94 <APP_LCD_Data+0x1c4>)
 801da24:	8818      	ldrh	r0, [r3, #0]
 801da26:	3001      	adds	r0, #1
 801da28:	b280      	uxth	r0, r0
 801da2a:	8018      	strh	r0, [r3, #0]
    if( (mios32_lcd_x % mios32_lcd_parameters.width) == 0 ) {
 801da2c:	88ab      	ldrh	r3, [r5, #4]
 801da2e:	fbb0 f2f3 	udiv	r2, r0, r3
 801da32:	fb03 0012 	mls	r0, r3, r2, r0
 801da36:	b280      	uxth	r0, r0
 801da38:	2800      	cmp	r0, #0
 801da3a:	d1bd      	bne.n	801d9b8 <APP_LCD_Data+0xe8>
      APP_LCD_Cmd(0x00); // set X=0
 801da3c:	f7ff fd2a 	bl	801d494 <APP_LCD_Cmd>
      APP_LCD_Cmd(0x10);
 801da40:	2010      	movs	r0, #16
 801da42:	f7ff fd27 	bl	801d494 <APP_LCD_Cmd>
 801da46:	e7b7      	b.n	801d9b8 <APP_LCD_Data+0xe8>
      MIOS32_BOARD_J15_RS_Set(1); // RS pin used to control DC
 801da48:	2001      	movs	r0, #1
 801da4a:	f7f9 fbeb 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
      MIOS32_BOARD_J15_SerDataShift(data);
 801da4e:	4630      	mov	r0, r6
 801da50:	f7f9 fbb4 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
 801da54:	e7e5      	b.n	801da22 <APP_LCD_Data+0x152>
    if( APP_LCD_PollUnbusy(2500) < 0 ) {
 801da56:	f640 10c4 	movw	r0, #2500	@ 0x9c4
 801da5a:	f7ff fc1b 	bl	801d294 <APP_LCD_PollUnbusy>
 801da5e:	2800      	cmp	r0, #0
 801da60:	f6ff af76 	blt.w	801d950 <APP_LCD_Data+0x80>
    MIOS32_BOARD_J15_DataSet(data);
 801da64:	4630      	mov	r0, r6
 801da66:	f7f9 fb85 	bl	8017174 <MIOS32_BOARD_J15_DataSet>
    MIOS32_BOARD_J15_RS_Set(1);
 801da6a:	2001      	movs	r0, #1
 801da6c:	f7f9 fbda 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
    APP_LCD_E_Set(1);
 801da70:	2001      	movs	r0, #1
 801da72:	f7ff fbd1 	bl	801d218 <APP_LCD_E_Set>
    APP_LCD_E_Set(0);
 801da76:	2000      	movs	r0, #0
 801da78:	f7ff fbce 	bl	801d218 <APP_LCD_E_Set>
    return 0; // no error
 801da7c:	e79c      	b.n	801d9b8 <APP_LCD_Data+0xe8>
    return -1; // direct access disabled in testmode
 801da7e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801da82:	e77d      	b.n	801d980 <APP_LCD_Data+0xb0>
 801da84:	200044ea 	.word	0x200044ea
 801da88:	20003148 	.word	0x20003148
 801da8c:	200044f0 	.word	0x200044f0
 801da90:	2000314a 	.word	0x2000314a
 801da94:	2000313e 	.word	0x2000313e
 801da98:	2000313c 	.word	0x2000313c
 801da9c:	200044e9 	.word	0x200044e9

0801daa0 <APP_LCD_Clear>:
// Clear Screen
// IN: -
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_Clear(void)
{
 801daa0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if( lcd_testmode )
 801daa4:	4b46      	ldr	r3, [pc, #280]	@ (801dbc0 <APP_LCD_Clear+0x120>)
 801daa6:	781b      	ldrb	r3, [r3, #0]
 801daa8:	2b00      	cmp	r3, #0
 801daaa:	f040 8085 	bne.w	801dbb8 <APP_LCD_Clear+0x118>
    return -1; // direct access disabled in testmode

  switch( mios32_lcd_parameters.lcd_type ) {
 801daae:	4d45      	ldr	r5, [pc, #276]	@ (801dbc4 <APP_LCD_Clear+0x124>)
 801dab0:	782b      	ldrb	r3, [r5, #0]
 801dab2:	3b81      	subs	r3, #129	@ 0x81
 801dab4:	2b05      	cmp	r3, #5
 801dab6:	d87a      	bhi.n	801dbae <APP_LCD_Clear+0x10e>
 801dab8:	e8df f003 	tbb	[pc, r3]
 801dabc:	45240303 	.word	0x45240303
 801dac0:	0345      	.short	0x0345
  case MIOS32_LCD_TYPE_GLCD_SED1520: {
    s32 error = 0;
    int x, y;

    // use default font
    MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
 801dac2:	4841      	ldr	r0, [pc, #260]	@ (801dbc8 <APP_LCD_Clear+0x128>)
 801dac4:	f7f6 fe02 	bl	80146cc <MIOS32_LCD_FontInit>

    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801dac8:	2600      	movs	r6, #0
    s32 error = 0;
 801daca:	4634      	mov	r4, r6
    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801dacc:	88eb      	ldrh	r3, [r5, #6]
 801dace:	ebb6 0fd3 	cmp.w	r6, r3, lsr #3
 801dad2:	db06      	blt.n	801dae2 <APP_LCD_Clear+0x42>
	  MIOS32_BOARD_J15_SerDataShift(0x00);
      }
    }

    // set X=0, Y=0
    error |= MIOS32_LCD_CursorSet(0, 0);
 801dad4:	2100      	movs	r1, #0
 801dad6:	4608      	mov	r0, r1
 801dad8:	f7f6 fdbe 	bl	8014658 <MIOS32_LCD_CursorSet>
 801dadc:	4320      	orrs	r0, r4
    // -> send clear command
    return APP_LCD_Cmd(0x01);
  }

  return -3; // not supported
}
 801dade:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      error |= MIOS32_LCD_CursorSet(0, y);
 801dae2:	b2b1      	uxth	r1, r6
 801dae4:	2000      	movs	r0, #0
 801dae6:	f7f6 fdb7 	bl	8014658 <MIOS32_LCD_CursorSet>
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801daea:	2700      	movs	r7, #0
      error |= MIOS32_LCD_CursorSet(0, y);
 801daec:	4304      	orrs	r4, r0
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801daee:	88ab      	ldrh	r3, [r5, #4]
 801daf0:	42bb      	cmp	r3, r7
 801daf2:	dc01      	bgt.n	801daf8 <APP_LCD_Clear+0x58>
    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801daf4:	3601      	adds	r6, #1
 801daf6:	e7e9      	b.n	801dacc <APP_LCD_Clear+0x2c>
	error |= APP_LCD_Data(0x00);
 801daf8:	2000      	movs	r0, #0
 801dafa:	f7ff fee9 	bl	801d8d0 <APP_LCD_Data>
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801dafe:	3701      	adds	r7, #1
	error |= APP_LCD_Data(0x00);
 801db00:	4304      	orrs	r4, r0
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db02:	e7f4      	b.n	801daee <APP_LCD_Clear+0x4e>
    MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
 801db04:	4830      	ldr	r0, [pc, #192]	@ (801dbc8 <APP_LCD_Clear+0x128>)
 801db06:	f7f6 fde1 	bl	80146cc <MIOS32_LCD_FontInit>
    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801db0a:	2600      	movs	r6, #0
    s32 error = 0;
 801db0c:	4634      	mov	r4, r6
    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801db0e:	88eb      	ldrh	r3, [r5, #6]
 801db10:	b2f1      	uxtb	r1, r6
 801db12:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
 801db16:	d2dd      	bcs.n	801dad4 <APP_LCD_Clear+0x34>
      error |= MIOS32_LCD_CursorSet(0, y);
 801db18:	2000      	movs	r0, #0
 801db1a:	f7f6 fd9d 	bl	8014658 <MIOS32_LCD_CursorSet>
 801db1e:	4304      	orrs	r4, r0
      APP_LCD_SERGLCD_CS_Set(1, 1);
 801db20:	2001      	movs	r0, #1
 801db22:	f7ff fc1f 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
      MIOS32_BOARD_J15_RS_Set(1); // RS pin used to control DC
 801db26:	2001      	movs	r0, #1
 801db28:	f7f9 fb7c 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db2c:	2700      	movs	r7, #0
 801db2e:	88aa      	ldrh	r2, [r5, #4]
 801db30:	b2fb      	uxtb	r3, r7
 801db32:	429a      	cmp	r2, r3
 801db34:	f107 0701 	add.w	r7, r7, #1
 801db38:	d801      	bhi.n	801db3e <APP_LCD_Clear+0x9e>
    for(y=0; y<(mios32_lcd_parameters.height/8); ++y) {
 801db3a:	3601      	adds	r6, #1
 801db3c:	e7e7      	b.n	801db0e <APP_LCD_Clear+0x6e>
	MIOS32_BOARD_J15_SerDataShift(0x00);
 801db3e:	2000      	movs	r0, #0
 801db40:	f7f9 fb3c 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
      for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db44:	e7f3      	b.n	801db2e <APP_LCD_Clear+0x8e>
    MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
 801db46:	4820      	ldr	r0, [pc, #128]	@ (801dbc8 <APP_LCD_Clear+0x128>)
      if( lcd_alt_pinning ) {
 801db48:	f8df 8080 	ldr.w	r8, [pc, #128]	@ 801dbcc <APP_LCD_Clear+0x12c>
    MIOS32_LCD_FontInit((u8 *)GLCD_FONT_NORMAL);
 801db4c:	f7f6 fdbe 	bl	80146cc <MIOS32_LCD_FontInit>
    for(y=0; y<mios32_lcd_parameters.height/8; ++y) {
 801db50:	2700      	movs	r7, #0
    s32 error = 0;
 801db52:	463c      	mov	r4, r7
    for(y=0; y<mios32_lcd_parameters.height/8; ++y) {
 801db54:	88eb      	ldrh	r3, [r5, #6]
 801db56:	b2f9      	uxtb	r1, r7
 801db58:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
 801db5c:	d2ba      	bcs.n	801dad4 <APP_LCD_Clear+0x34>
      error |= MIOS32_LCD_CursorSet(0, y);
 801db5e:	2000      	movs	r0, #0
 801db60:	f7f6 fd7a 	bl	8014658 <MIOS32_LCD_CursorSet>
 801db64:	4304      	orrs	r4, r0
      APP_LCD_SERGLCD_CS_Set(1, 1);
 801db66:	2001      	movs	r0, #1
 801db68:	f7ff fbfc 	bl	801d364 <APP_LCD_SERGLCD_CS_Set.constprop.0.isra.0>
      if( lcd_alt_pinning ) {
 801db6c:	f898 6000 	ldrb.w	r6, [r8]
 801db70:	b186      	cbz	r6, 801db94 <APP_LCD_Clear+0xf4>
	APP_LCD_ExtPort_PinSet(2, 1); // DC
 801db72:	2101      	movs	r1, #1
 801db74:	2002      	movs	r0, #2
 801db76:	f7ff fb11 	bl	801d19c <APP_LCD_ExtPort_PinSet.isra.0>
	for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db7a:	2600      	movs	r6, #0
 801db7c:	88aa      	ldrh	r2, [r5, #4]
 801db7e:	b2f3      	uxtb	r3, r6
 801db80:	429a      	cmp	r2, r3
 801db82:	f106 0601 	add.w	r6, r6, #1
 801db86:	d801      	bhi.n	801db8c <APP_LCD_Clear+0xec>
    for(y=0; y<mios32_lcd_parameters.height/8; ++y) {
 801db88:	3701      	adds	r7, #1
 801db8a:	e7e3      	b.n	801db54 <APP_LCD_Clear+0xb4>
	  APP_LCD_ExtPort_SerDataShift(0x00, 0);
 801db8c:	2000      	movs	r0, #0
 801db8e:	f7ff fae9 	bl	801d164 <APP_LCD_ExtPort_SerDataShift.constprop.0.isra.0>
	for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db92:	e7f3      	b.n	801db7c <APP_LCD_Clear+0xdc>
	MIOS32_BOARD_J15_RS_Set(1); // RS pin used to control DC
 801db94:	2001      	movs	r0, #1
 801db96:	f7f9 fb45 	bl	8017224 <MIOS32_BOARD_J15_RS_Set>
	for(x=0; x<mios32_lcd_parameters.width; ++x)
 801db9a:	88aa      	ldrh	r2, [r5, #4]
 801db9c:	b2f3      	uxtb	r3, r6
 801db9e:	429a      	cmp	r2, r3
 801dba0:	f106 0601 	add.w	r6, r6, #1
 801dba4:	d9f0      	bls.n	801db88 <APP_LCD_Clear+0xe8>
	  MIOS32_BOARD_J15_SerDataShift(0x00);
 801dba6:	2000      	movs	r0, #0
 801dba8:	f7f9 fb08 	bl	80171bc <MIOS32_BOARD_J15_SerDataShift>
	for(x=0; x<mios32_lcd_parameters.width; ++x)
 801dbac:	e7f5      	b.n	801db9a <APP_LCD_Clear+0xfa>
}
 801dbae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return APP_LCD_Cmd(0x01);
 801dbb2:	2001      	movs	r0, #1
 801dbb4:	f7ff bc6e 	b.w	801d494 <APP_LCD_Cmd>
    return -1; // direct access disabled in testmode
 801dbb8:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801dbbc:	e78f      	b.n	801dade <APP_LCD_Clear+0x3e>
 801dbbe:	bf00      	nop
 801dbc0:	200044ea 	.word	0x200044ea
 801dbc4:	2000314a 	.word	0x2000314a
 801dbc8:	08027173 	.word	0x08027173
 801dbcc:	200044e9 	.word	0x200044e9

0801dbd0 <APP_LCD_GCursorSet>:
// Sets graphical cursor to given position
// IN: <x> and <y>
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_GCursorSet(u16 x, u16 y)
{
 801dbd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if( lcd_testmode )
 801dbd2:	4b31      	ldr	r3, [pc, #196]	@ (801dc98 <APP_LCD_GCursorSet+0xc8>)
 801dbd4:	781b      	ldrb	r3, [r3, #0]
{
 801dbd6:	4606      	mov	r6, r0
 801dbd8:	460d      	mov	r5, r1
  if( lcd_testmode )
 801dbda:	2b00      	cmp	r3, #0
 801dbdc:	d156      	bne.n	801dc8c <APP_LCD_GCursorSet+0xbc>
    return -1; // direct access disabled in testmode

  switch( mios32_lcd_parameters.lcd_type ) {
 801dbde:	4f2f      	ldr	r7, [pc, #188]	@ (801dc9c <APP_LCD_GCursorSet+0xcc>)
 801dbe0:	783b      	ldrb	r3, [r7, #0]
 801dbe2:	3b81      	subs	r3, #129	@ 0x81
 801dbe4:	2b05      	cmp	r3, #5
 801dbe6:	d854      	bhi.n	801dc92 <APP_LCD_GCursorSet+0xc2>
 801dbe8:	e8df f003 	tbb	[pc, r3]
 801dbec:	3f1e0303 	.word	0x3f1e0303
 801dbf0:	123f      	.short	0x123f
  case MIOS32_LCD_TYPE_GLCD_KS0108:
  case MIOS32_LCD_TYPE_GLCD_KS0108_INVCS: {
    s32 error = 0;

    // set X position
    error |= APP_LCD_Cmd(0x40 | (x % 64));
 801dbf2:	f000 003f 	and.w	r0, r0, #63	@ 0x3f
 801dbf6:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 801dbfa:	f7ff fc4b 	bl	801d494 <APP_LCD_Cmd>
 801dbfe:	4604      	mov	r4, r0

    // set Y position
    error |= APP_LCD_Cmd(0xb8 | ((y>>3) & 0x7));
 801dc00:	f3c5 00c2 	ubfx	r0, r5, #3, #3
#else
    error |= APP_LCD_Cmd(0x00 | (x % 64));
#endif

    // set Y position
    error |= APP_LCD_Cmd(0xb8 | ((y>>3) & 0x3));
 801dc04:	f040 00b8 	orr.w	r0, r0, #184	@ 0xb8
    // set X position
    error |= APP_LCD_Cmd(0x00 | (x & 0xf));
    error |= APP_LCD_Cmd(0x10 | ((x>>4) & 0xf));

    // set Y position
    error |= APP_LCD_Cmd(0xb0 | ((y>>3) & 7));
 801dc08:	f7ff fc44 	bl	801d494 <APP_LCD_Cmd>
 801dc0c:	4320      	orrs	r0, r4
    return error;
  } break;
  }

  return -3; // not supported
}
 801dc0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    error |= APP_LCD_Cmd(0x00 | (x % 61));
 801dc10:	233d      	movs	r3, #61	@ 0x3d
 801dc12:	fbb0 f0f3 	udiv	r0, r0, r3
 801dc16:	fb03 6010 	mls	r0, r3, r0, r6
 801dc1a:	b2c0      	uxtb	r0, r0
 801dc1c:	f7ff fc3a 	bl	801d494 <APP_LCD_Cmd>
 801dc20:	4604      	mov	r4, r0
    error |= APP_LCD_Cmd(0xb8 | ((y>>3) & 0x3));
 801dc22:	f3c5 00c1 	ubfx	r0, r5, #3, #2
 801dc26:	e7ed      	b.n	801dc04 <APP_LCD_GCursorSet+0x34>
    error |= APP_LCD_Cmd(0x10 | (((x % mios32_lcd_parameters.width) >> 4) & 0x0f));   // First send MSB nibble
 801dc28:	88bb      	ldrh	r3, [r7, #4]
 801dc2a:	fbb0 f0f3 	udiv	r0, r0, r3
 801dc2e:	fb03 6010 	mls	r0, r3, r0, r6
 801dc32:	f3c0 1003 	ubfx	r0, r0, #4, #4
 801dc36:	f040 0010 	orr.w	r0, r0, #16
 801dc3a:	f7ff fc2b 	bl	801d494 <APP_LCD_Cmd>
    error |= APP_LCD_Cmd(0x00 | ((x % mios32_lcd_parameters.width) & 0x0f)); // Then send LSB nibble
 801dc3e:	88bb      	ldrh	r3, [r7, #4]
    error |= APP_LCD_Cmd(0x10 | (((x % mios32_lcd_parameters.width) >> 4) & 0x0f));   // First send MSB nibble
 801dc40:	4604      	mov	r4, r0
    error |= APP_LCD_Cmd(0x00 | ((x % mios32_lcd_parameters.width) & 0x0f)); // Then send LSB nibble
 801dc42:	fbb6 f0f3 	udiv	r0, r6, r3
 801dc46:	fb03 6010 	mls	r0, r3, r0, r6
 801dc4a:	f000 000f 	and.w	r0, r0, #15
 801dc4e:	f7ff fc21 	bl	801d494 <APP_LCD_Cmd>
    error |= APP_LCD_Cmd(0xb0 | ((y>>3) % (mios32_lcd_parameters.height/8)));
 801dc52:	88fb      	ldrh	r3, [r7, #6]
 801dc54:	08ed      	lsrs	r5, r5, #3
 801dc56:	08db      	lsrs	r3, r3, #3
 801dc58:	fbb5 f2f3 	udiv	r2, r5, r3
 801dc5c:	fb03 5512 	mls	r5, r3, r2, r5
    error |= APP_LCD_Cmd(0x00 | ((x % mios32_lcd_parameters.width) & 0x0f)); // Then send LSB nibble
 801dc60:	4304      	orrs	r4, r0
    error |= APP_LCD_Cmd(0xb0 | ((y>>3) % (mios32_lcd_parameters.height/8)));
 801dc62:	f065 004f 	orn	r0, r5, #79	@ 0x4f
 801dc66:	b2c0      	uxtb	r0, r0
 801dc68:	e7ce      	b.n	801dc08 <APP_LCD_GCursorSet+0x38>
    error |= APP_LCD_Cmd(0x00 | (x & 0xf));
 801dc6a:	f000 000f 	and.w	r0, r0, #15
 801dc6e:	f7ff fc11 	bl	801d494 <APP_LCD_Cmd>
 801dc72:	4604      	mov	r4, r0
    error |= APP_LCD_Cmd(0x10 | ((x>>4) & 0xf));
 801dc74:	f3c6 1003 	ubfx	r0, r6, #4, #4
 801dc78:	f040 0010 	orr.w	r0, r0, #16
 801dc7c:	f7ff fc0a 	bl	801d494 <APP_LCD_Cmd>
 801dc80:	4304      	orrs	r4, r0
    error |= APP_LCD_Cmd(0xb0 | ((y>>3) & 7));
 801dc82:	f3c5 00c2 	ubfx	r0, r5, #3, #3
 801dc86:	f040 00b0 	orr.w	r0, r0, #176	@ 0xb0
 801dc8a:	e7bd      	b.n	801dc08 <APP_LCD_GCursorSet+0x38>
    return -1; // direct access disabled in testmode
 801dc8c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801dc90:	e7bd      	b.n	801dc0e <APP_LCD_GCursorSet+0x3e>
  switch( mios32_lcd_parameters.lcd_type ) {
 801dc92:	f06f 0002 	mvn.w	r0, #2
 801dc96:	e7ba      	b.n	801dc0e <APP_LCD_GCursorSet+0x3e>
 801dc98:	200044ea 	.word	0x200044ea
 801dc9c:	2000314a 	.word	0x2000314a

0801dca0 <APP_LCD_CursorSet>:
  if( lcd_testmode )
 801dca0:	4b0d      	ldr	r3, [pc, #52]	@ (801dcd8 <APP_LCD_CursorSet+0x38>)
 801dca2:	781b      	ldrb	r3, [r3, #0]
 801dca4:	b9a3      	cbnz	r3, 801dcd0 <APP_LCD_CursorSet+0x30>
  if( mios32_lcd_parameters.lcd_type >= 0x80 ) { // GLCD
 801dca6:	4b0d      	ldr	r3, [pc, #52]	@ (801dcdc <APP_LCD_CursorSet+0x3c>)
 801dca8:	f993 3000 	ldrsb.w	r3, [r3]
 801dcac:	2b00      	cmp	r3, #0
 801dcae:	da05      	bge.n	801dcbc <APP_LCD_CursorSet+0x1c>
    return APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
 801dcb0:	4b0b      	ldr	r3, [pc, #44]	@ (801dce0 <APP_LCD_CursorSet+0x40>)
 801dcb2:	8819      	ldrh	r1, [r3, #0]
 801dcb4:	4b0b      	ldr	r3, [pc, #44]	@ (801dce4 <APP_LCD_CursorSet+0x44>)
 801dcb6:	8818      	ldrh	r0, [r3, #0]
 801dcb8:	f7ff bf8a 	b.w	801dbd0 <APP_LCD_GCursorSet>
    if( line >= MIOS32_LCD_MAX_MAP_LINES )
 801dcbc:	2903      	cmp	r1, #3
 801dcbe:	d807      	bhi.n	801dcd0 <APP_LCD_CursorSet+0x30>
    return APP_LCD_Cmd(0x80 | (mios32_lcd_cursor_map[line] + column));
 801dcc0:	4b09      	ldr	r3, [pc, #36]	@ (801dce8 <APP_LCD_CursorSet+0x48>)
 801dcc2:	5c5b      	ldrb	r3, [r3, r1]
 801dcc4:	4418      	add	r0, r3
 801dcc6:	f060 007f 	orn	r0, r0, #127	@ 0x7f
 801dcca:	b2c0      	uxtb	r0, r0
 801dccc:	f7ff bbe2 	b.w	801d494 <APP_LCD_Cmd>
}
 801dcd0:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801dcd4:	4770      	bx	lr
 801dcd6:	bf00      	nop
 801dcd8:	200044ea 	.word	0x200044ea
 801dcdc:	2000314a 	.word	0x2000314a
 801dce0:	2000313c 	.word	0x2000313c
 801dce4:	2000313e 	.word	0x2000313e
 801dce8:	20003140 	.word	0x20003140

0801dcec <APP_LCD_BColourSet>:
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BColourSet(u32 rgb)
{
  return -3; // not supported
}
 801dcec:	f06f 0002 	mvn.w	r0, #2
 801dcf0:	4770      	bx	lr

0801dcf2 <APP_LCD_FColourSet>:
// Sets the foreground colour
// Only relevant for colour GLCDs
// IN: r/g/b value
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_FColourSet(u32 rgb)
 801dcf2:	f06f 0002 	mvn.w	r0, #2
 801dcf6:	4770      	bx	lr

0801dcf8 <APP_LCD_BitmapPrint>:
// Transfers a Bitmap within given boundaries to the LCD
// IN: bitmap
// OUT: returns < 0 on errors
/////////////////////////////////////////////////////////////////////////////
s32 APP_LCD_BitmapPrint(mios32_lcd_bitmap_t bitmap)
{
 801dcf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801dcfc:	b085      	sub	sp, #20
 801dcfe:	ab04      	add	r3, sp, #16
 801dd00:	e903 0007 	stmdb	r3, {r0, r1, r2}
  if( lcd_testmode )
 801dd04:	4b24      	ldr	r3, [pc, #144]	@ (801dd98 <APP_LCD_BitmapPrint+0xa0>)
 801dd06:	781c      	ldrb	r4, [r3, #0]
 801dd08:	b124      	cbz	r4, 801dd14 <APP_LCD_BitmapPrint+0x1c>
    return -1; // direct access disabled in testmode
 801dd0a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
    mios32_lcd_y = initial_y;
    APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
  }

  return 0; // no error
}
 801dd0e:	b005      	add	sp, #20
 801dd10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if( !MIOS32_LCD_TypeIsGLCD() )
 801dd14:	f7f6 fc92 	bl	801463c <MIOS32_LCD_TypeIsGLCD>
 801dd18:	2800      	cmp	r0, #0
 801dd1a:	d0f6      	beq.n	801dd0a <APP_LCD_BitmapPrint+0x12>
  if( mios32_lcd_x >= mios32_lcd_parameters.width )
 801dd1c:	f8df a07c 	ldr.w	sl, [pc, #124]	@ 801dd9c <APP_LCD_BitmapPrint+0xa4>
 801dd20:	4b1f      	ldr	r3, [pc, #124]	@ (801dda0 <APP_LCD_BitmapPrint+0xa8>)
 801dd22:	f8ba 7000 	ldrh.w	r7, [sl]
 801dd26:	889b      	ldrh	r3, [r3, #4]
 801dd28:	42bb      	cmp	r3, r7
 801dd2a:	d932      	bls.n	801dd92 <APP_LCD_BitmapPrint+0x9a>
  u16 initial_y = mios32_lcd_y;
 801dd2c:	f8df 9074 	ldr.w	r9, [pc, #116]	@ 801dda4 <APP_LCD_BitmapPrint+0xac>
  int y_lines = (bitmap.height >> 3);
 801dd30:	f8bd 500a 	ldrh.w	r5, [sp, #10]
  u16 initial_y = mios32_lcd_y;
 801dd34:	f8b9 8000 	ldrh.w	r8, [r9]
  int y_lines = (bitmap.height >> 3);
 801dd38:	08ed      	lsrs	r5, r5, #3
  for(line=0; line<y_lines; ++line) {
 801dd3a:	42ac      	cmp	r4, r5
 801dd3c:	db02      	blt.n	801dd44 <APP_LCD_BitmapPrint+0x4c>
  if( y_lines >= 1 ) {
 801dd3e:	bb05      	cbnz	r5, 801dd82 <APP_LCD_BitmapPrint+0x8a>
  return 0; // no error
 801dd40:	2000      	movs	r0, #0
 801dd42:	e7e4      	b.n	801dd0e <APP_LCD_BitmapPrint+0x16>
    u8 *memory_ptr = bitmap.memory + line * bitmap.line_offset;
 801dd44:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801dd48:	9e01      	ldr	r6, [sp, #4]
 801dd4a:	fb04 6603 	mla	r6, r4, r3, r6
    if( line > 0 ) {
 801dd4e:	b154      	cbz	r4, 801dd66 <APP_LCD_BitmapPrint+0x6e>
      mios32_lcd_y += 8;
 801dd50:	f8b9 1000 	ldrh.w	r1, [r9]
      mios32_lcd_x = initial_x;
 801dd54:	f8aa 7000 	strh.w	r7, [sl]
      mios32_lcd_y += 8;
 801dd58:	3108      	adds	r1, #8
 801dd5a:	b289      	uxth	r1, r1
      APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
 801dd5c:	4638      	mov	r0, r7
      mios32_lcd_y += 8;
 801dd5e:	f8a9 1000 	strh.w	r1, [r9]
      APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
 801dd62:	f7ff ff35 	bl	801dbd0 <APP_LCD_GCursorSet>
{
 801dd66:	46b3      	mov	fp, r6
    for(x=0; x<bitmap.width; ++x)
 801dd68:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 801dd6c:	ebab 0306 	sub.w	r3, fp, r6
 801dd70:	429a      	cmp	r2, r3
 801dd72:	dc01      	bgt.n	801dd78 <APP_LCD_BitmapPrint+0x80>
  for(line=0; line<y_lines; ++line) {
 801dd74:	3401      	adds	r4, #1
 801dd76:	e7e0      	b.n	801dd3a <APP_LCD_BitmapPrint+0x42>
      APP_LCD_Data(*memory_ptr++);
 801dd78:	f81b 0b01 	ldrb.w	r0, [fp], #1
 801dd7c:	f7ff fda8 	bl	801d8d0 <APP_LCD_Data>
    for(x=0; x<bitmap.width; ++x)
 801dd80:	e7f2      	b.n	801dd68 <APP_LCD_BitmapPrint+0x70>
    APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
 801dd82:	f8ba 0000 	ldrh.w	r0, [sl]
    mios32_lcd_y = initial_y;
 801dd86:	f8a9 8000 	strh.w	r8, [r9]
    APP_LCD_GCursorSet(mios32_lcd_x, mios32_lcd_y);
 801dd8a:	4641      	mov	r1, r8
 801dd8c:	f7ff ff20 	bl	801dbd0 <APP_LCD_GCursorSet>
 801dd90:	e7d6      	b.n	801dd40 <APP_LCD_BitmapPrint+0x48>
    return -2;
 801dd92:	f06f 0001 	mvn.w	r0, #1
 801dd96:	e7ba      	b.n	801dd0e <APP_LCD_BitmapPrint+0x16>
 801dd98:	200044ea 	.word	0x200044ea
 801dd9c:	2000313e 	.word	0x2000313e
 801dda0:	2000314a 	.word	0x2000314a
 801dda4:	2000313c 	.word	0x2000313c

0801dda8 <AINSER_SetCs.isra.0>:


/////////////////////////////////////////////////////////////////////////////
// Internal function to set CS line depending on module
/////////////////////////////////////////////////////////////////////////////
static s32 AINSER_SetCs(u8 module, u8 value)
 801dda8:	460a      	mov	r2, r1
{
  switch( module ) {
 801ddaa:	4601      	mov	r1, r0
 801ddac:	b110      	cbz	r0, 801ddb4 <AINSER_SetCs.isra.0+0xc>
 801ddae:	2801      	cmp	r0, #1
 801ddb0:	d000      	beq.n	801ddb4 <AINSER_SetCs.isra.0+0xc>
 801ddb2:	4770      	bx	lr
  case 0: return MIOS32_SPI_RC_PinSet(AINSER_SPI, AINSER_SPI_RC_PIN_MODULE1, value); // spi, rc_pin, pin_value
  case 1: return MIOS32_SPI_RC_PinSet(AINSER_SPI, AINSER_SPI_RC_PIN_MODULE2, value); // spi, rc_pin, pin_value
 801ddb4:	2002      	movs	r0, #2
 801ddb6:	f7f8 be17 	b.w	80169e8 <MIOS32_SPI_RC_PinSet>
	...

0801ddbc <AINSER_Init>:
{
 801ddbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if( mode != 0 )
 801ddbe:	4604      	mov	r4, r0
 801ddc0:	bb28      	cbnz	r0, 801de0e <AINSER_Init+0x52>
  status |= MIOS32_SPI_IO_Init(AINSER_SPI, MIOS32_SPI_PIN_DRIVER_STRONG);
 801ddc2:	4601      	mov	r1, r0
 801ddc4:	2002      	movs	r0, #2
 801ddc6:	f7f8 fcdb 	bl	8016780 <MIOS32_SPI_IO_Init>
    num_used_pins[module] = AINSER_NUM_PINS;
 801ddca:	4e12      	ldr	r6, [pc, #72]	@ (801de14 <AINSER_Init+0x58>)
  num_used_modules = AINSER_NUM_MODULES;
 801ddcc:	4b12      	ldr	r3, [pc, #72]	@ (801de18 <AINSER_Init+0x5c>)
 801ddce:	2201      	movs	r2, #1
    num_used_pins[module] = AINSER_NUM_PINS;
 801ddd0:	2740      	movs	r7, #64	@ 0x40
  case 0: return MIOS32_SPI_RC_PinSet(AINSER_SPI, AINSER_SPI_RC_PIN_MODULE1, value); // spi, rc_pin, pin_value
 801ddd2:	4621      	mov	r1, r4
  status |= MIOS32_SPI_IO_Init(AINSER_SPI, MIOS32_SPI_PIN_DRIVER_STRONG);
 801ddd4:	4605      	mov	r5, r0
  case 0: return MIOS32_SPI_RC_PinSet(AINSER_SPI, AINSER_SPI_RC_PIN_MODULE1, value); // spi, rc_pin, pin_value
 801ddd6:	2002      	movs	r0, #2
  num_used_modules = AINSER_NUM_MODULES;
 801ddd8:	701a      	strb	r2, [r3, #0]
    num_used_pins[module] = AINSER_NUM_PINS;
 801ddda:	7037      	strb	r7, [r6, #0]
  case 0: return MIOS32_SPI_RC_PinSet(AINSER_SPI, AINSER_SPI_RC_PIN_MODULE1, value); // spi, rc_pin, pin_value
 801dddc:	f7f8 fe04 	bl	80169e8 <MIOS32_SPI_RC_PinSet>
    ainser_enable_mask |= (1 << module);
 801dde0:	4a0e      	ldr	r2, [pc, #56]	@ (801de1c <AINSER_Init+0x60>)
      ain_pin_values[module][pin] = 0;
 801dde2:	480f      	ldr	r0, [pc, #60]	@ (801de20 <AINSER_Init+0x64>)
    ainser_enable_mask |= (1 << module);
 801dde4:	7813      	ldrb	r3, [r2, #0]
  num_used_pins[module] = num_pins;
 801dde6:	7037      	strb	r7, [r6, #0]
    ainser_enable_mask |= (1 << module);
 801dde8:	f043 0301 	orr.w	r3, r3, #1
 801ddec:	7013      	strb	r3, [r2, #0]
    ainser_muxed_mask |= (1 << module);
 801ddee:	4a0d      	ldr	r2, [pc, #52]	@ (801de24 <AINSER_Init+0x68>)
 801ddf0:	7813      	ldrb	r3, [r2, #0]
 801ddf2:	f043 0301 	orr.w	r3, r3, #1
 801ddf6:	7013      	strb	r3, [r2, #0]
  ain_deadband[module] = deadband;
 801ddf8:	4b0b      	ldr	r3, [pc, #44]	@ (801de28 <AINSER_Init+0x6c>)
 801ddfa:	220f      	movs	r2, #15
 801ddfc:	701a      	strb	r2, [r3, #0]
      ain_pin_values[module][pin] = 0;
 801ddfe:	4621      	mov	r1, r4
 801de00:	2280      	movs	r2, #128	@ 0x80
 801de02:	f005 fba6 	bl	8023552 <memset>
    previous_ain_pin_value = 0;
 801de06:	4b09      	ldr	r3, [pc, #36]	@ (801de2c <AINSER_Init+0x70>)
 801de08:	801c      	strh	r4, [r3, #0]
}
 801de0a:	4628      	mov	r0, r5
 801de0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return -1; // unsupported mode
 801de0e:	f04f 35ff 	mov.w	r5, #4294967295	@ 0xffffffff
 801de12:	e7fa      	b.n	801de0a <AINSER_Init+0x4e>
 801de14:	20004580 	.word	0x20004580
 801de18:	2000005d 	.word	0x2000005d
 801de1c:	20004582 	.word	0x20004582
 801de20:	20004500 	.word	0x20004500
 801de24:	20004581 	.word	0x20004581
 801de28:	200044fd 	.word	0x200044fd
 801de2c:	200044fe 	.word	0x200044fe

0801de30 <AINSER_NumModulesSet>:
  if( num_modules >= AINSER_NUM_MODULES )
 801de30:	b910      	cbnz	r0, 801de38 <AINSER_NumModulesSet+0x8>
  num_used_modules = num_modules;
 801de32:	4b03      	ldr	r3, [pc, #12]	@ (801de40 <AINSER_NumModulesSet+0x10>)
 801de34:	7018      	strb	r0, [r3, #0]
  return 0; // no error
 801de36:	4770      	bx	lr
    return -1;
 801de38:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 801de3c:	4770      	bx	lr
 801de3e:	bf00      	nop
 801de40:	2000005d 	.word	0x2000005d

0801de44 <AINSER_MuxedSet>:
  if( module >= AINSER_NUM_MODULES )
 801de44:	b950      	cbnz	r0, 801de5c <AINSER_MuxedSet+0x18>
    ainser_muxed_mask |= (1 << module);
 801de46:	4a07      	ldr	r2, [pc, #28]	@ (801de64 <AINSER_MuxedSet+0x20>)
 801de48:	7813      	ldrb	r3, [r2, #0]
  if( muxed )
 801de4a:	b121      	cbz	r1, 801de56 <AINSER_MuxedSet+0x12>
    ainser_muxed_mask |= (1 << module);
 801de4c:	f043 0301 	orr.w	r3, r3, #1
 801de50:	7013      	strb	r3, [r2, #0]
  return 0; // no error
 801de52:	2000      	movs	r0, #0
 801de54:	4770      	bx	lr
    ainser_muxed_mask &= ~(1 << module);
 801de56:	f003 03fe 	and.w	r3, r3, #254	@ 0xfe
 801de5a:	e7f9      	b.n	801de50 <AINSER_MuxedSet+0xc>
    return -1; // invalid module
 801de5c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
}
 801de60:	4770      	bx	lr
 801de62:	bf00      	nop
 801de64:	20004581 	.word	0x20004581

0801de68 <AINSER_NumPinsSet>:
  if( module >= AINSER_NUM_MODULES )
 801de68:	b920      	cbnz	r0, 801de74 <AINSER_NumPinsSet+0xc>
  if( num_pins > AINSER_NUM_PINS )
 801de6a:	2940      	cmp	r1, #64	@ 0x40
 801de6c:	d805      	bhi.n	801de7a <AINSER_NumPinsSet+0x12>
  num_used_pins[module] = num_pins;
 801de6e:	4b04      	ldr	r3, [pc, #16]	@ (801de80 <AINSER_NumPinsSet+0x18>)
 801de70:	7019      	strb	r1, [r3, #0]
  return 0; // no error
 801de72:	4770      	bx	lr
    return -1; // invalid module
 801de74:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801de78:	4770      	bx	lr
    return -2;
 801de7a:	f06f 0001 	mvn.w	r0, #1
}
 801de7e:	4770      	bx	lr
 801de80:	20004580 	.word	0x20004580

0801de84 <AINSER_Handler>:
{
 801de84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  const u8 mux_pin_map[8] = {6, 3, 4, 2, 5, 0, 7, 1 }; // order of MUX channels
 801de88:	4a60      	ldr	r2, [pc, #384]	@ (801e00c <AINSER_Handler+0x188>)
      previous_ain_pin_value = ain_pin_values[module][pin];
 801de8a:	f8df 9184 	ldr.w	r9, [pc, #388]	@ 801e010 <AINSER_Handler+0x18c>
  const u8 mux_pin_map[8] = {6, 3, 4, 2, 5, 0, 7, 1 }; // order of MUX channels
 801de8e:	6851      	ldr	r1, [r2, #4]
{
 801de90:	b089      	sub	sp, #36	@ 0x24
 801de92:	4680      	mov	r8, r0
  const u8 mux_pin_map[8] = {6, 3, 4, 2, 5, 0, 7, 1 }; // order of MUX channels
 801de94:	6810      	ldr	r0, [r2, #0]
 801de96:	ab06      	add	r3, sp, #24
 801de98:	c303      	stmia	r3!, {r0, r1}
  status |= MIOS32_SPI_TransferModeInit(AINSER_SPI, MIOS32_SPI_MODE_CLK0_PHASE0, MIOS32_SPI_PRESCALER_64);
 801de9a:	2205      	movs	r2, #5
 801de9c:	2100      	movs	r1, #0
 801de9e:	2002      	movs	r0, #2
 801dea0:	f7f8 fdf2 	bl	8016a88 <MIOS32_SPI_TransferModeInit>
  ++link_status_ctr;
 801dea4:	4a5b      	ldr	r2, [pc, #364]	@ (801e014 <AINSER_Handler+0x190>)
  int next_mux_ctr = (mux_ctr + 1) % 8;
 801dea6:	4b5c      	ldr	r3, [pc, #368]	@ (801e018 <AINSER_Handler+0x194>)
 801dea8:	781e      	ldrb	r6, [r3, #0]
  ++link_status_ctr;
 801deaa:	8813      	ldrh	r3, [r2, #0]
 801deac:	3301      	adds	r3, #1
 801deae:	b29b      	uxth	r3, r3
  u32 pwm_duty = ((link_status_ctr / pwm_period) % pwm_sweep_steps) / (pwm_sweep_steps/pwm_period);
 801deb0:	2064      	movs	r0, #100	@ 0x64
 801deb2:	2114      	movs	r1, #20
  ++link_status_ctr;
 801deb4:	8013      	strh	r3, [r2, #0]
  u32 pwm_duty = ((link_status_ctr / pwm_period) % pwm_sweep_steps) / (pwm_sweep_steps/pwm_period);
 801deb6:	fbb3 f2f1 	udiv	r2, r3, r1
 801deba:	fbb2 f4f0 	udiv	r4, r2, r0
 801debe:	fb00 2214 	mls	r2, r0, r4, r2
  if( (link_status_ctr % (2*pwm_period*pwm_sweep_steps)) > pwm_period*pwm_sweep_steps )
 801dec2:	f44f 647a 	mov.w	r4, #4000	@ 0xfa0
  u32 pwm_duty = ((link_status_ctr / pwm_period) % pwm_sweep_steps) / (pwm_sweep_steps/pwm_period);
 801dec6:	2005      	movs	r0, #5
 801dec8:	fbb2 f2f0 	udiv	r2, r2, r0
  if( (link_status_ctr % (2*pwm_period*pwm_sweep_steps)) > pwm_period*pwm_sweep_steps )
 801decc:	fbb3 f0f4 	udiv	r0, r3, r4
 801ded0:	fb04 3010 	mls	r0, r4, r0, r3
 801ded4:	f5b0 6ffa 	cmp.w	r0, #2000	@ 0x7d0
    pwm_duty = pwm_period-pwm_duty; // negative direction each 20*25 ticks
 801ded8:	bf88      	it	hi
 801deda:	1a8a      	subhi	r2, r1, r2
  u32 link_status = ((link_status_ctr % pwm_period) > pwm_duty) ? 1 : 0;
 801dedc:	fbb3 f0f1 	udiv	r0, r3, r1
 801dee0:	fb01 3310 	mls	r3, r1, r0, r3
 801dee4:	4293      	cmp	r3, r2
  int next_mux_ctr = (mux_ctr + 1) % 8;
 801dee6:	f106 0601 	add.w	r6, r6, #1
  u32 link_status = ((link_status_ctr % pwm_period) > pwm_duty) ? 1 : 0;
 801deea:	bf94      	ite	ls
 801deec:	2300      	movls	r3, #0
 801deee:	2301      	movhi	r3, #1
  int next_mux_ctr = (mux_ctr + 1) % 8;
 801def0:	f006 0607 	and.w	r6, r6, #7
  u32 link_status = ((link_status_ctr % pwm_period) > pwm_duty) ? 1 : 0;
 801def4:	9301      	str	r3, [sp, #4]
  u32 module_mask = 1;
 801def6:	2701      	movs	r7, #1
  for(module=0; module<num_used_modules; ++module, module_mask <<= 1) {
 801def8:	f04f 0a00 	mov.w	sl, #0
 801defc:	4b47      	ldr	r3, [pc, #284]	@ (801e01c <AINSER_Handler+0x198>)
 801defe:	7819      	ldrb	r1, [r3, #0]
 801df00:	4551      	cmp	r1, sl
      u8 b2 = MIOS32_SPI_TransferByte(AINSER_SPI, ((chn == 7 ? next_mux_ctr : mux_ctr) << 5) | link_status);
 801df02:	b2f2      	uxtb	r2, r6
  for(module=0; module<num_used_modules; ++module, module_mask <<= 1) {
 801df04:	dc09      	bgt.n	801df1a <AINSER_Handler+0x96>
  mux_ctr = next_mux_ctr;
 801df06:	4b44      	ldr	r3, [pc, #272]	@ (801e018 <AINSER_Handler+0x194>)
 801df08:	701a      	strb	r2, [r3, #0]
  if( next_mux_ctr == 0 )
 801df0a:	b916      	cbnz	r6, 801df12 <AINSER_Handler+0x8e>
    first_scan_done = 1;
 801df0c:	4b44      	ldr	r3, [pc, #272]	@ (801e020 <AINSER_Handler+0x19c>)
 801df0e:	2201      	movs	r2, #1
 801df10:	701a      	strb	r2, [r3, #0]
}
 801df12:	2000      	movs	r0, #0
 801df14:	b009      	add	sp, #36	@ 0x24
 801df16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( !(ainser_enable_mask & module_mask) )
 801df1a:	4b42      	ldr	r3, [pc, #264]	@ (801e024 <AINSER_Handler+0x1a0>)
 801df1c:	7819      	ldrb	r1, [r3, #0]
 801df1e:	4239      	tst	r1, r7
 801df20:	d103      	bne.n	801df2a <AINSER_Handler+0xa6>
  for(module=0; module<num_used_modules; ++module, module_mask <<= 1) {
 801df22:	f10a 0a01 	add.w	sl, sl, #1
 801df26:	007f      	lsls	r7, r7, #1
 801df28:	e7e8      	b.n	801defc <AINSER_Handler+0x78>
    u8 muxed = ainser_muxed_mask & module_mask;
 801df2a:	493f      	ldr	r1, [pc, #252]	@ (801e028 <AINSER_Handler+0x1a4>)
 801df2c:	7809      	ldrb	r1, [r1, #0]
 801df2e:	ea01 0307 	and.w	r3, r1, r7
 801df32:	9302      	str	r3, [sp, #8]
      u8 b2 = MIOS32_SPI_TransferByte(AINSER_SPI, ((chn == 7 ? next_mux_ctr : mux_ctr) << 5) | link_status);
 801df34:	0153      	lsls	r3, r2, #5
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801df36:	4a3d      	ldr	r2, [pc, #244]	@ (801e02c <AINSER_Handler+0x1a8>)
      u8 b2 = MIOS32_SPI_TransferByte(AINSER_SPI, ((chn == 7 ? next_mux_ctr : mux_ctr) << 5) | link_status);
 801df38:	9303      	str	r3, [sp, #12]
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801df3a:	eb0a 0302 	add.w	r3, sl, r2
    for(chn=0; chn<8; ++chn) {
 801df3e:	2400      	movs	r4, #0
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801df40:	9304      	str	r3, [sp, #16]
      status |= AINSER_SetCs(module, 0);
 801df42:	fa5f fb8a 	uxtb.w	fp, sl
 801df46:	2100      	movs	r1, #0
 801df48:	4658      	mov	r0, fp
 801df4a:	f7ff ff2d 	bl	801dda8 <AINSER_SetCs.isra.0>
      MIOS32_SPI_TransferByte(AINSER_SPI, 0x06 | (chn>>2));
 801df4e:	f3c4 0187 	ubfx	r1, r4, #2, #8
 801df52:	f041 0106 	orr.w	r1, r1, #6
 801df56:	2002      	movs	r0, #2
 801df58:	f7f8 fd7c 	bl	8016a54 <MIOS32_SPI_TransferByte>
      u8 b1 = MIOS32_SPI_TransferByte(AINSER_SPI, chn << 6);
 801df5c:	01a1      	lsls	r1, r4, #6
 801df5e:	f001 01c0 	and.w	r1, r1, #192	@ 0xc0
 801df62:	2002      	movs	r0, #2
 801df64:	f7f8 fd76 	bl	8016a54 <MIOS32_SPI_TransferByte>
      u8 b2 = MIOS32_SPI_TransferByte(AINSER_SPI, ((chn == 7 ? next_mux_ctr : mux_ctr) << 5) | link_status);
 801df68:	2c07      	cmp	r4, #7
 801df6a:	bf18      	it	ne
 801df6c:	492a      	ldrne	r1, [pc, #168]	@ (801e018 <AINSER_Handler+0x194>)
 801df6e:	9b01      	ldr	r3, [sp, #4]
 801df70:	bf14      	ite	ne
 801df72:	7809      	ldrbne	r1, [r1, #0]
 801df74:	9903      	ldreq	r1, [sp, #12]
 801df76:	9005      	str	r0, [sp, #20]
 801df78:	bf1c      	itt	ne
 801df7a:	0149      	lslne	r1, r1, #5
 801df7c:	b2c9      	uxtbne	r1, r1
 801df7e:	4319      	orrs	r1, r3
 801df80:	2002      	movs	r0, #2
 801df82:	f7f8 fd67 	bl	8016a54 <MIOS32_SPI_TransferByte>
      AINSER_SetCs(module, 1);
 801df86:	2101      	movs	r1, #1
      u8 b2 = MIOS32_SPI_TransferByte(AINSER_SPI, ((chn == 7 ? next_mux_ctr : mux_ctr) << 5) | link_status);
 801df88:	b2c5      	uxtb	r5, r0
      AINSER_SetCs(module, 1);
 801df8a:	4658      	mov	r0, fp
 801df8c:	f7ff ff0c 	bl	801dda8 <AINSER_SetCs.isra.0>
      u16 pin = muxed ? (mux_pin_map[mux_ctr] + 8*(7-chn)) : (7-chn); // the mux/chn -> pin mapping is layout dependend
 801df90:	9b02      	ldr	r3, [sp, #8]
 801df92:	9a05      	ldr	r2, [sp, #20]
 801df94:	b303      	cbz	r3, 801dfd8 <AINSER_Handler+0x154>
 801df96:	4920      	ldr	r1, [pc, #128]	@ (801e018 <AINSER_Handler+0x194>)
 801df98:	7809      	ldrb	r1, [r1, #0]
 801df9a:	f101 0320 	add.w	r3, r1, #32
 801df9e:	eb0d 0103 	add.w	r1, sp, r3
 801dfa2:	ebc4 3044 	rsb	r0, r4, r4, lsl #13
 801dfa6:	f811 1c08 	ldrb.w	r1, [r1, #-8]
 801dfaa:	3138      	adds	r1, #56	@ 0x38
 801dfac:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
 801dfb0:	b289      	uxth	r1, r1
      previous_ain_pin_value = ain_pin_values[module][pin];
 801dfb2:	eb01 1c8a 	add.w	ip, r1, sl, lsl #6
 801dfb6:	4b1e      	ldr	r3, [pc, #120]	@ (801e030 <AINSER_Handler+0x1ac>)
 801dfb8:	f839 001c 	ldrh.w	r0, [r9, ip, lsl #1]
 801dfbc:	8018      	strh	r0, [r3, #0]
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801dfbe:	4b18      	ldr	r3, [pc, #96]	@ (801e020 <AINSER_Handler+0x19c>)
 801dfc0:	781b      	ldrb	r3, [r3, #0]
      u16 value = (b2 | (b1 << 8)) & 0xfff;
 801dfc2:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 801dfc6:	f3c5 020b 	ubfx	r2, r5, #0, #12
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801dfca:	b943      	cbnz	r3, 801dfde <AINSER_Handler+0x15a>
	ain_pin_values[module][pin] = value;
 801dfcc:	f829 201c 	strh.w	r2, [r9, ip, lsl #1]
    for(chn=0; chn<8; ++chn) {
 801dfd0:	3401      	adds	r4, #1
 801dfd2:	2c08      	cmp	r4, #8
 801dfd4:	d1b5      	bne.n	801df42 <AINSER_Handler+0xbe>
 801dfd6:	e7a4      	b.n	801df22 <AINSER_Handler+0x9e>
      u16 pin = muxed ? (mux_pin_map[mux_ctr] + 8*(7-chn)) : (7-chn); // the mux/chn -> pin mapping is layout dependend
 801dfd8:	f1c4 0107 	rsb	r1, r4, #7
 801dfdc:	e7e8      	b.n	801dfb0 <AINSER_Handler+0x12c>
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801dfde:	9b04      	ldr	r3, [sp, #16]
      int diff = value - previous_ain_pin_value;
 801dfe0:	1a10      	subs	r0, r2, r0
      int abs_diff = (diff > 0 ) ? diff : -diff;
 801dfe2:	2800      	cmp	r0, #0
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801dfe4:	f893 e000 	ldrb.w	lr, [r3]
      int abs_diff = (diff > 0 ) ? diff : -diff;
 801dfe8:	bfb8      	it	lt
 801dfea:	4240      	neglt	r0, r0
      if( !first_scan_done || abs_diff > ain_deadband[module] ) {
 801dfec:	4586      	cmp	lr, r0
 801dfee:	daef      	bge.n	801dfd0 <AINSER_Handler+0x14c>
	ain_pin_values[module][pin] = value;
 801dff0:	f829 201c 	strh.w	r2, [r9, ip, lsl #1]
	if( first_scan_done && _callback && pin < num_used_pins[module] )
 801dff4:	f1b8 0f00 	cmp.w	r8, #0
 801dff8:	d0ea      	beq.n	801dfd0 <AINSER_Handler+0x14c>
 801dffa:	480e      	ldr	r0, [pc, #56]	@ (801e034 <AINSER_Handler+0x1b0>)
 801dffc:	f810 000a 	ldrb.w	r0, [r0, sl]
 801e000:	4288      	cmp	r0, r1
 801e002:	d9e5      	bls.n	801dfd0 <AINSER_Handler+0x14c>
	  _callback(module, pin, value);
 801e004:	4650      	mov	r0, sl
 801e006:	47c0      	blx	r8
 801e008:	e7e2      	b.n	801dfd0 <AINSER_Handler+0x14c>
 801e00a:	bf00      	nop
 801e00c:	08027477 	.word	0x08027477
 801e010:	20004500 	.word	0x20004500
 801e014:	200044fa 	.word	0x200044fa
 801e018:	200044fc 	.word	0x200044fc
 801e01c:	2000005d 	.word	0x2000005d
 801e020:	200044f8 	.word	0x200044f8
 801e024:	20004582 	.word	0x20004582
 801e028:	20004581 	.word	0x20004581
 801e02c:	200044fd 	.word	0x200044fd
 801e030:	200044fe 	.word	0x200044fe
 801e034:	20004580 	.word	0x20004580

0801e038 <MIDI_ROUTER_PortMaskGet>:
// Returns 32bit selection mask for USB0..7, UART0..7, IIC0..7, OSC0..7
/////////////////////////////////////////////////////////////////////////////
static inline u32 MIDI_ROUTER_PortMaskGet(mios32_midi_port_t port)
{
  u8 port_ix = port & 0xf;
  if( port >= USB0 && port <= OSC7 && port_ix <= 7 ) {
 801e038:	f1a0 0310 	sub.w	r3, r0, #16
 801e03c:	b2da      	uxtb	r2, r3
 801e03e:	2a37      	cmp	r2, #55	@ 0x37
 801e040:	d80a      	bhi.n	801e058 <MIDI_ROUTER_PortMaskGet+0x20>
 801e042:	0702      	lsls	r2, r0, #28
 801e044:	d408      	bmi.n	801e058 <MIDI_ROUTER_PortMaskGet+0x20>
    return 1 << ((((port-USB0) & 0x30) >> 1) | port_ix);
 801e046:	105b      	asrs	r3, r3, #1
 801e048:	f000 000f 	and.w	r0, r0, #15
 801e04c:	f003 0318 	and.w	r3, r3, #24
 801e050:	4303      	orrs	r3, r0
 801e052:	2001      	movs	r0, #1
 801e054:	4098      	lsls	r0, r3
 801e056:	4770      	bx	lr
  }

  return 0;
 801e058:	2000      	movs	r0, #0
}
 801e05a:	4770      	bx	lr

0801e05c <get_dec>:
// help function which parses a decimal or hex value
// returns >= 0 if value is valid
// returns -1 if value is invalid
/////////////////////////////////////////////////////////////////////////////
static s32 get_dec(char *word)
{
 801e05c:	b513      	push	{r0, r1, r4, lr}
  if( word == NULL )
 801e05e:	4604      	mov	r4, r0
 801e060:	b918      	cbnz	r0, 801e06a <get_dec+0xe>
    return -1;
 801e062:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff

  if( word == next )
    return -1;

  return l; // value is valid
}
 801e066:	b002      	add	sp, #8
 801e068:	bd10      	pop	{r4, pc}
  long l = strtol(word, &next, 0);
 801e06a:	2200      	movs	r2, #0
 801e06c:	a901      	add	r1, sp, #4
 801e06e:	f7f5 f89f 	bl	80131b0 <strtol>
  if( word == next )
 801e072:	9b01      	ldr	r3, [sp, #4]
 801e074:	42a3      	cmp	r3, r4
 801e076:	d1f6      	bne.n	801e066 <get_dec+0xa>
 801e078:	e7f3      	b.n	801e062 <get_dec+0x6>
	...

0801e07c <MIDI_ROUTER_TerminalSetRouterSyntax.isra.0>:


/////////////////////////////////////////////////////////////////////////////
// print Syntax of "set router" command
/////////////////////////////////////////////////////////////////////////////
static s32 MIDI_ROUTER_TerminalSetRouterSyntax(void *_output_function)
 801e07c:	4603      	mov	r3, r0
{
  void (*out)(char *format, ...) = _output_function;

  out("  set router <node> <in-port> <off|channel|all> <out-port> <off|channel|all>: change router setting");
 801e07e:	4801      	ldr	r0, [pc, #4]	@ (801e084 <MIDI_ROUTER_TerminalSetRouterSyntax.isra.0+0x8>)
 801e080:	4718      	bx	r3
 801e082:	bf00      	nop
 801e084:	0802747f 	.word	0x0802747f

0801e088 <MIDI_ROUTER_Init>:
{
 801e088:	b510      	push	{r4, lr}
  if( mode != 0 )
 801e08a:	4604      	mov	r4, r0
 801e08c:	b968      	cbnz	r0, 801e0aa <MIDI_ROUTER_Init+0x22>
  midi_router_mclk_in = (0x01 << 0) | (0x0f << 8) | (0x0f << 16) | (0x00 << 24);
 801e08e:	4b08      	ldr	r3, [pc, #32]	@ (801e0b0 <MIDI_ROUTER_Init+0x28>)
 801e090:	4a08      	ldr	r2, [pc, #32]	@ (801e0b4 <MIDI_ROUTER_Init+0x2c>)
 801e092:	601a      	str	r2, [r3, #0]
  midi_router_mclk_out = 0x00ffffff;
 801e094:	4b08      	ldr	r3, [pc, #32]	@ (801e0b8 <MIDI_ROUTER_Init+0x30>)
 801e096:	f06f 427f 	mvn.w	r2, #4278190080	@ 0xff000000
 801e09a:	601a      	str	r2, [r3, #0]
    sysex_buffer_len[i] = 0;
 801e09c:	4601      	mov	r1, r0
 801e09e:	2224      	movs	r2, #36	@ 0x24
 801e0a0:	4806      	ldr	r0, [pc, #24]	@ (801e0bc <MIDI_ROUTER_Init+0x34>)
 801e0a2:	f005 fa56 	bl	8023552 <memset>
  return 0; // no error
 801e0a6:	4620      	mov	r0, r4
}
 801e0a8:	bd10      	pop	{r4, pc}
    return -1; // only mode 0 supported
 801e0aa:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e0ae:	e7fb      	b.n	801e0a8 <MIDI_ROUTER_Init+0x20>
 801e0b0:	200069ac 	.word	0x200069ac
 801e0b4:	000f0f01 	.word	0x000f0f01
 801e0b8:	200069a8 	.word	0x200069a8
 801e0bc:	20004584 	.word	0x20004584

0801e0c0 <MIDI_ROUTER_Receive>:
{
 801e0c0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if( midi_package.evnt0 < 0xf8 &&
 801e0c4:	f3c1 2a07 	ubfx	sl, r1, #8, #8
 801e0c8:	f1ba 0ff7 	cmp.w	sl, #247	@ 0xf7
{
 801e0cc:	4680      	mov	r8, r0
 801e0ce:	460d      	mov	r5, r1
 801e0d0:	f001 090f 	and.w	r9, r1, #15
  if( midi_package.evnt0 < 0xf8 &&
 801e0d4:	d808      	bhi.n	801e0e8 <MIDI_ROUTER_Receive+0x28>
 801e0d6:	464b      	mov	r3, r9
 801e0d8:	2b0f      	cmp	r3, #15
 801e0da:	d04f      	beq.n	801e17c <MIDI_ROUTER_Receive+0xbc>
      (midi_package.cin >= 0x4 && midi_package.cin <= 0x7)) )
 801e0dc:	f109 030c 	add.w	r3, r9, #12
      (midi_package.cin == 0xf ||
 801e0e0:	f003 030f 	and.w	r3, r3, #15
 801e0e4:	2b03      	cmp	r3, #3
 801e0e6:	d949      	bls.n	801e17c <MIDI_ROUTER_Receive+0xbc>
      if( ((port & 0xf0) == OSC0) && ((n->dst_port & 0xf0) == OSC0) )
 801e0e8:	f008 03f0 	and.w	r3, r8, #240	@ 0xf0
 801e0ec:	4c35      	ldr	r4, [pc, #212]	@ (801e1c4 <MIDI_ROUTER_Receive+0x104>)
 801e0ee:	9301      	str	r3, [sp, #4]
 801e0f0:	2700      	movs	r7, #0
    if( n->src_chn && n->dst_chn && (n->src_port == port) ) {
 801e0f2:	7862      	ldrb	r2, [r4, #1]
 801e0f4:	2a00      	cmp	r2, #0
 801e0f6:	d03d      	beq.n	801e174 <MIDI_ROUTER_Receive+0xb4>
 801e0f8:	78e3      	ldrb	r3, [r4, #3]
 801e0fa:	2b00      	cmp	r3, #0
 801e0fc:	d03a      	beq.n	801e174 <MIDI_ROUTER_Receive+0xb4>
 801e0fe:	7821      	ldrb	r1, [r4, #0]
 801e100:	4541      	cmp	r1, r8
 801e102:	d137      	bne.n	801e174 <MIDI_ROUTER_Receive+0xb4>
      if( ((port & 0xf0) == OSC0) && ((n->dst_port & 0xf0) == OSC0) )
 801e104:	9901      	ldr	r1, [sp, #4]
 801e106:	2940      	cmp	r1, #64	@ 0x40
 801e108:	d104      	bne.n	801e114 <MIDI_ROUTER_Receive+0x54>
 801e10a:	78a1      	ldrb	r1, [r4, #2]
 801e10c:	f001 01f0 	and.w	r1, r1, #240	@ 0xf0
 801e110:	2940      	cmp	r1, #64	@ 0x40
 801e112:	d02f      	beq.n	801e174 <MIDI_ROUTER_Receive+0xb4>
      if( midi_package.event >= NoteOff && midi_package.event <= PitchBend ) {
 801e114:	f3c5 3103 	ubfx	r1, r5, #12, #4
 801e118:	2907      	cmp	r1, #7
 801e11a:	d933      	bls.n	801e184 <MIDI_ROUTER_Receive+0xc4>
 801e11c:	f00a 01f0 	and.w	r1, sl, #240	@ 0xf0
 801e120:	29f0      	cmp	r1, #240	@ 0xf0
 801e122:	d02f      	beq.n	801e184 <MIDI_ROUTER_Receive+0xc4>
	if( n->src_chn == 17 || midi_package.chn == (n->src_chn-1) ) {
 801e124:	2a11      	cmp	r2, #17
 801e126:	d004      	beq.n	801e132 <MIDI_ROUTER_Receive+0x72>
 801e128:	f3c5 2103 	ubfx	r1, r5, #8, #4
 801e12c:	3a01      	subs	r2, #1
 801e12e:	4291      	cmp	r1, r2
 801e130:	d120      	bne.n	801e174 <MIDI_ROUTER_Receive+0xb4>
	  MUTEX_MIDIOUT_TAKE;
 801e132:	f8df b094 	ldr.w	fp, [pc, #148]	@ 801e1c8 <MIDI_ROUTER_Receive+0x108>
	  if( n->dst_chn <= 16 )
 801e136:	2b10      	cmp	r3, #16
	  mios32_midi_package_t fwd_package = midi_package;
 801e138:	f369 0503 	bfi	r5, r9, #0, #4
	    fwd_package.chn = (n->dst_chn-1);
 801e13c:	bf98      	it	ls
 801e13e:	f103 33ff 	addls.w	r3, r3, #4294967295	@ 0xffffffff
	  mios32_midi_package_t fwd_package = midi_package;
 801e142:	462e      	mov	r6, r5
	  MUTEX_MIDIOUT_TAKE;
 801e144:	f8db 1000 	ldr.w	r1, [fp]
	    fwd_package.chn = (n->dst_chn-1);
 801e148:	bf98      	it	ls
 801e14a:	f363 260b 	bfils	r6, r3, #8, #4
	  mios32_midi_port_t port = n->dst_port;
 801e14e:	78a3      	ldrb	r3, [r4, #2]
 801e150:	9300      	str	r3, [sp, #0]
	  MUTEX_MIDIOUT_TAKE;
 801e152:	b131      	cbz	r1, 801e162 <MIDI_ROUTER_Receive+0xa2>
 801e154:	f8db 0000 	ldr.w	r0, [fp]
 801e158:	2101      	movs	r1, #1
 801e15a:	f7f5 fe99 	bl	8013e90 <xQueueTakeMutexRecursive>
 801e15e:	2801      	cmp	r0, #1
 801e160:	d1f8      	bne.n	801e154 <MIDI_ROUTER_Receive+0x94>
	  MIOS32_MIDI_SendPackage(port, fwd_package);
 801e162:	9800      	ldr	r0, [sp, #0]
 801e164:	4631      	mov	r1, r6
 801e166:	f7f6 fbd7 	bl	8014918 <MIOS32_MIDI_SendPackage>
	  MUTEX_MIDIOUT_GIVE;
 801e16a:	f8db 0000 	ldr.w	r0, [fp]
 801e16e:	b108      	cbz	r0, 801e174 <MIDI_ROUTER_Receive+0xb4>
 801e170:	f7f5 fddd 	bl	8013d2e <xQueueGiveMutexRecursive>
  for(node=0; node<MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801e174:	4b15      	ldr	r3, [pc, #84]	@ (801e1cc <MIDI_ROUTER_Receive+0x10c>)
 801e176:	3404      	adds	r4, #4
 801e178:	429c      	cmp	r4, r3
 801e17a:	d1ba      	bne.n	801e0f2 <MIDI_ROUTER_Receive+0x32>
}
 801e17c:	2000      	movs	r0, #0
 801e17e:	b003      	add	sp, #12
 801e180:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u32 mask = MIDI_ROUTER_PortMaskGet(n->dst_port);
 801e184:	78a0      	ldrb	r0, [r4, #2]
 801e186:	f7ff ff57 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
	if( !mask || !(sysex_dst_fwd_done & mask) ) {
 801e18a:	4606      	mov	r6, r0
 801e18c:	b108      	cbz	r0, 801e192 <MIDI_ROUTER_Receive+0xd2>
 801e18e:	4238      	tst	r0, r7
 801e190:	d1f0      	bne.n	801e174 <MIDI_ROUTER_Receive+0xb4>
	  MUTEX_MIDIOUT_TAKE;
 801e192:	f8df b034 	ldr.w	fp, [pc, #52]	@ 801e1c8 <MIDI_ROUTER_Receive+0x108>
 801e196:	f8db 2000 	ldr.w	r2, [fp]
 801e19a:	b132      	cbz	r2, 801e1aa <MIDI_ROUTER_Receive+0xea>
 801e19c:	f8db 0000 	ldr.w	r0, [fp]
 801e1a0:	2101      	movs	r1, #1
 801e1a2:	f7f5 fe75 	bl	8013e90 <xQueueTakeMutexRecursive>
 801e1a6:	2801      	cmp	r0, #1
 801e1a8:	d1f8      	bne.n	801e19c <MIDI_ROUTER_Receive+0xdc>
	  MIOS32_MIDI_SendPackage(n->dst_port, midi_package);
 801e1aa:	f369 0503 	bfi	r5, r9, #0, #4
 801e1ae:	78a0      	ldrb	r0, [r4, #2]
 801e1b0:	4629      	mov	r1, r5
 801e1b2:	f7f6 fbb1 	bl	8014918 <MIOS32_MIDI_SendPackage>
	  MUTEX_MIDIOUT_GIVE;
 801e1b6:	f8db 0000 	ldr.w	r0, [fp]
 801e1ba:	b108      	cbz	r0, 801e1c0 <MIDI_ROUTER_Receive+0x100>
 801e1bc:	f7f5 fdb7 	bl	8013d2e <xQueueGiveMutexRecursive>
	  sysex_dst_fwd_done |= mask;
 801e1c0:	4337      	orrs	r7, r6
 801e1c2:	e7d7      	b.n	801e174 <MIDI_ROUTER_Receive+0xb4>
 801e1c4:	2000005e 	.word	0x2000005e
 801e1c8:	200000d0 	.word	0x200000d0
 801e1cc:	2000009e 	.word	0x2000009e

0801e1d0 <MIDI_ROUTER_ReceiveSysEx>:
{
 801e1d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e1d4:	b085      	sub	sp, #20
 801e1d6:	460d      	mov	r5, r1
 801e1d8:	9002      	str	r0, [sp, #8]
  int sysex_in = MIDI_PORT_InIxGet(port);
 801e1da:	f000 fc27 	bl	801ea2c <MIDI_PORT_InIxGet>
  if( sysex_in == 0 )
 801e1de:	2800      	cmp	r0, #0
 801e1e0:	d075      	beq.n	801e2ce <MIDI_ROUTER_ReceiveSysEx+0xfe>
  sysex_in -= 1;
 801e1e2:	1e44      	subs	r4, r0, #1
  if( sysex_in >= NUM_SYSEX_BUFFERS )
 801e1e4:	2c08      	cmp	r4, #8
 801e1e6:	dc75      	bgt.n	801e2d4 <MIDI_ROUTER_ReceiveSysEx+0x104>
  u32 buffer_len = sysex_buffer_len[sysex_in];
 801e1e8:	f8df 80f0 	ldr.w	r8, [pc, #240]	@ 801e2dc <MIDI_ROUTER_ReceiveSysEx+0x10c>
 801e1ec:	4f3c      	ldr	r7, [pc, #240]	@ (801e2e0 <MIDI_ROUTER_ReceiveSysEx+0x110>)
 801e1ee:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
  if( midi_in == 0xf7 || (midi_in == 0xf0 && buffer_len != 0) || buffer_len >= (MIDI_ROUTER_SYSEX_BUFFER_SIZE-1) ) {
 801e1f2:	2df7      	cmp	r5, #247	@ 0xf7
 801e1f4:	ea4f 2a84 	mov.w	sl, r4, lsl #10
 801e1f8:	d050      	beq.n	801e29c <MIDI_ROUTER_ReceiveSysEx+0xcc>
 801e1fa:	2df0      	cmp	r5, #240	@ 0xf0
 801e1fc:	d106      	bne.n	801e20c <MIDI_ROUTER_ReceiveSysEx+0x3c>
 801e1fe:	b94b      	cbnz	r3, 801e214 <MIDI_ROUTER_ReceiveSysEx+0x44>
    sysex_buffer[sysex_in][sysex_buffer_len[sysex_in]++] = midi_in;
 801e200:	4457      	add	r7, sl
 801e202:	1c5a      	adds	r2, r3, #1
 801e204:	f848 2024 	str.w	r2, [r8, r4, lsl #2]
 801e208:	54fd      	strb	r5, [r7, r3]
 801e20a:	e043      	b.n	801e294 <MIDI_ROUTER_ReceiveSysEx+0xc4>
  if( midi_in == 0xf7 || (midi_in == 0xf0 && buffer_len != 0) || buffer_len >= (MIDI_ROUTER_SYSEX_BUFFER_SIZE-1) ) {
 801e20c:	f240 32fe 	movw	r2, #1022	@ 0x3fe
 801e210:	4293      	cmp	r3, r2
 801e212:	d9f5      	bls.n	801e200 <MIDI_ROUTER_ReceiveSysEx+0x30>
	    OSC_CLIENT_SendSysEx(port & 0x0f, sysex_buffer[sysex_in], sysex_buffer_len[sysex_in]);
 801e214:	eb07 030a 	add.w	r3, r7, sl
 801e218:	4e32      	ldr	r6, [pc, #200]	@ (801e2e4 <MIDI_ROUTER_ReceiveSysEx+0x114>)
	  MUTEX_MIDIOUT_TAKE;
 801e21a:	f8df b0cc 	ldr.w	fp, [pc, #204]	@ 801e2e8 <MIDI_ROUTER_ReceiveSysEx+0x118>
	    OSC_CLIENT_SendSysEx(port & 0x0f, sysex_buffer[sysex_in], sysex_buffer_len[sysex_in]);
 801e21e:	9301      	str	r3, [sp, #4]
 801e220:	f04f 0900 	mov.w	r9, #0
      if( n->src_chn && n->dst_chn && (n->src_port == port) ) {
 801e224:	7873      	ldrb	r3, [r6, #1]
 801e226:	b333      	cbz	r3, 801e276 <MIDI_ROUTER_ReceiveSysEx+0xa6>
 801e228:	78f3      	ldrb	r3, [r6, #3]
 801e22a:	b323      	cbz	r3, 801e276 <MIDI_ROUTER_ReceiveSysEx+0xa6>
 801e22c:	7833      	ldrb	r3, [r6, #0]
 801e22e:	9a02      	ldr	r2, [sp, #8]
 801e230:	4293      	cmp	r3, r2
 801e232:	d120      	bne.n	801e276 <MIDI_ROUTER_ReceiveSysEx+0xa6>
	u32 mask = MIDI_ROUTER_PortMaskGet(n->dst_port);
 801e234:	78b3      	ldrb	r3, [r6, #2]
 801e236:	9303      	str	r3, [sp, #12]
 801e238:	4618      	mov	r0, r3
 801e23a:	f7ff fefd 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
	if( !mask || !(sysex_dst_fwd_done & mask) ) {
 801e23e:	9b03      	ldr	r3, [sp, #12]
 801e240:	9000      	str	r0, [sp, #0]
 801e242:	b110      	cbz	r0, 801e24a <MIDI_ROUTER_ReceiveSysEx+0x7a>
 801e244:	ea10 0f09 	tst.w	r0, r9
 801e248:	d115      	bne.n	801e276 <MIDI_ROUTER_ReceiveSysEx+0xa6>
	  MUTEX_MIDIOUT_TAKE;
 801e24a:	f8db 2000 	ldr.w	r2, [fp]
 801e24e:	bb7a      	cbnz	r2, 801e2b0 <MIDI_ROUTER_ReceiveSysEx+0xe0>
	  if( (port & 0xf0) == OSC0 )
 801e250:	f003 01f0 	and.w	r1, r3, #240	@ 0xf0
 801e254:	2940      	cmp	r1, #64	@ 0x40
	    OSC_CLIENT_SendSysEx(port & 0x0f, sysex_buffer[sysex_in], sysex_buffer_len[sysex_in]);
 801e256:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
	  if( (port & 0xf0) == OSC0 )
 801e25a:	d133      	bne.n	801e2c4 <MIDI_ROUTER_ReceiveSysEx+0xf4>
	    OSC_CLIENT_SendSysEx(port & 0x0f, sysex_buffer[sysex_in], sysex_buffer_len[sysex_in]);
 801e25c:	9901      	ldr	r1, [sp, #4]
 801e25e:	f003 000f 	and.w	r0, r3, #15
 801e262:	f003 fc5b 	bl	8021b1c <OSC_CLIENT_SendSysEx>
	  MUTEX_MIDIOUT_GIVE;
 801e266:	f8db 0000 	ldr.w	r0, [fp]
 801e26a:	b108      	cbz	r0, 801e270 <MIDI_ROUTER_ReceiveSysEx+0xa0>
 801e26c:	f7f5 fd5f 	bl	8013d2e <xQueueGiveMutexRecursive>
	  sysex_dst_fwd_done |= mask;
 801e270:	9b00      	ldr	r3, [sp, #0]
 801e272:	ea49 0903 	orr.w	r9, r9, r3
    for(node=0; node<MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801e276:	4b1d      	ldr	r3, [pc, #116]	@ (801e2ec <MIDI_ROUTER_ReceiveSysEx+0x11c>)
 801e278:	3604      	adds	r6, #4
 801e27a:	429e      	cmp	r6, r3
 801e27c:	d1d2      	bne.n	801e224 <MIDI_ROUTER_ReceiveSysEx+0x54>
    if( midi_in != 0xf7 )
 801e27e:	2df7      	cmp	r5, #247	@ 0xf7
    sysex_buffer_len[sysex_in] = 0;
 801e280:	bf0b      	itete	eq
 801e282:	2300      	moveq	r3, #0
      sysex_buffer[sysex_in][sysex_buffer_len[sysex_in]++] = midi_in;
 801e284:	2301      	movne	r3, #1
    sysex_buffer_len[sysex_in] = 0;
 801e286:	f848 3024 	streq.w	r3, [r8, r4, lsl #2]
      sysex_buffer[sysex_in][sysex_buffer_len[sysex_in]++] = midi_in;
 801e28a:	f848 3024 	strne.w	r3, [r8, r4, lsl #2]
 801e28e:	bf18      	it	ne
 801e290:	f807 500a 	strbne.w	r5, [r7, sl]
  return 0; // no error
 801e294:	2000      	movs	r0, #0
}
 801e296:	b005      	add	sp, #20
 801e298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( midi_in == 0xf7 && buffer_len < MIDI_ROUTER_SYSEX_BUFFER_SIZE ) // note: we always have a free byte for F7
 801e29c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
      sysex_buffer[sysex_in][sysex_buffer_len[sysex_in]++] = midi_in;
 801e2a0:	bf3f      	itttt	cc
 801e2a2:	1c5a      	addcc	r2, r3, #1
 801e2a4:	f848 2024 	strcc.w	r2, [r8, r4, lsl #2]
 801e2a8:	eb07 020a 	addcc.w	r2, r7, sl
 801e2ac:	54d5      	strbcc	r5, [r2, r3]
 801e2ae:	e7b1      	b.n	801e214 <MIDI_ROUTER_ReceiveSysEx+0x44>
	  MUTEX_MIDIOUT_TAKE;
 801e2b0:	f8db 0000 	ldr.w	r0, [fp]
 801e2b4:	9303      	str	r3, [sp, #12]
 801e2b6:	2101      	movs	r1, #1
 801e2b8:	f7f5 fdea 	bl	8013e90 <xQueueTakeMutexRecursive>
 801e2bc:	2801      	cmp	r0, #1
 801e2be:	9b03      	ldr	r3, [sp, #12]
 801e2c0:	d1f6      	bne.n	801e2b0 <MIDI_ROUTER_ReceiveSysEx+0xe0>
 801e2c2:	e7c5      	b.n	801e250 <MIDI_ROUTER_ReceiveSysEx+0x80>
	    MIOS32_MIDI_SendSysEx(port, sysex_buffer[sysex_in], sysex_buffer_len[sysex_in]);
 801e2c4:	9901      	ldr	r1, [sp, #4]
 801e2c6:	4618      	mov	r0, r3
 801e2c8:	f7f6 fb84 	bl	80149d4 <MIOS32_MIDI_SendSysEx>
 801e2cc:	e7cb      	b.n	801e266 <MIDI_ROUTER_ReceiveSysEx+0x96>
    return -1; // not assigned
 801e2ce:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e2d2:	e7e0      	b.n	801e296 <MIDI_ROUTER_ReceiveSysEx+0xc6>
    return -2; // error in sysex assignments
 801e2d4:	f06f 0001 	mvn.w	r0, #1
 801e2d8:	e7dd      	b.n	801e296 <MIDI_ROUTER_ReceiveSysEx+0xc6>
 801e2da:	bf00      	nop
 801e2dc:	20004584 	.word	0x20004584
 801e2e0:	200045a8 	.word	0x200045a8
 801e2e4:	2000005e 	.word	0x2000005e
 801e2e8:	200000d0 	.word	0x200000d0
 801e2ec:	2000009e 	.word	0x2000009e

0801e2f0 <MIDI_ROUTER_MIDIClockInGet>:
{
 801e2f0:	b508      	push	{r3, lr}
  if( (port & 0xf0) == IIC0 )
 801e2f2:	f000 03f0 	and.w	r3, r0, #240	@ 0xf0
 801e2f6:	2b30      	cmp	r3, #48	@ 0x30
 801e2f8:	d009      	beq.n	801e30e <MIDI_ROUTER_MIDIClockInGet+0x1e>
  u32 mask = MIDI_ROUTER_PortMaskGet(port);
 801e2fa:	f7ff fe9d 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
  if( mask ) {
 801e2fe:	b148      	cbz	r0, 801e314 <MIDI_ROUTER_MIDIClockInGet+0x24>
    return (midi_router_mclk_in & mask) ? 1 : 0;
 801e300:	4b06      	ldr	r3, [pc, #24]	@ (801e31c <MIDI_ROUTER_MIDIClockInGet+0x2c>)
 801e302:	681b      	ldr	r3, [r3, #0]
 801e304:	4218      	tst	r0, r3
 801e306:	bf14      	ite	ne
 801e308:	2001      	movne	r0, #1
 801e30a:	2000      	moveq	r0, #0
}
 801e30c:	bd08      	pop	{r3, pc}
    return -2; // MIDI In function disabled
 801e30e:	f06f 0001 	mvn.w	r0, #1
 801e312:	e7fb      	b.n	801e30c <MIDI_ROUTER_MIDIClockInGet+0x1c>
  return -1; // port not supported
 801e314:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e318:	e7f8      	b.n	801e30c <MIDI_ROUTER_MIDIClockInGet+0x1c>
 801e31a:	bf00      	nop
 801e31c:	200069ac 	.word	0x200069ac

0801e320 <MIDI_ROUTER_MIDIClockInSet>:
{
 801e320:	b508      	push	{r3, lr}
  u32 mask = MIDI_ROUTER_PortMaskGet(port);
 801e322:	f7ff fe89 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
  if( mask ) {
 801e326:	b148      	cbz	r0, 801e33c <MIDI_ROUTER_MIDIClockInSet+0x1c>
      midi_router_mclk_in |= mask;
 801e328:	4a06      	ldr	r2, [pc, #24]	@ (801e344 <MIDI_ROUTER_MIDIClockInSet+0x24>)
 801e32a:	6813      	ldr	r3, [r2, #0]
    if( enable )
 801e32c:	b119      	cbz	r1, 801e336 <MIDI_ROUTER_MIDIClockInSet+0x16>
      midi_router_mclk_in |= mask;
 801e32e:	4318      	orrs	r0, r3
      midi_router_mclk_in &= ~mask;
 801e330:	6010      	str	r0, [r2, #0]
    return 0; // no error
 801e332:	2000      	movs	r0, #0
}
 801e334:	bd08      	pop	{r3, pc}
      midi_router_mclk_in &= ~mask;
 801e336:	ea23 0000 	bic.w	r0, r3, r0
 801e33a:	e7f9      	b.n	801e330 <MIDI_ROUTER_MIDIClockInSet+0x10>
  return -1; // port not supported
 801e33c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e340:	e7f8      	b.n	801e334 <MIDI_ROUTER_MIDIClockInSet+0x14>
 801e342:	bf00      	nop
 801e344:	200069ac 	.word	0x200069ac

0801e348 <MIDI_ROUTER_MIDIClockOutGet>:
{
 801e348:	b508      	push	{r3, lr}
  u32 mask = MIDI_ROUTER_PortMaskGet(port);
 801e34a:	f7ff fe75 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
  if( mask ) {
 801e34e:	b130      	cbz	r0, 801e35e <MIDI_ROUTER_MIDIClockOutGet+0x16>
    return (midi_router_mclk_out & mask) ? 1 : 0;
 801e350:	4b04      	ldr	r3, [pc, #16]	@ (801e364 <MIDI_ROUTER_MIDIClockOutGet+0x1c>)
 801e352:	681b      	ldr	r3, [r3, #0]
 801e354:	4218      	tst	r0, r3
 801e356:	bf14      	ite	ne
 801e358:	2001      	movne	r0, #1
 801e35a:	2000      	moveq	r0, #0
}
 801e35c:	bd08      	pop	{r3, pc}
  return -1; // port not supported
 801e35e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e362:	e7fb      	b.n	801e35c <MIDI_ROUTER_MIDIClockOutGet+0x14>
 801e364:	200069a8 	.word	0x200069a8

0801e368 <MIDI_ROUTER_MIDIClockOutSet>:
{
 801e368:	b508      	push	{r3, lr}
  u32 mask = MIDI_ROUTER_PortMaskGet(port);
 801e36a:	f7ff fe65 	bl	801e038 <MIDI_ROUTER_PortMaskGet>
  if( mask ) {
 801e36e:	b148      	cbz	r0, 801e384 <MIDI_ROUTER_MIDIClockOutSet+0x1c>
      midi_router_mclk_out |= mask;
 801e370:	4a06      	ldr	r2, [pc, #24]	@ (801e38c <MIDI_ROUTER_MIDIClockOutSet+0x24>)
 801e372:	6813      	ldr	r3, [r2, #0]
    if( enable )
 801e374:	b119      	cbz	r1, 801e37e <MIDI_ROUTER_MIDIClockOutSet+0x16>
      midi_router_mclk_out |= mask;
 801e376:	4318      	orrs	r0, r3
      midi_router_mclk_out &= ~mask;
 801e378:	6010      	str	r0, [r2, #0]
    return 0; // no error
 801e37a:	2000      	movs	r0, #0
}
 801e37c:	bd08      	pop	{r3, pc}
      midi_router_mclk_out &= ~mask;
 801e37e:	ea23 0000 	bic.w	r0, r3, r0
 801e382:	e7f9      	b.n	801e378 <MIDI_ROUTER_MIDIClockOutSet+0x10>
  return -1; // port not supported
 801e384:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801e388:	e7f8      	b.n	801e37c <MIDI_ROUTER_MIDIClockOutSet+0x14>
 801e38a:	bf00      	nop
 801e38c:	200069a8 	.word	0x200069a8

0801e390 <MIDI_ROUTER_TerminalHelp>:

/////////////////////////////////////////////////////////////////////////////
// Returns help page for implemented terminal commands of this module
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_ROUTER_TerminalHelp(void *_output_function)
{
 801e390:	b510      	push	{r4, lr}
 801e392:	4604      	mov	r4, r0
  void (*out)(char *format, ...) = _output_function;

  out("  router:                           print MIDI router info\n");
 801e394:	4805      	ldr	r0, [pc, #20]	@ (801e3ac <MIDI_ROUTER_TerminalHelp+0x1c>)
 801e396:	47a0      	blx	r4
  MIDI_ROUTER_TerminalSetRouterSyntax(out);
 801e398:	4620      	mov	r0, r4
 801e39a:	f7ff fe6f 	bl	801e07c <MIDI_ROUTER_TerminalSetRouterSyntax.isra.0>
  out("  set mclk_in  <in-port>  <on|off>: change MIDI IN Clock setting");
 801e39e:	4804      	ldr	r0, [pc, #16]	@ (801e3b0 <MIDI_ROUTER_TerminalHelp+0x20>)
 801e3a0:	47a0      	blx	r4
  out("  set mclk_out <out-port> <on|off>: change MIDI OUT Clock setting");
 801e3a2:	4804      	ldr	r0, [pc, #16]	@ (801e3b4 <MIDI_ROUTER_TerminalHelp+0x24>)
 801e3a4:	47a0      	blx	r4

  return 0; // no error
}
 801e3a6:	2000      	movs	r0, #0
 801e3a8:	bd10      	pop	{r4, pc}
 801e3aa:	bf00      	nop
 801e3ac:	080274e3 	.word	0x080274e3
 801e3b0:	0802751f 	.word	0x0802751f
 801e3b4:	08027560 	.word	0x08027560

0801e3b8 <MIDI_ROUTER_TerminalPrintConfig>:

/////////////////////////////////////////////////////////////////////////////
// Keyboard Configuration (can also be called from external)
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_ROUTER_TerminalPrintConfig(void *_output_function)
{
 801e3b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e3bc:	4604      	mov	r4, r0
 801e3be:	b08b      	sub	sp, #44	@ 0x2c
  void (*out)(char *format, ...) = _output_function;

  out("MIDI Router Nodes (change with 'set router <node> <in-port> <channel> <out-port> <channel>)");
 801e3c0:	4846      	ldr	r0, [pc, #280]	@ (801e4dc <MIDI_ROUTER_TerminalPrintConfig+0x124>)
  out("Example: set router 1 IN1 all USB1 all");

  u8 node;
  midi_router_node_entry_t *n = &midi_router_node[0];
 801e3c2:	4d47      	ldr	r5, [pc, #284]	@ (801e4e0 <MIDI_ROUTER_TerminalPrintConfig+0x128>)
    if( !n->src_chn )
      sprintf(src_chn, "off");
    else if( n->src_chn > 16 )
      sprintf(src_chn, "all");
    else
      sprintf(src_chn, "#%2d", n->src_chn);
 801e3c4:	f8df 911c 	ldr.w	r9, [pc, #284]	@ 801e4e4 <MIDI_ROUTER_TerminalPrintConfig+0x12c>
      sprintf(src_chn, "all");
 801e3c8:	f8df a11c 	ldr.w	sl, [pc, #284]	@ 801e4e8 <MIDI_ROUTER_TerminalPrintConfig+0x130>
      sprintf(src_chn, "off");
 801e3cc:	f8df b11c 	ldr.w	fp, [pc, #284]	@ 801e4ec <MIDI_ROUTER_TerminalPrintConfig+0x134>
  out("MIDI Router Nodes (change with 'set router <node> <in-port> <channel> <out-port> <channel>)");
 801e3d0:	47a0      	blx	r4
  out("Example: set router 1 IN1 all USB1 all");
 801e3d2:	4847      	ldr	r0, [pc, #284]	@ (801e4f0 <MIDI_ROUTER_TerminalPrintConfig+0x138>)
 801e3d4:	47a0      	blx	r4
 801e3d6:	2601      	movs	r6, #1
    if( !n->src_chn )
 801e3d8:	786a      	ldrb	r2, [r5, #1]
 801e3da:	2a00      	cmp	r2, #0
 801e3dc:	d137      	bne.n	801e44e <MIDI_ROUTER_TerminalPrintConfig+0x96>
      sprintf(src_chn, "off");
 801e3de:	4659      	mov	r1, fp
      sprintf(src_chn, "all");
 801e3e0:	a804      	add	r0, sp, #16
 801e3e2:	f005 f87b 	bl	80234dc <strcpy>

    char dst_chn[10];
    if( !n->dst_chn )
 801e3e6:	78ea      	ldrb	r2, [r5, #3]
 801e3e8:	af07      	add	r7, sp, #28
 801e3ea:	2a00      	cmp	r2, #0
 801e3ec:	d138      	bne.n	801e460 <MIDI_ROUTER_TerminalPrintConfig+0xa8>
      sprintf(dst_chn, "off");
 801e3ee:	4659      	mov	r1, fp
    else if( n->dst_chn > 16 )
      sprintf(dst_chn, "all");
 801e3f0:	4638      	mov	r0, r7
 801e3f2:	f005 f873 	bl	80234dc <strcpy>
    else
      sprintf(dst_chn, "#%2d", n->dst_chn);

    out("  %2d  SRC:%s %s  DST:%s %s",
 801e3f6:	7828      	ldrb	r0, [r5, #0]
 801e3f8:	f000 fb18 	bl	801ea2c <MIDI_PORT_InIxGet>
 801e3fc:	f000 fac2 	bl	801e984 <MIDI_PORT_InNameGet>
 801e400:	4680      	mov	r8, r0
 801e402:	78a8      	ldrb	r0, [r5, #2]
 801e404:	f000 fb24 	bl	801ea50 <MIDI_PORT_OutIxGet>
 801e408:	f000 facc 	bl	801e9a4 <MIDI_PORT_OutNameGet>
 801e40c:	4631      	mov	r1, r6
 801e40e:	e9cd 0700 	strd	r0, r7, [sp]
 801e412:	ab04      	add	r3, sp, #16
 801e414:	4837      	ldr	r0, [pc, #220]	@ (801e4f4 <MIDI_ROUTER_TerminalPrintConfig+0x13c>)
 801e416:	4642      	mov	r2, r8
  for(node=0; node<MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801e418:	3601      	adds	r6, #1
    out("  %2d  SRC:%s %s  DST:%s %s",
 801e41a:	47a0      	blx	r4
  for(node=0; node<MIDI_ROUTER_NUM_NODES; ++node, ++n) {
 801e41c:	2e11      	cmp	r6, #17
 801e41e:	f105 0504 	add.w	r5, r5, #4
 801e422:	d1d9      	bne.n	801e3d8 <MIDI_ROUTER_TerminalPrintConfig+0x20>
        src_chn,
        MIDI_PORT_OutNameGet(MIDI_PORT_OutIxGet(n->dst_port)),
        dst_chn);
  }

  out("");
 801e424:	4834      	ldr	r0, [pc, #208]	@ (801e4f8 <MIDI_ROUTER_TerminalPrintConfig+0x140>)

    s32 enab_tx = MIDI_ROUTER_MIDIClockOutGet(mclk_port);
    if( !MIDI_PORT_ClkCheckAvailable(mclk_port) )
      enab_tx = -1; // MIDI In port not available

    out("  %s  IN:%s  OUT:%s\n",
 801e426:	f8df 90c4 	ldr.w	r9, [pc, #196]	@ 801e4ec <MIDI_ROUTER_TerminalPrintConfig+0x134>
        MIDI_PORT_ClkNameGet(port_ix),
        (enab_rx == 0) ? "off" : ((enab_rx == 1) ? "on " : "---"),
 801e42a:	f8df a0d0 	ldr.w	sl, [pc, #208]	@ 801e4fc <MIDI_ROUTER_TerminalPrintConfig+0x144>
 801e42e:	f8df b0d0 	ldr.w	fp, [pc, #208]	@ 801e500 <MIDI_ROUTER_TerminalPrintConfig+0x148>
  out("");
 801e432:	47a0      	blx	r4
  out("MIDI Clock (change with 'set mclk_in <in-port> <on|off>' resp. 'set mclk_out <out-port> <on|off>')");
 801e434:	4833      	ldr	r0, [pc, #204]	@ (801e504 <MIDI_ROUTER_TerminalPrintConfig+0x14c>)
 801e436:	47a0      	blx	r4
  int num_mclk_ports = MIDI_PORT_ClkNumGet();
 801e438:	f000 faa2 	bl	801e980 <MIDI_PORT_ClkNumGet>
  for(port_ix=0; port_ix<num_mclk_ports; ++port_ix) {
 801e43c:	2700      	movs	r7, #0
  int num_mclk_ports = MIDI_PORT_ClkNumGet();
 801e43e:	9002      	str	r0, [sp, #8]
  for(port_ix=0; port_ix<num_mclk_ports; ++port_ix) {
 801e440:	9b02      	ldr	r3, [sp, #8]
 801e442:	429f      	cmp	r7, r3
 801e444:	db15      	blt.n	801e472 <MIDI_ROUTER_TerminalPrintConfig+0xba>
        (enab_tx == 0) ? "off" : ((enab_tx == 1) ? "on " : "---"));
  }

  return 0; // no error
}
 801e446:	2000      	movs	r0, #0
 801e448:	b00b      	add	sp, #44	@ 0x2c
 801e44a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if( n->src_chn > 16 )
 801e44e:	2a10      	cmp	r2, #16
 801e450:	d901      	bls.n	801e456 <MIDI_ROUTER_TerminalPrintConfig+0x9e>
      sprintf(src_chn, "all");
 801e452:	4651      	mov	r1, sl
 801e454:	e7c4      	b.n	801e3e0 <MIDI_ROUTER_TerminalPrintConfig+0x28>
      sprintf(src_chn, "#%2d", n->src_chn);
 801e456:	4649      	mov	r1, r9
 801e458:	a804      	add	r0, sp, #16
 801e45a:	f7fa fcb3 	bl	8018dc4 <sprintf>
 801e45e:	e7c2      	b.n	801e3e6 <MIDI_ROUTER_TerminalPrintConfig+0x2e>
    else if( n->dst_chn > 16 )
 801e460:	2a10      	cmp	r2, #16
 801e462:	d901      	bls.n	801e468 <MIDI_ROUTER_TerminalPrintConfig+0xb0>
      sprintf(dst_chn, "all");
 801e464:	4651      	mov	r1, sl
 801e466:	e7c3      	b.n	801e3f0 <MIDI_ROUTER_TerminalPrintConfig+0x38>
      sprintf(dst_chn, "#%2d", n->dst_chn);
 801e468:	4649      	mov	r1, r9
 801e46a:	4638      	mov	r0, r7
 801e46c:	f7fa fcaa 	bl	8018dc4 <sprintf>
 801e470:	e7c1      	b.n	801e3f6 <MIDI_ROUTER_TerminalPrintConfig+0x3e>
    mios32_midi_port_t mclk_port = MIDI_PORT_ClkPortGet(port_ix);
 801e472:	b2fa      	uxtb	r2, r7
 801e474:	4610      	mov	r0, r2
 801e476:	9203      	str	r2, [sp, #12]
 801e478:	f000 facc 	bl	801ea14 <MIDI_PORT_ClkPortGet>
 801e47c:	4606      	mov	r6, r0
    s32 enab_rx = MIDI_ROUTER_MIDIClockInGet(mclk_port);
 801e47e:	f7ff ff37 	bl	801e2f0 <MIDI_ROUTER_MIDIClockInGet>
 801e482:	4680      	mov	r8, r0
    if( !MIDI_PORT_ClkCheckAvailable(mclk_port) )
 801e484:	4630      	mov	r0, r6
 801e486:	f000 faf5 	bl	801ea74 <MIDI_PORT_ClkCheckAvailable>
      enab_rx = -1; // MIDI In port not available
 801e48a:	2800      	cmp	r0, #0
    s32 enab_tx = MIDI_ROUTER_MIDIClockOutGet(mclk_port);
 801e48c:	4630      	mov	r0, r6
      enab_rx = -1; // MIDI In port not available
 801e48e:	bf08      	it	eq
 801e490:	f04f 38ff 	moveq.w	r8, #4294967295	@ 0xffffffff
    s32 enab_tx = MIDI_ROUTER_MIDIClockOutGet(mclk_port);
 801e494:	f7ff ff58 	bl	801e348 <MIDI_ROUTER_MIDIClockOutGet>
 801e498:	4605      	mov	r5, r0
    if( !MIDI_PORT_ClkCheckAvailable(mclk_port) )
 801e49a:	4630      	mov	r0, r6
 801e49c:	f000 faea 	bl	801ea74 <MIDI_PORT_ClkCheckAvailable>
    out("  %s  IN:%s  OUT:%s\n",
 801e4a0:	9a03      	ldr	r2, [sp, #12]
      enab_tx = -1; // MIDI In port not available
 801e4a2:	2800      	cmp	r0, #0
    out("  %s  IN:%s  OUT:%s\n",
 801e4a4:	4610      	mov	r0, r2
      enab_tx = -1; // MIDI In port not available
 801e4a6:	bf08      	it	eq
 801e4a8:	f04f 35ff 	moveq.w	r5, #4294967295	@ 0xffffffff
    out("  %s  IN:%s  OUT:%s\n",
 801e4ac:	f000 fa8a 	bl	801e9c4 <MIDI_PORT_ClkNameGet>
 801e4b0:	4601      	mov	r1, r0
 801e4b2:	f1b8 0f00 	cmp.w	r8, #0
 801e4b6:	d00d      	beq.n	801e4d4 <MIDI_ROUTER_TerminalPrintConfig+0x11c>
        (enab_rx == 0) ? "off" : ((enab_rx == 1) ? "on " : "---"),
 801e4b8:	f1b8 0f01 	cmp.w	r8, #1
 801e4bc:	bf14      	ite	ne
 801e4be:	4652      	movne	r2, sl
 801e4c0:	465a      	moveq	r2, fp
    out("  %s  IN:%s  OUT:%s\n",
 801e4c2:	b14d      	cbz	r5, 801e4d8 <MIDI_ROUTER_TerminalPrintConfig+0x120>
        (enab_tx == 0) ? "off" : ((enab_tx == 1) ? "on " : "---"));
 801e4c4:	2d01      	cmp	r5, #1
 801e4c6:	bf14      	ite	ne
 801e4c8:	4653      	movne	r3, sl
 801e4ca:	465b      	moveq	r3, fp
    out("  %s  IN:%s  OUT:%s\n",
 801e4cc:	480e      	ldr	r0, [pc, #56]	@ (801e508 <MIDI_ROUTER_TerminalPrintConfig+0x150>)
 801e4ce:	47a0      	blx	r4
  for(port_ix=0; port_ix<num_mclk_ports; ++port_ix) {
 801e4d0:	3701      	adds	r7, #1
 801e4d2:	e7b5      	b.n	801e440 <MIDI_ROUTER_TerminalPrintConfig+0x88>
    out("  %s  IN:%s  OUT:%s\n",
 801e4d4:	464a      	mov	r2, r9
 801e4d6:	e7f4      	b.n	801e4c2 <MIDI_ROUTER_TerminalPrintConfig+0x10a>
 801e4d8:	464b      	mov	r3, r9
 801e4da:	e7f7      	b.n	801e4cc <MIDI_ROUTER_TerminalPrintConfig+0x114>
 801e4dc:	080275a6 	.word	0x080275a6
 801e4e0:	2000005e 	.word	0x2000005e
 801e4e4:	08027629 	.word	0x08027629
 801e4e8:	08027625 	.word	0x08027625
 801e4ec:	0802531e 	.word	0x0802531e
 801e4f0:	08027602 	.word	0x08027602
 801e4f4:	0802762e 	.word	0x0802762e
 801e4f8:	080237bc 	.word	0x080237bc
 801e4fc:	08027968 	.word	0x08027968
 801e500:	080275a2 	.word	0x080275a2
 801e504:	0802764a 	.word	0x0802764a
 801e508:	080276ad 	.word	0x080276ad

0801e50c <MIDI_ROUTER_TerminalParseLine>:
{
 801e50c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e510:	b08b      	sub	sp, #44	@ 0x2c
 801e512:	4607      	mov	r7, r0
 801e514:	460c      	mov	r4, r1
  int input_len = strlen(input);
 801e516:	f004 fff9 	bl	802350c <strlen>
  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 801e51a:	499d      	ldr	r1, [pc, #628]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
  int input_len = strlen(input);
 801e51c:	4681      	mov	r9, r0
  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 801e51e:	aa06      	add	r2, sp, #24
 801e520:	4638      	mov	r0, r7
 801e522:	f005 f86f 	bl	8023604 <strtok_r>
 801e526:	4605      	mov	r5, r0
 801e528:	b948      	cbnz	r0, 801e53e <MIDI_ROUTER_TerminalParseLine+0x32>
 801e52a:	1e7a      	subs	r2, r7, #1
  for(i=0; i<input_len; ++i, ++input_ptr)
 801e52c:	f1c7 0301 	rsb	r3, r7, #1
      *input_ptr = ' ';
 801e530:	2020      	movs	r0, #32
  for(i=0; i<input_len; ++i, ++input_ptr)
 801e532:	1899      	adds	r1, r3, r2
 801e534:	4589      	cmp	r9, r1
 801e536:	f300 81db 	bgt.w	801e8f0 <MIDI_ROUTER_TerminalParseLine+0x3e4>
  return 0; // command not taken
 801e53a:	2000      	movs	r0, #0
 801e53c:	e007      	b.n	801e54e <MIDI_ROUTER_TerminalParseLine+0x42>
    if( strcmp(parameter, "router") == 0 ) {
 801e53e:	4995      	ldr	r1, [pc, #596]	@ (801e794 <MIDI_ROUTER_TerminalParseLine+0x288>)
 801e540:	f005 f863 	bl	802360a <strcmp>
 801e544:	b930      	cbnz	r0, 801e554 <MIDI_ROUTER_TerminalParseLine+0x48>
      MIDI_ROUTER_TerminalPrintConfig(_output_function);
 801e546:	4620      	mov	r0, r4
 801e548:	f7ff ff36 	bl	801e3b8 <MIDI_ROUTER_TerminalPrintConfig>
      return 1; // command taken
 801e54c:	2001      	movs	r0, #1
}
 801e54e:	b00b      	add	sp, #44	@ 0x2c
 801e550:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    } else if( strcmp(parameter, "set") == 0 ) {
 801e554:	4990      	ldr	r1, [pc, #576]	@ (801e798 <MIDI_ROUTER_TerminalParseLine+0x28c>)
 801e556:	4628      	mov	r0, r5
 801e558:	f005 f857 	bl	802360a <strcmp>
 801e55c:	2800      	cmp	r0, #0
 801e55e:	d1e4      	bne.n	801e52a <MIDI_ROUTER_TerminalParseLine+0x1e>
      if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801e560:	498b      	ldr	r1, [pc, #556]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e562:	aa06      	add	r2, sp, #24
 801e564:	f005 f84e 	bl	8023604 <strtok_r>
 801e568:	4606      	mov	r6, r0
 801e56a:	b910      	cbnz	r0, 801e572 <MIDI_ROUTER_TerminalParseLine+0x66>
	out("Missing parameter after 'set'!");
 801e56c:	488b      	ldr	r0, [pc, #556]	@ (801e79c <MIDI_ROUTER_TerminalParseLine+0x290>)
 801e56e:	47a0      	blx	r4
	return 1; // command taken
 801e570:	e7ec      	b.n	801e54c <MIDI_ROUTER_TerminalParseLine+0x40>
      if( strcmp(parameter, "router") == 0 ) {
 801e572:	4988      	ldr	r1, [pc, #544]	@ (801e794 <MIDI_ROUTER_TerminalParseLine+0x288>)
 801e574:	f005 f849 	bl	802360a <strcmp>
 801e578:	4605      	mov	r5, r0
 801e57a:	2800      	cmp	r0, #0
 801e57c:	f040 80f0 	bne.w	801e760 <MIDI_ROUTER_TerminalParseLine+0x254>
	if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801e580:	4983      	ldr	r1, [pc, #524]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e582:	aa06      	add	r2, sp, #24
 801e584:	f005 f83e 	bl	8023604 <strtok_r>
 801e588:	b910      	cbnz	r0, 801e590 <MIDI_ROUTER_TerminalParseLine+0x84>
	  out("Missing node number!");
 801e58a:	4885      	ldr	r0, [pc, #532]	@ (801e7a0 <MIDI_ROUTER_TerminalParseLine+0x294>)
	  out("Missing destination channel, expecting off, 1..16 or all!");
 801e58c:	47a0      	blx	r4
 801e58e:	e00a      	b.n	801e5a6 <MIDI_ROUTER_TerminalParseLine+0x9a>
	s32 node = get_dec(parameter);
 801e590:	f7ff fd64 	bl	801e05c <get_dec>
	if( node < 1 || node > MIDI_ROUTER_NUM_NODES ) {
 801e594:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
 801e598:	f1ba 0f0f 	cmp.w	sl, #15
	s32 node = get_dec(parameter);
 801e59c:	4681      	mov	r9, r0
	if( node < 1 || node > MIDI_ROUTER_NUM_NODES ) {
 801e59e:	d906      	bls.n	801e5ae <MIDI_ROUTER_TerminalParseLine+0xa2>
	  out("Expecting node number between 1..%d!", MIDI_ROUTER_NUM_NODES);
 801e5a0:	4880      	ldr	r0, [pc, #512]	@ (801e7a4 <MIDI_ROUTER_TerminalParseLine+0x298>)
 801e5a2:	2110      	movs	r1, #16
 801e5a4:	47a0      	blx	r4
	  MIDI_ROUTER_TerminalSetRouterSyntax(out);
 801e5a6:	4620      	mov	r0, r4
 801e5a8:	f7ff fd68 	bl	801e07c <MIDI_ROUTER_TerminalSetRouterSyntax.isra.0>
	  return 1; // command taken
 801e5ac:	e7ce      	b.n	801e54c <MIDI_ROUTER_TerminalParseLine+0x40>
	if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801e5ae:	4978      	ldr	r1, [pc, #480]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e5b0:	aa06      	add	r2, sp, #24
 801e5b2:	4628      	mov	r0, r5
 801e5b4:	f005 f826 	bl	8023604 <strtok_r>
 801e5b8:	4607      	mov	r7, r0
 801e5ba:	bb78      	cbnz	r0, 801e61c <MIDI_ROUTER_TerminalParseLine+0x110>
	  out("Missing input port!");
 801e5bc:	487a      	ldr	r0, [pc, #488]	@ (801e7a8 <MIDI_ROUTER_TerminalParseLine+0x29c>)
 801e5be:	e7e5      	b.n	801e58c <MIDI_ROUTER_TerminalParseLine+0x80>
	  int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e5c0:	f813 2b01 	ldrb.w	r2, [r3], #1
 801e5c4:	2a20      	cmp	r2, #32
 801e5c6:	bf08      	it	eq
 801e5c8:	f803 bc01 	strbeq.w	fp, [r3, #-1]
 801e5cc:	3601      	adds	r6, #1
 801e5ce:	e00f      	b.n	801e5f0 <MIDI_ROUTER_TerminalParseLine+0xe4>
	for(port_ix=0; port_ix<MIDI_PORT_InNumGet(); ++port_ix) {
 801e5d0:	3501      	adds	r5, #1
 801e5d2:	f000 f9d1 	bl	801e978 <MIDI_PORT_InNumGet>
 801e5d6:	42a8      	cmp	r0, r5
 801e5d8:	dd1e      	ble.n	801e618 <MIDI_ROUTER_TerminalParseLine+0x10c>
	  strcpy(port_name, MIDI_PORT_InNameGet(port_ix));
 801e5da:	fa5f f885 	uxtb.w	r8, r5
 801e5de:	4640      	mov	r0, r8
 801e5e0:	f000 f9d0 	bl	801e984 <MIDI_PORT_InNameGet>
 801e5e4:	4601      	mov	r1, r0
 801e5e6:	a807      	add	r0, sp, #28
 801e5e8:	f004 ff78 	bl	80234dc <strcpy>
	  int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e5ec:	2600      	movs	r6, #0
 801e5ee:	ab07      	add	r3, sp, #28
 801e5f0:	a807      	add	r0, sp, #28
 801e5f2:	9303      	str	r3, [sp, #12]
 801e5f4:	f004 ff8a 	bl	802350c <strlen>
 801e5f8:	42b0      	cmp	r0, r6
 801e5fa:	9b03      	ldr	r3, [sp, #12]
 801e5fc:	d8e0      	bhi.n	801e5c0 <MIDI_ROUTER_TerminalParseLine+0xb4>
	  if( strcasecmp(parameter, port_name) == 0 ) {
 801e5fe:	a907      	add	r1, sp, #28
 801e600:	4638      	mov	r0, r7
 801e602:	f004 ff51 	bl	80234a8 <strcasecmp>
 801e606:	4606      	mov	r6, r0
 801e608:	2800      	cmp	r0, #0
 801e60a:	d1e1      	bne.n	801e5d0 <MIDI_ROUTER_TerminalParseLine+0xc4>
	    src_port = MIDI_PORT_InPortGet(port_ix);
 801e60c:	4640      	mov	r0, r8
 801e60e:	f000 f9e9 	bl	801e9e4 <MIDI_PORT_InPortGet>
	if( src_port >= 0xf0 ) {
 801e612:	28ef      	cmp	r0, #239	@ 0xef
	    src_port = MIDI_PORT_InPortGet(port_ix);
 801e614:	4607      	mov	r7, r0
	if( src_port >= 0xf0 ) {
 801e616:	d903      	bls.n	801e620 <MIDI_ROUTER_TerminalParseLine+0x114>
	  out("Unknown or invalid MIDI input port!");
 801e618:	4864      	ldr	r0, [pc, #400]	@ (801e7ac <MIDI_ROUTER_TerminalParseLine+0x2a0>)
 801e61a:	e7a8      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
	  int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e61c:	46ab      	mov	fp, r5
 801e61e:	e7d8      	b.n	801e5d2 <MIDI_ROUTER_TerminalParseLine+0xc6>
	if( !(arg_src_chn = strtok_r(NULL, separators, &brkt)) ) {
 801e620:	4630      	mov	r0, r6
 801e622:	495b      	ldr	r1, [pc, #364]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e624:	aa06      	add	r2, sp, #24
 801e626:	f004 ffed 	bl	8023604 <strtok_r>
 801e62a:	4606      	mov	r6, r0
 801e62c:	b908      	cbnz	r0, 801e632 <MIDI_ROUTER_TerminalParseLine+0x126>
	  out("Missing source channel, expecting off, 1..16 or all!");
 801e62e:	4860      	ldr	r0, [pc, #384]	@ (801e7b0 <MIDI_ROUTER_TerminalParseLine+0x2a4>)
 801e630:	e7ac      	b.n	801e58c <MIDI_ROUTER_TerminalParseLine+0x80>
	if( strcmp(arg_src_chn, "---") == 0 || strcasecmp(arg_src_chn, "off") == 0 )
 801e632:	4960      	ldr	r1, [pc, #384]	@ (801e7b4 <MIDI_ROUTER_TerminalParseLine+0x2a8>)
 801e634:	f004 ffe9 	bl	802360a <strcmp>
 801e638:	4605      	mov	r5, r0
 801e63a:	b198      	cbz	r0, 801e664 <MIDI_ROUTER_TerminalParseLine+0x158>
 801e63c:	495e      	ldr	r1, [pc, #376]	@ (801e7b8 <MIDI_ROUTER_TerminalParseLine+0x2ac>)
 801e63e:	4630      	mov	r0, r6
 801e640:	f004 ff32 	bl	80234a8 <strcasecmp>
 801e644:	4605      	mov	r5, r0
 801e646:	b168      	cbz	r0, 801e664 <MIDI_ROUTER_TerminalParseLine+0x158>
	else if( strcasecmp(arg_src_chn, "All") == 0 )
 801e648:	495c      	ldr	r1, [pc, #368]	@ (801e7bc <MIDI_ROUTER_TerminalParseLine+0x2b0>)
 801e64a:	4630      	mov	r0, r6
 801e64c:	f004 ff2c 	bl	80234a8 <strcasecmp>
 801e650:	b138      	cbz	r0, 801e662 <MIDI_ROUTER_TerminalParseLine+0x156>
	  src_chn = get_dec(arg_src_chn);
 801e652:	4630      	mov	r0, r6
 801e654:	f7ff fd02 	bl	801e05c <get_dec>
	  if( src_chn > 16 )
 801e658:	2810      	cmp	r0, #16
	  src_chn = get_dec(arg_src_chn);
 801e65a:	4605      	mov	r5, r0
	  if( src_chn > 16 )
 801e65c:	d902      	bls.n	801e664 <MIDI_ROUTER_TerminalParseLine+0x158>
	  out("Invalid source channel, expecting off, 1..16 or all!");
 801e65e:	4858      	ldr	r0, [pc, #352]	@ (801e7c0 <MIDI_ROUTER_TerminalParseLine+0x2b4>)
 801e660:	e785      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
	  src_chn = 17;
 801e662:	2511      	movs	r5, #17
	if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801e664:	494a      	ldr	r1, [pc, #296]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e666:	aa06      	add	r2, sp, #24
 801e668:	2000      	movs	r0, #0
 801e66a:	f004 ffcb 	bl	8023604 <strtok_r>
 801e66e:	9003      	str	r0, [sp, #12]
 801e670:	2800      	cmp	r0, #0
 801e672:	d134      	bne.n	801e6de <MIDI_ROUTER_TerminalParseLine+0x1d2>
	  out("Missing output port!");
 801e674:	4853      	ldr	r0, [pc, #332]	@ (801e7c4 <MIDI_ROUTER_TerminalParseLine+0x2b8>)
 801e676:	e789      	b.n	801e58c <MIDI_ROUTER_TerminalParseLine+0x80>
	  int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e678:	f812 1b01 	ldrb.w	r1, [r2], #1
 801e67c:	2920      	cmp	r1, #32
 801e67e:	bf04      	itt	eq
 801e680:	2100      	moveq	r1, #0
 801e682:	f802 1c01 	strbeq.w	r1, [r2, #-1]
 801e686:	3301      	adds	r3, #1
 801e688:	e010      	b.n	801e6ac <MIDI_ROUTER_TerminalParseLine+0x1a0>
	for(port_ix=0; port_ix<MIDI_PORT_OutNumGet(); ++port_ix) {
 801e68a:	f108 0801 	add.w	r8, r8, #1
 801e68e:	f000 f975 	bl	801e97c <MIDI_PORT_OutNumGet>
 801e692:	4540      	cmp	r0, r8
 801e694:	dd21      	ble.n	801e6da <MIDI_ROUTER_TerminalParseLine+0x1ce>
	  strcpy(port_name, MIDI_PORT_OutNameGet(port_ix));
 801e696:	fa5f fb88 	uxtb.w	fp, r8
 801e69a:	4658      	mov	r0, fp
 801e69c:	f000 f982 	bl	801e9a4 <MIDI_PORT_OutNameGet>
 801e6a0:	4601      	mov	r1, r0
 801e6a2:	a807      	add	r0, sp, #28
 801e6a4:	f004 ff1a 	bl	80234dc <strcpy>
	  int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e6a8:	aa07      	add	r2, sp, #28
 801e6aa:	2300      	movs	r3, #0
 801e6ac:	a807      	add	r0, sp, #28
 801e6ae:	e9cd 3204 	strd	r3, r2, [sp, #16]
 801e6b2:	f004 ff2b 	bl	802350c <strlen>
 801e6b6:	9b04      	ldr	r3, [sp, #16]
 801e6b8:	9a05      	ldr	r2, [sp, #20]
 801e6ba:	4298      	cmp	r0, r3
 801e6bc:	d8dc      	bhi.n	801e678 <MIDI_ROUTER_TerminalParseLine+0x16c>
	  if( strcasecmp(parameter, port_name) == 0 ) {
 801e6be:	9803      	ldr	r0, [sp, #12]
 801e6c0:	a907      	add	r1, sp, #28
 801e6c2:	f004 fef1 	bl	80234a8 <strcasecmp>
 801e6c6:	2800      	cmp	r0, #0
 801e6c8:	d1df      	bne.n	801e68a <MIDI_ROUTER_TerminalParseLine+0x17e>
 801e6ca:	9003      	str	r0, [sp, #12]
	    dst_port = MIDI_PORT_OutPortGet(port_ix);
 801e6cc:	4658      	mov	r0, fp
 801e6ce:	f000 f995 	bl	801e9fc <MIDI_PORT_OutPortGet>
	if( dst_port >= 0xf0 ) {
 801e6d2:	28ef      	cmp	r0, #239	@ 0xef
 801e6d4:	9b03      	ldr	r3, [sp, #12]
	    dst_port = MIDI_PORT_OutPortGet(port_ix);
 801e6d6:	4683      	mov	fp, r0
	if( dst_port >= 0xf0 ) {
 801e6d8:	d904      	bls.n	801e6e4 <MIDI_ROUTER_TerminalParseLine+0x1d8>
	  out("Unknown or invalid MIDI output port!");
 801e6da:	483b      	ldr	r0, [pc, #236]	@ (801e7c8 <MIDI_ROUTER_TerminalParseLine+0x2bc>)
 801e6dc:	e747      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
	for(port_ix=0; port_ix<MIDI_PORT_OutNumGet(); ++port_ix) {
 801e6de:	f04f 0800 	mov.w	r8, #0
 801e6e2:	e7d4      	b.n	801e68e <MIDI_ROUTER_TerminalParseLine+0x182>
	if( !(arg_dst_chn = strtok_r(NULL, separators, &brkt)) ) {
 801e6e4:	492a      	ldr	r1, [pc, #168]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e6e6:	aa06      	add	r2, sp, #24
 801e6e8:	4618      	mov	r0, r3
 801e6ea:	f004 ff8b 	bl	8023604 <strtok_r>
 801e6ee:	4680      	mov	r8, r0
 801e6f0:	b908      	cbnz	r0, 801e6f6 <MIDI_ROUTER_TerminalParseLine+0x1ea>
	  out("Missing destination channel, expecting off, 1..16 or all!");
 801e6f2:	4836      	ldr	r0, [pc, #216]	@ (801e7cc <MIDI_ROUTER_TerminalParseLine+0x2c0>)
 801e6f4:	e74a      	b.n	801e58c <MIDI_ROUTER_TerminalParseLine+0x80>
	if( strcmp(arg_dst_chn, "---") == 0 || strcasecmp(arg_dst_chn, "off") == 0 )
 801e6f6:	492f      	ldr	r1, [pc, #188]	@ (801e7b4 <MIDI_ROUTER_TerminalParseLine+0x2a8>)
 801e6f8:	f004 ff87 	bl	802360a <strcmp>
 801e6fc:	b188      	cbz	r0, 801e722 <MIDI_ROUTER_TerminalParseLine+0x216>
 801e6fe:	492e      	ldr	r1, [pc, #184]	@ (801e7b8 <MIDI_ROUTER_TerminalParseLine+0x2ac>)
 801e700:	4640      	mov	r0, r8
 801e702:	f004 fed1 	bl	80234a8 <strcasecmp>
 801e706:	b160      	cbz	r0, 801e722 <MIDI_ROUTER_TerminalParseLine+0x216>
	else if( strcasecmp(arg_dst_chn, "All") == 0 )
 801e708:	492c      	ldr	r1, [pc, #176]	@ (801e7bc <MIDI_ROUTER_TerminalParseLine+0x2b0>)
 801e70a:	4640      	mov	r0, r8
 801e70c:	f004 fecc 	bl	80234a8 <strcasecmp>
 801e710:	b130      	cbz	r0, 801e720 <MIDI_ROUTER_TerminalParseLine+0x214>
	  dst_chn = get_dec(arg_dst_chn);
 801e712:	4640      	mov	r0, r8
 801e714:	f7ff fca2 	bl	801e05c <get_dec>
	  if( dst_chn > 16 )
 801e718:	2810      	cmp	r0, #16
 801e71a:	d902      	bls.n	801e722 <MIDI_ROUTER_TerminalParseLine+0x216>
	  out("Invalid destination channel, expecting off, 1..16 or all!");
 801e71c:	482c      	ldr	r0, [pc, #176]	@ (801e7d0 <MIDI_ROUTER_TerminalParseLine+0x2c4>)
 801e71e:	e726      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
	  dst_chn = 17;
 801e720:	2011      	movs	r0, #17
	n->src_port = src_port;
 801e722:	4b2c      	ldr	r3, [pc, #176]	@ (801e7d4 <MIDI_ROUTER_TerminalParseLine+0x2c8>)
 801e724:	f803 702a 	strb.w	r7, [r3, sl, lsl #2]
	n->src_chn = src_chn;
 801e728:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
	n->dst_chn = dst_chn;
 801e72c:	f88a 0003 	strb.w	r0, [sl, #3]
	out("Changed Node %d to SRC:%s %s  DST:%s %s",
 801e730:	4638      	mov	r0, r7
	n->src_chn = src_chn;
 801e732:	f88a 5001 	strb.w	r5, [sl, #1]
	n->dst_port = dst_port;
 801e736:	f88a b002 	strb.w	fp, [sl, #2]
	out("Changed Node %d to SRC:%s %s  DST:%s %s",
 801e73a:	f000 f977 	bl	801ea2c <MIDI_PORT_InIxGet>
 801e73e:	f000 f921 	bl	801e984 <MIDI_PORT_InNameGet>
 801e742:	4605      	mov	r5, r0
 801e744:	f89a 0002 	ldrb.w	r0, [sl, #2]
 801e748:	f000 f982 	bl	801ea50 <MIDI_PORT_OutIxGet>
 801e74c:	f000 f92a 	bl	801e9a4 <MIDI_PORT_OutNameGet>
 801e750:	4633      	mov	r3, r6
 801e752:	e9cd 0800 	strd	r0, r8, [sp]
 801e756:	462a      	mov	r2, r5
 801e758:	481f      	ldr	r0, [pc, #124]	@ (801e7d8 <MIDI_ROUTER_TerminalParseLine+0x2cc>)
 801e75a:	4649      	mov	r1, r9
 801e75c:	47a0      	blx	r4
	return 1; // command taken
 801e75e:	e6f5      	b.n	801e54c <MIDI_ROUTER_TerminalParseLine+0x40>
      } else if( strcmp(parameter, "mclk_in") == 0 || strcmp(parameter, "mclk_out") == 0 ) {
 801e760:	491e      	ldr	r1, [pc, #120]	@ (801e7dc <MIDI_ROUTER_TerminalParseLine+0x2d0>)
 801e762:	4630      	mov	r0, r6
 801e764:	f004 ff51 	bl	802360a <strcmp>
 801e768:	4680      	mov	r8, r0
 801e76a:	b130      	cbz	r0, 801e77a <MIDI_ROUTER_TerminalParseLine+0x26e>
 801e76c:	491c      	ldr	r1, [pc, #112]	@ (801e7e0 <MIDI_ROUTER_TerminalParseLine+0x2d4>)
 801e76e:	4630      	mov	r0, r6
 801e770:	f004 ff4b 	bl	802360a <strcmp>
 801e774:	2800      	cmp	r0, #0
 801e776:	f47f aed8 	bne.w	801e52a <MIDI_ROUTER_TerminalParseLine+0x1e>
          if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801e77a:	4905      	ldr	r1, [pc, #20]	@ (801e790 <MIDI_ROUTER_TerminalParseLine+0x284>)
 801e77c:	aa06      	add	r2, sp, #24
 801e77e:	2000      	movs	r0, #0
 801e780:	f004 ff40 	bl	8023604 <strtok_r>
 801e784:	4606      	mov	r6, r0
 801e786:	2800      	cmp	r0, #0
 801e788:	d167      	bne.n	801e85a <MIDI_ROUTER_TerminalParseLine+0x34e>
            out("Missing MIDI clock port!");
 801e78a:	4816      	ldr	r0, [pc, #88]	@ (801e7e4 <MIDI_ROUTER_TerminalParseLine+0x2d8>)
 801e78c:	e6ef      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
 801e78e:	bf00      	nop
 801e790:	080237ba 	.word	0x080237ba
 801e794:	080276c2 	.word	0x080276c2
 801e798:	0802391b 	.word	0x0802391b
 801e79c:	08023b98 	.word	0x08023b98
 801e7a0:	080276c9 	.word	0x080276c9
 801e7a4:	080276de 	.word	0x080276de
 801e7a8:	08027703 	.word	0x08027703
 801e7ac:	08027717 	.word	0x08027717
 801e7b0:	0802773b 	.word	0x0802773b
 801e7b4:	08027968 	.word	0x08027968
 801e7b8:	0802531e 	.word	0x0802531e
 801e7bc:	08027770 	.word	0x08027770
 801e7c0:	08027774 	.word	0x08027774
 801e7c4:	080277a9 	.word	0x080277a9
 801e7c8:	080277be 	.word	0x080277be
 801e7cc:	080277e3 	.word	0x080277e3
 801e7d0:	0802781d 	.word	0x0802781d
 801e7d4:	2000005e 	.word	0x2000005e
 801e7d8:	08027857 	.word	0x08027857
 801e7dc:	0802787f 	.word	0x0802787f
 801e7e0:	08027887 	.word	0x08027887
 801e7e4:	08027890 	.word	0x08027890
              strcpy(port_name, MIDI_PORT_ClkNameGet(port_ix));
 801e7e8:	fa5f fa85 	uxtb.w	sl, r5
 801e7ec:	4650      	mov	r0, sl
 801e7ee:	f000 f8e9 	bl	801e9c4 <MIDI_PORT_ClkNameGet>
 801e7f2:	4601      	mov	r1, r0
 801e7f4:	a807      	add	r0, sp, #28
 801e7f6:	f004 fe71 	bl	80234dc <strcpy>
              int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e7fa:	f10d 091c 	add.w	r9, sp, #28
 801e7fe:	2700      	movs	r7, #0
 801e800:	a807      	add	r0, sp, #28
 801e802:	f004 fe83 	bl	802350c <strlen>
 801e806:	42b8      	cmp	r0, r7
 801e808:	d816      	bhi.n	801e838 <MIDI_ROUTER_TerminalParseLine+0x32c>
              if( strcasecmp(parameter, port_name) == 0 ) {
 801e80a:	a907      	add	r1, sp, #28
 801e80c:	4630      	mov	r0, r6
 801e80e:	f004 fe4b 	bl	80234a8 <strcasecmp>
 801e812:	b9c8      	cbnz	r0, 801e848 <MIDI_ROUTER_TerminalParseLine+0x33c>
                mclk_port = MIDI_PORT_ClkPortGet(port_ix);
 801e814:	4650      	mov	r0, sl
 801e816:	f000 f8fd 	bl	801ea14 <MIDI_PORT_ClkPortGet>
 801e81a:	4605      	mov	r5, r0
            if( mclk_in && mclk_port >= 0xf0 ) {
 801e81c:	f1b8 0f00 	cmp.w	r8, #0
 801e820:	d01e      	beq.n	801e860 <MIDI_ROUTER_TerminalParseLine+0x354>
            if( !mclk_in && mclk_port >= 0xf0 ) {
 801e822:	28ef      	cmp	r0, #239	@ 0xef
 801e824:	d92b      	bls.n	801e87e <MIDI_ROUTER_TerminalParseLine+0x372>
              if( strncmp(parameter, "OUT", 3) == 0 && parameter[3] >= '1' && parameter[3] <= '4' )
 801e826:	4936      	ldr	r1, [pc, #216]	@ (801e900 <MIDI_ROUTER_TerminalParseLine+0x3f4>)
 801e828:	2203      	movs	r2, #3
 801e82a:	4630      	mov	r0, r6
 801e82c:	f004 fe76 	bl	802351c <strncmp>
 801e830:	2800      	cmp	r0, #0
 801e832:	d140      	bne.n	801e8b6 <MIDI_ROUTER_TerminalParseLine+0x3aa>
 801e834:	78f5      	ldrb	r5, [r6, #3]
 801e836:	e01c      	b.n	801e872 <MIDI_ROUTER_TerminalParseLine+0x366>
              int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e838:	f819 3b01 	ldrb.w	r3, [r9], #1
 801e83c:	2b20      	cmp	r3, #32
 801e83e:	bf08      	it	eq
 801e840:	f809 bc01 	strbeq.w	fp, [r9, #-1]
 801e844:	3701      	adds	r7, #1
 801e846:	e7db      	b.n	801e800 <MIDI_ROUTER_TerminalParseLine+0x2f4>
            for(port_ix=0; port_ix<MIDI_PORT_ClkNumGet(); ++port_ix) {
 801e848:	3501      	adds	r5, #1
 801e84a:	f000 f899 	bl	801e980 <MIDI_PORT_ClkNumGet>
 801e84e:	42a8      	cmp	r0, r5
 801e850:	dcca      	bgt.n	801e7e8 <MIDI_ROUTER_TerminalParseLine+0x2dc>
            if( mclk_in && mclk_port >= 0xf0 ) {
 801e852:	f1b8 0f00 	cmp.w	r8, #0
 801e856:	d1e6      	bne.n	801e826 <MIDI_ROUTER_TerminalParseLine+0x31a>
 801e858:	e004      	b.n	801e864 <MIDI_ROUTER_TerminalParseLine+0x358>
            for(port_ix=0; port_ix<MIDI_PORT_ClkNumGet(); ++port_ix) {
 801e85a:	2500      	movs	r5, #0
              int i; for(i=0; i<strlen(port_name); ++i) if( port_name[i] == ' ' ) port_name[i] = 0;
 801e85c:	46ab      	mov	fp, r5
 801e85e:	e7f4      	b.n	801e84a <MIDI_ROUTER_TerminalParseLine+0x33e>
            if( mclk_in && mclk_port >= 0xf0 ) {
 801e860:	28ef      	cmp	r0, #239	@ 0xef
 801e862:	d90c      	bls.n	801e87e <MIDI_ROUTER_TerminalParseLine+0x372>
              if( strncmp(parameter, "IN", 2) == 0 && parameter[2] >= '1' && parameter[2] <= '4' )
 801e864:	4927      	ldr	r1, [pc, #156]	@ (801e904 <MIDI_ROUTER_TerminalParseLine+0x3f8>)
 801e866:	2202      	movs	r2, #2
 801e868:	4630      	mov	r0, r6
 801e86a:	f004 fe57 	bl	802351c <strncmp>
 801e86e:	bb10      	cbnz	r0, 801e8b6 <MIDI_ROUTER_TerminalParseLine+0x3aa>
 801e870:	78b5      	ldrb	r5, [r6, #2]
              if( strncmp(parameter, "OUT", 3) == 0 && parameter[3] >= '1' && parameter[3] <= '4' )
 801e872:	f1a5 0331 	sub.w	r3, r5, #49	@ 0x31
 801e876:	2b03      	cmp	r3, #3
 801e878:	d81d      	bhi.n	801e8b6 <MIDI_ROUTER_TerminalParseLine+0x3aa>
                mclk_port = UART0 + (parameter[3] - '1');
 801e87a:	3d11      	subs	r5, #17
 801e87c:	b2ed      	uxtb	r5, r5
	    if( !(arg_on_off = strtok_r(NULL, separators, &brkt)) ||
 801e87e:	4922      	ldr	r1, [pc, #136]	@ (801e908 <MIDI_ROUTER_TerminalParseLine+0x3fc>)
 801e880:	aa06      	add	r2, sp, #24
 801e882:	2000      	movs	r0, #0
 801e884:	f004 febe 	bl	8023604 <strtok_r>
 801e888:	4607      	mov	r7, r0
 801e88a:	b190      	cbz	r0, 801e8b2 <MIDI_ROUTER_TerminalParseLine+0x3a6>
  if( strcmp(word, "on") == 0 || strcmp(word, "1") == 0 )
 801e88c:	491f      	ldr	r1, [pc, #124]	@ (801e90c <MIDI_ROUTER_TerminalParseLine+0x400>)
 801e88e:	f004 febc 	bl	802360a <strcmp>
 801e892:	b190      	cbz	r0, 801e8ba <MIDI_ROUTER_TerminalParseLine+0x3ae>
 801e894:	491e      	ldr	r1, [pc, #120]	@ (801e910 <MIDI_ROUTER_TerminalParseLine+0x404>)
 801e896:	4638      	mov	r0, r7
 801e898:	f004 feb7 	bl	802360a <strcmp>
 801e89c:	b168      	cbz	r0, 801e8ba <MIDI_ROUTER_TerminalParseLine+0x3ae>
  if( strcmp(word, "off") == 0 || strcmp(word, "0") == 0 )
 801e89e:	491d      	ldr	r1, [pc, #116]	@ (801e914 <MIDI_ROUTER_TerminalParseLine+0x408>)
 801e8a0:	4638      	mov	r0, r7
 801e8a2:	f004 feb2 	bl	802360a <strcmp>
 801e8a6:	b148      	cbz	r0, 801e8bc <MIDI_ROUTER_TerminalParseLine+0x3b0>
 801e8a8:	491b      	ldr	r1, [pc, #108]	@ (801e918 <MIDI_ROUTER_TerminalParseLine+0x40c>)
 801e8aa:	4638      	mov	r0, r7
 801e8ac:	f004 fead 	bl	802360a <strcmp>
 801e8b0:	b120      	cbz	r0, 801e8bc <MIDI_ROUTER_TerminalParseLine+0x3b0>
	      out("Missing 'on' or 'off' after port name!");
 801e8b2:	481a      	ldr	r0, [pc, #104]	@ (801e91c <MIDI_ROUTER_TerminalParseLine+0x410>)
 801e8b4:	e65b      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
              out("Unknown or invalid MIDI Clock port!");
 801e8b6:	481a      	ldr	r0, [pc, #104]	@ (801e920 <MIDI_ROUTER_TerminalParseLine+0x414>)
 801e8b8:	e659      	b.n	801e56e <MIDI_ROUTER_TerminalParseLine+0x62>
    return 1;
 801e8ba:	2001      	movs	r0, #1
	      if( MIDI_ROUTER_MIDIClockInSet(mclk_port, on_off) < 0 )
 801e8bc:	b2c1      	uxtb	r1, r0
 801e8be:	4628      	mov	r0, r5
	    if( mclk_in ) {
 801e8c0:	f1b8 0f00 	cmp.w	r8, #0
 801e8c4:	d10c      	bne.n	801e8e0 <MIDI_ROUTER_TerminalParseLine+0x3d4>
	      if( MIDI_ROUTER_MIDIClockInSet(mclk_port, on_off) < 0 )
 801e8c6:	f7ff fd2b 	bl	801e320 <MIDI_ROUTER_MIDIClockInSet>
 801e8ca:	2800      	cmp	r0, #0
 801e8cc:	da03      	bge.n	801e8d6 <MIDI_ROUTER_TerminalParseLine+0x3ca>
		out("Failed to set MIDI Clock port %s", parameter);
 801e8ce:	4815      	ldr	r0, [pc, #84]	@ (801e924 <MIDI_ROUTER_TerminalParseLine+0x418>)
 801e8d0:	4631      	mov	r1, r6
 801e8d2:	47a0      	blx	r4
 801e8d4:	e63a      	b.n	801e54c <MIDI_ROUTER_TerminalParseLine+0x40>
		out("Set MIDI Clock for IN port %s to %s\n", parameter, arg_on_off);
 801e8d6:	4814      	ldr	r0, [pc, #80]	@ (801e928 <MIDI_ROUTER_TerminalParseLine+0x41c>)
 801e8d8:	463a      	mov	r2, r7
 801e8da:	4631      	mov	r1, r6
		out("Set MIDI Clock for OUT port %s to %s\n", parameter, arg_on_off);
 801e8dc:	47a0      	blx	r4
 801e8de:	e635      	b.n	801e54c <MIDI_ROUTER_TerminalParseLine+0x40>
	      if( MIDI_ROUTER_MIDIClockOutSet(mclk_port, on_off) < 0 )
 801e8e0:	f7ff fd42 	bl	801e368 <MIDI_ROUTER_MIDIClockOutSet>
 801e8e4:	2800      	cmp	r0, #0
 801e8e6:	dbf2      	blt.n	801e8ce <MIDI_ROUTER_TerminalParseLine+0x3c2>
		out("Set MIDI Clock for OUT port %s to %s\n", parameter, arg_on_off);
 801e8e8:	4810      	ldr	r0, [pc, #64]	@ (801e92c <MIDI_ROUTER_TerminalParseLine+0x420>)
 801e8ea:	463a      	mov	r2, r7
 801e8ec:	4631      	mov	r1, r6
 801e8ee:	e7f5      	b.n	801e8dc <MIDI_ROUTER_TerminalParseLine+0x3d0>
    if( !*input_ptr )
 801e8f0:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 801e8f4:	2900      	cmp	r1, #0
 801e8f6:	f47f ae1c 	bne.w	801e532 <MIDI_ROUTER_TerminalParseLine+0x26>
      *input_ptr = ' ';
 801e8fa:	7010      	strb	r0, [r2, #0]
  for(i=0; i<input_len; ++i, ++input_ptr)
 801e8fc:	e619      	b.n	801e532 <MIDI_ROUTER_TerminalParseLine+0x26>
 801e8fe:	bf00      	nop
 801e900:	080278ac 	.word	0x080278ac
 801e904:	080278a9 	.word	0x080278a9
 801e908:	080237ba 	.word	0x080237ba
 801e90c:	08024c4d 	.word	0x08024c4d
 801e910:	080283d9 	.word	0x080283d9
 801e914:	0802531e 	.word	0x0802531e
 801e918:	080283d6 	.word	0x080283d6
 801e91c:	080278d4 	.word	0x080278d4
 801e920:	080278b0 	.word	0x080278b0
 801e924:	080278fb 	.word	0x080278fb
 801e928:	0802791c 	.word	0x0802791c
 801e92c:	08027941 	.word	0x08027941

0801e930 <MIDI_PORT_Init>:

/////////////////////////////////////////////////////////////////////////////
// Initialisation
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_PORT_Init(u32 mode)
{
 801e930:	b538      	push	{r3, r4, r5, lr}
  int i;

  // init MIDI In/Out monitor variables
  for(i=0; i<MIDI_PORT_NUM_OUT_PORTS; ++i) {
    midi_out_ctr[i] = 0;
 801e932:	2400      	movs	r4, #0
 801e934:	4b0b      	ldr	r3, [pc, #44]	@ (801e964 <MIDI_PORT_Init+0x34>)
    midi_out_package[i].ALL = 0;
 801e936:	480c      	ldr	r0, [pc, #48]	@ (801e968 <MIDI_PORT_Init+0x38>)
    midi_out_ctr[i] = 0;
 801e938:	601c      	str	r4, [r3, #0]
    midi_out_package[i].ALL = 0;
 801e93a:	2528      	movs	r5, #40	@ 0x28
 801e93c:	462a      	mov	r2, r5
 801e93e:	4621      	mov	r1, r4
    midi_out_ctr[i] = 0;
 801e940:	605c      	str	r4, [r3, #4]
 801e942:	811c      	strh	r4, [r3, #8]
    midi_out_package[i].ALL = 0;
 801e944:	f004 fe05 	bl	8023552 <memset>
  }

  for(i=0; i<MIDI_PORT_NUM_IN_PORTS; ++i) {
    midi_in_ctr[i] = 0;
 801e948:	4b08      	ldr	r3, [pc, #32]	@ (801e96c <MIDI_PORT_Init+0x3c>)
    midi_in_package[i].ALL = 0;
 801e94a:	4809      	ldr	r0, [pc, #36]	@ (801e970 <MIDI_PORT_Init+0x40>)
    midi_in_ctr[i] = 0;
 801e94c:	601c      	str	r4, [r3, #0]
    midi_in_package[i].ALL = 0;
 801e94e:	462a      	mov	r2, r5
 801e950:	4621      	mov	r1, r4
    midi_in_ctr[i] = 0;
 801e952:	605c      	str	r4, [r3, #4]
 801e954:	811c      	strh	r4, [r3, #8]
    midi_in_package[i].ALL = 0;
 801e956:	f004 fdfc 	bl	8023552 <memset>
  }

  midi_port_mon_filter.ALL = 0;
 801e95a:	4b06      	ldr	r3, [pc, #24]	@ (801e974 <MIDI_PORT_Init+0x44>)
 801e95c:	2203      	movs	r2, #3
 801e95e:	701a      	strb	r2, [r3, #0]
  midi_port_mon_filter.MIDI_CLOCK = 1;
  midi_port_mon_filter.ACTIVE_SENSE = 1;

  return 0; // no error
}
 801e960:	4620      	mov	r0, r4
 801e962:	bd38      	pop	{r3, r4, r5, pc}
 801e964:	20006a10 	.word	0x20006a10
 801e968:	200069e8 	.word	0x200069e8
 801e96c:	200069dc 	.word	0x200069dc
 801e970:	200069b4 	.word	0x200069b4
 801e974:	200069b1 	.word	0x200069b1

0801e978 <MIDI_PORT_InNumGet>:
// Returns number of available MIDI IN/OUT port
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_PORT_InNumGet(void)
{
  return MIDI_PORT_NUM_IN_PORTS;
}
 801e978:	200a      	movs	r0, #10
 801e97a:	4770      	bx	lr

0801e97c <MIDI_PORT_OutNumGet>:

s32 MIDI_PORT_OutNumGet(void)
 801e97c:	200a      	movs	r0, #10
 801e97e:	4770      	bx	lr

0801e980 <MIDI_PORT_ClkNumGet>:
}

s32 MIDI_PORT_ClkNumGet(void)
{
  return MIDI_PORT_NUM_CLK_PORTS;
}
 801e980:	2009      	movs	r0, #9
 801e982:	4770      	bx	lr

0801e984 <MIDI_PORT_InNameGet>:
// Returns name of MIDI IN/OUT port in (4 characters + zero terminator)
// port_ix is within 0..MIDI_PORT_In/OutNumGet()-1
/////////////////////////////////////////////////////////////////////////////
char *MIDI_PORT_InNameGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_IN_PORTS )
 801e984:	2809      	cmp	r0, #9
    return "----";
  else
    return (char *)in_ports[port_ix].name;
 801e986:	bf9f      	itttt	ls
 801e988:	2306      	movls	r3, #6
 801e98a:	2201      	movls	r2, #1
 801e98c:	fb13 2000 	smlabbls	r0, r3, r0, r2
 801e990:	4b02      	ldrls	r3, [pc, #8]	@ (801e99c <MIDI_PORT_InNameGet+0x18>)
 801e992:	bf94      	ite	ls
 801e994:	18c0      	addls	r0, r0, r3
    return "----";
 801e996:	4802      	ldrhi	r0, [pc, #8]	@ (801e9a0 <MIDI_PORT_InNameGet+0x1c>)
}
 801e998:	4770      	bx	lr
 801e99a:	bf00      	nop
 801e99c:	080279de 	.word	0x080279de
 801e9a0:	08027967 	.word	0x08027967

0801e9a4 <MIDI_PORT_OutNameGet>:

char *MIDI_PORT_OutNameGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_OUT_PORTS )
 801e9a4:	2809      	cmp	r0, #9
    return "----";
  else
    return (char *)out_ports[port_ix].name;
 801e9a6:	bf9f      	itttt	ls
 801e9a8:	2306      	movls	r3, #6
 801e9aa:	2201      	movls	r2, #1
 801e9ac:	fb13 2000 	smlabbls	r0, r3, r0, r2
 801e9b0:	4b02      	ldrls	r3, [pc, #8]	@ (801e9bc <MIDI_PORT_OutNameGet+0x18>)
 801e9b2:	bf94      	ite	ls
 801e9b4:	18c0      	addls	r0, r0, r3
    return "----";
 801e9b6:	4802      	ldrhi	r0, [pc, #8]	@ (801e9c0 <MIDI_PORT_OutNameGet+0x1c>)
}
 801e9b8:	4770      	bx	lr
 801e9ba:	bf00      	nop
 801e9bc:	080279a2 	.word	0x080279a2
 801e9c0:	08027967 	.word	0x08027967

0801e9c4 <MIDI_PORT_ClkNameGet>:

char *MIDI_PORT_ClkNameGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_CLK_PORTS )
 801e9c4:	2808      	cmp	r0, #8
    return "----";
  else
    return (char *)clk_ports[port_ix].name;
 801e9c6:	bf9f      	itttt	ls
 801e9c8:	2306      	movls	r3, #6
 801e9ca:	2201      	movls	r2, #1
 801e9cc:	fb13 2000 	smlabbls	r0, r3, r0, r2
 801e9d0:	4b02      	ldrls	r3, [pc, #8]	@ (801e9dc <MIDI_PORT_ClkNameGet+0x18>)
 801e9d2:	bf94      	ite	ls
 801e9d4:	18c0      	addls	r0, r0, r3
    return "----";
 801e9d6:	4802      	ldrhi	r0, [pc, #8]	@ (801e9e0 <MIDI_PORT_ClkNameGet+0x1c>)
}
 801e9d8:	4770      	bx	lr
 801e9da:	bf00      	nop
 801e9dc:	0802796c 	.word	0x0802796c
 801e9e0:	08027967 	.word	0x08027967

0801e9e4 <MIDI_PORT_InPortGet>:
// Returns the MIOS32 MIDI Port ID of a MIDI IN/OUT port
// port_ix is within 0..MIDI_PORT_In/OutNumGet()-1
/////////////////////////////////////////////////////////////////////////////
mios32_midi_port_t MIDI_PORT_InPortGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_IN_PORTS )
 801e9e4:	2809      	cmp	r0, #9
    return 0xff; // dummy interface
  else
    return in_ports[port_ix].port;
 801e9e6:	bf9f      	itttt	ls
 801e9e8:	2306      	movls	r3, #6
 801e9ea:	4358      	mulls	r0, r3
 801e9ec:	4b02      	ldrls	r3, [pc, #8]	@ (801e9f8 <MIDI_PORT_InPortGet+0x14>)
 801e9ee:	5c18      	ldrbls	r0, [r3, r0]
    return 0xff; // dummy interface
 801e9f0:	bf88      	it	hi
 801e9f2:	20ff      	movhi	r0, #255	@ 0xff
}
 801e9f4:	4770      	bx	lr
 801e9f6:	bf00      	nop
 801e9f8:	080279de 	.word	0x080279de

0801e9fc <MIDI_PORT_OutPortGet>:

mios32_midi_port_t MIDI_PORT_OutPortGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_OUT_PORTS )
 801e9fc:	2809      	cmp	r0, #9
    return 0xff; // dummy interface
  else
    return out_ports[port_ix].port;
 801e9fe:	bf9f      	itttt	ls
 801ea00:	2306      	movls	r3, #6
 801ea02:	4358      	mulls	r0, r3
 801ea04:	4b02      	ldrls	r3, [pc, #8]	@ (801ea10 <MIDI_PORT_OutPortGet+0x14>)
 801ea06:	5c18      	ldrbls	r0, [r3, r0]
    return 0xff; // dummy interface
 801ea08:	bf88      	it	hi
 801ea0a:	20ff      	movhi	r0, #255	@ 0xff
}
 801ea0c:	4770      	bx	lr
 801ea0e:	bf00      	nop
 801ea10:	080279a2 	.word	0x080279a2

0801ea14 <MIDI_PORT_ClkPortGet>:

mios32_midi_port_t MIDI_PORT_ClkPortGet(u8 port_ix)
{
  if( port_ix >= MIDI_PORT_NUM_CLK_PORTS )
 801ea14:	2808      	cmp	r0, #8
    return 0xff; // dummy interface
  else
    return clk_ports[port_ix].port;
 801ea16:	bf9f      	itttt	ls
 801ea18:	2306      	movls	r3, #6
 801ea1a:	4358      	mulls	r0, r3
 801ea1c:	4b02      	ldrls	r3, [pc, #8]	@ (801ea28 <MIDI_PORT_ClkPortGet+0x14>)
 801ea1e:	5c18      	ldrbls	r0, [r3, r0]
    return 0xff; // dummy interface
 801ea20:	bf88      	it	hi
 801ea22:	20ff      	movhi	r0, #255	@ 0xff
}
 801ea24:	4770      	bx	lr
 801ea26:	bf00      	nop
 801ea28:	0802796c 	.word	0x0802796c

0801ea2c <MIDI_PORT_InIxGet>:

/////////////////////////////////////////////////////////////////////////////
// Returns the MBSEQ MIDI Port Index of a MIOS32 MIDI IN/OUT port
/////////////////////////////////////////////////////////////////////////////
u8 MIDI_PORT_InIxGet(mios32_midi_port_t port)
{
 801ea2c:	b510      	push	{r4, lr}
  u8 ix;
  for(ix=0; ix<MIDI_PORT_NUM_IN_PORTS; ++ix) {
    if( in_ports[ix].port == port )
 801ea2e:	4907      	ldr	r1, [pc, #28]	@ (801ea4c <MIDI_PORT_InIxGet+0x20>)
{
 801ea30:	2300      	movs	r3, #0
    if( in_ports[ix].port == port )
 801ea32:	2206      	movs	r2, #6
 801ea34:	fb02 f403 	mul.w	r4, r2, r3
 801ea38:	5d0c      	ldrb	r4, [r1, r4]
 801ea3a:	4284      	cmp	r4, r0
 801ea3c:	d004      	beq.n	801ea48 <MIDI_PORT_InIxGet+0x1c>
  for(ix=0; ix<MIDI_PORT_NUM_IN_PORTS; ++ix) {
 801ea3e:	3301      	adds	r3, #1
 801ea40:	2b0a      	cmp	r3, #10
 801ea42:	d1f7      	bne.n	801ea34 <MIDI_PORT_InIxGet+0x8>
      return ix;
  }

  return 0; // return first ix if not found
 801ea44:	2000      	movs	r0, #0
}
 801ea46:	bd10      	pop	{r4, pc}
 801ea48:	b2d8      	uxtb	r0, r3
 801ea4a:	e7fc      	b.n	801ea46 <MIDI_PORT_InIxGet+0x1a>
 801ea4c:	080279de 	.word	0x080279de

0801ea50 <MIDI_PORT_OutIxGet>:

u8 MIDI_PORT_OutIxGet(mios32_midi_port_t port)
{
 801ea50:	b510      	push	{r4, lr}
  u8 ix;
  for(ix=0; ix<MIDI_PORT_NUM_OUT_PORTS; ++ix) {
    if( out_ports[ix].port == port )
 801ea52:	4907      	ldr	r1, [pc, #28]	@ (801ea70 <MIDI_PORT_OutIxGet+0x20>)
{
 801ea54:	2300      	movs	r3, #0
    if( out_ports[ix].port == port )
 801ea56:	2206      	movs	r2, #6
 801ea58:	fb02 f403 	mul.w	r4, r2, r3
 801ea5c:	5d0c      	ldrb	r4, [r1, r4]
 801ea5e:	4284      	cmp	r4, r0
 801ea60:	d004      	beq.n	801ea6c <MIDI_PORT_OutIxGet+0x1c>
  for(ix=0; ix<MIDI_PORT_NUM_OUT_PORTS; ++ix) {
 801ea62:	3301      	adds	r3, #1
 801ea64:	2b0a      	cmp	r3, #10
 801ea66:	d1f7      	bne.n	801ea58 <MIDI_PORT_OutIxGet+0x8>
      return ix;
  }

  return 0; // return first ix if not found
 801ea68:	2000      	movs	r0, #0
}
 801ea6a:	bd10      	pop	{r4, pc}
 801ea6c:	b2d8      	uxtb	r0, r3
 801ea6e:	e7fc      	b.n	801ea6a <MIDI_PORT_OutIxGet+0x1a>
 801ea70:	080279a2 	.word	0x080279a2

0801ea74 <MIDI_PORT_ClkCheckAvailable>:
  }
  return 0; // port not available
}

s32 MIDI_PORT_ClkCheckAvailable(mios32_midi_port_t port)
{
 801ea74:	b410      	push	{r4}
  u8 ix;
  for(ix=0; ix<MIDI_PORT_NUM_CLK_PORTS; ++ix) {
    if( clk_ports[ix].port == port ) {
 801ea76:	490d      	ldr	r1, [pc, #52]	@ (801eaac <MIDI_PORT_ClkCheckAvailable+0x38>)
{
 801ea78:	2300      	movs	r3, #0
    if( clk_ports[ix].port == port ) {
 801ea7a:	2206      	movs	r2, #6
 801ea7c:	fb02 f403 	mul.w	r4, r2, r3
 801ea80:	5d0c      	ldrb	r4, [r1, r4]
 801ea82:	4284      	cmp	r4, r0
 801ea84:	d10a      	bne.n	801ea9c <MIDI_PORT_ClkCheckAvailable+0x28>
      if( port == 0x80 ) {
 801ea86:	2880      	cmp	r0, #128	@ 0x80
 801ea88:	d00b      	beq.n	801eaa2 <MIDI_PORT_ClkCheckAvailable+0x2e>
	//return SEQ_CV_IfGet() ? 1 : 0;
	return 0;
      } else if ( port >= 0xf0 )
 801ea8a:	28ef      	cmp	r0, #239	@ 0xef
 801ea8c:	d80c      	bhi.n	801eaa8 <MIDI_PORT_ClkCheckAvailable+0x34>
	return 1; // Bus is always available
      else if( (port & 0xf0) == OSC0 )
 801ea8e:	f000 03f0 	and.w	r3, r0, #240	@ 0xf0
 801ea92:	2b40      	cmp	r3, #64	@ 0x40
 801ea94:	d008      	beq.n	801eaa8 <MIDI_PORT_ClkCheckAvailable+0x34>
      else
	return MIOS32_MIDI_CheckAvailable(port);
    }
  }
  return 0; // port not available
}
 801ea96:	bc10      	pop	{r4}
	return MIOS32_MIDI_CheckAvailable(port);
 801ea98:	f7f5 bf22 	b.w	80148e0 <MIOS32_MIDI_CheckAvailable>
  for(ix=0; ix<MIDI_PORT_NUM_CLK_PORTS; ++ix) {
 801ea9c:	3301      	adds	r3, #1
 801ea9e:	2b09      	cmp	r3, #9
 801eaa0:	d1ec      	bne.n	801ea7c <MIDI_PORT_ClkCheckAvailable+0x8>
	return 0;
 801eaa2:	2000      	movs	r0, #0
}
 801eaa4:	bc10      	pop	{r4}
 801eaa6:	4770      	bx	lr
	return 1; // Bus is always available
 801eaa8:	2001      	movs	r0, #1
 801eaaa:	e7fb      	b.n	801eaa4 <MIDI_PORT_ClkCheckAvailable+0x30>
 801eaac:	0802796c 	.word	0x0802796c

0801eab0 <MIDI_PORT_Period1mS>:
{
  int i;
  static u8 predivider = 0;

  // counters are handled each 10 mS
  if( ++predivider >= 10 ) {
 801eab0:	4a0f      	ldr	r2, [pc, #60]	@ (801eaf0 <MIDI_PORT_Period1mS+0x40>)
 801eab2:	7813      	ldrb	r3, [r2, #0]
 801eab4:	3301      	adds	r3, #1
 801eab6:	b2db      	uxtb	r3, r3
 801eab8:	2b09      	cmp	r3, #9
 801eaba:	d917      	bls.n	801eaec <MIDI_PORT_Period1mS+0x3c>
    predivider = 0;
 801eabc:	2300      	movs	r3, #0
 801eabe:	490d      	ldr	r1, [pc, #52]	@ (801eaf4 <MIDI_PORT_Period1mS+0x44>)
 801eac0:	7013      	strb	r3, [r2, #0]
 801eac2:	220a      	movs	r2, #10

    for(i=0; i<MIDI_PORT_NUM_OUT_PORTS; ++i)
      if( midi_out_ctr[i] )
 801eac4:	f811 3b01 	ldrb.w	r3, [r1], #1
 801eac8:	b113      	cbz	r3, 801ead0 <MIDI_PORT_Period1mS+0x20>
	--midi_out_ctr[i];
 801eaca:	3b01      	subs	r3, #1
 801eacc:	f801 3c01 	strb.w	r3, [r1, #-1]
    for(i=0; i<MIDI_PORT_NUM_OUT_PORTS; ++i)
 801ead0:	3a01      	subs	r2, #1
 801ead2:	d1f7      	bne.n	801eac4 <MIDI_PORT_Period1mS+0x14>
 801ead4:	4908      	ldr	r1, [pc, #32]	@ (801eaf8 <MIDI_PORT_Period1mS+0x48>)
 801ead6:	220a      	movs	r2, #10

    for(i=0; i<MIDI_PORT_NUM_IN_PORTS; ++i)
      if( midi_in_ctr[i] )
 801ead8:	f811 3b01 	ldrb.w	r3, [r1], #1
 801eadc:	b113      	cbz	r3, 801eae4 <MIDI_PORT_Period1mS+0x34>
	--midi_in_ctr[i];
 801eade:	3b01      	subs	r3, #1
 801eae0:	f801 3c01 	strb.w	r3, [r1, #-1]
    for(i=0; i<MIDI_PORT_NUM_IN_PORTS; ++i)
 801eae4:	3a01      	subs	r2, #1
 801eae6:	d1f7      	bne.n	801ead8 <MIDI_PORT_Period1mS+0x28>
  }

  return 0;
}
 801eae8:	2000      	movs	r0, #0
 801eaea:	4770      	bx	lr
  if( ++predivider >= 10 ) {
 801eaec:	7013      	strb	r3, [r2, #0]
 801eaee:	e7fb      	b.n	801eae8 <MIDI_PORT_Period1mS+0x38>
 801eaf0:	200069b0 	.word	0x200069b0
 801eaf4:	20006a10 	.word	0x20006a10
 801eaf8:	200069dc 	.word	0x200069dc

0801eafc <MIDI_PORT_NotifyMIDITx>:
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_PORT_NotifyMIDITx(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // MIDI Out monitor function
  u8 mon_filtered = 0;
  if( midi_port_mon_filter.MIDI_CLOCK && package.evnt0 == 0xf8 )
 801eafc:	4b17      	ldr	r3, [pc, #92]	@ (801eb5c <MIDI_PORT_NotifyMIDITx+0x60>)
 801eafe:	781b      	ldrb	r3, [r3, #0]
{
 801eb00:	b570      	push	{r4, r5, r6, lr}
 801eb02:	460e      	mov	r6, r1
 801eb04:	f3c1 2407 	ubfx	r4, r1, #8, #8
  if( midi_port_mon_filter.MIDI_CLOCK && package.evnt0 == 0xf8 )
 801eb08:	07d9      	lsls	r1, r3, #31
{
 801eb0a:	4605      	mov	r5, r0
  if( midi_port_mon_filter.MIDI_CLOCK && package.evnt0 == 0xf8 )
 801eb0c:	d501      	bpl.n	801eb12 <MIDI_PORT_NotifyMIDITx+0x16>
 801eb0e:	2cf8      	cmp	r4, #248	@ 0xf8
 801eb10:	d00e      	beq.n	801eb30 <MIDI_PORT_NotifyMIDITx+0x34>
    mon_filtered = 1;
  else if( midi_port_mon_filter.ACTIVE_SENSE && package.evnt0 == 0xfe )
 801eb12:	079a      	lsls	r2, r3, #30
 801eb14:	d501      	bpl.n	801eb1a <MIDI_PORT_NotifyMIDITx+0x1e>
 801eb16:	2cfe      	cmp	r4, #254	@ 0xfe
 801eb18:	d00a      	beq.n	801eb30 <MIDI_PORT_NotifyMIDITx+0x34>
    mon_filtered = 1;

  if( !mon_filtered ) {
    int port_ix = -1;
    if( port != DEFAULT ) {
 801eb1a:	b185      	cbz	r5, 801eb3e <MIDI_PORT_NotifyMIDITx+0x42>
      port_ix = MIDI_PORT_OutIxGet(port);
 801eb1c:	4628      	mov	r0, r5
 801eb1e:	f7ff ff97 	bl	801ea50 <MIDI_PORT_OutIxGet>

      if( !port_ix )
 801eb22:	b128      	cbz	r0, 801eb30 <MIDI_PORT_NotifyMIDITx+0x34>
	port_ix = -1; // port not mapped
    }

    if( port_ix >= 0 ) {
      midi_out_package[port_ix] = package;
 801eb24:	4b0e      	ldr	r3, [pc, #56]	@ (801eb60 <MIDI_PORT_NotifyMIDITx+0x64>)
 801eb26:	f843 6020 	str.w	r6, [r3, r0, lsl #2]
      midi_out_ctr[port_ix] = 20; // 2 seconds lifetime
 801eb2a:	4b0e      	ldr	r3, [pc, #56]	@ (801eb64 <MIDI_PORT_NotifyMIDITx+0x68>)
 801eb2c:	2214      	movs	r2, #20
 801eb2e:	541a      	strb	r2, [r3, r0]
    }
  }


  // DIN Sync Event (0xf9 sent over port 0xff)
  if( port == 0xff && package.evnt0 == 0xf9 ) {
 801eb30:	2dff      	cmp	r5, #255	@ 0xff
 801eb32:	d106      	bne.n	801eb42 <MIDI_PORT_NotifyMIDITx+0x46>
 801eb34:	f1a4 03f9 	sub.w	r3, r4, #249	@ 0xf9
 801eb38:	4258      	negs	r0, r3
 801eb3a:	4158      	adcs	r0, r3
    if( OSC_CLIENT_SendMIDIEvent(port & 0x0f, package) >= 0 )
      return 1; // filter package
  }

  return 0; // don't filter package
}
 801eb3c:	bd70      	pop	{r4, r5, r6, pc}
  return 0; // don't filter package
 801eb3e:	2000      	movs	r0, #0
 801eb40:	e7fc      	b.n	801eb3c <MIDI_PORT_NotifyMIDITx+0x40>
  if( (port & 0xf0) == OSC0 ) { // OSC1..4 port
 801eb42:	f005 03f0 	and.w	r3, r5, #240	@ 0xf0
 801eb46:	2b40      	cmp	r3, #64	@ 0x40
 801eb48:	d1f9      	bne.n	801eb3e <MIDI_PORT_NotifyMIDITx+0x42>
    if( OSC_CLIENT_SendMIDIEvent(port & 0x0f, package) >= 0 )
 801eb4a:	4631      	mov	r1, r6
 801eb4c:	f005 000f 	and.w	r0, r5, #15
 801eb50:	f002 fdfa 	bl	8021748 <OSC_CLIENT_SendMIDIEvent>
 801eb54:	43c0      	mvns	r0, r0
 801eb56:	0fc0      	lsrs	r0, r0, #31
 801eb58:	e7f0      	b.n	801eb3c <MIDI_PORT_NotifyMIDITx+0x40>
 801eb5a:	bf00      	nop
 801eb5c:	200069b1 	.word	0x200069b1
 801eb60:	200069e8 	.word	0x200069e8
 801eb64:	20006a10 	.word	0x20006a10

0801eb68 <MIDI_PORT_NotifyMIDIRx>:
/////////////////////////////////////////////////////////////////////////////
s32 MIDI_PORT_NotifyMIDIRx(mios32_midi_port_t port, mios32_midi_package_t package)
{
  // MIDI In monitor function
  u8 mon_filtered = 0;
  if( midi_port_mon_filter.MIDI_CLOCK && package.evnt0 == 0xf8 )
 801eb68:	4a0c      	ldr	r2, [pc, #48]	@ (801eb9c <MIDI_PORT_NotifyMIDIRx+0x34>)
 801eb6a:	7812      	ldrb	r2, [r2, #0]
{
 801eb6c:	b510      	push	{r4, lr}
 801eb6e:	f3c1 2307 	ubfx	r3, r1, #8, #8
 801eb72:	460c      	mov	r4, r1
  if( midi_port_mon_filter.MIDI_CLOCK && package.evnt0 == 0xf8 )
 801eb74:	07d1      	lsls	r1, r2, #31
 801eb76:	d501      	bpl.n	801eb7c <MIDI_PORT_NotifyMIDIRx+0x14>
 801eb78:	2bf8      	cmp	r3, #248	@ 0xf8
 801eb7a:	d00d      	beq.n	801eb98 <MIDI_PORT_NotifyMIDIRx+0x30>
    mon_filtered = 1;
  else if( midi_port_mon_filter.ACTIVE_SENSE && package.evnt0 == 0xfe )
 801eb7c:	0792      	lsls	r2, r2, #30
 801eb7e:	d501      	bpl.n	801eb84 <MIDI_PORT_NotifyMIDIRx+0x1c>
 801eb80:	2bfe      	cmp	r3, #254	@ 0xfe
 801eb82:	d009      	beq.n	801eb98 <MIDI_PORT_NotifyMIDIRx+0x30>
    mon_filtered = 1;

  if( !mon_filtered ) {
    int port_ix = -1;
    if( port != DEFAULT ) {
 801eb84:	b140      	cbz	r0, 801eb98 <MIDI_PORT_NotifyMIDIRx+0x30>
      port_ix = MIDI_PORT_InIxGet(port);
 801eb86:	f7ff ff51 	bl	801ea2c <MIDI_PORT_InIxGet>

      if( !port_ix )
 801eb8a:	b128      	cbz	r0, 801eb98 <MIDI_PORT_NotifyMIDIRx+0x30>
	port_ix = -1; // port not mapped
    }

    if( port_ix >= 0 ) {
      midi_in_package[port_ix] = package;
 801eb8c:	4b04      	ldr	r3, [pc, #16]	@ (801eba0 <MIDI_PORT_NotifyMIDIRx+0x38>)
 801eb8e:	f843 4020 	str.w	r4, [r3, r0, lsl #2]
      midi_in_ctr[port_ix] = 20; // 2 seconds lifetime
 801eb92:	4b04      	ldr	r3, [pc, #16]	@ (801eba4 <MIDI_PORT_NotifyMIDIRx+0x3c>)
 801eb94:	2214      	movs	r2, #20
 801eb96:	541a      	strb	r2, [r3, r0]
    }
  }

  return 0; // no error
}
 801eb98:	2000      	movs	r0, #0
 801eb9a:	bd10      	pop	{r4, pc}
 801eb9c:	200069b1 	.word	0x200069b1
 801eba0:	200069b4 	.word	0x200069b4
 801eba4:	200069dc 	.word	0x200069dc

0801eba8 <get_on_off>:
/////////////////////////////////////////////////////////////////////////////
// help function which parses for on or off
// returns 0 if 'off', 1 if 'on', -1 if invalid
/////////////////////////////////////////////////////////////////////////////
static s32 get_on_off(char *word)
{
 801eba8:	b510      	push	{r4, lr}
  if( strcmp(word, "on") == 0 || strcmp(word, "1") == 0 )
 801ebaa:	490d      	ldr	r1, [pc, #52]	@ (801ebe0 <get_on_off+0x38>)
{
 801ebac:	4604      	mov	r4, r0
  if( strcmp(word, "on") == 0 || strcmp(word, "1") == 0 )
 801ebae:	f004 fd2c 	bl	802360a <strcmp>
 801ebb2:	b190      	cbz	r0, 801ebda <get_on_off+0x32>
 801ebb4:	490b      	ldr	r1, [pc, #44]	@ (801ebe4 <get_on_off+0x3c>)
 801ebb6:	4620      	mov	r0, r4
 801ebb8:	f004 fd27 	bl	802360a <strcmp>
 801ebbc:	b168      	cbz	r0, 801ebda <get_on_off+0x32>
    return 1;

  if( strcmp(word, "off") == 0 || strcmp(word, "0") == 0 )
 801ebbe:	490a      	ldr	r1, [pc, #40]	@ (801ebe8 <get_on_off+0x40>)
 801ebc0:	4620      	mov	r0, r4
 801ebc2:	f004 fd22 	bl	802360a <strcmp>
 801ebc6:	b138      	cbz	r0, 801ebd8 <get_on_off+0x30>
 801ebc8:	4908      	ldr	r1, [pc, #32]	@ (801ebec <get_on_off+0x44>)
 801ebca:	4620      	mov	r0, r4
 801ebcc:	f004 fd1d 	bl	802360a <strcmp>
 801ebd0:	3800      	subs	r0, #0
 801ebd2:	bf18      	it	ne
 801ebd4:	2001      	movne	r0, #1
 801ebd6:	4240      	negs	r0, r0
    return 0;

  return -1;
}
 801ebd8:	bd10      	pop	{r4, pc}
    return 1;
 801ebda:	2001      	movs	r0, #1
 801ebdc:	e7fc      	b.n	801ebd8 <get_on_off+0x30>
 801ebde:	bf00      	nop
 801ebe0:	08024c4d 	.word	0x08024c4d
 801ebe4:	080283d9 	.word	0x080283d9
 801ebe8:	0802531e 	.word	0x0802531e
 801ebec:	080283d6 	.word	0x080283d6

0801ebf0 <MIDIMON_Init>:
{
 801ebf0:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( mode > 0 )
 801ebf2:	b9e0      	cbnz	r0, 801ec2e <MIDIMON_Init+0x3e>
    midi_clk_pos[tempo_port_ix].ALL = 0;
 801ebf4:	490f      	ldr	r1, [pc, #60]	@ (801ec34 <MIDIMON_Init+0x44>)
 801ebf6:	4b10      	ldr	r3, [pc, #64]	@ (801ec38 <MIDIMON_Init+0x48>)
 801ebf8:	2600      	movs	r6, #0
 801ebfa:	2700      	movs	r7, #0
    midi_clk_pos[tempo_port_ix].subtick = -1;
 801ebfc:	1d8c      	adds	r4, r1, #6
 801ebfe:	25ff      	movs	r5, #255	@ 0xff
      tempo_samples[tempo_port_ix][i] = 0;
 801ec00:	4602      	mov	r2, r0
    midi_clk_pos[tempo_port_ix].ALL = 0;
 801ec02:	eb01 0cc0 	add.w	ip, r1, r0, lsl #3
 801ec06:	e9cc 6700 	strd	r6, r7, [ip]
    midi_clk_pos[tempo_port_ix].subtick = -1;
 801ec0a:	f804 5030 	strb.w	r5, [r4, r0, lsl #3]
  for(tempo_port_ix=0; tempo_port_ix<NUM_TEMPO_PORTS; ++tempo_port_ix) {
 801ec0e:	3001      	adds	r0, #1
 801ec10:	2804      	cmp	r0, #4
      tempo_samples[tempo_port_ix][i] = 0;
 801ec12:	e9c3 2200 	strd	r2, r2, [r3]
 801ec16:	e9c3 2202 	strd	r2, r2, [r3, #8]
 801ec1a:	e9c3 2204 	strd	r2, r2, [r3, #16]
 801ec1e:	619a      	str	r2, [r3, #24]
  for(tempo_port_ix=0; tempo_port_ix<NUM_TEMPO_PORTS; ++tempo_port_ix) {
 801ec20:	f103 031c 	add.w	r3, r3, #28
 801ec24:	d1ed      	bne.n	801ec02 <MIDIMON_Init+0x12>
    tempo_sample_pos[tempo_port_ix] = 0;
 801ec26:	4b05      	ldr	r3, [pc, #20]	@ (801ec3c <MIDIMON_Init+0x4c>)
  return 0; // no error
 801ec28:	2000      	movs	r0, #0
    tempo_sample_pos[tempo_port_ix] = 0;
 801ec2a:	601a      	str	r2, [r3, #0]
}
 801ec2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1; // only mode 0 supported yet
 801ec2e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 801ec32:	e7fb      	b.n	801ec2c <MIDIMON_Init+0x3c>
 801ec34:	20006a90 	.word	0x20006a90
 801ec38:	20006a20 	.word	0x20006a20
 801ec3c:	20006a1c 	.word	0x20006a1c

0801ec40 <MIDIMON_InitFromPresets>:
  midimon_active = _midimon_active;
 801ec40:	4b03      	ldr	r3, [pc, #12]	@ (801ec50 <MIDIMON_InitFromPresets+0x10>)
 801ec42:	7018      	strb	r0, [r3, #0]
  filter_active = _filter_active;
 801ec44:	4b03      	ldr	r3, [pc, #12]	@ (801ec54 <MIDIMON_InitFromPresets+0x14>)
 801ec46:	7019      	strb	r1, [r3, #0]
  tempo_active = _tempo_active;
 801ec48:	4b03      	ldr	r3, [pc, #12]	@ (801ec58 <MIDIMON_InitFromPresets+0x18>)
}
 801ec4a:	2000      	movs	r0, #0
  tempo_active = _tempo_active;
 801ec4c:	701a      	strb	r2, [r3, #0]
}
 801ec4e:	4770      	bx	lr
 801ec50:	20006a1b 	.word	0x20006a1b
 801ec54:	2000009e 	.word	0x2000009e
 801ec58:	20006a1a 	.word	0x20006a1a

0801ec5c <MIDIMON_ActiveGet>:
}
 801ec5c:	4b01      	ldr	r3, [pc, #4]	@ (801ec64 <MIDIMON_ActiveGet+0x8>)
 801ec5e:	7818      	ldrb	r0, [r3, #0]
 801ec60:	4770      	bx	lr
 801ec62:	bf00      	nop
 801ec64:	20006a1b 	.word	0x20006a1b

0801ec68 <MIDIMON_FilterActiveGet>:
}
 801ec68:	4b01      	ldr	r3, [pc, #4]	@ (801ec70 <MIDIMON_FilterActiveGet+0x8>)
 801ec6a:	7818      	ldrb	r0, [r3, #0]
 801ec6c:	4770      	bx	lr
 801ec6e:	bf00      	nop
 801ec70:	2000009e 	.word	0x2000009e

0801ec74 <MIDIMON_TempoActiveGet>:
}
 801ec74:	4b01      	ldr	r3, [pc, #4]	@ (801ec7c <MIDIMON_TempoActiveGet+0x8>)
 801ec76:	7818      	ldrb	r0, [r3, #0]
 801ec78:	4770      	bx	lr
 801ec7a:	bf00      	nop
 801ec7c:	20006a1a 	.word	0x20006a1a

0801ec80 <MIDIMON_Print>:
{
 801ec80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801ec84:	b097      	sub	sp, #92	@ 0x5c
 801ec86:	4681      	mov	r9, r0
 801ec88:	460e      	mov	r6, r1
 801ec8a:	4690      	mov	r8, r2
 801ec8c:	9305      	str	r3, [sp, #20]
 801ec8e:	f002 0b0f 	and.w	fp, r2, #15
 801ec92:	f3c2 2507 	ubfx	r5, r2, #8, #8
 801ec96:	f3c2 4407 	ubfx	r4, r2, #16, #8
 801ec9a:	0e17      	lsrs	r7, r2, #24
  if( strlen(prefix_str) > 50 ) {
 801ec9c:	f004 fc36 	bl	802350c <strlen>
 801eca0:	2832      	cmp	r0, #50	@ 0x32
{
 801eca2:	f89d a080 	ldrb.w	sl, [sp, #128]	@ 0x80
  if( strlen(prefix_str) > 50 ) {
 801eca6:	d902      	bls.n	801ecae <MIDIMON_Print+0x2e>
    MSG("[ERROR:MIDIMON_PRINT] prefix_str shouldn't be longer than 50 chars!");
 801eca8:	4874      	ldr	r0, [pc, #464]	@ (801ee7c <MIDIMON_Print+0x1fc>)
 801ecaa:	f7f5 ff9d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  u8 port_ix = port & 0x0f;
 801ecae:	f006 030f 	and.w	r3, r6, #15
  char port_ix_name = (port_ix < 9) ? ('1'+port_ix) : ('A'+(port_ix-9));
 801ecb2:	2b08      	cmp	r3, #8
 801ecb4:	f006 02f0 	and.w	r2, r6, #240	@ 0xf0
 801ecb8:	bf94      	ite	ls
 801ecba:	3331      	addls	r3, #49	@ 0x31
 801ecbc:	3338      	addhi	r3, #56	@ 0x38
  switch( port & 0xf0 ) {
 801ecbe:	2a30      	cmp	r2, #48	@ 0x30
 801ecc0:	d039      	beq.n	801ed36 <MIDIMON_Print+0xb6>
 801ecc2:	d807      	bhi.n	801ecd4 <MIDIMON_Print+0x54>
 801ecc4:	2a10      	cmp	r2, #16
 801ecc6:	d00c      	beq.n	801ece2 <MIDIMON_Print+0x62>
 801ecc8:	2a20      	cmp	r2, #32
 801ecca:	d014      	beq.n	801ecf6 <MIDIMON_Print+0x76>
    default:    sprintf(pre_str, "[%sP.%02X ]", prefix_str, port);
 801eccc:	496c      	ldr	r1, [pc, #432]	@ (801ee80 <MIDIMON_Print+0x200>)
 801ecce:	4633      	mov	r3, r6
 801ecd0:	464a      	mov	r2, r9
 801ecd2:	e032      	b.n	801ed3a <MIDIMON_Print+0xba>
  switch( port & 0xf0 ) {
 801ecd4:	2a40      	cmp	r2, #64	@ 0x40
 801ecd6:	d034      	beq.n	801ed42 <MIDIMON_Print+0xc2>
 801ecd8:	2a50      	cmp	r2, #80	@ 0x50
 801ecda:	d1f7      	bne.n	801eccc <MIDIMON_Print+0x4c>
    case SPIM0: sprintf(pre_str, "[%sSPI%c]", prefix_str, port_ix_name); break;
 801ecdc:	4969      	ldr	r1, [pc, #420]	@ (801ee84 <MIDIMON_Print+0x204>)
 801ecde:	464a      	mov	r2, r9
 801ece0:	e02b      	b.n	801ed3a <MIDIMON_Print+0xba>
    case USB0:  sprintf(pre_str, "[%sUSB%c]", prefix_str, port_ix_name); break;
 801ece2:	4969      	ldr	r1, [pc, #420]	@ (801ee88 <MIDIMON_Print+0x208>)
 801ece4:	464a      	mov	r2, r9
 801ece6:	a806      	add	r0, sp, #24
 801ece8:	f7fa f86c 	bl	8018dc4 <sprintf>
  switch( port ) {
 801ecec:	3e10      	subs	r6, #16
 801ecee:	b2f6      	uxtb	r6, r6
 801ecf0:	4b66      	ldr	r3, [pc, #408]	@ (801ee8c <MIDIMON_Print+0x20c>)
 801ecf2:	579e      	ldrsb	r6, [r3, r6]
 801ecf4:	e00a      	b.n	801ed0c <MIDIMON_Print+0x8c>
    case UART0: sprintf(pre_str, "[%sIN%c ]", prefix_str, port_ix_name); break;
 801ecf6:	3e10      	subs	r6, #16
 801ecf8:	4965      	ldr	r1, [pc, #404]	@ (801ee90 <MIDIMON_Print+0x210>)
 801ecfa:	464a      	mov	r2, r9
 801ecfc:	a806      	add	r0, sp, #24
 801ecfe:	b2f6      	uxtb	r6, r6
 801ed00:	f7fa f860 	bl	8018dc4 <sprintf>
  switch( port ) {
 801ed04:	2e11      	cmp	r6, #17
 801ed06:	d9f3      	bls.n	801ecf0 <MIDIMON_Print+0x70>
{
 801ed08:	f04f 36ff 	mov.w	r6, #4294967295	@ 0xffffffff
  switch( package.type ) {
 801ed0c:	f1ab 0302 	sub.w	r3, fp, #2
 801ed10:	2b0d      	cmp	r3, #13
 801ed12:	f200 8209 	bhi.w	801f128 <MIDIMON_Print+0x4a8>
 801ed16:	e8df f013 	tbh	[pc, r3, lsl #1]
 801ed1a:	0017      	.short	0x0017
 801ed1c:	008c006e 	.word	0x008c006e
 801ed20:	01960095 	.word	0x01960095
 801ed24:	019f008c 	.word	0x019f008c
 801ed28:	01c901b5 	.word	0x01c901b5
 801ed2c:	01e501dd 	.word	0x01e501dd
 801ed30:	01ff01ec 	.word	0x01ff01ec
 801ed34:	0095      	.short	0x0095
    case IIC0:  sprintf(pre_str, "[%sIIC%c]", prefix_str, port_ix_name); break;
 801ed36:	4957      	ldr	r1, [pc, #348]	@ (801ee94 <MIDIMON_Print+0x214>)
 801ed38:	464a      	mov	r2, r9
    default:    sprintf(pre_str, "[%sP.%02X ]", prefix_str, port);
 801ed3a:	a806      	add	r0, sp, #24
 801ed3c:	f7fa f842 	bl	8018dc4 <sprintf>
  switch( port ) {
 801ed40:	e7e2      	b.n	801ed08 <MIDIMON_Print+0x88>
    case OSC0:  sprintf(pre_str, "[%sOSC%c]", prefix_str, port_ix_name); break;
 801ed42:	4955      	ldr	r1, [pc, #340]	@ (801ee98 <MIDIMON_Print+0x218>)
 801ed44:	464a      	mov	r2, r9
 801ed46:	e7f8      	b.n	801ed3a <MIDIMON_Print+0xba>
      if( package.evnt0 == 0xf1 ) {
 801ed48:	2df1      	cmp	r5, #241	@ 0xf1
 801ed4a:	d14d      	bne.n	801ede8 <MIDIMON_Print+0x168>
	if( !filter_active ) {
 801ed4c:	4b53      	ldr	r3, [pc, #332]	@ (801ee9c <MIDIMON_Print+0x21c>)
 801ed4e:	781b      	ldrb	r3, [r3, #0]
 801ed50:	bb4b      	cbnz	r3, 801eda6 <MIDIMON_Print+0x126>
	  switch( package.evnt1 & 0xf0 ) {
 801ed52:	f004 03f0 	and.w	r3, r4, #240	@ 0xf0
 801ed56:	2b40      	cmp	r3, #64	@ 0x40
 801ed58:	d033      	beq.n	801edc2 <MIDIMON_Print+0x142>
 801ed5a:	d814      	bhi.n	801ed86 <MIDIMON_Print+0x106>
 801ed5c:	2b20      	cmp	r3, #32
 801ed5e:	d02b      	beq.n	801edb8 <MIDIMON_Print+0x138>
 801ed60:	d80a      	bhi.n	801ed78 <MIDIMON_Print+0xf8>
 801ed62:	b1db      	cbz	r3, 801ed9c <MIDIMON_Print+0x11c>
 801ed64:	2b10      	cmp	r3, #16
 801ed66:	d022      	beq.n	801edae <MIDIMON_Print+0x12e>
	      MSG("%s MTC Invalid: %02X %02X %02X\n", pre_str, package.evnt0, package.evnt1, package.evnt2);
 801ed68:	484d      	ldr	r0, [pc, #308]	@ (801eea0 <MIDIMON_Print+0x220>)
 801ed6a:	9700      	str	r7, [sp, #0]
 801ed6c:	4623      	mov	r3, r4
 801ed6e:	22f1      	movs	r2, #241	@ 0xf1
 801ed70:	a906      	add	r1, sp, #24
      MSG("%s MIDI Clock: %3d.%d.%d  (???.? BPM)\n", 
 801ed72:	f7f5 ff39 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
 801ed76:	e016      	b.n	801eda6 <MIDIMON_Print+0x126>
 801ed78:	2b30      	cmp	r3, #48	@ 0x30
 801ed7a:	d1f5      	bne.n	801ed68 <MIDIMON_Print+0xe8>
	    case 0x30: MSG("%s MTC Seconds High: %X\n", pre_str, package.evnt1 & 0xf); break;
 801ed7c:	4849      	ldr	r0, [pc, #292]	@ (801eea4 <MIDIMON_Print+0x224>)
 801ed7e:	f004 020f 	and.w	r2, r4, #15
 801ed82:	a906      	add	r1, sp, #24
 801ed84:	e00d      	b.n	801eda2 <MIDIMON_Print+0x122>
 801ed86:	2b60      	cmp	r3, #96	@ 0x60
 801ed88:	d020      	beq.n	801edcc <MIDIMON_Print+0x14c>
 801ed8a:	2b70      	cmp	r3, #112	@ 0x70
 801ed8c:	d023      	beq.n	801edd6 <MIDIMON_Print+0x156>
 801ed8e:	2b50      	cmp	r3, #80	@ 0x50
 801ed90:	d1ea      	bne.n	801ed68 <MIDIMON_Print+0xe8>
	    case 0x50: MSG("%s MTC Minutes High: %X\n", pre_str, package.evnt1 & 0xf); break;
 801ed92:	4845      	ldr	r0, [pc, #276]	@ (801eea8 <MIDIMON_Print+0x228>)
 801ed94:	f004 020f 	and.w	r2, r4, #15
 801ed98:	a906      	add	r1, sp, #24
 801ed9a:	e002      	b.n	801eda2 <MIDIMON_Print+0x122>
	    case 0x00: MSG("%s MTC Frame   Low:  %X\n", pre_str, package.evnt1 & 0xf); break;
 801ed9c:	4843      	ldr	r0, [pc, #268]	@ (801eeac <MIDIMON_Print+0x22c>)
 801ed9e:	4622      	mov	r2, r4
 801eda0:	a906      	add	r1, sp, #24
	MSG("%s Song Number #%d\n", pre_str, package.evnt1);
 801eda2:	f7f5 ff21 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
}
 801eda6:	2000      	movs	r0, #0
 801eda8:	b017      	add	sp, #92	@ 0x5c
 801edaa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    case 0x10: MSG("%s MTC Frame   High: %X\n", pre_str, package.evnt1 & 0xf); break;
 801edae:	4840      	ldr	r0, [pc, #256]	@ (801eeb0 <MIDIMON_Print+0x230>)
 801edb0:	f004 020f 	and.w	r2, r4, #15
 801edb4:	a906      	add	r1, sp, #24
 801edb6:	e7f4      	b.n	801eda2 <MIDIMON_Print+0x122>
	    case 0x20: MSG("%s MTC Seconds Low:  %X\n", pre_str, package.evnt1 & 0xf); break;
 801edb8:	483e      	ldr	r0, [pc, #248]	@ (801eeb4 <MIDIMON_Print+0x234>)
 801edba:	f004 020f 	and.w	r2, r4, #15
 801edbe:	a906      	add	r1, sp, #24
 801edc0:	e7ef      	b.n	801eda2 <MIDIMON_Print+0x122>
	    case 0x40: MSG("%s MTC Minutes Low:  %X\n", pre_str, package.evnt1 & 0xf); break;
 801edc2:	483d      	ldr	r0, [pc, #244]	@ (801eeb8 <MIDIMON_Print+0x238>)
 801edc4:	f004 020f 	and.w	r2, r4, #15
 801edc8:	a906      	add	r1, sp, #24
 801edca:	e7ea      	b.n	801eda2 <MIDIMON_Print+0x122>
	    case 0x60: MSG("%s MTC Hours   Low:  %X\n", pre_str, package.evnt1 & 0xf); break;
 801edcc:	483b      	ldr	r0, [pc, #236]	@ (801eebc <MIDIMON_Print+0x23c>)
 801edce:	f004 020f 	and.w	r2, r4, #15
 801edd2:	a906      	add	r1, sp, #24
 801edd4:	e7e5      	b.n	801eda2 <MIDIMON_Print+0x122>
	    case 0x70: MSG("%s MTC Hours   High: %X (SMPTE Type: %d)\n", 
 801edd6:	483a      	ldr	r0, [pc, #232]	@ (801eec0 <MIDIMON_Print+0x240>)
 801edd8:	f3c4 0342 	ubfx	r3, r4, #1, #3
 801eddc:	f004 0201 	and.w	r2, r4, #1
 801ede0:	a906      	add	r1, sp, #24
      MSG("%s Chn%2d  PitchBend %5d\n",
 801ede2:	f7f5 ff01 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801ede6:	e7de      	b.n	801eda6 <MIDIMON_Print+0x126>
      } else if( package.evnt0 == 0xf3 ) {
 801ede8:	2df3      	cmp	r5, #243	@ 0xf3
 801edea:	f040 819d 	bne.w	801f128 <MIDIMON_Print+0x4a8>
	MSG("%s Song Number #%d\n", pre_str, package.evnt1);
 801edee:	4835      	ldr	r0, [pc, #212]	@ (801eec4 <MIDIMON_Print+0x244>)
 801edf0:	4622      	mov	r2, r4
 801edf2:	a906      	add	r1, sp, #24
 801edf4:	e7d5      	b.n	801eda2 <MIDIMON_Print+0x122>
      if( package.evnt0 == 0xf2 ) {
 801edf6:	2df2      	cmp	r5, #242	@ 0xf2
 801edf8:	f040 8196 	bne.w	801f128 <MIDIMON_Print+0x4a8>
	u16 song_pos = package.evnt1 | (package.evnt2 >> 7);
 801edfc:	ea44 14d7 	orr.w	r4, r4, r7, lsr #7
	u8 step = song_pos % 4;
 801ee00:	f004 0703 	and.w	r7, r4, #3
	u8 beat = (song_pos / 4) % 4;
 801ee04:	f3c4 0581 	ubfx	r5, r4, #2, #2
	MSG("%s Song Position %d.%d.%d\n", pre_str, measure+1, beat+1, step+1);
 801ee08:	1c7b      	adds	r3, r7, #1
	u32 measure = song_pos / 16;
 801ee0a:	0924      	lsrs	r4, r4, #4
	MSG("%s Song Position %d.%d.%d\n", pre_str, measure+1, beat+1, step+1);
 801ee0c:	9300      	str	r3, [sp, #0]
 801ee0e:	a906      	add	r1, sp, #24
 801ee10:	482d      	ldr	r0, [pc, #180]	@ (801eec8 <MIDIMON_Print+0x248>)
 801ee12:	1c6b      	adds	r3, r5, #1
 801ee14:	1c62      	adds	r2, r4, #1
 801ee16:	f7f5 fee7 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
	if( tempo_port_ix >= 0 ) {
 801ee1a:	1c71      	adds	r1, r6, #1
 801ee1c:	d0c3      	beq.n	801eda6 <MIDIMON_Print+0x126>
	  mcp->subtick = -1; // ensure that next clock starts with 0
 801ee1e:	4a2b      	ldr	r2, [pc, #172]	@ (801eecc <MIDIMON_Print+0x24c>)
 801ee20:	eb02 03c6 	add.w	r3, r2, r6, lsl #3
 801ee24:	21ff      	movs	r1, #255	@ 0xff
	  mcp->measure = measure;
 801ee26:	f842 4036 	str.w	r4, [r2, r6, lsl #3]
	  mcp->subtick = -1; // ensure that next clock starts with 0
 801ee2a:	7199      	strb	r1, [r3, #6]
	  mcp->step = step;
 801ee2c:	715f      	strb	r7, [r3, #5]
	  mcp->beat = beat;
 801ee2e:	711d      	strb	r5, [r3, #4]
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801ee30:	e7b9      	b.n	801eda6 <MIDIMON_Print+0x126>
      if( !filter_sysex_message )
 801ee32:	f1ba 0f00 	cmp.w	sl, #0
 801ee36:	d1b6      	bne.n	801eda6 <MIDIMON_Print+0x126>
	MSG("%s SysEx: %02X %02X %02X\n", pre_str, package.evnt0, package.evnt1, package.evnt2);
 801ee38:	4825      	ldr	r0, [pc, #148]	@ (801eed0 <MIDIMON_Print+0x250>)
 801ee3a:	9700      	str	r7, [sp, #0]
 801ee3c:	4623      	mov	r3, r4
 801ee3e:	462a      	mov	r2, r5
 801ee40:	a906      	add	r1, sp, #24
 801ee42:	e796      	b.n	801ed72 <MIDIMON_Print+0xf2>
      switch( package.evnt0 ) {
 801ee44:	f1a5 03f6 	sub.w	r3, r5, #246	@ 0xf6
 801ee48:	2b09      	cmp	r3, #9
 801ee4a:	f200 80f2 	bhi.w	801f032 <MIDIMON_Print+0x3b2>
 801ee4e:	e8df f013 	tbh	[pc, r3, lsl #1]
 801ee52:	000a      	.short	0x000a
 801ee54:	0045000f 	.word	0x0045000f
 801ee58:	00cb00c8 	.word	0x00cb00c8
 801ee5c:	00df00dc 	.word	0x00df00dc
 801ee60:	00e500e2 	.word	0x00e500e2
 801ee64:	00ed      	.short	0x00ed
        case 0xf6: MSG("%s Tune Request (F6)\n", pre_str); break;
 801ee66:	481b      	ldr	r0, [pc, #108]	@ (801eed4 <MIDIMON_Print+0x254>)
 801ee68:	a906      	add	r1, sp, #24
        case 0xff: MSG("%s Reset (FF)\n", pre_str); break;
 801ee6a:	f7f5 febd 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801ee6e:	e79a      	b.n	801eda6 <MIDIMON_Print+0x126>
        case 0xf7: if( !filter_sysex_message ) { MSG("%s SysEx End (F7)\n", pre_str); } break;
 801ee70:	f1ba 0f00 	cmp.w	sl, #0
 801ee74:	d197      	bne.n	801eda6 <MIDIMON_Print+0x126>
 801ee76:	4818      	ldr	r0, [pc, #96]	@ (801eed8 <MIDIMON_Print+0x258>)
 801ee78:	a906      	add	r1, sp, #24
 801ee7a:	e7f6      	b.n	801ee6a <MIDIMON_Print+0x1ea>
 801ee7c:	08027a1a 	.word	0x08027a1a
 801ee80:	08027a90 	.word	0x08027a90
 801ee84:	08027a86 	.word	0x08027a86
 801ee88:	08027a5e 	.word	0x08027a5e
 801ee8c:	0802802a 	.word	0x0802802a
 801ee90:	08027a68 	.word	0x08027a68
 801ee94:	08027a72 	.word	0x08027a72
 801ee98:	08027a7c 	.word	0x08027a7c
 801ee9c:	2000009e 	.word	0x2000009e
 801eea0:	08027b75 	.word	0x08027b75
 801eea4:	08027ae7 	.word	0x08027ae7
 801eea8:	08027b19 	.word	0x08027b19
 801eeac:	08027a9c 	.word	0x08027a9c
 801eeb0:	08027ab5 	.word	0x08027ab5
 801eeb4:	08027ace 	.word	0x08027ace
 801eeb8:	08027b00 	.word	0x08027b00
 801eebc:	08027b32 	.word	0x08027b32
 801eec0:	08027b4b 	.word	0x08027b4b
 801eec4:	08027b95 	.word	0x08027b95
 801eec8:	08027ba9 	.word	0x08027ba9
 801eecc:	20006a90 	.word	0x20006a90
 801eed0:	08027bc4 	.word	0x08027bc4
 801eed4:	08027bde 	.word	0x08027bde
 801eed8:	08027bf4 	.word	0x08027bf4
	  if( !filter_active ) {
 801eedc:	4bb2      	ldr	r3, [pc, #712]	@ (801f1a8 <MIDIMON_Print+0x528>)
 801eede:	781b      	ldrb	r3, [r3, #0]
 801eee0:	b91b      	cbnz	r3, 801eeea <MIDIMON_Print+0x26a>
	    MSG("%s MIDI Clock (F8)\n", pre_str);
 801eee2:	48b2      	ldr	r0, [pc, #712]	@ (801f1ac <MIDIMON_Print+0x52c>)
 801eee4:	a906      	add	r1, sp, #24
 801eee6:	f7f5 fe7f 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
	  if( tempo_port_ix >= 0 ) {
 801eeea:	1c72      	adds	r2, r6, #1
 801eeec:	f43f af5b 	beq.w	801eda6 <MIDIMON_Print+0x126>
	    if( ++mcp->subtick >= 6 ) {
 801eef0:	49af      	ldr	r1, [pc, #700]	@ (801f1b0 <MIDIMON_Print+0x530>)
 801eef2:	eb01 03c6 	add.w	r3, r1, r6, lsl #3
 801eef6:	ea4f 0cc6 	mov.w	ip, r6, lsl #3
 801eefa:	799a      	ldrb	r2, [r3, #6]
 801eefc:	3201      	adds	r2, #1
 801eefe:	b252      	sxtb	r2, r2
 801ef00:	2a05      	cmp	r2, #5
 801ef02:	dc56      	bgt.n	801efb2 <MIDIMON_Print+0x332>
 801ef04:	719a      	strb	r2, [r3, #6]
	    tempo_samples[tempo_port_ix][tempo_sample_pos[tempo_port_ix]] = timestamp;
 801ef06:	4aab      	ldr	r2, [pc, #684]	@ (801f1b4 <MIDIMON_Print+0x534>)
 801ef08:	f8df 82ac 	ldr.w	r8, [pc, #684]	@ 801f1b8 <MIDIMON_Print+0x538>
 801ef0c:	5d93      	ldrb	r3, [r2, r6]
 801ef0e:	9c05      	ldr	r4, [sp, #20]
 801ef10:	ebac 0906 	sub.w	r9, ip, r6
 801ef14:	eb09 0003 	add.w	r0, r9, r3
	    if( ++tempo_sample_pos[tempo_port_ix] >= NUM_TEMPO_SAMPLES )
 801ef18:	3301      	adds	r3, #1
 801ef1a:	b2db      	uxtb	r3, r3
	      tempo_sample_pos[tempo_port_ix] = 0;
 801ef1c:	2b07      	cmp	r3, #7
 801ef1e:	bf28      	it	cs
 801ef20:	2300      	movcs	r3, #0
 801ef22:	5593      	strb	r3, [r2, r6]
	    if( mcp->subtick == 0 )
 801ef24:	eb01 020c 	add.w	r2, r1, ip
	    tempo_samples[tempo_port_ix][tempo_sample_pos[tempo_port_ix]] = timestamp;
 801ef28:	f848 4020 	str.w	r4, [r8, r0, lsl #2]
	    if( mcp->subtick == 0 )
 801ef2c:	f992 4006 	ldrsb.w	r4, [r2, #6]
 801ef30:	2c00      	cmp	r4, #0
 801ef32:	f47f af38 	bne.w	801eda6 <MIDIMON_Print+0x126>
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801ef36:	4aa1      	ldr	r2, [pc, #644]	@ (801f1bc <MIDIMON_Print+0x53c>)
 801ef38:	7812      	ldrb	r2, [r2, #0]
 801ef3a:	2a00      	cmp	r2, #0
 801ef3c:	f43f af33 	beq.w	801eda6 <MIDIMON_Print+0x126>
    u32 sample_timestamp = tempo_samples[tempo_port_ix][pos];
 801ef40:	eb09 0203 	add.w	r2, r9, r3
 801ef44:	f04f 0e06 	mov.w	lr, #6
 801ef48:	f858 5022 	ldr.w	r5, [r8, r2, lsl #2]
    int weight = 100;
 801ef4c:	2264      	movs	r2, #100	@ 0x64
    u32 filter_value = 0;
 801ef4e:	4620      	mov	r0, r4
    int valid = 1;
 801ef50:	2701      	movs	r7, #1
      weight = (weight*100) / 110; // if divided by 100, we will get an unweighted mean value
 801ef52:	4693      	mov	fp, r2
      if( ++pos >= NUM_TEMPO_SAMPLES )
 801ef54:	3301      	adds	r3, #1
	pos = 0;      
 801ef56:	2b07      	cmp	r3, #7
 801ef58:	bf08      	it	eq
 801ef5a:	2300      	moveq	r3, #0
      u32 delta = tempo_samples[tempo_port_ix][pos] - sample_timestamp;
 801ef5c:	eb09 0a03 	add.w	sl, r9, r3
      divisor += weight;
 801ef60:	4414      	add	r4, r2
      u32 delta = tempo_samples[tempo_port_ix][pos] - sample_timestamp;
 801ef62:	f858 a02a 	ldr.w	sl, [r8, sl, lsl #2]
 801ef66:	ebaa 0505 	sub.w	r5, sl, r5
	valid = 0;
 801ef6a:	f5b5 7f7a 	cmp.w	r5, #1000	@ 0x3e8
 801ef6e:	bf28      	it	cs
 801ef70:	2700      	movcs	r7, #0
    for(i=0; i<(NUM_TEMPO_SAMPLES-1); ++i) {
 801ef72:	f1be 0e01 	subs.w	lr, lr, #1
      filter_value += weight * delta;
 801ef76:	fb05 0002 	mla	r0, r5, r2, r0
      weight = (weight*100) / 110; // if divided by 100, we will get an unweighted mean value
 801ef7a:	fb0b f202 	mul.w	r2, fp, r2
 801ef7e:	f04f 056e 	mov.w	r5, #110	@ 0x6e
 801ef82:	fb92 f2f5 	sdiv	r2, r2, r5
    for(i=0; i<(NUM_TEMPO_SAMPLES-1); ++i) {
 801ef86:	f040 80d6 	bne.w	801f136 <MIDIMON_Print+0x4b6>
      MSG("%s MIDI Clock: %3d.%d.%d  (???.? BPM)\n", 
 801ef8a:	f851 5036 	ldr.w	r5, [r1, r6, lsl #3]
	  mcp->measure+1, mcp->beat+1, mcp->step+1);
 801ef8e:	4461      	add	r1, ip
      MSG("%s MIDI Clock: %3d.%d.%d  (???.? BPM)\n", 
 801ef90:	3501      	adds	r5, #1
	  mcp->measure+1, mcp->beat+1, mcp->step+1);
 801ef92:	790e      	ldrb	r6, [r1, #4]
 801ef94:	f891 8005 	ldrb.w	r8, [r1, #5]
      MSG("%s MIDI Clock: %3d.%d.%d  (???.? BPM)\n", 
 801ef98:	3601      	adds	r6, #1
 801ef9a:	f108 0801 	add.w	r8, r8, #1
    if( !valid ) {
 801ef9e:	2f00      	cmp	r7, #0
 801efa0:	f040 80cb 	bne.w	801f13a <MIDIMON_Print+0x4ba>
      MSG("%s MIDI Clock: %3d.%d.%d  (???.? BPM)\n", 
 801efa4:	4886      	ldr	r0, [pc, #536]	@ (801f1c0 <MIDIMON_Print+0x540>)
 801efa6:	f8cd 8000 	str.w	r8, [sp]
 801efaa:	4633      	mov	r3, r6
 801efac:	462a      	mov	r2, r5
 801efae:	a906      	add	r1, sp, #24
 801efb0:	e6df      	b.n	801ed72 <MIDIMON_Print+0xf2>
	      if( ++mcp->step >= 4 ) {
 801efb2:	795a      	ldrb	r2, [r3, #5]
 801efb4:	3201      	adds	r2, #1
 801efb6:	b2d2      	uxtb	r2, r2
	      mcp->subtick = 0;
 801efb8:	2000      	movs	r0, #0
	      if( ++mcp->step >= 4 ) {
 801efba:	2a03      	cmp	r2, #3
	      mcp->subtick = 0;
 801efbc:	7198      	strb	r0, [r3, #6]
	      if( ++mcp->step >= 4 ) {
 801efbe:	d801      	bhi.n	801efc4 <MIDIMON_Print+0x344>
 801efc0:	715a      	strb	r2, [r3, #5]
 801efc2:	e7a0      	b.n	801ef06 <MIDIMON_Print+0x286>
		if( ++mcp->beat >= 4 ) {
 801efc4:	791a      	ldrb	r2, [r3, #4]
		mcp->step = 0;
 801efc6:	7158      	strb	r0, [r3, #5]
		if( ++mcp->beat >= 4 ) {
 801efc8:	3201      	adds	r2, #1
 801efca:	b2d2      	uxtb	r2, r2
 801efcc:	2a03      	cmp	r2, #3
		  mcp->beat = 0;
 801efce:	bf85      	ittet	hi
 801efd0:	7118      	strbhi	r0, [r3, #4]
		  ++mcp->measure;
 801efd2:	f851 3036 	ldrhi.w	r3, [r1, r6, lsl #3]
		if( ++mcp->beat >= 4 ) {
 801efd6:	711a      	strbls	r2, [r3, #4]
		  ++mcp->measure;
 801efd8:	3301      	addhi	r3, #1
 801efda:	bf88      	it	hi
 801efdc:	f841 3036 	strhi.w	r3, [r1, r6, lsl #3]
 801efe0:	e791      	b.n	801ef06 <MIDIMON_Print+0x286>
        case 0xf9: MSG("%s MIDI Tick (F9)\n", pre_str); break;
 801efe2:	4878      	ldr	r0, [pc, #480]	@ (801f1c4 <MIDIMON_Print+0x544>)
 801efe4:	a906      	add	r1, sp, #24
 801efe6:	e740      	b.n	801ee6a <MIDIMON_Print+0x1ea>
	  MSG("%s MIDI Clock Start (FA)\n", pre_str);
 801efe8:	4877      	ldr	r0, [pc, #476]	@ (801f1c8 <MIDIMON_Print+0x548>)
 801efea:	a906      	add	r1, sp, #24
 801efec:	f7f5 fdfc 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
	  if( tempo_port_ix >= 0 ) {
 801eff0:	1c73      	adds	r3, r6, #1
 801eff2:	f43f aed8 	beq.w	801eda6 <MIDIMON_Print+0x126>
	    mcp->ALL = 0;
 801eff6:	4b6e      	ldr	r3, [pc, #440]	@ (801f1b0 <MIDIMON_Print+0x530>)
 801eff8:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 801effc:	2000      	movs	r0, #0
 801effe:	2100      	movs	r1, #0
	    mcp->subtick = -1; // ensure that next clock starts with 0
 801f000:	22ff      	movs	r2, #255	@ 0xff
	    mcp->ALL = 0;
 801f002:	e9c3 0100 	strd	r0, r1, [r3]
	    mcp->subtick = -1; // ensure that next clock starts with 0
 801f006:	719a      	strb	r2, [r3, #6]
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801f008:	e6cd      	b.n	801eda6 <MIDIMON_Print+0x126>
        case 0xfb: MSG("%s MIDI Clock Continue (FB)\n", pre_str); break;
 801f00a:	4870      	ldr	r0, [pc, #448]	@ (801f1cc <MIDIMON_Print+0x54c>)
 801f00c:	a906      	add	r1, sp, #24
 801f00e:	e72c      	b.n	801ee6a <MIDIMON_Print+0x1ea>
        case 0xfc: MSG("%s MIDI Clock Stop (FC)\n", pre_str); break;
 801f010:	486f      	ldr	r0, [pc, #444]	@ (801f1d0 <MIDIMON_Print+0x550>)
 801f012:	a906      	add	r1, sp, #24
 801f014:	e729      	b.n	801ee6a <MIDIMON_Print+0x1ea>
        case 0xfd: MSG("%s Inspecified Realtime Event (FD)\n", pre_str); break;
 801f016:	486f      	ldr	r0, [pc, #444]	@ (801f1d4 <MIDIMON_Print+0x554>)
 801f018:	a906      	add	r1, sp, #24
 801f01a:	e726      	b.n	801ee6a <MIDIMON_Print+0x1ea>
        case 0xfe: if( !filter_active ) { MSG("%s Active Sense (FE)\n", pre_str); } break;
 801f01c:	4b62      	ldr	r3, [pc, #392]	@ (801f1a8 <MIDIMON_Print+0x528>)
 801f01e:	781b      	ldrb	r3, [r3, #0]
 801f020:	2b00      	cmp	r3, #0
 801f022:	f47f aec0 	bne.w	801eda6 <MIDIMON_Print+0x126>
 801f026:	486c      	ldr	r0, [pc, #432]	@ (801f1d8 <MIDIMON_Print+0x558>)
 801f028:	a906      	add	r1, sp, #24
 801f02a:	e71e      	b.n	801ee6a <MIDIMON_Print+0x1ea>
        case 0xff: MSG("%s Reset (FF)\n", pre_str); break;
 801f02c:	486b      	ldr	r0, [pc, #428]	@ (801f1dc <MIDIMON_Print+0x55c>)
 801f02e:	a906      	add	r1, sp, #24
 801f030:	e71b      	b.n	801ee6a <MIDIMON_Print+0x1ea>
	  if( package.type == 0xf )
 801f032:	f008 080f 	and.w	r8, r8, #15
 801f036:	f1b8 0f0f 	cmp.w	r8, #15
	    MSG("%s Single-Byte Package: %02X\n", pre_str, package.evnt0);
 801f03a:	bf0c      	ite	eq
 801f03c:	4868      	ldreq	r0, [pc, #416]	@ (801f1e0 <MIDIMON_Print+0x560>)
	    MSG("%s Invalid SysEx Single-Byte Event (%02X)\n", pre_str, package.evnt0);
 801f03e:	4869      	ldrne	r0, [pc, #420]	@ (801f1e4 <MIDIMON_Print+0x564>)
	    MSG("%s Single-Byte Package: %02X\n", pre_str, package.evnt0);
 801f040:	462a      	mov	r2, r5
 801f042:	a906      	add	r1, sp, #24
 801f044:	e6ad      	b.n	801eda2 <MIDIMON_Print+0x122>
      if( !filter_sysex_message )
 801f046:	f1ba 0f00 	cmp.w	sl, #0
 801f04a:	f47f aeac 	bne.w	801eda6 <MIDIMON_Print+0x126>
	MSG("%s SysEx: %02X %02X\n", pre_str, package.evnt0, package.evnt1);
 801f04e:	4866      	ldr	r0, [pc, #408]	@ (801f1e8 <MIDIMON_Print+0x568>)
 801f050:	4623      	mov	r3, r4
 801f052:	462a      	mov	r2, r5
 801f054:	a906      	add	r1, sp, #24
 801f056:	e6c4      	b.n	801ede2 <MIDIMON_Print+0x162>
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f058:	230c      	movs	r3, #12
 801f05a:	fbb4 f1f3 	udiv	r1, r4, r3
 801f05e:	fb03 4311 	mls	r3, r3, r1, r4
 801f062:	b2c9      	uxtb	r1, r1
      MSG("%s Chn%2d  Note Off %s%d  V:%3d\n",
 801f064:	3902      	subs	r1, #2
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f066:	b2db      	uxtb	r3, r3
      MSG("%s Chn%2d  Note Off %s%d  V:%3d\n",
 801f068:	9100      	str	r1, [sp, #0]
 801f06a:	4960      	ldr	r1, [pc, #384]	@ (801f1ec <MIDIMON_Print+0x56c>)
 801f06c:	4860      	ldr	r0, [pc, #384]	@ (801f1f0 <MIDIMON_Print+0x570>)
 801f06e:	9701      	str	r7, [sp, #4]
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f070:	eb03 0343 	add.w	r3, r3, r3, lsl #1
      MSG("%s Chn%2d  Note Off %s%d  V:%3d\n",
 801f074:	f005 020f 	and.w	r2, r5, #15
 801f078:	440b      	add	r3, r1
 801f07a:	3201      	adds	r2, #1
 801f07c:	a906      	add	r1, sp, #24
    MSG("%s Invalid Package (Type %d: %02X %02X %02X)\n",
 801f07e:	f7f5 fdb3 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  if( display_midi_clk && tempo_active && tempo_port_ix >= 0 ) {
 801f082:	e690      	b.n	801eda6 <MIDIMON_Print+0x126>
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f084:	230c      	movs	r3, #12
 801f086:	fbb4 f1f3 	udiv	r1, r4, r3
 801f08a:	fb03 4311 	mls	r3, r3, r1, r4
 801f08e:	b2c9      	uxtb	r1, r1
      MSG("%s Chn%2d  Note On  %s%d  V:%3d\n",
 801f090:	3902      	subs	r1, #2
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f092:	b2db      	uxtb	r3, r3
      MSG("%s Chn%2d  Note On  %s%d  V:%3d\n",
 801f094:	9100      	str	r1, [sp, #0]
 801f096:	4955      	ldr	r1, [pc, #340]	@ (801f1ec <MIDIMON_Print+0x56c>)
 801f098:	4856      	ldr	r0, [pc, #344]	@ (801f1f4 <MIDIMON_Print+0x574>)
 801f09a:	9701      	str	r7, [sp, #4]
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f09c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
      MSG("%s Chn%2d  Note On  %s%d  V:%3d\n",
 801f0a0:	f005 020f 	and.w	r2, r5, #15
 801f0a4:	440b      	add	r3, r1
 801f0a6:	3201      	adds	r2, #1
 801f0a8:	a906      	add	r1, sp, #24
 801f0aa:	e7e8      	b.n	801f07e <MIDIMON_Print+0x3fe>
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f0ac:	230c      	movs	r3, #12
 801f0ae:	fbb4 f1f3 	udiv	r1, r4, r3
 801f0b2:	fb03 4311 	mls	r3, r3, r1, r4
 801f0b6:	b2c9      	uxtb	r1, r1
      MSG("%s Chn%2d  Poly Aftertouch %s%d  V:%3d\n",
 801f0b8:	3902      	subs	r1, #2
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f0ba:	b2db      	uxtb	r3, r3
      MSG("%s Chn%2d  Poly Aftertouch %s%d  V:%3d\n",
 801f0bc:	9100      	str	r1, [sp, #0]
 801f0be:	494b      	ldr	r1, [pc, #300]	@ (801f1ec <MIDIMON_Print+0x56c>)
 801f0c0:	484d      	ldr	r0, [pc, #308]	@ (801f1f8 <MIDIMON_Print+0x578>)
 801f0c2:	9701      	str	r7, [sp, #4]
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2, package.evnt2);
 801f0c4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
      MSG("%s Chn%2d  Poly Aftertouch %s%d  V:%3d\n",
 801f0c8:	f005 020f 	and.w	r2, r5, #15
 801f0cc:	440b      	add	r3, r1
 801f0ce:	3201      	adds	r2, #1
 801f0d0:	a906      	add	r1, sp, #24
 801f0d2:	e7d4      	b.n	801f07e <MIDIMON_Print+0x3fe>
      MSG("%s Chn%2d  CC#%3d  V:%3d\n",
 801f0d4:	f005 020f 	and.w	r2, r5, #15
 801f0d8:	4848      	ldr	r0, [pc, #288]	@ (801f1fc <MIDIMON_Print+0x57c>)
 801f0da:	9700      	str	r7, [sp, #0]
 801f0dc:	4623      	mov	r3, r4
 801f0de:	3201      	adds	r2, #1
 801f0e0:	a906      	add	r1, sp, #24
 801f0e2:	e646      	b.n	801ed72 <MIDIMON_Print+0xf2>
      MSG("%s Chn%2d  Program Change #%3d\n",
 801f0e4:	f005 020f 	and.w	r2, r5, #15
 801f0e8:	4845      	ldr	r0, [pc, #276]	@ (801f200 <MIDIMON_Print+0x580>)
 801f0ea:	4623      	mov	r3, r4
 801f0ec:	3201      	adds	r2, #1
 801f0ee:	a906      	add	r1, sp, #24
 801f0f0:	e677      	b.n	801ede2 <MIDIMON_Print+0x162>
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2);
 801f0f2:	230c      	movs	r3, #12
 801f0f4:	fbb4 f1f3 	udiv	r1, r4, r3
 801f0f8:	fb03 4311 	mls	r3, r3, r1, r4
 801f0fc:	b2c9      	uxtb	r1, r1
      MSG("%s Chn%2d  Channel Aftertouch %s%d\n",
 801f0fe:	3902      	subs	r1, #2
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2);
 801f100:	b2db      	uxtb	r3, r3
      MSG("%s Chn%2d  Channel Aftertouch %s%d\n",
 801f102:	9100      	str	r1, [sp, #0]
 801f104:	4939      	ldr	r1, [pc, #228]	@ (801f1ec <MIDIMON_Print+0x56c>)
 801f106:	483f      	ldr	r0, [pc, #252]	@ (801f204 <MIDIMON_Print+0x584>)
	  pre_str, (package.evnt0 & 0xf)+1, note_name[package.evnt1%12], (int)(package.evnt1/12)-2);
 801f108:	eb03 0343 	add.w	r3, r3, r3, lsl #1
      MSG("%s Chn%2d  Channel Aftertouch %s%d\n",
 801f10c:	f005 020f 	and.w	r2, r5, #15
 801f110:	440b      	add	r3, r1
 801f112:	3201      	adds	r2, #1
 801f114:	a906      	add	r1, sp, #24
 801f116:	e62c      	b.n	801ed72 <MIDIMON_Print+0xf2>
      MSG("%s Chn%2d  PitchBend %5d\n",
 801f118:	f005 020f 	and.w	r2, r5, #15
 801f11c:	483a      	ldr	r0, [pc, #232]	@ (801f208 <MIDIMON_Print+0x588>)
 801f11e:	ea44 13c7 	orr.w	r3, r4, r7, lsl #7
 801f122:	3201      	adds	r2, #1
 801f124:	a906      	add	r1, sp, #24
 801f126:	e65c      	b.n	801ede2 <MIDIMON_Print+0x162>
    MSG("%s Invalid Package (Type %d: %02X %02X %02X)\n",
 801f128:	e9cd 4700 	strd	r4, r7, [sp]
 801f12c:	4837      	ldr	r0, [pc, #220]	@ (801f20c <MIDIMON_Print+0x58c>)
 801f12e:	462b      	mov	r3, r5
 801f130:	465a      	mov	r2, fp
 801f132:	a906      	add	r1, sp, #24
 801f134:	e7a3      	b.n	801f07e <MIDIMON_Print+0x3fe>
      sample_timestamp = tempo_samples[tempo_port_ix][pos];
 801f136:	4655      	mov	r5, sl
 801f138:	e70c      	b.n	801ef54 <MIDIMON_Print+0x2d4>
      float mean_value = (float)filter_value / (float)divisor;
 801f13a:	f003 ffd9 	bl	80230f0 <__aeabi_ui2f>
 801f13e:	4607      	mov	r7, r0
 801f140:	4620      	mov	r0, r4
 801f142:	f003 ffd9 	bl	80230f8 <__aeabi_i2f>
 801f146:	4601      	mov	r1, r0
 801f148:	4638      	mov	r0, r7
 801f14a:	f004 f8dd 	bl	8023308 <__aeabi_fdiv>
      float bpm = 60.0 / ((mean_value/1000.0) * 24.0);
 801f14e:	f003 fc37 	bl	80229c0 <__aeabi_f2d>
 801f152:	4b2f      	ldr	r3, [pc, #188]	@ (801f210 <MIDIMON_Print+0x590>)
 801f154:	2200      	movs	r2, #0
 801f156:	f003 fdb5 	bl	8022cc4 <__aeabi_ddiv>
 801f15a:	4b2e      	ldr	r3, [pc, #184]	@ (801f214 <MIDIMON_Print+0x594>)
 801f15c:	2200      	movs	r2, #0
 801f15e:	f003 fc87 	bl	8022a70 <__aeabi_dmul>
 801f162:	4602      	mov	r2, r0
 801f164:	460b      	mov	r3, r1
 801f166:	2000      	movs	r0, #0
 801f168:	492b      	ldr	r1, [pc, #172]	@ (801f218 <MIDIMON_Print+0x598>)
 801f16a:	f003 fdab 	bl	8022cc4 <__aeabi_ddiv>
 801f16e:	f003 feb9 	bl	8022ee4 <__aeabi_d2f>
 801f172:	4604      	mov	r4, r0
	  (int)bpm, (int)(10.0*bpm) % 10);
 801f174:	f003 fc24 	bl	80229c0 <__aeabi_f2d>
 801f178:	4b28      	ldr	r3, [pc, #160]	@ (801f21c <MIDIMON_Print+0x59c>)
 801f17a:	2200      	movs	r2, #0
 801f17c:	f003 fc78 	bl	8022a70 <__aeabi_dmul>
 801f180:	f003 fe88 	bl	8022e94 <__aeabi_d2iz>
      MSG("%s MIDI Clock: %3d.%d.%d  (%3d.%d BPM)\n", 
 801f184:	230a      	movs	r3, #10
 801f186:	fb90 f2f3 	sdiv	r2, r0, r3
 801f18a:	fb02 0313 	mls	r3, r2, r3, r0
 801f18e:	4620      	mov	r0, r4
 801f190:	9302      	str	r3, [sp, #8]
 801f192:	f004 f955 	bl	8023440 <__aeabi_f2iz>
 801f196:	4633      	mov	r3, r6
 801f198:	e9cd 8000 	strd	r8, r0, [sp]
 801f19c:	462a      	mov	r2, r5
 801f19e:	a906      	add	r1, sp, #24
 801f1a0:	481f      	ldr	r0, [pc, #124]	@ (801f220 <MIDIMON_Print+0x5a0>)
 801f1a2:	f7f5 fd21 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
 801f1a6:	e5fe      	b.n	801eda6 <MIDIMON_Print+0x126>
 801f1a8:	2000009e 	.word	0x2000009e
 801f1ac:	08027c07 	.word	0x08027c07
 801f1b0:	20006a90 	.word	0x20006a90
 801f1b4:	20006a1c 	.word	0x20006a1c
 801f1b8:	20006a20 	.word	0x20006a20
 801f1bc:	20006a1a 	.word	0x20006a1a
 801f1c0:	08027e35 	.word	0x08027e35
 801f1c4:	08027c1b 	.word	0x08027c1b
 801f1c8:	08027c2e 	.word	0x08027c2e
 801f1cc:	08027c48 	.word	0x08027c48
 801f1d0:	08027c65 	.word	0x08027c65
 801f1d4:	08027c7e 	.word	0x08027c7e
 801f1d8:	08027ca2 	.word	0x08027ca2
 801f1dc:	08027cb8 	.word	0x08027cb8
 801f1e0:	08027cc7 	.word	0x08027cc7
 801f1e4:	08027ce5 	.word	0x08027ce5
 801f1e8:	08027d10 	.word	0x08027d10
 801f1ec:	0802803c 	.word	0x0802803c
 801f1f0:	08027d25 	.word	0x08027d25
 801f1f4:	08027d46 	.word	0x08027d46
 801f1f8:	08027d67 	.word	0x08027d67
 801f1fc:	08027d8f 	.word	0x08027d8f
 801f200:	08027da9 	.word	0x08027da9
 801f204:	08027dc9 	.word	0x08027dc9
 801f208:	08027ded 	.word	0x08027ded
 801f20c:	08027e07 	.word	0x08027e07
 801f210:	408f4000 	.word	0x408f4000
 801f214:	40380000 	.word	0x40380000
 801f218:	404e0000 	.word	0x404e0000
 801f21c:	40240000 	.word	0x40240000
 801f220:	08027e5c 	.word	0x08027e5c

0801f224 <MIDIMON_Receive>:
{
 801f224:	b573      	push	{r0, r1, r4, r5, r6, lr}
  if( !midimon_active )
 801f226:	4b08      	ldr	r3, [pc, #32]	@ (801f248 <MIDIMON_Receive+0x24>)
{
 801f228:	4604      	mov	r4, r0
  if( !midimon_active )
 801f22a:	7818      	ldrb	r0, [r3, #0]
{
 801f22c:	460d      	mov	r5, r1
 801f22e:	4616      	mov	r6, r2
  if( !midimon_active )
 801f230:	b140      	cbz	r0, 801f244 <MIDIMON_Receive+0x20>
  return MIDIMON_Print("", port, package, MIOS32_TIMESTAMP_Get(), filter_sysex_message);
 801f232:	f7f7 f8fd 	bl	8016430 <MIOS32_TIMESTAMP_Get>
 801f236:	9600      	str	r6, [sp, #0]
 801f238:	4603      	mov	r3, r0
 801f23a:	462a      	mov	r2, r5
 801f23c:	4803      	ldr	r0, [pc, #12]	@ (801f24c <MIDIMON_Receive+0x28>)
 801f23e:	4621      	mov	r1, r4
 801f240:	f7ff fd1e 	bl	801ec80 <MIDIMON_Print>
}
 801f244:	b002      	add	sp, #8
 801f246:	bd70      	pop	{r4, r5, r6, pc}
 801f248:	20006a1b 	.word	0x20006a1b
 801f24c:	080237bc 	.word	0x080237bc

0801f250 <MIDIMON_TerminalHelp>:

/////////////////////////////////////////////////////////////////////////////
// Returns help page for implemented terminal commands of this module
/////////////////////////////////////////////////////////////////////////////
s32 MIDIMON_TerminalHelp(void *_output_function)
{
 801f250:	b510      	push	{r4, lr}
 801f252:	4604      	mov	r4, r0
  void (*out)(char *format, ...) = _output_function;

  out("  set midimon <on|off>:             enables/disables the MIDI monitor");
 801f254:	4803      	ldr	r0, [pc, #12]	@ (801f264 <MIDIMON_TerminalHelp+0x14>)
 801f256:	47a0      	blx	r4
  out("  set midimon_filter <on|off>:      enables/disables MIDI monitor filters");
 801f258:	4803      	ldr	r0, [pc, #12]	@ (801f268 <MIDIMON_TerminalHelp+0x18>)
 801f25a:	47a0      	blx	r4
  out("  set midimon_tempo <on|off>:       enables/disables the tempo display");
 801f25c:	4803      	ldr	r0, [pc, #12]	@ (801f26c <MIDIMON_TerminalHelp+0x1c>)
 801f25e:	47a0      	blx	r4

  return 0; // no error
}
 801f260:	2000      	movs	r0, #0
 801f262:	bd10      	pop	{r4, pc}
 801f264:	08027e84 	.word	0x08027e84
 801f268:	08027eca 	.word	0x08027eca
 801f26c:	08027f14 	.word	0x08027f14

0801f270 <MIDIMON_TerminalParseLine>:
/////////////////////////////////////////////////////////////////////////////
// Parser for a complete line
// Returns > 0 if command line matches with UIP terminal commands
/////////////////////////////////////////////////////////////////////////////
s32 MIDIMON_TerminalParseLine(char *input, void *_output_function)
{
 801f270:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 801f272:	4605      	mov	r5, r0
 801f274:	460c      	mov	r4, r1
  char *brkt;
  char *parameter;

  // since strtok_r works destructive (separators in *input replaced by NUL), we have to restore them
  // on an unsuccessful call (whenever this function returns < 1)
  int input_len = strlen(input);
 801f276:	f004 f949 	bl	802350c <strlen>

  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 801f27a:	4939      	ldr	r1, [pc, #228]	@ (801f360 <MIDIMON_TerminalParseLine+0xf0>)
  int input_len = strlen(input);
 801f27c:	4607      	mov	r7, r0
  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 801f27e:	aa01      	add	r2, sp, #4
 801f280:	4628      	mov	r0, r5
 801f282:	f004 f9bf 	bl	8023604 <strtok_r>
 801f286:	b940      	cbnz	r0, 801f29a <MIDIMON_TerminalParseLine+0x2a>
 801f288:	1e6b      	subs	r3, r5, #1
  // restore input line (replace NUL characters by spaces)
  int i;
  char *input_ptr = input;
  for(i=0; i<input_len; ++i, ++input_ptr)
    if( !*input_ptr )
      *input_ptr = ' ';
 801f28a:	2120      	movs	r1, #32
  for(i=0; i<input_len; ++i, ++input_ptr)
 801f28c:	f1c5 0501 	rsb	r5, r5, #1
 801f290:	18ea      	adds	r2, r5, r3
 801f292:	4297      	cmp	r7, r2
 801f294:	dc5e      	bgt.n	801f354 <MIDIMON_TerminalParseLine+0xe4>

  return 0; // command not taken
 801f296:	2000      	movs	r0, #0
 801f298:	e00d      	b.n	801f2b6 <MIDIMON_TerminalParseLine+0x46>
    if( strcmp(parameter, "set") == 0 ) {
 801f29a:	4932      	ldr	r1, [pc, #200]	@ (801f364 <MIDIMON_TerminalParseLine+0xf4>)
 801f29c:	f004 f9b5 	bl	802360a <strcmp>
 801f2a0:	2800      	cmp	r0, #0
 801f2a2:	d1f1      	bne.n	801f288 <MIDIMON_TerminalParseLine+0x18>
      if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 801f2a4:	492e      	ldr	r1, [pc, #184]	@ (801f360 <MIDIMON_TerminalParseLine+0xf0>)
 801f2a6:	aa01      	add	r2, sp, #4
 801f2a8:	f004 f9ac 	bl	8023604 <strtok_r>
 801f2ac:	4606      	mov	r6, r0
 801f2ae:	b920      	cbnz	r0, 801f2ba <MIDIMON_TerminalParseLine+0x4a>
	out("Missing parameter after 'set'!");
 801f2b0:	482d      	ldr	r0, [pc, #180]	@ (801f368 <MIDIMON_TerminalParseLine+0xf8>)
	  out("Expecting 'on' or 'off'!");
 801f2b2:	47a0      	blx	r4
	return 1; // command taken
 801f2b4:	2001      	movs	r0, #1
}
 801f2b6:	b003      	add	sp, #12
 801f2b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if( strcmp(parameter, "midimon") == 0 ) {
 801f2ba:	492c      	ldr	r1, [pc, #176]	@ (801f36c <MIDIMON_TerminalParseLine+0xfc>)
 801f2bc:	f004 f9a5 	bl	802360a <strcmp>
 801f2c0:	b9a8      	cbnz	r0, 801f2ee <MIDIMON_TerminalParseLine+0x7e>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 801f2c2:	4927      	ldr	r1, [pc, #156]	@ (801f360 <MIDIMON_TerminalParseLine+0xf0>)
 801f2c4:	aa01      	add	r2, sp, #4
 801f2c6:	f004 f99d 	bl	8023604 <strtok_r>
 801f2ca:	b118      	cbz	r0, 801f2d4 <MIDIMON_TerminalParseLine+0x64>
	  on_off = get_on_off(parameter);
 801f2cc:	f7ff fc6c 	bl	801eba8 <get_on_off>
	if( on_off < 0 ) {
 801f2d0:	2800      	cmp	r0, #0
 801f2d2:	da01      	bge.n	801f2d8 <MIDIMON_TerminalParseLine+0x68>
	  out("Expecting 'on' or 'off'!");
 801f2d4:	4826      	ldr	r0, [pc, #152]	@ (801f370 <MIDIMON_TerminalParseLine+0x100>)
 801f2d6:	e7ec      	b.n	801f2b2 <MIDIMON_TerminalParseLine+0x42>
  midimon_active = active;
 801f2d8:	4b26      	ldr	r3, [pc, #152]	@ (801f374 <MIDIMON_TerminalParseLine+0x104>)
	out("MIDI Monitor %s!", MIDIMON_ActiveGet() ? "enabled" : "disabled");
 801f2da:	4927      	ldr	r1, [pc, #156]	@ (801f378 <MIDIMON_TerminalParseLine+0x108>)
	MIDIMON_ActiveSet(on_off);
 801f2dc:	7018      	strb	r0, [r3, #0]
	out("MIDI Monitor %s!", MIDIMON_ActiveGet() ? "enabled" : "disabled");
 801f2de:	4b27      	ldr	r3, [pc, #156]	@ (801f37c <MIDIMON_TerminalParseLine+0x10c>)
 801f2e0:	b2c0      	uxtb	r0, r0
 801f2e2:	2800      	cmp	r0, #0
 801f2e4:	bf18      	it	ne
 801f2e6:	4619      	movne	r1, r3
 801f2e8:	4825      	ldr	r0, [pc, #148]	@ (801f380 <MIDIMON_TerminalParseLine+0x110>)
	out("MIDI Monitor Tempo Display %s!", MIDIMON_TempoActiveGet() ? "enabled" : "disabled");
 801f2ea:	47a0      	blx	r4
	return 1; // command taken
 801f2ec:	e7e2      	b.n	801f2b4 <MIDIMON_TerminalParseLine+0x44>
      } else if( strcmp(parameter, "midimon_filter") == 0 ) {
 801f2ee:	4925      	ldr	r1, [pc, #148]	@ (801f384 <MIDIMON_TerminalParseLine+0x114>)
 801f2f0:	4630      	mov	r0, r6
 801f2f2:	f004 f98a 	bl	802360a <strcmp>
 801f2f6:	b998      	cbnz	r0, 801f320 <MIDIMON_TerminalParseLine+0xb0>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 801f2f8:	4919      	ldr	r1, [pc, #100]	@ (801f360 <MIDIMON_TerminalParseLine+0xf0>)
 801f2fa:	aa01      	add	r2, sp, #4
 801f2fc:	f004 f982 	bl	8023604 <strtok_r>
 801f300:	2800      	cmp	r0, #0
 801f302:	d0e7      	beq.n	801f2d4 <MIDIMON_TerminalParseLine+0x64>
	  on_off = get_on_off(parameter);
 801f304:	f7ff fc50 	bl	801eba8 <get_on_off>
	if( on_off < 0 ) {
 801f308:	2800      	cmp	r0, #0
 801f30a:	dbe3      	blt.n	801f2d4 <MIDIMON_TerminalParseLine+0x64>
  filter_active = active;
 801f30c:	4b1e      	ldr	r3, [pc, #120]	@ (801f388 <MIDIMON_TerminalParseLine+0x118>)
	out("MIDI Monitor Filter %s!", MIDIMON_FilterActiveGet() ? "enabled" : "disabled");
 801f30e:	491a      	ldr	r1, [pc, #104]	@ (801f378 <MIDIMON_TerminalParseLine+0x108>)
	MIDIMON_FilterActiveSet(on_off);
 801f310:	7018      	strb	r0, [r3, #0]
	out("MIDI Monitor Filter %s!", MIDIMON_FilterActiveGet() ? "enabled" : "disabled");
 801f312:	4b1a      	ldr	r3, [pc, #104]	@ (801f37c <MIDIMON_TerminalParseLine+0x10c>)
 801f314:	b2c0      	uxtb	r0, r0
 801f316:	2800      	cmp	r0, #0
 801f318:	bf18      	it	ne
 801f31a:	4619      	movne	r1, r3
 801f31c:	481b      	ldr	r0, [pc, #108]	@ (801f38c <MIDIMON_TerminalParseLine+0x11c>)
 801f31e:	e7e4      	b.n	801f2ea <MIDIMON_TerminalParseLine+0x7a>
      } else if( strcmp(parameter, "midimon_tempo") == 0 ) {
 801f320:	491b      	ldr	r1, [pc, #108]	@ (801f390 <MIDIMON_TerminalParseLine+0x120>)
 801f322:	4630      	mov	r0, r6
 801f324:	f004 f971 	bl	802360a <strcmp>
 801f328:	2800      	cmp	r0, #0
 801f32a:	d1ad      	bne.n	801f288 <MIDIMON_TerminalParseLine+0x18>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 801f32c:	490c      	ldr	r1, [pc, #48]	@ (801f360 <MIDIMON_TerminalParseLine+0xf0>)
 801f32e:	aa01      	add	r2, sp, #4
 801f330:	f004 f968 	bl	8023604 <strtok_r>
 801f334:	2800      	cmp	r0, #0
 801f336:	d0cd      	beq.n	801f2d4 <MIDIMON_TerminalParseLine+0x64>
	  on_off = get_on_off(parameter);
 801f338:	f7ff fc36 	bl	801eba8 <get_on_off>
	if( on_off < 0 ) {
 801f33c:	2800      	cmp	r0, #0
 801f33e:	dbc9      	blt.n	801f2d4 <MIDIMON_TerminalParseLine+0x64>
  tempo_active = active;
 801f340:	4b14      	ldr	r3, [pc, #80]	@ (801f394 <MIDIMON_TerminalParseLine+0x124>)
	out("MIDI Monitor Tempo Display %s!", MIDIMON_TempoActiveGet() ? "enabled" : "disabled");
 801f342:	490d      	ldr	r1, [pc, #52]	@ (801f378 <MIDIMON_TerminalParseLine+0x108>)
	MIDIMON_TempoActiveSet(on_off);
 801f344:	7018      	strb	r0, [r3, #0]
	out("MIDI Monitor Tempo Display %s!", MIDIMON_TempoActiveGet() ? "enabled" : "disabled");
 801f346:	4b0d      	ldr	r3, [pc, #52]	@ (801f37c <MIDIMON_TerminalParseLine+0x10c>)
 801f348:	b2c0      	uxtb	r0, r0
 801f34a:	2800      	cmp	r0, #0
 801f34c:	bf18      	it	ne
 801f34e:	4619      	movne	r1, r3
 801f350:	4811      	ldr	r0, [pc, #68]	@ (801f398 <MIDIMON_TerminalParseLine+0x128>)
 801f352:	e7ca      	b.n	801f2ea <MIDIMON_TerminalParseLine+0x7a>
    if( !*input_ptr )
 801f354:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 801f358:	2a00      	cmp	r2, #0
 801f35a:	d199      	bne.n	801f290 <MIDIMON_TerminalParseLine+0x20>
      *input_ptr = ' ';
 801f35c:	7019      	strb	r1, [r3, #0]
  for(i=0; i<input_len; ++i, ++input_ptr)
 801f35e:	e797      	b.n	801f290 <MIDIMON_TerminalParseLine+0x20>
 801f360:	080237ba 	.word	0x080237ba
 801f364:	0802391b 	.word	0x0802391b
 801f368:	08023b98 	.word	0x08023b98
 801f36c:	08027f5b 	.word	0x08027f5b
 801f370:	08027f63 	.word	0x08027f63
 801f374:	20006a1b 	.word	0x20006a1b
 801f378:	080254c5 	.word	0x080254c5
 801f37c:	080254bd 	.word	0x080254bd
 801f380:	08027f7c 	.word	0x08027f7c
 801f384:	08027f8d 	.word	0x08027f8d
 801f388:	2000009e 	.word	0x2000009e
 801f38c:	08027f9c 	.word	0x08027f9c
 801f390:	08027fb4 	.word	0x08027fb4
 801f394:	20006a1a 	.word	0x20006a1a
 801f398:	08027fc2 	.word	0x08027fc2

0801f39c <MIDIMON_TerminalPrintConfig>:

/////////////////////////////////////////////////////////////////////////////
// Keyboard Configuration (can also be called from external)
/////////////////////////////////////////////////////////////////////////////
s32 MIDIMON_TerminalPrintConfig(void *_output_function)
{
 801f39c:	b570      	push	{r4, r5, r6, lr}
  return midimon_active;
 801f39e:	4b0e      	ldr	r3, [pc, #56]	@ (801f3d8 <MIDIMON_TerminalPrintConfig+0x3c>)
  void (*out)(char *format, ...) = _output_function;

  out("MIDI Monitor: %s", MIDIMON_ActiveGet() ? "enabled" : "disabled");
 801f3a0:	4e0e      	ldr	r6, [pc, #56]	@ (801f3dc <MIDIMON_TerminalPrintConfig+0x40>)
 801f3a2:	4d0f      	ldr	r5, [pc, #60]	@ (801f3e0 <MIDIMON_TerminalPrintConfig+0x44>)
 801f3a4:	7819      	ldrb	r1, [r3, #0]
{
 801f3a6:	4604      	mov	r4, r0
  out("MIDI Monitor: %s", MIDIMON_ActiveGet() ? "enabled" : "disabled");
 801f3a8:	2900      	cmp	r1, #0
 801f3aa:	bf0c      	ite	eq
 801f3ac:	4631      	moveq	r1, r6
 801f3ae:	4629      	movne	r1, r5
 801f3b0:	480c      	ldr	r0, [pc, #48]	@ (801f3e4 <MIDIMON_TerminalPrintConfig+0x48>)
 801f3b2:	47a0      	blx	r4
  return filter_active;
 801f3b4:	4b0c      	ldr	r3, [pc, #48]	@ (801f3e8 <MIDIMON_TerminalPrintConfig+0x4c>)
  out("MIDI Monitor Filters: %s", MIDIMON_FilterActiveGet() ? "enabled" : "disabled");
 801f3b6:	480d      	ldr	r0, [pc, #52]	@ (801f3ec <MIDIMON_TerminalPrintConfig+0x50>)
 801f3b8:	7819      	ldrb	r1, [r3, #0]
 801f3ba:	2900      	cmp	r1, #0
 801f3bc:	bf0c      	ite	eq
 801f3be:	4631      	moveq	r1, r6
 801f3c0:	4629      	movne	r1, r5
 801f3c2:	47a0      	blx	r4
  return tempo_active;
 801f3c4:	4b0a      	ldr	r3, [pc, #40]	@ (801f3f0 <MIDIMON_TerminalPrintConfig+0x54>)
  out("MIDI Monitor Tempo Display: %s", MIDIMON_TempoActiveGet() ? "enabled" : "disabled");
 801f3c6:	480b      	ldr	r0, [pc, #44]	@ (801f3f4 <MIDIMON_TerminalPrintConfig+0x58>)
 801f3c8:	7819      	ldrb	r1, [r3, #0]
 801f3ca:	2900      	cmp	r1, #0
 801f3cc:	bf0c      	ite	eq
 801f3ce:	4631      	moveq	r1, r6
 801f3d0:	4629      	movne	r1, r5
 801f3d2:	47a0      	blx	r4

  return 0; // no error
}
 801f3d4:	2000      	movs	r0, #0
 801f3d6:	bd70      	pop	{r4, r5, r6, pc}
 801f3d8:	20006a1b 	.word	0x20006a1b
 801f3dc:	080254c5 	.word	0x080254c5
 801f3e0:	080254bd 	.word	0x080254bd
 801f3e4:	08027fe1 	.word	0x08027fe1
 801f3e8:	2000009e 	.word	0x2000009e
 801f3ec:	08027ff2 	.word	0x08027ff2
 801f3f0:	20006a1a 	.word	0x20006a1a
 801f3f4:	0802800b 	.word	0x0802800b

0801f3f8 <chksum>:
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
 801f3f8:	3a01      	subs	r2, #1
{
 801f3fa:	b570      	push	{r4, r5, r6, lr}
  dataptr = data;
 801f3fc:	460b      	mov	r3, r1
  last_byte = data + len - 1;
 801f3fe:	188c      	adds	r4, r1, r2
  
  while(dataptr < last_byte) {	/* At least two more bytes */
 801f400:	42a3      	cmp	r3, r4
 801f402:	d315      	bcc.n	801f430 <chksum+0x38>
 801f404:	f1c1 0301 	rsb	r3, r1, #1
 801f408:	4423      	add	r3, r4
 801f40a:	f023 0301 	bic.w	r3, r3, #1
 801f40e:	1e4d      	subs	r5, r1, #1
 801f410:	42a5      	cmp	r5, r4
 801f412:	bf88      	it	hi
 801f414:	2300      	movhi	r3, #0
 801f416:	440b      	add	r3, r1
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
 801f418:	42a3      	cmp	r3, r4
 801f41a:	d108      	bne.n	801f42e <chksum+0x36>
    t = (dataptr[0] << 8) + 0;
 801f41c:	5c8b      	ldrb	r3, [r1, r2]
    sum += t;
 801f41e:	eb00 2003 	add.w	r0, r0, r3, lsl #8
 801f422:	b280      	uxth	r0, r0
    if(sum < t) {
 801f424:	ebb0 2f03 	cmp.w	r0, r3, lsl #8
      sum++;		/* carry */
 801f428:	bf3c      	itt	cc
 801f42a:	3001      	addcc	r0, #1
 801f42c:	b280      	uxthcc	r0, r0
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
 801f42e:	bd70      	pop	{r4, r5, r6, pc}
    t = (dataptr[0] << 8) + dataptr[1];
 801f430:	881d      	ldrh	r5, [r3, #0]
 801f432:	ba6d      	rev16	r5, r5
    sum += t;
 801f434:	fa10 f085 	uxtah	r0, r0, r5
 801f438:	b280      	uxth	r0, r0
 801f43a:	b2ae      	uxth	r6, r5
    if(sum < t) {
 801f43c:	4286      	cmp	r6, r0
      sum++;		/* carry */
 801f43e:	bf84      	itt	hi
 801f440:	3001      	addhi	r0, #1
 801f442:	b280      	uxthhi	r0, r0
    dataptr += 2;
 801f444:	3302      	adds	r3, #2
 801f446:	e7db      	b.n	801f400 <chksum+0x8>

0801f448 <uip_add32>:
{
 801f448:	b570      	push	{r4, r5, r6, lr}
  uip_acc32[3] = op32[3] + (op16 & 0xff);
 801f44a:	78c5      	ldrb	r5, [r0, #3]
 801f44c:	4a12      	ldr	r2, [pc, #72]	@ (801f498 <uip_add32+0x50>)
 801f44e:	440d      	add	r5, r1
 801f450:	b2ed      	uxtb	r5, r5
 801f452:	70d5      	strb	r5, [r2, #3]
  uip_acc32[2] = op32[2] + (op16 >> 8);
 801f454:	7883      	ldrb	r3, [r0, #2]
 801f456:	eb03 2311 	add.w	r3, r3, r1, lsr #8
 801f45a:	b2db      	uxtb	r3, r3
 801f45c:	7093      	strb	r3, [r2, #2]
  uip_acc32[1] = op32[1];
 801f45e:	7844      	ldrb	r4, [r0, #1]
 801f460:	7054      	strb	r4, [r2, #1]
  uip_acc32[0] = op32[0];
 801f462:	7806      	ldrb	r6, [r0, #0]
 801f464:	7016      	strb	r6, [r2, #0]
  if(uip_acc32[2] < (op16 >> 8)) {
 801f466:	ebb3 2f11 	cmp.w	r3, r1, lsr #8
 801f46a:	d205      	bcs.n	801f478 <uip_add32+0x30>
    ++uip_acc32[1];
 801f46c:	1c60      	adds	r0, r4, #1
 801f46e:	b2c0      	uxtb	r0, r0
 801f470:	7050      	strb	r0, [r2, #1]
    if(uip_acc32[1] == 0) {
 801f472:	b908      	cbnz	r0, 801f478 <uip_add32+0x30>
      ++uip_acc32[0];
 801f474:	3601      	adds	r6, #1
 801f476:	7016      	strb	r6, [r2, #0]
  if(uip_acc32[3] < (op16 & 0xff)) {
 801f478:	b2c9      	uxtb	r1, r1
 801f47a:	428d      	cmp	r5, r1
 801f47c:	da0b      	bge.n	801f496 <uip_add32+0x4e>
    ++uip_acc32[2];
 801f47e:	3301      	adds	r3, #1
 801f480:	b2db      	uxtb	r3, r3
 801f482:	7093      	strb	r3, [r2, #2]
    if(uip_acc32[2] == 0) {
 801f484:	b93b      	cbnz	r3, 801f496 <uip_add32+0x4e>
      ++uip_acc32[1];
 801f486:	7853      	ldrb	r3, [r2, #1]
 801f488:	3301      	adds	r3, #1
 801f48a:	b2db      	uxtb	r3, r3
 801f48c:	7053      	strb	r3, [r2, #1]
      if(uip_acc32[1] == 0) {
 801f48e:	b913      	cbnz	r3, 801f496 <uip_add32+0x4e>
	++uip_acc32[0];
 801f490:	7813      	ldrb	r3, [r2, #0]
 801f492:	3301      	adds	r3, #1
 801f494:	7013      	strb	r3, [r2, #0]
}
 801f496:	bd70      	pop	{r4, r5, r6, pc}
 801f498:	20006ae7 	.word	0x20006ae7

0801f49c <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
 801f49c:	b510      	push	{r4, lr}
  uip_add32(uip_conn->rcv_nxt, n);
 801f49e:	4c08      	ldr	r4, [pc, #32]	@ (801f4c0 <uip_add_rcv_nxt+0x24>)
{
 801f4a0:	4601      	mov	r1, r0
  uip_add32(uip_conn->rcv_nxt, n);
 801f4a2:	6820      	ldr	r0, [r4, #0]
 801f4a4:	3008      	adds	r0, #8
 801f4a6:	f7ff ffcf 	bl	801f448 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
 801f4aa:	4a06      	ldr	r2, [pc, #24]	@ (801f4c4 <uip_add_rcv_nxt+0x28>)
 801f4ac:	6823      	ldr	r3, [r4, #0]
 801f4ae:	7811      	ldrb	r1, [r2, #0]
 801f4b0:	7219      	strb	r1, [r3, #8]
  uip_conn->rcv_nxt[1] = uip_acc32[1];
 801f4b2:	7851      	ldrb	r1, [r2, #1]
 801f4b4:	7259      	strb	r1, [r3, #9]
  uip_conn->rcv_nxt[2] = uip_acc32[2];
 801f4b6:	7891      	ldrb	r1, [r2, #2]
  uip_conn->rcv_nxt[3] = uip_acc32[3];
 801f4b8:	78d2      	ldrb	r2, [r2, #3]
  uip_conn->rcv_nxt[2] = uip_acc32[2];
 801f4ba:	7299      	strb	r1, [r3, #10]
  uip_conn->rcv_nxt[3] = uip_acc32[3];
 801f4bc:	72da      	strb	r2, [r3, #11]
}
 801f4be:	bd10      	pop	{r4, pc}
 801f4c0:	20006eb8 	.word	0x20006eb8
 801f4c4:	20006ae7 	.word	0x20006ae7

0801f4c8 <uip_ipchksum>:
{
 801f4c8:	b508      	push	{r3, lr}
  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
 801f4ca:	4906      	ldr	r1, [pc, #24]	@ (801f4e4 <uip_ipchksum+0x1c>)
 801f4cc:	2214      	movs	r2, #20
 801f4ce:	2000      	movs	r0, #0
 801f4d0:	f7ff ff92 	bl	801f3f8 <chksum>
  return (sum == 0) ? 0xffff : htons(sum);
 801f4d4:	b110      	cbz	r0, 801f4dc <uip_ipchksum+0x14>
 801f4d6:	ba40      	rev16	r0, r0
 801f4d8:	b280      	uxth	r0, r0
}
 801f4da:	bd08      	pop	{r3, pc}
  return (sum == 0) ? 0xffff : htons(sum);
 801f4dc:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 801f4e0:	e7fb      	b.n	801f4da <uip_ipchksum+0x12>
 801f4e2:	bf00      	nop
 801f4e4:	20006eda 	.word	0x20006eda

0801f4e8 <uip_tcpchksum>:
{
 801f4e8:	b538      	push	{r3, r4, r5, lr}
 801f4ea:	4d0d      	ldr	r5, [pc, #52]	@ (801f520 <uip_tcpchksum+0x38>)
 801f4ec:	8a2c      	ldrh	r4, [r5, #16]
 801f4ee:	ba64      	rev16	r4, r4
 801f4f0:	b2a4      	uxth	r4, r4
  sum = upper_layer_len + proto;
 801f4f2:	f1a4 000e 	sub.w	r0, r4, #14
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
 801f4f6:	2208      	movs	r2, #8
 801f4f8:	f105 011a 	add.w	r1, r5, #26
 801f4fc:	b280      	uxth	r0, r0
 801f4fe:	f7ff ff7b 	bl	801f3f8 <chksum>
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
 801f502:	f1a4 0214 	sub.w	r2, r4, #20
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
 801f506:	b292      	uxth	r2, r2
 801f508:	f105 0122 	add.w	r1, r5, #34	@ 0x22
 801f50c:	f7ff ff74 	bl	801f3f8 <chksum>
  return (sum == 0) ? 0xffff : htons(sum);
 801f510:	b110      	cbz	r0, 801f518 <uip_tcpchksum+0x30>
 801f512:	ba40      	rev16	r0, r0
 801f514:	b280      	uxth	r0, r0
}
 801f516:	bd38      	pop	{r3, r4, r5, pc}
  return (sum == 0) ? 0xffff : htons(sum);
 801f518:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 801f51c:	e7fb      	b.n	801f516 <uip_tcpchksum+0x2e>
 801f51e:	bf00      	nop
 801f520:	20006ecc 	.word	0x20006ecc

0801f524 <uip_init>:
    uip_listenports[c] = 0;
 801f524:	2214      	movs	r2, #20
 801f526:	2100      	movs	r1, #0
{
 801f528:	b510      	push	{r4, lr}
    uip_listenports[c] = 0;
 801f52a:	4812      	ldr	r0, [pc, #72]	@ (801f574 <uip_init+0x50>)
 801f52c:	f004 f811 	bl	8023552 <memset>
 801f530:	4a11      	ldr	r2, [pc, #68]	@ (801f578 <uip_init+0x54>)
 801f532:	230b      	movs	r3, #11
    uip_conns[c].tcpstateflags = UIP_CLOSED;
 801f534:	2100      	movs	r1, #0
  for(c = 0; c < UIP_CONNS; ++c) {
 801f536:	3b01      	subs	r3, #1
 801f538:	f013 03ff 	ands.w	r3, r3, #255	@ 0xff
 801f53c:	f102 021e 	add.w	r2, r2, #30
 801f540:	d110      	bne.n	801f564 <uip_init+0x40>
  lastport = 1024;
 801f542:	4a0e      	ldr	r2, [pc, #56]	@ (801f57c <uip_init+0x58>)
    uip_udp_conns[c].lport = 0;
 801f544:	480e      	ldr	r0, [pc, #56]	@ (801f580 <uip_init+0x5c>)
  lastport = 1024;
 801f546:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 801f54a:	8011      	strh	r1, [r2, #0]
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 801f54c:	4a0d      	ldr	r2, [pc, #52]	@ (801f584 <uip_init+0x60>)
 801f54e:	4619      	mov	r1, r3
 801f550:	7013      	strb	r3, [r2, #0]
    uip_udp_conns[c].lport = 0;
 801f552:	461c      	mov	r4, r3
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 801f554:	3320      	adds	r3, #32
 801f556:	f5b3 7fb0 	cmp.w	r3, #352	@ 0x160
 801f55a:	d106      	bne.n	801f56a <uip_init+0x46>
 801f55c:	b109      	cbz	r1, 801f562 <uip_init+0x3e>
 801f55e:	230a      	movs	r3, #10
 801f560:	7013      	strb	r3, [r2, #0]
}
 801f562:	bd10      	pop	{r4, pc}
    uip_conns[c].tcpstateflags = UIP_CLOSED;
 801f564:	f802 1c05 	strb.w	r1, [r2, #-5]
  for(c = 0; c < UIP_CONNS; ++c) {
 801f568:	e7e5      	b.n	801f536 <uip_init+0x12>
    uip_udp_conns[c].lport = 0;
 801f56a:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
 801f56e:	2101      	movs	r1, #1
 801f570:	e7f0      	b.n	801f554 <uip_init+0x30>
 801f572:	bf00      	nop
 801f574:	20006d78 	.word	0x20006d78
 801f578:	20006d8c 	.word	0x20006d8c
 801f57c:	20006aec 	.word	0x20006aec
 801f580:	20006ab8 	.word	0x20006ab8
 801f584:	20006ae6 	.word	0x20006ae6

0801f588 <uip_udp_new>:
{
 801f588:	b5f0      	push	{r4, r5, r6, r7, lr}
 801f58a:	4604      	mov	r4, r0
 801f58c:	481f      	ldr	r0, [pc, #124]	@ (801f60c <uip_udp_new+0x84>)
    if(uip_udp_conns[c].lport == htons(lastport)) {
 801f58e:	4e20      	ldr	r6, [pc, #128]	@ (801f610 <uip_udp_new+0x88>)
 801f590:	8803      	ldrh	r3, [r0, #0]
  ++lastport;
 801f592:	3301      	adds	r3, #1
 801f594:	b29b      	uxth	r3, r3
    lastport = 4096;
 801f596:	f5b3 4ffa 	cmp.w	r3, #32000	@ 0x7d00
 801f59a:	bf28      	it	cs
 801f59c:	f44f 5380 	movcs.w	r3, #4096	@ 0x1000
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 801f5a0:	ba5f      	rev16	r7, r3
 801f5a2:	b2bd      	uxth	r5, r7
    lastport = 4096;
 801f5a4:	2200      	movs	r2, #0
    if(uip_udp_conns[c].lport == htons(lastport)) {
 801f5a6:	3220      	adds	r2, #32
 801f5a8:	f836 c012 	ldrh.w	ip, [r6, r2, lsl #1]
 801f5ac:	45ac      	cmp	ip, r5
 801f5ae:	d0f0      	beq.n	801f592 <uip_udp_new+0xa>
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 801f5b0:	f5b2 7fa0 	cmp.w	r2, #320	@ 0x140
 801f5b4:	d1f7      	bne.n	801f5a6 <uip_udp_new+0x1e>
 801f5b6:	8003      	strh	r3, [r0, #0]
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
 801f5b8:	4d16      	ldr	r5, [pc, #88]	@ (801f614 <uip_udp_new+0x8c>)
 801f5ba:	4817      	ldr	r0, [pc, #92]	@ (801f618 <uip_udp_new+0x90>)
 801f5bc:	2300      	movs	r3, #0
 801f5be:	702b      	strb	r3, [r5, #0]
 801f5c0:	461e      	mov	r6, r3
 801f5c2:	4602      	mov	r2, r0
 801f5c4:	2b0a      	cmp	r3, #10
 801f5c6:	d103      	bne.n	801f5d0 <uip_udp_new+0x48>
 801f5c8:	b106      	cbz	r6, 801f5cc <uip_udp_new+0x44>
 801f5ca:	702b      	strb	r3, [r5, #0]
    return 0;
 801f5cc:	2000      	movs	r0, #0
}
 801f5ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(uip_udp_conns[c].lport == 0) {
 801f5d0:	f8b0 e004 	ldrh.w	lr, [r0, #4]
 801f5d4:	f103 0c01 	add.w	ip, r3, #1
 801f5d8:	3040      	adds	r0, #64	@ 0x40
 801f5da:	f1be 0f00 	cmp.w	lr, #0
 801f5de:	d10c      	bne.n	801f5fa <uip_udp_new+0x72>
 801f5e0:	b106      	cbz	r6, 801f5e4 <uip_udp_new+0x5c>
 801f5e2:	702b      	strb	r3, [r5, #0]
      conn = &uip_udp_conns[c];
 801f5e4:	eb02 1083 	add.w	r0, r2, r3, lsl #6
 801f5e8:	019d      	lsls	r5, r3, #6
  conn->lport = HTONS(lastport);
 801f5ea:	8087      	strh	r7, [r0, #4]
  conn->rport = rport;
 801f5ec:	80c1      	strh	r1, [r0, #6]
  if(ripaddr == NULL) {
 801f5ee:	b93c      	cbnz	r4, 801f600 <uip_udp_new+0x78>
    memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
 801f5f0:	5154      	str	r4, [r2, r5]
  conn->ttl = UIP_TTL;
 801f5f2:	442a      	add	r2, r5
 801f5f4:	2340      	movs	r3, #64	@ 0x40
 801f5f6:	7213      	strb	r3, [r2, #8]
  return conn;
 801f5f8:	e7e9      	b.n	801f5ce <uip_udp_new+0x46>
 801f5fa:	4663      	mov	r3, ip
 801f5fc:	2601      	movs	r6, #1
 801f5fe:	e7e1      	b.n	801f5c4 <uip_udp_new+0x3c>
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
 801f600:	8823      	ldrh	r3, [r4, #0]
 801f602:	5353      	strh	r3, [r2, r5]
 801f604:	8863      	ldrh	r3, [r4, #2]
 801f606:	8043      	strh	r3, [r0, #2]
 801f608:	e7f3      	b.n	801f5f2 <uip_udp_new+0x6a>
 801f60a:	bf00      	nop
 801f60c:	20006aec 	.word	0x20006aec
 801f610:	20006ab8 	.word	0x20006ab8
 801f614:	20006ae6 	.word	0x20006ae6
 801f618:	20006af4 	.word	0x20006af4

0801f61c <uip_process>:
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
 801f61c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  register struct uip_conn *uip_connr = uip_conn;
 801f620:	4ba1      	ldr	r3, [pc, #644]	@ (801f8a8 <uip_process+0x28c>)
 801f622:	4fa2      	ldr	r7, [pc, #648]	@ (801f8ac <uip_process+0x290>)
 801f624:	681c      	ldr	r4, [r3, #0]

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
 801f626:	2804      	cmp	r0, #4
{
 801f628:	b085      	sub	sp, #20
  if(flag == UIP_UDP_SEND_CONN) {
 801f62a:	f000 80c9 	beq.w	801f7c0 <uip_process+0x1a4>
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 801f62e:	f8df 9280 	ldr.w	r9, [pc, #640]	@ 801f8b0 <uip_process+0x294>
 801f632:	4aa0      	ldr	r2, [pc, #640]	@ (801f8b4 <uip_process+0x298>)
 801f634:	4ba0      	ldr	r3, [pc, #640]	@ (801f8b8 <uip_process+0x29c>)
 801f636:	f8c9 3000 	str.w	r3, [r9]

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
 801f63a:	2803      	cmp	r0, #3
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
 801f63c:	6013      	str	r3, [r2, #0]
  if(flag == UIP_POLL_REQUEST) {
 801f63e:	d117      	bne.n	801f670 <uip_process+0x54>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
 801f640:	7e63      	ldrb	r3, [r4, #25]
 801f642:	f003 030f 	and.w	r3, r3, #15
 801f646:	2b03      	cmp	r3, #3
 801f648:	d138      	bne.n	801f6bc <uip_process+0xa0>
 801f64a:	8a23      	ldrh	r3, [r4, #16]
 801f64c:	2b00      	cmp	r3, #0
 801f64e:	d135      	bne.n	801f6bc <uip_process+0xa0>
       !uip_outstanding(uip_connr)) {
	uip_flags = UIP_POLL;
 801f650:	4b9a      	ldr	r3, [pc, #616]	@ (801f8bc <uip_process+0x2a0>)
 801f652:	2208      	movs	r2, #8
 801f654:	701a      	strb	r2, [r3, #0]
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
      uip_slen = 0;
      UIP_APPCALL();
 801f656:	f001 f8b2 	bl	80207be <UIP_TASK_AppCall>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
 801f65a:	4b98      	ldr	r3, [pc, #608]	@ (801f8bc <uip_process+0x2a0>)
 801f65c:	781a      	ldrb	r2, [r3, #0]
 801f65e:	4b98      	ldr	r3, [pc, #608]	@ (801f8c0 <uip_process+0x2a4>)
 801f660:	f012 0120 	ands.w	r1, r2, #32
 801f664:	f000 8542 	beq.w	80200ec <uip_process+0xad0>
	uip_slen = 0;
 801f668:	2200      	movs	r2, #0
 801f66a:	801a      	strh	r2, [r3, #0]
	uip_connr->tcpstateflags = UIP_CLOSED;
 801f66c:	7662      	strb	r2, [r4, #25]
 801f66e:	e041      	b.n	801f6f4 <uip_process+0xd8>
  } else if(flag == UIP_TIMER) {
 801f670:	2802      	cmp	r0, #2
 801f672:	f040 808e 	bne.w	801f792 <uip_process+0x176>
    if(++iss[3] == 0) {
 801f676:	4a93      	ldr	r2, [pc, #588]	@ (801f8c4 <uip_process+0x2a8>)
 801f678:	78d3      	ldrb	r3, [r2, #3]
 801f67a:	3301      	adds	r3, #1
 801f67c:	b2db      	uxtb	r3, r3
 801f67e:	70d3      	strb	r3, [r2, #3]
 801f680:	b963      	cbnz	r3, 801f69c <uip_process+0x80>
      if(++iss[2] == 0) {
 801f682:	7893      	ldrb	r3, [r2, #2]
 801f684:	3301      	adds	r3, #1
 801f686:	b2db      	uxtb	r3, r3
 801f688:	7093      	strb	r3, [r2, #2]
 801f68a:	b93b      	cbnz	r3, 801f69c <uip_process+0x80>
	if(++iss[1] == 0) {
 801f68c:	7853      	ldrb	r3, [r2, #1]
 801f68e:	3301      	adds	r3, #1
 801f690:	b2db      	uxtb	r3, r3
 801f692:	7053      	strb	r3, [r2, #1]
 801f694:	b913      	cbnz	r3, 801f69c <uip_process+0x80>
	  ++iss[0];
 801f696:	7813      	ldrb	r3, [r2, #0]
 801f698:	3301      	adds	r3, #1
 801f69a:	7013      	strb	r3, [r2, #0]
    uip_slen = 0;
 801f69c:	4b88      	ldr	r3, [pc, #544]	@ (801f8c0 <uip_process+0x2a4>)
    uip_len = 0;
 801f69e:	2200      	movs	r2, #0
    uip_slen = 0;
 801f6a0:	801a      	strh	r2, [r3, #0]
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 801f6a2:	7e63      	ldrb	r3, [r4, #25]
    uip_len = 0;
 801f6a4:	803a      	strh	r2, [r7, #0]
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
 801f6a6:	f003 01fd 	and.w	r1, r3, #253	@ 0xfd
 801f6aa:	2905      	cmp	r1, #5
 801f6ac:	d109      	bne.n	801f6c2 <uip_process+0xa6>
      ++(uip_connr->timer);
 801f6ae:	7ea3      	ldrb	r3, [r4, #26]
 801f6b0:	3301      	adds	r3, #1
 801f6b2:	b2db      	uxtb	r3, r3
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 801f6b4:	2b78      	cmp	r3, #120	@ 0x78
      ++(uip_connr->timer);
 801f6b6:	76a3      	strb	r3, [r4, #26]
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
 801f6b8:	d100      	bne.n	801f6bc <uip_process+0xa0>
	uip_connr->tcpstateflags = UIP_CLOSED;
 801f6ba:	7662      	strb	r2, [r4, #25]
  UIP_STAT(++uip_stat.ip.sent);
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
 801f6bc:	2300      	movs	r3, #0
 801f6be:	803b      	strh	r3, [r7, #0]
  uip_flags = 0;
  return;
 801f6c0:	e239      	b.n	801fb36 <uip_process+0x51a>
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
 801f6c2:	2b00      	cmp	r3, #0
 801f6c4:	d0fa      	beq.n	801f6bc <uip_process+0xa0>
      if(uip_outstanding(uip_connr)) {
 801f6c6:	8a22      	ldrh	r2, [r4, #16]
 801f6c8:	487c      	ldr	r0, [pc, #496]	@ (801f8bc <uip_process+0x2a0>)
 801f6ca:	2a00      	cmp	r2, #0
 801f6cc:	d05a      	beq.n	801f784 <uip_process+0x168>
	if(uip_connr->timer-- == 0) {
 801f6ce:	7ea1      	ldrb	r1, [r4, #26]
 801f6d0:	1e4a      	subs	r2, r1, #1
 801f6d2:	76a2      	strb	r2, [r4, #26]
 801f6d4:	2900      	cmp	r1, #0
 801f6d6:	d1f1      	bne.n	801f6bc <uip_process+0xa0>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
 801f6d8:	7ee2      	ldrb	r2, [r4, #27]
 801f6da:	2a08      	cmp	r2, #8
 801f6dc:	d004      	beq.n	801f6e8 <uip_process+0xcc>
 801f6de:	1e5d      	subs	r5, r3, #1
 801f6e0:	2d01      	cmp	r5, #1
 801f6e2:	d80e      	bhi.n	801f702 <uip_process+0xe6>
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
 801f6e4:	2a05      	cmp	r2, #5
 801f6e6:	d10c      	bne.n	801f702 <uip_process+0xe6>
	    uip_connr->tcpstateflags = UIP_CLOSED;
 801f6e8:	2300      	movs	r3, #0
 801f6ea:	7663      	strb	r3, [r4, #25]
	    uip_flags = UIP_TIMEDOUT;
 801f6ec:	2380      	movs	r3, #128	@ 0x80
 801f6ee:	7003      	strb	r3, [r0, #0]
	    UIP_APPCALL();
 801f6f0:	f001 f865 	bl	80207be <UIP_TASK_AppCall>
	goto tcp_send_nodata;
 801f6f4:	2314      	movs	r3, #20
	    BUF->flags = TCP_RST | TCP_ACK;
 801f6f6:	4a74      	ldr	r2, [pc, #464]	@ (801f8c8 <uip_process+0x2ac>)
 801f6f8:	f882 302f 	strb.w	r3, [r2, #47]	@ 0x2f
  uip_len = UIP_IPTCPH_LEN;
 801f6fc:	2328      	movs	r3, #40	@ 0x28
 801f6fe:	803b      	strh	r3, [r7, #0]
 801f700:	e03e      	b.n	801f780 <uip_process+0x164>
					 4:
 801f702:	2a04      	cmp	r2, #4
 801f704:	4616      	mov	r6, r2
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 801f706:	f04f 0503 	mov.w	r5, #3
					 4:
 801f70a:	bf28      	it	cs
 801f70c:	2604      	movcs	r6, #4
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
 801f70e:	40b5      	lsls	r5, r6
 801f710:	76a5      	strb	r5, [r4, #26]
	  ++(uip_connr->nrtx);
 801f712:	3201      	adds	r2, #1
	  UIP_STAT(++uip_stat.tcp.rexmit);
 801f714:	4d6d      	ldr	r5, [pc, #436]	@ (801f8cc <uip_process+0x2b0>)
	  ++(uip_connr->nrtx);
 801f716:	76e2      	strb	r2, [r4, #27]
	  UIP_STAT(++uip_stat.tcp.rexmit);
 801f718:	8cea      	ldrh	r2, [r5, #38]	@ 0x26
 801f71a:	3201      	adds	r2, #1
 801f71c:	84ea      	strh	r2, [r5, #38]	@ 0x26
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 801f71e:	f003 020f 	and.w	r2, r3, #15
 801f722:	3a01      	subs	r2, #1
 801f724:	2a07      	cmp	r2, #7
 801f726:	d8c9      	bhi.n	801f6bc <uip_process+0xa0>
 801f728:	a301      	add	r3, pc, #4	@ (adr r3, 801f730 <uip_process+0x114>)
 801f72a:	f853 f022 	ldr.w	pc, [r3, r2, lsl #2]
 801f72e:	bf00      	nop
 801f730:	0801fd3d 	.word	0x0801fd3d
 801f734:	0801fd3f 	.word	0x0801fd3f
 801f738:	0801f751 	.word	0x0801f751
 801f73c:	0802006f 	.word	0x0802006f
 801f740:	0801f6bd 	.word	0x0801f6bd
 801f744:	0802006f 	.word	0x0802006f
 801f748:	0801f6bd 	.word	0x0801f6bd
 801f74c:	0802006f 	.word	0x0802006f
	    uip_flags = UIP_REXMIT;
 801f750:	2304      	movs	r3, #4
 801f752:	7003      	strb	r3, [r0, #0]
	    UIP_APPCALL();
 801f754:	f001 f833 	bl	80207be <UIP_TASK_AppCall>
      uip_appdata = uip_sappdata;
 801f758:	4b56      	ldr	r3, [pc, #344]	@ (801f8b4 <uip_process+0x298>)
 801f75a:	681b      	ldr	r3, [r3, #0]
 801f75c:	f8c9 3000 	str.w	r3, [r9]
      if(uip_slen > 0 && uip_connr->len > 0) {
 801f760:	4b57      	ldr	r3, [pc, #348]	@ (801f8c0 <uip_process+0x2a4>)
 801f762:	881b      	ldrh	r3, [r3, #0]
 801f764:	2b00      	cmp	r3, #0
 801f766:	f000 84de 	beq.w	8020126 <uip_process+0xb0a>
 801f76a:	8a23      	ldrh	r3, [r4, #16]
 801f76c:	2b00      	cmp	r3, #0
 801f76e:	f000 84da 	beq.w	8020126 <uip_process+0xb0a>
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
 801f772:	3328      	adds	r3, #40	@ 0x28
 801f774:	b29b      	uxth	r3, r3
	goto tcp_send_noopts;
 801f776:	2218      	movs	r2, #24
	uip_len = UIP_TCPIP_HLEN;
 801f778:	803b      	strh	r3, [r7, #0]
	BUF->flags = TCP_ACK;
 801f77a:	4b53      	ldr	r3, [pc, #332]	@ (801f8c8 <uip_process+0x2ac>)
 801f77c:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
 tcp_send_noopts:
 801f780:	2250      	movs	r2, #80	@ 0x50
 801f782:	e2f0      	b.n	801fd66 <uip_process+0x74a>
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
 801f784:	f003 030f 	and.w	r3, r3, #15
 801f788:	2b03      	cmp	r3, #3
 801f78a:	d197      	bne.n	801f6bc <uip_process+0xa0>
	uip_flags = UIP_POLL;
 801f78c:	2308      	movs	r3, #8
 801f78e:	7003      	strb	r3, [r0, #0]
	UIP_APPCALL();
 801f790:	e761      	b.n	801f656 <uip_process+0x3a>
  if(flag == UIP_UDP_TIMER) {
 801f792:	2805      	cmp	r0, #5
 801f794:	d159      	bne.n	801f84a <uip_process+0x22e>
    if(uip_udp_conn->lport != 0) {
 801f796:	4a4e      	ldr	r2, [pc, #312]	@ (801f8d0 <uip_process+0x2b4>)
 801f798:	6812      	ldr	r2, [r2, #0]
 801f79a:	8892      	ldrh	r2, [r2, #4]
 801f79c:	2a00      	cmp	r2, #0
 801f79e:	d08d      	beq.n	801f6bc <uip_process+0xa0>
      uip_conn = NULL;
 801f7a0:	4941      	ldr	r1, [pc, #260]	@ (801f8a8 <uip_process+0x28c>)
 801f7a2:	2200      	movs	r2, #0
 801f7a4:	600a      	str	r2, [r1, #0]
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 801f7a6:	4943      	ldr	r1, [pc, #268]	@ (801f8b4 <uip_process+0x298>)
      uip_len = uip_slen = 0;
 801f7a8:	803a      	strh	r2, [r7, #0]
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 801f7aa:	3b0c      	subs	r3, #12
 801f7ac:	f8c9 3000 	str.w	r3, [r9]
 801f7b0:	600b      	str	r3, [r1, #0]
      uip_len = uip_slen = 0;
 801f7b2:	4b43      	ldr	r3, [pc, #268]	@ (801f8c0 <uip_process+0x2a4>)
 801f7b4:	801a      	strh	r2, [r3, #0]
      uip_flags = UIP_POLL;
 801f7b6:	4b41      	ldr	r3, [pc, #260]	@ (801f8bc <uip_process+0x2a0>)
 801f7b8:	2208      	movs	r2, #8
 801f7ba:	701a      	strb	r2, [r3, #0]
  UIP_UDP_APPCALL();
 801f7bc:	f001 f9aa 	bl	8020b14 <UIP_TASK_UDP_AppCall>
  if(uip_slen == 0) {
 801f7c0:	4b3f      	ldr	r3, [pc, #252]	@ (801f8c0 <uip_process+0x2a4>)
 801f7c2:	881a      	ldrh	r2, [r3, #0]
 801f7c4:	2a00      	cmp	r2, #0
 801f7c6:	f43f af79 	beq.w	801f6bc <uip_process+0xa0>
  BUF->len[0] = (uip_len >> 8);
 801f7ca:	4b3f      	ldr	r3, [pc, #252]	@ (801f8c8 <uip_process+0x2ac>)
  uip_len = uip_slen + UIP_IPUDPH_LEN;
 801f7cc:	f102 011c 	add.w	r1, r2, #28
 801f7d0:	b289      	uxth	r1, r1
  BUF->len[1] = (uip_len & 0xff);
 801f7d2:	7459      	strb	r1, [r3, #17]
  BUF->len[0] = (uip_len >> 8);
 801f7d4:	0a08      	lsrs	r0, r1, #8
  uip_len = uip_slen + UIP_IPUDPH_LEN;
 801f7d6:	8039      	strh	r1, [r7, #0]
  BUF->ttl = uip_udp_conn->ttl;
 801f7d8:	493d      	ldr	r1, [pc, #244]	@ (801f8d0 <uip_process+0x2b4>)
  BUF->len[0] = (uip_len >> 8);
 801f7da:	7418      	strb	r0, [r3, #16]
  BUF->ttl = uip_udp_conn->ttl;
 801f7dc:	6809      	ldr	r1, [r1, #0]
  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
 801f7de:	3208      	adds	r2, #8
  BUF->ttl = uip_udp_conn->ttl;
 801f7e0:	7a08      	ldrb	r0, [r1, #8]
 801f7e2:	7598      	strb	r0, [r3, #22]
  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
 801f7e4:	ba52      	rev16	r2, r2
  BUF->proto = UIP_PROTO_UDP;
 801f7e6:	2011      	movs	r0, #17
 801f7e8:	75d8      	strb	r0, [r3, #23]
  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
 801f7ea:	84da      	strh	r2, [r3, #38]	@ 0x26
  UDPBUF->udpchksum = 0;
 801f7ec:	2200      	movs	r2, #0
 801f7ee:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
 801f7f2:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
  BUF->srcport  = uip_udp_conn->lport;
 801f7f6:	888a      	ldrh	r2, [r1, #4]
 801f7f8:	845a      	strh	r2, [r3, #34]	@ 0x22
  BUF->destport = uip_udp_conn->rport;
 801f7fa:	88ca      	ldrh	r2, [r1, #6]
 801f7fc:	849a      	strh	r2, [r3, #36]	@ 0x24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801f7fe:	4a35      	ldr	r2, [pc, #212]	@ (801f8d4 <uip_process+0x2b8>)
 801f800:	8810      	ldrh	r0, [r2, #0]
 801f802:	8852      	ldrh	r2, [r2, #2]
 801f804:	8358      	strh	r0, [r3, #26]
 801f806:	839a      	strh	r2, [r3, #28]
  uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
 801f808:	880a      	ldrh	r2, [r1, #0]
 801f80a:	83da      	strh	r2, [r3, #30]
 801f80c:	884a      	ldrh	r2, [r1, #2]
 801f80e:	841a      	strh	r2, [r3, #32]
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
 801f810:	4a27      	ldr	r2, [pc, #156]	@ (801f8b0 <uip_process+0x294>)
 801f812:	3336      	adds	r3, #54	@ 0x36
 801f814:	6013      	str	r3, [r2, #0]
  BUF->vhl = 0x45;
 801f816:	4c2c      	ldr	r4, [pc, #176]	@ (801f8c8 <uip_process+0x2ac>)
  ++ipid;
 801f818:	492f      	ldr	r1, [pc, #188]	@ (801f8d8 <uip_process+0x2bc>)
  BUF->vhl = 0x45;
 801f81a:	2345      	movs	r3, #69	@ 0x45
 801f81c:	73a3      	strb	r3, [r4, #14]
  ++ipid;
 801f81e:	880b      	ldrh	r3, [r1, #0]
 801f820:	3301      	adds	r3, #1
 801f822:	b29b      	uxth	r3, r3
  BUF->tos = 0;
 801f824:	2200      	movs	r2, #0
  ++ipid;
 801f826:	800b      	strh	r3, [r1, #0]
  BUF->ipid[0] = ipid >> 8;
 801f828:	0a19      	lsrs	r1, r3, #8
  BUF->tos = 0;
 801f82a:	73e2      	strb	r2, [r4, #15]
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
 801f82c:	7562      	strb	r2, [r4, #21]
 801f82e:	7522      	strb	r2, [r4, #20]
  BUF->ipid[1] = ipid & 0xff;
 801f830:	74e3      	strb	r3, [r4, #19]
  BUF->ipchksum = 0;
 801f832:	7622      	strb	r2, [r4, #24]
 801f834:	7662      	strb	r2, [r4, #25]
  BUF->ipid[0] = ipid >> 8;
 801f836:	74a1      	strb	r1, [r4, #18]
  BUF->ipchksum = ~(uip_ipchksum());
 801f838:	f7ff fe46 	bl	801f4c8 <uip_ipchksum>
  UIP_STAT(++uip_stat.tcp.sent);
 801f83c:	4a23      	ldr	r2, [pc, #140]	@ (801f8cc <uip_process+0x2b0>)
 801f83e:	8bd3      	ldrh	r3, [r2, #30]
  BUF->ipchksum = ~(uip_ipchksum());
 801f840:	43c0      	mvns	r0, r0
  UIP_STAT(++uip_stat.tcp.sent);
 801f842:	3301      	adds	r3, #1
  BUF->ipchksum = ~(uip_ipchksum());
 801f844:	8320      	strh	r0, [r4, #24]
  UIP_STAT(++uip_stat.tcp.sent);
 801f846:	83d3      	strh	r3, [r2, #30]
 801f848:	e171      	b.n	801fb2e <uip_process+0x512>
  UIP_STAT(++uip_stat.ip.recv);
 801f84a:	4e20      	ldr	r6, [pc, #128]	@ (801f8cc <uip_process+0x2b0>)
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
 801f84c:	f1a3 0536 	sub.w	r5, r3, #54	@ 0x36
  UIP_STAT(++uip_stat.ip.recv);
 801f850:	8872      	ldrh	r2, [r6, #2]
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
 801f852:	f813 3c28 	ldrb.w	r3, [r3, #-40]
  UIP_STAT(++uip_stat.ip.recv);
 801f856:	3201      	adds	r2, #1
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
 801f858:	2b45      	cmp	r3, #69	@ 0x45
  UIP_STAT(++uip_stat.ip.recv);
 801f85a:	8072      	strh	r2, [r6, #2]
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
 801f85c:	d009      	beq.n	801f872 <uip_process+0x256>
    UIP_STAT(++uip_stat.ip.drop);
 801f85e:	8833      	ldrh	r3, [r6, #0]
    UIP_LOG("ip: invalid version or header length.");
 801f860:	481e      	ldr	r0, [pc, #120]	@ (801f8dc <uip_process+0x2c0>)
    UIP_STAT(++uip_stat.ip.drop);
 801f862:	3301      	adds	r3, #1
 801f864:	8033      	strh	r3, [r6, #0]
    UIP_STAT(++uip_stat.ip.vhlerr);
 801f866:	88f3      	ldrh	r3, [r6, #6]
 801f868:	3301      	adds	r3, #1
 801f86a:	80f3      	strh	r3, [r6, #6]
    UIP_LOG("ip: packet shorter than reported in IP header.");
 801f86c:	f000 ffa6 	bl	80207bc <uip_log>
    goto drop;
 801f870:	e724      	b.n	801f6bc <uip_process+0xa0>
  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
 801f872:	8a2a      	ldrh	r2, [r5, #16]
 801f874:	8839      	ldrh	r1, [r7, #0]
 801f876:	ba52      	rev16	r2, r2
 801f878:	b293      	uxth	r3, r2
 801f87a:	4299      	cmp	r1, r3
 801f87c:	9302      	str	r3, [sp, #8]
 801f87e:	d310      	bcc.n	801f8a2 <uip_process+0x286>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
 801f880:	f895 8014 	ldrb.w	r8, [r5, #20]
 801f884:	803a      	strh	r2, [r7, #0]
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
 801f886:	7d6a      	ldrb	r2, [r5, #21]
 801f888:	f008 083f 	and.w	r8, r8, #63	@ 0x3f
 801f88c:	ea58 0802 	orrs.w	r8, r8, r2
 801f890:	d02a      	beq.n	801f8e8 <uip_process+0x2cc>
    UIP_STAT(++uip_stat.ip.drop);
 801f892:	8833      	ldrh	r3, [r6, #0]
    UIP_LOG("ip: fragment dropped.");
 801f894:	4812      	ldr	r0, [pc, #72]	@ (801f8e0 <uip_process+0x2c4>)
    UIP_STAT(++uip_stat.ip.drop);
 801f896:	3301      	adds	r3, #1
 801f898:	8033      	strh	r3, [r6, #0]
    UIP_STAT(++uip_stat.ip.fragerr);
 801f89a:	89b3      	ldrh	r3, [r6, #12]
 801f89c:	3301      	adds	r3, #1
 801f89e:	81b3      	strh	r3, [r6, #12]
    UIP_LOG("ip: fragment dropped.");
 801f8a0:	e7e4      	b.n	801f86c <uip_process+0x250>
    UIP_LOG("ip: packet shorter than reported in IP header.");
 801f8a2:	4810      	ldr	r0, [pc, #64]	@ (801f8e4 <uip_process+0x2c8>)
 801f8a4:	e7e2      	b.n	801f86c <uip_process+0x250>
 801f8a6:	bf00      	nop
 801f8a8:	20006eb8 	.word	0x20006eb8
 801f8ac:	20006ec0 	.word	0x20006ec0
 801f8b0:	20006ec8 	.word	0x20006ec8
 801f8b4:	20006ec4 	.word	0x20006ec4
 801f8b8:	20006f02 	.word	0x20006f02
 801f8bc:	20006ebc 	.word	0x20006ebc
 801f8c0:	20006ebe 	.word	0x20006ebe
 801f8c4:	20006aee 	.word	0x20006aee
 801f8c8:	20006ecc 	.word	0x20006ecc
 801f8cc:	20006ab0 	.word	0x20006ab0
 801f8d0:	20006d74 	.word	0x20006d74
 801f8d4:	200074ca 	.word	0x200074ca
 801f8d8:	20006af2 	.word	0x20006af2
 801f8dc:	08028060 	.word	0x08028060
 801f8e0:	080280b5 	.word	0x080280b5
 801f8e4:	08028086 	.word	0x08028086
  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
 801f8e8:	4aa1      	ldr	r2, [pc, #644]	@ (801fb70 <uip_process+0x554>)
 801f8ea:	f8b2 b000 	ldrh.w	fp, [r2]
 801f8ee:	f8b2 a002 	ldrh.w	sl, [r2, #2]
 801f8f2:	ea5b 020a 	orrs.w	r2, fp, sl
 801f8f6:	d009      	beq.n	801f90c <uip_process+0x2f0>
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
 801f8f8:	8bea      	ldrh	r2, [r5, #30]
 801f8fa:	455a      	cmp	r2, fp
 801f8fc:	d102      	bne.n	801f904 <uip_process+0x2e8>
 801f8fe:	8c2a      	ldrh	r2, [r5, #32]
 801f900:	4552      	cmp	r2, sl
 801f902:	d003      	beq.n	801f90c <uip_process+0x2f0>
      UIP_STAT(++uip_stat.ip.drop);
 801f904:	8833      	ldrh	r3, [r6, #0]
 801f906:	3301      	adds	r3, #1
 801f908:	8033      	strh	r3, [r6, #0]
      goto drop;
 801f90a:	e6d7      	b.n	801f6bc <uip_process+0xa0>
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
 801f90c:	f7ff fddc 	bl	801f4c8 <uip_ipchksum>
 801f910:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 801f914:	4290      	cmp	r0, r2
 801f916:	4604      	mov	r4, r0
 801f918:	d007      	beq.n	801f92a <uip_process+0x30e>
    UIP_STAT(++uip_stat.ip.drop);
 801f91a:	8833      	ldrh	r3, [r6, #0]
    UIP_LOG("ip: bad checksum.");
 801f91c:	4895      	ldr	r0, [pc, #596]	@ (801fb74 <uip_process+0x558>)
    UIP_STAT(++uip_stat.ip.drop);
 801f91e:	3301      	adds	r3, #1
 801f920:	8033      	strh	r3, [r6, #0]
    UIP_STAT(++uip_stat.ip.chkerr);
 801f922:	89f3      	ldrh	r3, [r6, #14]
 801f924:	3301      	adds	r3, #1
 801f926:	81f3      	strh	r3, [r6, #14]
    UIP_LOG("ip: bad checksum.");
 801f928:	e7a0      	b.n	801f86c <uip_process+0x250>
  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
 801f92a:	7dea      	ldrb	r2, [r5, #23]
 801f92c:	2a06      	cmp	r2, #6
 801f92e:	f040 809a 	bne.w	801fa66 <uip_process+0x44a>
  UIP_STAT(++uip_stat.tcp.recv);
 801f932:	8bb2      	ldrh	r2, [r6, #28]
 801f934:	3201      	adds	r2, #1
 801f936:	83b2      	strh	r2, [r6, #28]
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
 801f938:	f7ff fdd6 	bl	801f4e8 <uip_tcpchksum>
 801f93c:	42a0      	cmp	r0, r4
 801f93e:	f040 810e 	bne.w	801fb5e <uip_process+0x542>
       BUF->destport == uip_connr->lport &&
 801f942:	f8b5 e024 	ldrh.w	lr, [r5, #36]	@ 0x24
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
 801f946:	4c8c      	ldr	r4, [pc, #560]	@ (801fb78 <uip_process+0x55c>)
       BUF->destport == uip_connr->lport &&
 801f948:	fa1f f38e 	uxth.w	r3, lr
 801f94c:	9301      	str	r3, [sp, #4]
       BUF->srcport == uip_connr->rport &&
 801f94e:	8c6b      	ldrh	r3, [r5, #34]	@ 0x22
 801f950:	9303      	str	r3, [sp, #12]
 801f952:	f8bd a00c 	ldrh.w	sl, [sp, #12]
 801f956:	220b      	movs	r2, #11
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
 801f958:	3a01      	subs	r2, #1
 801f95a:	f040 812d 	bne.w	801fbb8 <uip_process+0x59c>
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
 801f95e:	f8df a21c 	ldr.w	sl, [pc, #540]	@ 801fb7c <uip_process+0x560>
 801f962:	f89a 302f 	ldrb.w	r3, [sl, #47]	@ 0x2f
 801f966:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801f96a:	2b02      	cmp	r3, #2
 801f96c:	d114      	bne.n	801f998 <uip_process+0x37c>
  tmp16 = BUF->destport;
 801f96e:	f8df b210 	ldr.w	fp, [pc, #528]	@ 801fb80 <uip_process+0x564>
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 801f972:	f8df 9210 	ldr.w	r9, [pc, #528]	@ 801fb84 <uip_process+0x568>
 801f976:	4884      	ldr	r0, [pc, #528]	@ (801fb88 <uip_process+0x56c>)
  tmp16 = BUF->destport;
 801f978:	f8ab e000 	strh.w	lr, [fp]
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
 801f97c:	f889 2000 	strb.w	r2, [r9]
 801f980:	4613      	mov	r3, r2
 801f982:	4611      	mov	r1, r2
 801f984:	2b0a      	cmp	r3, #10
 801f986:	f040 8143 	bne.w	801fc10 <uip_process+0x5f4>
 801f98a:	b109      	cbz	r1, 801f990 <uip_process+0x374>
 801f98c:	f889 3000 	strb.w	r3, [r9]
  UIP_STAT(++uip_stat.tcp.synrst);
 801f990:	4a7e      	ldr	r2, [pc, #504]	@ (801fb8c <uip_process+0x570>)
 801f992:	8d53      	ldrh	r3, [r2, #42]	@ 0x2a
 801f994:	3301      	adds	r3, #1
 801f996:	8553      	strh	r3, [r2, #42]	@ 0x2a
  if(BUF->flags & TCP_RST) {
 801f998:	4b78      	ldr	r3, [pc, #480]	@ (801fb7c <uip_process+0x560>)
 801f99a:	f893 202f 	ldrb.w	r2, [r3, #47]	@ 0x2f
 801f99e:	0754      	lsls	r4, r2, #29
 801f9a0:	f53f ae8c 	bmi.w	801f6bc <uip_process+0xa0>
  UIP_STAT(++uip_stat.tcp.rst);
 801f9a4:	8cb2      	ldrh	r2, [r6, #36]	@ 0x24
  c = BUF->seqno[3];
 801f9a6:	f893 0029 	ldrb.w	r0, [r3, #41]	@ 0x29
  BUF->seqno[1] = BUF->ackno[1];
 801f9aa:	f893 402b 	ldrb.w	r4, [r3, #43]	@ 0x2b
  c = BUF->seqno[2];
 801f9ae:	f893 1028 	ldrb.w	r1, [r3, #40]	@ 0x28
  UIP_STAT(++uip_stat.tcp.rst);
 801f9b2:	3201      	adds	r2, #1
 801f9b4:	84b2      	strh	r2, [r6, #36]	@ 0x24
  BUF->flags = TCP_RST | TCP_ACK;
 801f9b6:	2214      	movs	r2, #20
 801f9b8:	f883 202f 	strb.w	r2, [r3, #47]	@ 0x2f
  uip_len = UIP_IPTCPH_LEN;
 801f9bc:	2228      	movs	r2, #40	@ 0x28
 801f9be:	803a      	strh	r2, [r7, #0]
  BUF->tcpoffset = 5 << 4;
 801f9c0:	2250      	movs	r2, #80	@ 0x50
 801f9c2:	f883 202e 	strb.w	r2, [r3, #46]	@ 0x2e
  BUF->seqno[3] = BUF->ackno[3];
 801f9c6:	f893 202d 	ldrb.w	r2, [r3, #45]	@ 0x2d
  c = BUF->seqno[0];
 801f9ca:	4e6e      	ldr	r6, [pc, #440]	@ (801fb84 <uip_process+0x568>)
  BUF->seqno[3] = BUF->ackno[3];
 801f9cc:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
  BUF->seqno[2] = BUF->ackno[2];
 801f9d0:	f893 202c 	ldrb.w	r2, [r3, #44]	@ 0x2c
 801f9d4:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
  if(++BUF->ackno[3] == 0) {
 801f9d8:	3001      	adds	r0, #1
  c = BUF->seqno[1];
 801f9da:	f893 2027 	ldrb.w	r2, [r3, #39]	@ 0x27
  BUF->seqno[1] = BUF->ackno[1];
 801f9de:	f883 4027 	strb.w	r4, [r3, #39]	@ 0x27
  c = BUF->seqno[0];
 801f9e2:	f893 4026 	ldrb.w	r4, [r3, #38]	@ 0x26
 801f9e6:	7034      	strb	r4, [r6, #0]
  if(++BUF->ackno[3] == 0) {
 801f9e8:	b2c0      	uxtb	r0, r0
  BUF->seqno[0] = BUF->ackno[0];
 801f9ea:	f893 602a 	ldrb.w	r6, [r3, #42]	@ 0x2a
  BUF->ackno[2] = c;
 801f9ee:	f883 102c 	strb.w	r1, [r3, #44]	@ 0x2c
  BUF->ackno[1] = c;
 801f9f2:	f883 202b 	strb.w	r2, [r3, #43]	@ 0x2b
  BUF->seqno[0] = BUF->ackno[0];
 801f9f6:	f883 6026 	strb.w	r6, [r3, #38]	@ 0x26
  BUF->ackno[0] = c;
 801f9fa:	f883 402a 	strb.w	r4, [r3, #42]	@ 0x2a
  if(++BUF->ackno[3] == 0) {
 801f9fe:	f883 002d 	strb.w	r0, [r3, #45]	@ 0x2d
 801fa02:	b960      	cbnz	r0, 801fa1e <uip_process+0x402>
    if(++BUF->ackno[2] == 0) {
 801fa04:	3101      	adds	r1, #1
 801fa06:	b2c9      	uxtb	r1, r1
 801fa08:	f883 102c 	strb.w	r1, [r3, #44]	@ 0x2c
 801fa0c:	b939      	cbnz	r1, 801fa1e <uip_process+0x402>
      if(++BUF->ackno[1] == 0) {
 801fa0e:	3201      	adds	r2, #1
 801fa10:	b2d2      	uxtb	r2, r2
 801fa12:	f883 202b 	strb.w	r2, [r3, #43]	@ 0x2b
 801fa16:	b912      	cbnz	r2, 801fa1e <uip_process+0x402>
	++BUF->ackno[0];
 801fa18:	1c62      	adds	r2, r4, #1
 801fa1a:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a
  tmp16 = BUF->srcport;
 801fa1e:	4a58      	ldr	r2, [pc, #352]	@ (801fb80 <uip_process+0x564>)
 801fa20:	8c6b      	ldrh	r3, [r5, #34]	@ 0x22
 801fa22:	8013      	strh	r3, [r2, #0]
  BUF->srcport = BUF->destport;
 801fa24:	8caa      	ldrh	r2, [r5, #36]	@ 0x24
  BUF->destport = tmp16;
 801fa26:	84ab      	strh	r3, [r5, #36]	@ 0x24
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
 801fa28:	8b6b      	ldrh	r3, [r5, #26]
 801fa2a:	83eb      	strh	r3, [r5, #30]
 801fa2c:	8bab      	ldrh	r3, [r5, #28]
 801fa2e:	842b      	strh	r3, [r5, #32]
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801fa30:	4b4f      	ldr	r3, [pc, #316]	@ (801fb70 <uip_process+0x554>)
  BUF->srcport = BUF->destport;
 801fa32:	846a      	strh	r2, [r5, #34]	@ 0x22
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801fa34:	881a      	ldrh	r2, [r3, #0]
 801fa36:	885b      	ldrh	r3, [r3, #2]
 801fa38:	836a      	strh	r2, [r5, #26]
 801fa3a:	83ab      	strh	r3, [r5, #28]
  BUF->ttl = UIP_TTL;
 801fa3c:	4c4f      	ldr	r4, [pc, #316]	@ (801fb7c <uip_process+0x560>)
 801fa3e:	2340      	movs	r3, #64	@ 0x40
 801fa40:	75a3      	strb	r3, [r4, #22]
  BUF->len[0] = (uip_len >> 8);
 801fa42:	883b      	ldrh	r3, [r7, #0]
  BUF->len[1] = (uip_len & 0xff);
 801fa44:	7463      	strb	r3, [r4, #17]
  BUF->len[0] = (uip_len >> 8);
 801fa46:	0a1a      	lsrs	r2, r3, #8
  BUF->urgp[0] = BUF->urgp[1] = 0;
 801fa48:	2300      	movs	r3, #0
  BUF->len[0] = (uip_len >> 8);
 801fa4a:	7422      	strb	r2, [r4, #16]
  BUF->urgp[0] = BUF->urgp[1] = 0;
 801fa4c:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
 801fa50:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
  BUF->tcpchksum = 0;
 801fa54:	f884 3032 	strb.w	r3, [r4, #50]	@ 0x32
 801fa58:	f884 3033 	strb.w	r3, [r4, #51]	@ 0x33
  BUF->tcpchksum = ~(uip_tcpchksum());
 801fa5c:	f7ff fd44 	bl	801f4e8 <uip_tcpchksum>
 801fa60:	43c0      	mvns	r0, r0
 801fa62:	8660      	strh	r0, [r4, #50]	@ 0x32
 801fa64:	e6d7      	b.n	801f816 <uip_process+0x1fa>
  if(BUF->proto == UIP_PROTO_UDP) {
 801fa66:	2a11      	cmp	r2, #17
 801fa68:	d131      	bne.n	801face <uip_process+0x4b2>
  uip_len = uip_len - UIP_IPUDPH_LEN;
 801fa6a:	9b02      	ldr	r3, [sp, #8]
  for(uip_udp_conn = &uip_udp_conns[0];
 801fa6c:	4a48      	ldr	r2, [pc, #288]	@ (801fb90 <uip_process+0x574>)
	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
 801fa6e:	f8b5 e01a 	ldrh.w	lr, [r5, #26]
 801fa72:	f8b5 801c 	ldrh.w	r8, [r5, #28]
  uip_len = uip_len - UIP_IPUDPH_LEN;
 801fa76:	3b1c      	subs	r3, #28
 801fa78:	803b      	strh	r3, [r7, #0]
  for(uip_udp_conn = &uip_udp_conns[0];
 801fa7a:	4b46      	ldr	r3, [pc, #280]	@ (801fb94 <uip_process+0x578>)
 801fa7c:	6013      	str	r3, [r2, #0]
       UDPBUF->destport == uip_udp_conn->lport &&
 801fa7e:	8cae      	ldrh	r6, [r5, #36]	@ 0x24
        UDPBUF->srcport == uip_udp_conn->rport) &&
 801fa80:	f8b5 c022 	ldrh.w	ip, [r5, #34]	@ 0x22
  for(uip_udp_conn = &uip_udp_conns[0];
 801fa84:	200b      	movs	r0, #11
 801fa86:	2100      	movs	r1, #0
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
 801fa88:	3801      	subs	r0, #1
 801fa8a:	d010      	beq.n	801faae <uip_process+0x492>
    if(uip_udp_conn->lport != 0 &&
 801fa8c:	889d      	ldrh	r5, [r3, #4]
 801fa8e:	2d00      	cmp	r5, #0
 801fa90:	d062      	beq.n	801fb58 <uip_process+0x53c>
 801fa92:	42b5      	cmp	r5, r6
 801fa94:	d160      	bne.n	801fb58 <uip_process+0x53c>
       (uip_udp_conn->rport == 0 ||
 801fa96:	88dd      	ldrh	r5, [r3, #6]
       UDPBUF->destport == uip_udp_conn->lport &&
 801fa98:	b10d      	cbz	r5, 801fa9e <uip_process+0x482>
       (uip_udp_conn->rport == 0 ||
 801fa9a:	4565      	cmp	r5, ip
 801fa9c:	d15c      	bne.n	801fb58 <uip_process+0x53c>
       (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
 801fa9e:	881d      	ldrh	r5, [r3, #0]
        UDPBUF->srcport == uip_udp_conn->rport) &&
 801faa0:	2d00      	cmp	r5, #0
 801faa2:	d14e      	bne.n	801fb42 <uip_process+0x526>
       (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
 801faa4:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 801faa8:	f1ba 0f00 	cmp.w	sl, #0
 801faac:	d14f      	bne.n	801fb4e <uip_process+0x532>
 801faae:	b101      	cbz	r1, 801fab2 <uip_process+0x496>
 801fab0:	6013      	str	r3, [r2, #0]
  uip_conn = NULL;
 801fab2:	4a39      	ldr	r2, [pc, #228]	@ (801fb98 <uip_process+0x57c>)
 801fab4:	2300      	movs	r3, #0
 801fab6:	6013      	str	r3, [r2, #0]
  uip_flags = UIP_NEWDATA;
 801fab8:	4a38      	ldr	r2, [pc, #224]	@ (801fb9c <uip_process+0x580>)
 801faba:	2102      	movs	r1, #2
 801fabc:	7011      	strb	r1, [r2, #0]
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
 801fabe:	4938      	ldr	r1, [pc, #224]	@ (801fba0 <uip_process+0x584>)
 801fac0:	4a38      	ldr	r2, [pc, #224]	@ (801fba4 <uip_process+0x588>)
 801fac2:	f8c9 2000 	str.w	r2, [r9]
 801fac6:	600a      	str	r2, [r1, #0]
  uip_slen = 0;
 801fac8:	4a37      	ldr	r2, [pc, #220]	@ (801fba8 <uip_process+0x58c>)
 801faca:	8013      	strh	r3, [r2, #0]
 801facc:	e676      	b.n	801f7bc <uip_process+0x1a0>
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
 801face:	2a01      	cmp	r2, #1
 801fad0:	d007      	beq.n	801fae2 <uip_process+0x4c6>
    UIP_STAT(++uip_stat.ip.drop);
 801fad2:	8833      	ldrh	r3, [r6, #0]
    UIP_LOG("ip: neither tcp nor icmp.");
 801fad4:	4835      	ldr	r0, [pc, #212]	@ (801fbac <uip_process+0x590>)
    UIP_STAT(++uip_stat.ip.drop);
 801fad6:	3301      	adds	r3, #1
 801fad8:	8033      	strh	r3, [r6, #0]
    UIP_STAT(++uip_stat.ip.protoerr);
 801fada:	8a33      	ldrh	r3, [r6, #16]
 801fadc:	3301      	adds	r3, #1
 801fade:	8233      	strh	r3, [r6, #16]
    UIP_LOG("ip: neither tcp nor icmp.");
 801fae0:	e6c4      	b.n	801f86c <uip_process+0x250>
  UIP_STAT(++uip_stat.icmp.recv);
 801fae2:	8ab3      	ldrh	r3, [r6, #20]
 801fae4:	3301      	adds	r3, #1
 801fae6:	82b3      	strh	r3, [r6, #20]
  if(ICMPBUF->type != ICMP_ECHO) {
 801fae8:	f895 3022 	ldrb.w	r3, [r5, #34]	@ 0x22
 801faec:	2b08      	cmp	r3, #8
 801faee:	d007      	beq.n	801fb00 <uip_process+0x4e4>
    UIP_STAT(++uip_stat.icmp.drop);
 801faf0:	8a73      	ldrh	r3, [r6, #18]
    UIP_LOG("icmp: not icmp echo.");
 801faf2:	482f      	ldr	r0, [pc, #188]	@ (801fbb0 <uip_process+0x594>)
    UIP_STAT(++uip_stat.icmp.drop);
 801faf4:	3301      	adds	r3, #1
 801faf6:	8273      	strh	r3, [r6, #18]
    UIP_STAT(++uip_stat.icmp.typeerr);
 801faf8:	8b33      	ldrh	r3, [r6, #24]
 801fafa:	3301      	adds	r3, #1
 801fafc:	8333      	strh	r3, [r6, #24]
    UIP_LOG("icmp: not icmp echo.");
 801fafe:	e6b5      	b.n	801f86c <uip_process+0x250>
  ICMPBUF->type = ICMP_ECHO_REPLY;
 801fb00:	2300      	movs	r3, #0
 801fb02:	f885 3022 	strb.w	r3, [r5, #34]	@ 0x22
  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
 801fb06:	8cab      	ldrh	r3, [r5, #36]	@ 0x24
 801fb08:	f64f 72f6 	movw	r2, #65526	@ 0xfff6
 801fb0c:	4293      	cmp	r3, r2
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
 801fb0e:	bf8c      	ite	hi
 801fb10:	3309      	addhi	r3, #9
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
 801fb12:	3308      	addls	r3, #8
 801fb14:	b29b      	uxth	r3, r3
 801fb16:	84ab      	strh	r3, [r5, #36]	@ 0x24
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
 801fb18:	8b6b      	ldrh	r3, [r5, #26]
 801fb1a:	83eb      	strh	r3, [r5, #30]
 801fb1c:	8bab      	ldrh	r3, [r5, #28]
 801fb1e:	842b      	strh	r3, [r5, #32]
  UIP_STAT(++uip_stat.icmp.sent);
 801fb20:	8af3      	ldrh	r3, [r6, #22]
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801fb22:	f8a5 b01a 	strh.w	fp, [r5, #26]
  UIP_STAT(++uip_stat.icmp.sent);
 801fb26:	3301      	adds	r3, #1
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801fb28:	f8a5 a01c 	strh.w	sl, [r5, #28]
  UIP_STAT(++uip_stat.icmp.sent);
 801fb2c:	82f3      	strh	r3, [r6, #22]
  UIP_STAT(++uip_stat.ip.sent);
 801fb2e:	4a17      	ldr	r2, [pc, #92]	@ (801fb8c <uip_process+0x570>)
 801fb30:	8893      	ldrh	r3, [r2, #4]
 801fb32:	3301      	adds	r3, #1
 801fb34:	8093      	strh	r3, [r2, #4]
  uip_flags = 0;
 801fb36:	4b19      	ldr	r3, [pc, #100]	@ (801fb9c <uip_process+0x580>)
 801fb38:	2200      	movs	r2, #0
 801fb3a:	701a      	strb	r2, [r3, #0]
}
 801fb3c:	b005      	add	sp, #20
 801fb3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
       (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
 801fb42:	42a5      	cmp	r5, r4
 801fb44:	d103      	bne.n	801fb4e <uip_process+0x532>
	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
 801fb46:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 801fb4a:	45a2      	cmp	sl, r4
 801fb4c:	d0af      	beq.n	801faae <uip_process+0x492>
 801fb4e:	4575      	cmp	r5, lr
 801fb50:	d102      	bne.n	801fb58 <uip_process+0x53c>
	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
 801fb52:	885d      	ldrh	r5, [r3, #2]
 801fb54:	4545      	cmp	r5, r8
 801fb56:	d0aa      	beq.n	801faae <uip_process+0x492>
      ++uip_udp_conn) {
 801fb58:	3340      	adds	r3, #64	@ 0x40
  for(uip_udp_conn = &uip_udp_conns[0];
 801fb5a:	2101      	movs	r1, #1
 801fb5c:	e794      	b.n	801fa88 <uip_process+0x46c>
    UIP_STAT(++uip_stat.tcp.drop);
 801fb5e:	8b73      	ldrh	r3, [r6, #26]
    UIP_LOG("tcp: bad checksum.");
 801fb60:	4814      	ldr	r0, [pc, #80]	@ (801fbb4 <uip_process+0x598>)
    UIP_STAT(++uip_stat.tcp.drop);
 801fb62:	3301      	adds	r3, #1
 801fb64:	8373      	strh	r3, [r6, #26]
    UIP_STAT(++uip_stat.tcp.chkerr);
 801fb66:	8c33      	ldrh	r3, [r6, #32]
 801fb68:	3301      	adds	r3, #1
 801fb6a:	8433      	strh	r3, [r6, #32]
    UIP_LOG("tcp: bad checksum.");
 801fb6c:	e67e      	b.n	801f86c <uip_process+0x250>
 801fb6e:	bf00      	nop
 801fb70:	200074ca 	.word	0x200074ca
 801fb74:	080280cb 	.word	0x080280cb
 801fb78:	20006d8c 	.word	0x20006d8c
 801fb7c:	20006ecc 	.word	0x20006ecc
 801fb80:	20006ae4 	.word	0x20006ae4
 801fb84:	20006ae6 	.word	0x20006ae6
 801fb88:	20006d78 	.word	0x20006d78
 801fb8c:	20006ab0 	.word	0x20006ab0
 801fb90:	20006d74 	.word	0x20006d74
 801fb94:	20006af4 	.word	0x20006af4
 801fb98:	20006eb8 	.word	0x20006eb8
 801fb9c:	20006ebc 	.word	0x20006ebc
 801fba0:	20006ec4 	.word	0x20006ec4
 801fba4:	20006ef6 	.word	0x20006ef6
 801fba8:	20006ebe 	.word	0x20006ebe
 801fbac:	080280dd 	.word	0x080280dd
 801fbb0:	080280f7 	.word	0x080280f7
 801fbb4:	0802810c 	.word	0x0802810c
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
 801fbb8:	7e60      	ldrb	r0, [r4, #25]
 801fbba:	b338      	cbz	r0, 801fc0c <uip_process+0x5f0>
 801fbbc:	88a1      	ldrh	r1, [r4, #4]
 801fbbe:	9b01      	ldr	r3, [sp, #4]
 801fbc0:	4299      	cmp	r1, r3
 801fbc2:	d123      	bne.n	801fc0c <uip_process+0x5f0>
       BUF->destport == uip_connr->lport &&
 801fbc4:	88e1      	ldrh	r1, [r4, #6]
 801fbc6:	4551      	cmp	r1, sl
 801fbc8:	d120      	bne.n	801fc0c <uip_process+0x5f0>
       uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
 801fbca:	f8df b21c 	ldr.w	fp, [pc, #540]	@ 801fde8 <uip_process+0x7cc>
       BUF->srcport == uip_connr->rport &&
 801fbce:	8821      	ldrh	r1, [r4, #0]
 801fbd0:	f8bb c01a 	ldrh.w	ip, [fp, #26]
 801fbd4:	458c      	cmp	ip, r1
 801fbd6:	d119      	bne.n	801fc0c <uip_process+0x5f0>
       uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
 801fbd8:	f8bb c01c 	ldrh.w	ip, [fp, #28]
 801fbdc:	8861      	ldrh	r1, [r4, #2]
 801fbde:	458c      	cmp	ip, r1
 801fbe0:	d114      	bne.n	801fc0c <uip_process+0x5f0>
  uip_conn = uip_connr;
 801fbe2:	4b82      	ldr	r3, [pc, #520]	@ (801fdec <uip_process+0x7d0>)
  if(BUF->flags & TCP_RST) {
 801fbe4:	f89b 102f 	ldrb.w	r1, [fp, #47]	@ 0x2f
  uip_conn = uip_connr;
 801fbe8:	601c      	str	r4, [r3, #0]
  uip_flags = 0;
 801fbea:	4b81      	ldr	r3, [pc, #516]	@ (801fdf0 <uip_process+0x7d4>)
 801fbec:	2200      	movs	r2, #0
  if(BUF->flags & TCP_RST) {
 801fbee:	f011 0804 	ands.w	r8, r1, #4
  uip_flags = 0;
 801fbf2:	701a      	strb	r2, [r3, #0]
  if(BUF->flags & TCP_RST) {
 801fbf4:	f000 810a 	beq.w	801fe0c <uip_process+0x7f0>
    uip_connr->tcpstateflags = UIP_CLOSED;
 801fbf8:	7662      	strb	r2, [r4, #25]
    UIP_LOG("tcp: got reset, aborting connection.");
 801fbfa:	487e      	ldr	r0, [pc, #504]	@ (801fdf4 <uip_process+0x7d8>)
 801fbfc:	f000 fdde 	bl	80207bc <uip_log>
    uip_flags = UIP_ABORT;
 801fc00:	4a7b      	ldr	r2, [pc, #492]	@ (801fdf0 <uip_process+0x7d4>)
 801fc02:	2320      	movs	r3, #32
 801fc04:	7013      	strb	r3, [r2, #0]
      UIP_APPCALL();
 801fc06:	f000 fdda 	bl	80207be <UIP_TASK_AppCall>
 801fc0a:	e557      	b.n	801f6bc <uip_process+0xa0>
      ++uip_connr) {
 801fc0c:	341e      	adds	r4, #30
 801fc0e:	e6a3      	b.n	801f958 <uip_process+0x33c>
    if(tmp16 == uip_listenports[c])
 801fc10:	f830 4b02 	ldrh.w	r4, [r0], #2
 801fc14:	f8dd c004 	ldr.w	ip, [sp, #4]
 801fc18:	45a4      	cmp	ip, r4
 801fc1a:	f103 0301 	add.w	r3, r3, #1
 801fc1e:	f04f 0101 	mov.w	r1, #1
 801fc22:	f47f aeaf 	bne.w	801f984 <uip_process+0x368>
  for(c = 0; c < UIP_CONNS; ++c) {
 801fc26:	4b74      	ldr	r3, [pc, #464]	@ (801fdf8 <uip_process+0x7dc>)
 801fc28:	2100      	movs	r1, #0
  uip_connr = 0;
 801fc2a:	460c      	mov	r4, r1
 801fc2c:	461e      	mov	r6, r3
  for(c = 0; c < UIP_CONNS; ++c) {
 801fc2e:	2a0a      	cmp	r2, #10
 801fc30:	d109      	bne.n	801fc46 <uip_process+0x62a>
 801fc32:	b109      	cbz	r1, 801fc38 <uip_process+0x61c>
 801fc34:	f889 2000 	strb.w	r2, [r9]
  if(uip_connr == 0) {
 801fc38:	b974      	cbnz	r4, 801fc58 <uip_process+0x63c>
    UIP_STAT(++uip_stat.tcp.syndrop);
 801fc3a:	4a70      	ldr	r2, [pc, #448]	@ (801fdfc <uip_process+0x7e0>)
    UIP_LOG("tcp: found no unused connections.");
 801fc3c:	4870      	ldr	r0, [pc, #448]	@ (801fe00 <uip_process+0x7e4>)
    UIP_STAT(++uip_stat.tcp.syndrop);
 801fc3e:	8d13      	ldrh	r3, [r2, #40]	@ 0x28
 801fc40:	3301      	adds	r3, #1
 801fc42:	8513      	strh	r3, [r2, #40]	@ 0x28
    UIP_LOG("tcp: found no unused connections.");
 801fc44:	e612      	b.n	801f86c <uip_process+0x250>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
 801fc46:	7e58      	ldrb	r0, [r3, #25]
 801fc48:	2800      	cmp	r0, #0
 801fc4a:	d148      	bne.n	801fcde <uip_process+0x6c2>
 801fc4c:	b109      	cbz	r1, 801fc52 <uip_process+0x636>
 801fc4e:	f889 2000 	strb.w	r2, [r9]
      uip_connr = &uip_conns[c];
 801fc52:	241e      	movs	r4, #30
 801fc54:	fb04 6402 	mla	r4, r4, r2, r6
  uip_conn = uip_connr;
 801fc58:	4b64      	ldr	r3, [pc, #400]	@ (801fdec <uip_process+0x7d0>)
  uip_connr->lport = BUF->destport;
 801fc5a:	f8a4 e004 	strh.w	lr, [r4, #4]
  uip_conn = uip_connr;
 801fc5e:	601c      	str	r4, [r3, #0]
  uip_connr->rport = BUF->srcport;
 801fc60:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 801fc64:	80e3      	strh	r3, [r4, #6]
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
 801fc66:	8b6b      	ldrh	r3, [r5, #26]
 801fc68:	8023      	strh	r3, [r4, #0]
 801fc6a:	8bab      	ldrh	r3, [r5, #28]
 801fc6c:	8063      	strh	r3, [r4, #2]
  uip_connr->sa = 0;
 801fc6e:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 801fc72:	82e3      	strh	r3, [r4, #22]
  uip_connr->rto = uip_connr->timer = UIP_RTO;
 801fc74:	f240 1303 	movw	r3, #259	@ 0x103
 801fc78:	8323      	strh	r3, [r4, #24]
 801fc7a:	2303      	movs	r3, #3
 801fc7c:	8363      	strh	r3, [r4, #26]
  uip_connr->snd_nxt[0] = iss[0];
 801fc7e:	4b61      	ldr	r3, [pc, #388]	@ (801fe04 <uip_process+0x7e8>)
 801fc80:	781a      	ldrb	r2, [r3, #0]
 801fc82:	7322      	strb	r2, [r4, #12]
  uip_connr->snd_nxt[1] = iss[1];
 801fc84:	785a      	ldrb	r2, [r3, #1]
 801fc86:	7362      	strb	r2, [r4, #13]
  uip_connr->snd_nxt[2] = iss[2];
 801fc88:	789a      	ldrb	r2, [r3, #2]
  uip_connr->snd_nxt[3] = iss[3];
 801fc8a:	78db      	ldrb	r3, [r3, #3]
 801fc8c:	73e3      	strb	r3, [r4, #15]
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
 801fc8e:	f895 3029 	ldrb.w	r3, [r5, #41]	@ 0x29
 801fc92:	72e3      	strb	r3, [r4, #11]
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
 801fc94:	f895 3028 	ldrb.w	r3, [r5, #40]	@ 0x28
 801fc98:	72a3      	strb	r3, [r4, #10]
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
 801fc9a:	f895 3027 	ldrb.w	r3, [r5, #39]	@ 0x27
 801fc9e:	7263      	strb	r3, [r4, #9]
  uip_connr->len = 1;
 801fca0:	2001      	movs	r0, #1
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
 801fca2:	f895 3026 	ldrb.w	r3, [r5, #38]	@ 0x26
  uip_connr->snd_nxt[2] = iss[2];
 801fca6:	73a2      	strb	r2, [r4, #14]
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
 801fca8:	7223      	strb	r3, [r4, #8]
  uip_connr->len = 1;
 801fcaa:	8220      	strh	r0, [r4, #16]
  uip_add_rcv_nxt(1);
 801fcac:	f7ff fbf6 	bl	801f49c <uip_add_rcv_nxt>
  if((BUF->tcpoffset & 0xf0) > 0x50) {
 801fcb0:	f895 202e 	ldrb.w	r2, [r5, #46]	@ 0x2e
 801fcb4:	f002 03f0 	and.w	r3, r2, #240	@ 0xf0
 801fcb8:	2b50      	cmp	r3, #80	@ 0x50
 801fcba:	d93f      	bls.n	801fd3c <uip_process+0x720>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 801fcbc:	0912      	lsrs	r2, r2, #4
 801fcbe:	2300      	movs	r3, #0
 801fcc0:	3a05      	subs	r2, #5
 801fcc2:	f889 3000 	strb.w	r3, [r9]
 801fcc6:	0092      	lsls	r2, r2, #2
 801fcc8:	4590      	cmp	r8, r2
 801fcca:	da04      	bge.n	801fcd6 <uip_process+0x6ba>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
 801fccc:	eb0a 0108 	add.w	r1, sl, r8
 801fcd0:	f891 0036 	ldrb.w	r0, [r1, #54]	@ 0x36
      if(opt == TCP_OPT_END) {
 801fcd4:	b988      	cbnz	r0, 801fcfa <uip_process+0x6de>
 801fcd6:	b38b      	cbz	r3, 801fd3c <uip_process+0x720>
 801fcd8:	f889 8000 	strb.w	r8, [r9]
 801fcdc:	e02e      	b.n	801fd3c <uip_process+0x720>
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
 801fcde:	2807      	cmp	r0, #7
 801fce0:	d105      	bne.n	801fcee <uip_process+0x6d2>
      if(uip_connr == 0 ||
 801fce2:	b144      	cbz	r4, 801fcf6 <uip_process+0x6da>
 801fce4:	7e98      	ldrb	r0, [r3, #26]
 801fce6:	7ea1      	ldrb	r1, [r4, #26]
	uip_connr = &uip_conns[c];
 801fce8:	4288      	cmp	r0, r1
 801fcea:	bf88      	it	hi
 801fcec:	461c      	movhi	r4, r3
  for(c = 0; c < UIP_CONNS; ++c) {
 801fcee:	3201      	adds	r2, #1
 801fcf0:	331e      	adds	r3, #30
  uip_connr = 0;
 801fcf2:	2101      	movs	r1, #1
 801fcf4:	e79b      	b.n	801fc2e <uip_process+0x612>
	uip_connr = &uip_conns[c];
 801fcf6:	461c      	mov	r4, r3
 801fcf8:	e7f9      	b.n	801fcee <uip_process+0x6d2>
      } else if(opt == TCP_OPT_NOOP) {
 801fcfa:	2801      	cmp	r0, #1
 801fcfc:	d105      	bne.n	801fd0a <uip_process+0x6ee>
	++c;
 801fcfe:	f108 0801 	add.w	r8, r8, #1
 801fd02:	fa5f f888 	uxtb.w	r8, r8
  uip_connr = 0;
 801fd06:	2301      	movs	r3, #1
 801fd08:	e7de      	b.n	801fcc8 <uip_process+0x6ac>
      } else if(opt == TCP_OPT_MSS &&
 801fd0a:	2802      	cmp	r0, #2
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 801fd0c:	f891 1037 	ldrb.w	r1, [r1, #55]	@ 0x37
      } else if(opt == TCP_OPT_MSS &&
 801fd10:	d163      	bne.n	801fdda <uip_process+0x7be>
 801fd12:	2904      	cmp	r1, #4
 801fd14:	d161      	bne.n	801fdda <uip_process+0x7be>
 801fd16:	b10b      	cbz	r3, 801fd1c <uip_process+0x700>
 801fd18:	f889 8000 	strb.w	r8, [r9]
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801fd1c:	44a8      	add	r8, r5
 801fd1e:	f898 2038 	ldrb.w	r2, [r8, #56]	@ 0x38
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
 801fd22:	f898 3039 	ldrb.w	r3, [r8, #57]	@ 0x39
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801fd26:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 801fd2a:	f5b3 6fb7 	cmp.w	r3, #1464	@ 0x5b8
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801fd2e:	f8ab 3000 	strh.w	r3, [fp]
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 801fd32:	bf28      	it	cs
 801fd34:	f44f 63b7 	movcs.w	r3, #1464	@ 0x5b8
	uip_connr->initialmss = uip_connr->mss =
 801fd38:	8263      	strh	r3, [r4, #18]
 801fd3a:	82a3      	strh	r3, [r4, #20]
 tcp_send_synack:
 801fd3c:	2110      	movs	r1, #16
  BUF->flags |= TCP_SYN;
 801fd3e:	4a2a      	ldr	r2, [pc, #168]	@ (801fde8 <uip_process+0x7cc>)
 801fd40:	f041 0302 	orr.w	r3, r1, #2
 801fd44:	f882 302f 	strb.w	r3, [r2, #47]	@ 0x2f
  BUF->optdata[0] = TCP_OPT_MSS;
 801fd48:	2302      	movs	r3, #2
 801fd4a:	f882 3036 	strb.w	r3, [r2, #54]	@ 0x36
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
 801fd4e:	2304      	movs	r3, #4
 801fd50:	f882 3037 	strb.w	r3, [r2, #55]	@ 0x37
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
 801fd54:	2305      	movs	r3, #5
 801fd56:	f882 3038 	strb.w	r3, [r2, #56]	@ 0x38
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
 801fd5a:	23b8      	movs	r3, #184	@ 0xb8
 801fd5c:	f882 3039 	strb.w	r3, [r2, #57]	@ 0x39
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
 801fd60:	232c      	movs	r3, #44	@ 0x2c
 801fd62:	803b      	strh	r3, [r7, #0]
  goto tcp_send;
 801fd64:	2260      	movs	r2, #96	@ 0x60
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
 801fd66:	4b20      	ldr	r3, [pc, #128]	@ (801fde8 <uip_process+0x7cc>)
 801fd68:	f883 202e 	strb.w	r2, [r3, #46]	@ 0x2e
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
 801fd6c:	7a22      	ldrb	r2, [r4, #8]
 801fd6e:	f883 202a 	strb.w	r2, [r3, #42]	@ 0x2a
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
 801fd72:	7a62      	ldrb	r2, [r4, #9]
 801fd74:	f883 202b 	strb.w	r2, [r3, #43]	@ 0x2b
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
 801fd78:	7aa2      	ldrb	r2, [r4, #10]
 801fd7a:	f883 202c 	strb.w	r2, [r3, #44]	@ 0x2c
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
 801fd7e:	7ae2      	ldrb	r2, [r4, #11]
 801fd80:	f883 202d 	strb.w	r2, [r3, #45]	@ 0x2d
  BUF->seqno[0] = uip_connr->snd_nxt[0];
 801fd84:	7b22      	ldrb	r2, [r4, #12]
 801fd86:	f883 2026 	strb.w	r2, [r3, #38]	@ 0x26
  BUF->seqno[1] = uip_connr->snd_nxt[1];
 801fd8a:	7b62      	ldrb	r2, [r4, #13]
 801fd8c:	f883 2027 	strb.w	r2, [r3, #39]	@ 0x27
  BUF->seqno[2] = uip_connr->snd_nxt[2];
 801fd90:	7ba2      	ldrb	r2, [r4, #14]
 801fd92:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
  BUF->seqno[3] = uip_connr->snd_nxt[3];
 801fd96:	7be2      	ldrb	r2, [r4, #15]
 801fd98:	f883 2029 	strb.w	r2, [r3, #41]	@ 0x29
  BUF->proto = UIP_PROTO_TCP;
 801fd9c:	2206      	movs	r2, #6
 801fd9e:	75da      	strb	r2, [r3, #23]
  BUF->srcport  = uip_connr->lport;
 801fda0:	88a2      	ldrh	r2, [r4, #4]
 801fda2:	845a      	strh	r2, [r3, #34]	@ 0x22
  BUF->destport = uip_connr->rport;
 801fda4:	88e2      	ldrh	r2, [r4, #6]
 801fda6:	849a      	strh	r2, [r3, #36]	@ 0x24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
 801fda8:	4a17      	ldr	r2, [pc, #92]	@ (801fe08 <uip_process+0x7ec>)
 801fdaa:	8811      	ldrh	r1, [r2, #0]
 801fdac:	8852      	ldrh	r2, [r2, #2]
 801fdae:	8359      	strh	r1, [r3, #26]
 801fdb0:	839a      	strh	r2, [r3, #28]
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
 801fdb2:	8822      	ldrh	r2, [r4, #0]
 801fdb4:	83da      	strh	r2, [r3, #30]
 801fdb6:	8862      	ldrh	r2, [r4, #2]
 801fdb8:	841a      	strh	r2, [r3, #32]
  if(uip_connr->tcpstateflags & UIP_STOPPED) {
 801fdba:	7e62      	ldrb	r2, [r4, #25]
 801fdbc:	06d2      	lsls	r2, r2, #27
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
 801fdbe:	bf51      	iteee	pl
 801fdc0:	2205      	movpl	r2, #5
    BUF->wnd[0] = BUF->wnd[1] = 0;
 801fdc2:	2200      	movmi	r2, #0
 801fdc4:	f883 2031 	strbmi.w	r2, [r3, #49]	@ 0x31
 801fdc8:	f883 2030 	strbmi.w	r2, [r3, #48]	@ 0x30
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
 801fdcc:	bf5e      	ittt	pl
 801fdce:	f883 2030 	strbpl.w	r2, [r3, #48]	@ 0x30
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
 801fdd2:	22b8      	movpl	r2, #184	@ 0xb8
 801fdd4:	f883 2031 	strbpl.w	r2, [r3, #49]	@ 0x31
 801fdd8:	e630      	b.n	801fa3c <uip_process+0x420>
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
 801fdda:	2900      	cmp	r1, #0
 801fddc:	f43f af7b 	beq.w	801fcd6 <uip_process+0x6ba>
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 801fde0:	4441      	add	r1, r8
 801fde2:	fa5f f881 	uxtb.w	r8, r1
 801fde6:	e78e      	b.n	801fd06 <uip_process+0x6ea>
 801fde8:	20006ecc 	.word	0x20006ecc
 801fdec:	20006eb8 	.word	0x20006eb8
 801fdf0:	20006ebc 	.word	0x20006ebc
 801fdf4:	08028141 	.word	0x08028141
 801fdf8:	20006d8c 	.word	0x20006d8c
 801fdfc:	20006ab0 	.word	0x20006ab0
 801fe00:	0802811f 	.word	0x0802811f
 801fe04:	20006aee 	.word	0x20006aee
 801fe08:	200074ca 	.word	0x200074ca
  c = (BUF->tcpoffset >> 4) << 2;
 801fe0c:	f89b 202e 	ldrb.w	r2, [fp, #46]	@ 0x2e
 801fe10:	4b98      	ldr	r3, [pc, #608]	@ (8020074 <uip_process+0xa58>)
 801fe12:	0912      	lsrs	r2, r2, #4
 801fe14:	0092      	lsls	r2, r2, #2
 801fe16:	701a      	strb	r2, [r3, #0]
  uip_len = uip_len - c - UIP_IPH_LEN;
 801fe18:	9b02      	ldr	r3, [sp, #8]
 801fe1a:	3b14      	subs	r3, #20
 801fe1c:	1a9b      	subs	r3, r3, r2
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 801fe1e:	f000 000f 	and.w	r0, r0, #15
  uip_len = uip_len - c - UIP_IPH_LEN;
 801fe22:	b29b      	uxth	r3, r3
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 801fe24:	2802      	cmp	r0, #2
  uip_len = uip_len - c - UIP_IPH_LEN;
 801fe26:	803b      	strh	r3, [r7, #0]
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
 801fe28:	d103      	bne.n	801fe32 <uip_process+0x816>
 801fe2a:	f001 023f 	and.w	r2, r1, #63	@ 0x3f
 801fe2e:	2a12      	cmp	r2, #18
 801fe30:	d00d      	beq.n	801fe4e <uip_process+0x832>
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
 801fe32:	b90b      	cbnz	r3, 801fe38 <uip_process+0x81c>
 801fe34:	0788      	lsls	r0, r1, #30
 801fe36:	d00a      	beq.n	801fe4e <uip_process+0x832>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
 801fe38:	4b8f      	ldr	r3, [pc, #572]	@ (8020078 <uip_process+0xa5c>)
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
 801fe3a:	8922      	ldrh	r2, [r4, #8]
 801fe3c:	8cd8      	ldrh	r0, [r3, #38]	@ 0x26
 801fe3e:	4290      	cmp	r0, r2
 801fe40:	f040 81a1 	bne.w	8020186 <uip_process+0xb6a>
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
 801fe44:	8d1a      	ldrh	r2, [r3, #40]	@ 0x28
 801fe46:	8963      	ldrh	r3, [r4, #10]
 801fe48:	429a      	cmp	r2, r3
 801fe4a:	f040 819c 	bne.w	8020186 <uip_process+0xb6a>
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
 801fe4e:	06c9      	lsls	r1, r1, #27
 801fe50:	d54a      	bpl.n	801fee8 <uip_process+0x8cc>
 801fe52:	8a21      	ldrh	r1, [r4, #16]
 801fe54:	2900      	cmp	r1, #0
 801fe56:	d047      	beq.n	801fee8 <uip_process+0x8cc>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
 801fe58:	f104 000c 	add.w	r0, r4, #12
 801fe5c:	f7ff faf4 	bl	801f448 <uip_add32>
    if(BUF->ackno[0] == uip_acc32[0] &&
 801fe60:	4a86      	ldr	r2, [pc, #536]	@ (802007c <uip_process+0xa60>)
 801fe62:	4b85      	ldr	r3, [pc, #532]	@ (8020078 <uip_process+0xa5c>)
 801fe64:	7811      	ldrb	r1, [r2, #0]
 801fe66:	f893 c02a 	ldrb.w	ip, [r3, #42]	@ 0x2a
 801fe6a:	458c      	cmp	ip, r1
 801fe6c:	d13c      	bne.n	801fee8 <uip_process+0x8cc>
       BUF->ackno[1] == uip_acc32[1] &&
 801fe6e:	7851      	ldrb	r1, [r2, #1]
    if(BUF->ackno[0] == uip_acc32[0] &&
 801fe70:	f893 002b 	ldrb.w	r0, [r3, #43]	@ 0x2b
 801fe74:	4288      	cmp	r0, r1
 801fe76:	d137      	bne.n	801fee8 <uip_process+0x8cc>
       BUF->ackno[2] == uip_acc32[2] &&
 801fe78:	f892 e002 	ldrb.w	lr, [r2, #2]
       BUF->ackno[1] == uip_acc32[1] &&
 801fe7c:	f893 102c 	ldrb.w	r1, [r3, #44]	@ 0x2c
 801fe80:	4571      	cmp	r1, lr
 801fe82:	d131      	bne.n	801fee8 <uip_process+0x8cc>
       BUF->ackno[3] == uip_acc32[3]) {
 801fe84:	78d2      	ldrb	r2, [r2, #3]
       BUF->ackno[2] == uip_acc32[2] &&
 801fe86:	f893 302d 	ldrb.w	r3, [r3, #45]	@ 0x2d
 801fe8a:	4293      	cmp	r3, r2
 801fe8c:	d12c      	bne.n	801fee8 <uip_process+0x8cc>
      uip_connr->snd_nxt[3] = uip_acc32[3];
 801fe8e:	73e3      	strb	r3, [r4, #15]
      if(uip_connr->nrtx == 0) {
 801fe90:	7ee3      	ldrb	r3, [r4, #27]
      uip_connr->snd_nxt[0] = uip_acc32[0];
 801fe92:	f884 c00c 	strb.w	ip, [r4, #12]
      uip_connr->snd_nxt[1] = uip_acc32[1];
 801fe96:	7360      	strb	r0, [r4, #13]
      uip_connr->snd_nxt[2] = uip_acc32[2];
 801fe98:	73a1      	strb	r1, [r4, #14]
      if(uip_connr->nrtx == 0) {
 801fe9a:	b9f3      	cbnz	r3, 801feda <uip_process+0x8be>
	m = uip_connr->rto - uip_connr->timer;
 801fe9c:	7ea2      	ldrb	r2, [r4, #26]
 801fe9e:	f894 e018 	ldrb.w	lr, [r4, #24]
	m = m - (uip_connr->sa >> 3);
 801fea2:	f894 c016 	ldrb.w	ip, [r4, #22]
	m = uip_connr->rto - uip_connr->timer;
 801fea6:	ebae 0302 	sub.w	r3, lr, r2
	m = m - (uip_connr->sa >> 3);
 801feaa:	eba3 03dc 	sub.w	r3, r3, ip, lsr #3
 801feae:	b259      	sxtb	r1, r3
	if(m < 0) {
 801feb0:	2900      	cmp	r1, #0
	m = m - (uip_connr->sa >> 3);
 801feb2:	ea4f 00dc 	mov.w	r0, ip, lsr #3
	  m = -m;
 801feb6:	bfbe      	ittt	lt
 801feb8:	eba0 000e 	sublt.w	r0, r0, lr
 801febc:	1812      	addlt	r2, r2, r0
 801febe:	b251      	sxtblt	r1, r2
	m = m - (uip_connr->sv >> 2);
 801fec0:	7de2      	ldrb	r2, [r4, #23]
	uip_connr->sv += m;
 801fec2:	eba2 0292 	sub.w	r2, r2, r2, lsr #2
	uip_connr->sa += m;
 801fec6:	fa5c f383 	uxtab	r3, ip, r3
	uip_connr->sv += m;
 801feca:	440a      	add	r2, r1
	uip_connr->sa += m;
 801fecc:	b2db      	uxtb	r3, r3
	uip_connr->sv += m;
 801fece:	b2d2      	uxtb	r2, r2
 801fed0:	75e2      	strb	r2, [r4, #23]
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
 801fed2:	eb02 02d3 	add.w	r2, r2, r3, lsr #3
	uip_connr->sa += m;
 801fed6:	75a3      	strb	r3, [r4, #22]
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
 801fed8:	7622      	strb	r2, [r4, #24]
      uip_flags = UIP_ACKDATA;
 801feda:	4b69      	ldr	r3, [pc, #420]	@ (8020080 <uip_process+0xa64>)
 801fedc:	2201      	movs	r2, #1
 801fede:	701a      	strb	r2, [r3, #0]
      uip_connr->timer = uip_connr->rto;
 801fee0:	7e23      	ldrb	r3, [r4, #24]
 801fee2:	76a3      	strb	r3, [r4, #26]
      uip_connr->len = 0;
 801fee4:	2300      	movs	r3, #0
 801fee6:	8223      	strh	r3, [r4, #16]
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
 801fee8:	f894 c019 	ldrb.w	ip, [r4, #25]
 801feec:	f8df a190 	ldr.w	sl, [pc, #400]	@ 8020080 <uip_process+0xa64>
 801fef0:	f00c 020f 	and.w	r2, ip, #15
 801fef4:	3a01      	subs	r2, #1
 801fef6:	2a07      	cmp	r2, #7
 801fef8:	f63f abe0 	bhi.w	801f6bc <uip_process+0xa0>
 801fefc:	e8df f012 	tbh	[pc, r2, lsl #1]
 801ff00:	00200008 	.word	0x00200008
 801ff04:	01270092 	.word	0x01270092
 801ff08:	0162014f 	.word	0x0162014f
 801ff0c:	011c0143 	.word	0x011c0143
    if(uip_flags & UIP_ACKDATA) {
 801ff10:	f89a 2000 	ldrb.w	r2, [sl]
 801ff14:	07d2      	lsls	r2, r2, #31
 801ff16:	f57f abd1 	bpl.w	801f6bc <uip_process+0xa0>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
 801ff1a:	2203      	movs	r2, #3
 801ff1c:	7662      	strb	r2, [r4, #25]
      if(uip_len > 0) {
 801ff1e:	8838      	ldrh	r0, [r7, #0]
      uip_flags = UIP_CONNECTED;
 801ff20:	2240      	movs	r2, #64	@ 0x40
 801ff22:	f88a 2000 	strb.w	r2, [sl]
      uip_connr->len = 0;
 801ff26:	2200      	movs	r2, #0
 801ff28:	8222      	strh	r2, [r4, #16]
      if(uip_len > 0) {
 801ff2a:	b120      	cbz	r0, 801ff36 <uip_process+0x91a>
        uip_flags |= UIP_NEWDATA;
 801ff2c:	2242      	movs	r2, #66	@ 0x42
 801ff2e:	f88a 2000 	strb.w	r2, [sl]
        uip_add_rcv_nxt(uip_len);
 801ff32:	f7ff fab3 	bl	801f49c <uip_add_rcv_nxt>
      uip_slen = 0;
 801ff36:	4b53      	ldr	r3, [pc, #332]	@ (8020084 <uip_process+0xa68>)
 801ff38:	2200      	movs	r2, #0
 801ff3a:	801a      	strh	r2, [r3, #0]
 801ff3c:	f7ff bb8b 	b.w	801f656 <uip_process+0x3a>
    if((uip_flags & UIP_ACKDATA) &&
 801ff40:	f89a 3000 	ldrb.w	r3, [sl]
 801ff44:	07db      	lsls	r3, r3, #31
 801ff46:	d563      	bpl.n	8020010 <uip_process+0x9f4>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
 801ff48:	494b      	ldr	r1, [pc, #300]	@ (8020078 <uip_process+0xa5c>)
    if((uip_flags & UIP_ACKDATA) &&
 801ff4a:	f891 302f 	ldrb.w	r3, [r1, #47]	@ 0x2f
 801ff4e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 801ff52:	2b12      	cmp	r3, #18
 801ff54:	d15c      	bne.n	8020010 <uip_process+0x9f4>
      if((BUF->tcpoffset & 0xf0) > 0x50) {
 801ff56:	f891 202e 	ldrb.w	r2, [r1, #46]	@ 0x2e
 801ff5a:	f002 03f0 	and.w	r3, r2, #240	@ 0xf0
 801ff5e:	2b50      	cmp	r3, #80	@ 0x50
 801ff60:	d935      	bls.n	801ffce <uip_process+0x9b2>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
 801ff62:	4844      	ldr	r0, [pc, #272]	@ (8020074 <uip_process+0xa58>)
 801ff64:	0912      	lsrs	r2, r2, #4
 801ff66:	2300      	movs	r3, #0
 801ff68:	3a05      	subs	r2, #5
 801ff6a:	7003      	strb	r3, [r0, #0]
 801ff6c:	0092      	lsls	r2, r2, #2
 801ff6e:	4590      	cmp	r8, r2
 801ff70:	da06      	bge.n	801ff80 <uip_process+0x964>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
 801ff72:	eb01 0608 	add.w	r6, r1, r8
 801ff76:	f896 c036 	ldrb.w	ip, [r6, #54]	@ 0x36
	  if(opt == TCP_OPT_END) {
 801ff7a:	f1bc 0f00 	cmp.w	ip, #0
 801ff7e:	d103      	bne.n	801ff88 <uip_process+0x96c>
 801ff80:	b32b      	cbz	r3, 801ffce <uip_process+0x9b2>
 801ff82:	f880 8000 	strb.w	r8, [r0]
 801ff86:	e022      	b.n	801ffce <uip_process+0x9b2>
	  } else if(opt == TCP_OPT_NOOP) {
 801ff88:	f1bc 0f01 	cmp.w	ip, #1
 801ff8c:	d105      	bne.n	801ff9a <uip_process+0x97e>
	    ++c;
 801ff8e:	f108 0801 	add.w	r8, r8, #1
 801ff92:	fa5f f888 	uxtb.w	r8, r8
 tcp_send_synack:
 801ff96:	2301      	movs	r3, #1
 801ff98:	e7e9      	b.n	801ff6e <uip_process+0x952>
	  } else if(opt == TCP_OPT_MSS &&
 801ff9a:	f1bc 0f02 	cmp.w	ip, #2
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
 801ff9e:	f896 6037 	ldrb.w	r6, [r6, #55]	@ 0x37
	  } else if(opt == TCP_OPT_MSS &&
 801ffa2:	d12f      	bne.n	8020004 <uip_process+0x9e8>
 801ffa4:	2e04      	cmp	r6, #4
 801ffa6:	d12d      	bne.n	8020004 <uip_process+0x9e8>
 801ffa8:	b10b      	cbz	r3, 801ffae <uip_process+0x992>
 801ffaa:	f880 8000 	strb.w	r8, [r0]
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801ffae:	44a8      	add	r8, r5
 801ffb0:	f898 2038 	ldrb.w	r2, [r8, #56]	@ 0x38
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
 801ffb4:	f898 3039 	ldrb.w	r3, [r8, #57]	@ 0x39
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801ffb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 801ffbc:	4a32      	ldr	r2, [pc, #200]	@ (8020088 <uip_process+0xa6c>)
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 801ffbe:	f5b3 6fb7 	cmp.w	r3, #1464	@ 0x5b8
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
 801ffc2:	8013      	strh	r3, [r2, #0]
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
 801ffc4:	bf28      	it	cs
 801ffc6:	f44f 63b7 	movcs.w	r3, #1464	@ 0x5b8
 801ffca:	8263      	strh	r3, [r4, #18]
	    uip_connr->initialmss =
 801ffcc:	82a3      	strh	r3, [r4, #20]
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
 801ffce:	2303      	movs	r3, #3
 801ffd0:	7663      	strb	r3, [r4, #25]
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
 801ffd2:	f895 3026 	ldrb.w	r3, [r5, #38]	@ 0x26
 801ffd6:	7223      	strb	r3, [r4, #8]
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
 801ffd8:	f895 3027 	ldrb.w	r3, [r5, #39]	@ 0x27
 801ffdc:	7263      	strb	r3, [r4, #9]
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
 801ffde:	f895 3028 	ldrb.w	r3, [r5, #40]	@ 0x28
 801ffe2:	72a3      	strb	r3, [r4, #10]
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
 801ffe4:	f895 3029 	ldrb.w	r3, [r5, #41]	@ 0x29
 801ffe8:	72e3      	strb	r3, [r4, #11]
      uip_add_rcv_nxt(1);
 801ffea:	2001      	movs	r0, #1
 801ffec:	f7ff fa56 	bl	801f49c <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
 801fff0:	4a23      	ldr	r2, [pc, #140]	@ (8020080 <uip_process+0xa64>)
 801fff2:	2342      	movs	r3, #66	@ 0x42
 801fff4:	7013      	strb	r3, [r2, #0]
      uip_slen = 0;
 801fff6:	4a23      	ldr	r2, [pc, #140]	@ (8020084 <uip_process+0xa68>)
      uip_connr->len = 0;
 801fff8:	2300      	movs	r3, #0
 801fffa:	8223      	strh	r3, [r4, #16]
      uip_len = 0;
 801fffc:	803b      	strh	r3, [r7, #0]
      uip_slen = 0;
 801fffe:	8013      	strh	r3, [r2, #0]
      UIP_APPCALL();
 8020000:	f7ff bb29 	b.w	801f656 <uip_process+0x3a>
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
 8020004:	2e00      	cmp	r6, #0
 8020006:	d0bb      	beq.n	801ff80 <uip_process+0x964>
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
 8020008:	4446      	add	r6, r8
 802000a:	fa5f f886 	uxtb.w	r8, r6
 802000e:	e7c2      	b.n	801ff96 <uip_process+0x97a>
    uip_flags = UIP_ABORT;
 8020010:	4a1b      	ldr	r2, [pc, #108]	@ (8020080 <uip_process+0xa64>)
 8020012:	2320      	movs	r3, #32
 8020014:	7013      	strb	r3, [r2, #0]
    UIP_APPCALL();
 8020016:	f000 fbd2 	bl	80207be <UIP_TASK_AppCall>
    uip_conn->tcpstateflags = UIP_CLOSED;
 802001a:	4b1c      	ldr	r3, [pc, #112]	@ (802008c <uip_process+0xa70>)
 802001c:	681b      	ldr	r3, [r3, #0]
 802001e:	2200      	movs	r2, #0
 8020020:	765a      	strb	r2, [r3, #25]
    goto reset;
 8020022:	e4b9      	b.n	801f998 <uip_process+0x37c>
    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
 8020024:	4a14      	ldr	r2, [pc, #80]	@ (8020078 <uip_process+0xa5c>)
 8020026:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
 802002a:	07d5      	lsls	r5, r2, #31
 802002c:	d530      	bpl.n	8020090 <uip_process+0xa74>
 802002e:	f01c 0f10 	tst.w	ip, #16
 8020032:	d12d      	bne.n	8020090 <uip_process+0xa74>
      if(uip_outstanding(uip_connr)) {
 8020034:	8a22      	ldrh	r2, [r4, #16]
 8020036:	2a00      	cmp	r2, #0
 8020038:	f47f ab40 	bne.w	801f6bc <uip_process+0xa0>
      uip_add_rcv_nxt(1 + uip_len);
 802003c:	8838      	ldrh	r0, [r7, #0]
 802003e:	3001      	adds	r0, #1
 8020040:	b280      	uxth	r0, r0
 8020042:	f7ff fa2b 	bl	801f49c <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
 8020046:	f89a 2000 	ldrb.w	r2, [sl]
 802004a:	f042 0110 	orr.w	r1, r2, #16
 802004e:	f88a 1000 	strb.w	r1, [sl]
      if(uip_len > 0) {
 8020052:	8839      	ldrh	r1, [r7, #0]
 8020054:	b119      	cbz	r1, 802005e <uip_process+0xa42>
	uip_flags |= UIP_NEWDATA;
 8020056:	f042 0212 	orr.w	r2, r2, #18
 802005a:	f88a 2000 	strb.w	r2, [sl]
      UIP_APPCALL();
 802005e:	f000 fbae 	bl	80207be <UIP_TASK_AppCall>
      uip_connr->len = 1;
 8020062:	2301      	movs	r3, #1
 8020064:	8223      	strh	r3, [r4, #16]
      uip_connr->tcpstateflags = UIP_LAST_ACK;
 8020066:	2308      	movs	r3, #8
 8020068:	7663      	strb	r3, [r4, #25]
      uip_connr->nrtx = 0;
 802006a:	2300      	movs	r3, #0
 802006c:	76e3      	strb	r3, [r4, #27]
	goto tcp_send_nodata;
 802006e:	2311      	movs	r3, #17
 8020070:	f7ff bb41 	b.w	801f6f6 <uip_process+0xda>
 8020074:	20006ae6 	.word	0x20006ae6
 8020078:	20006ecc 	.word	0x20006ecc
 802007c:	20006ae7 	.word	0x20006ae7
 8020080:	20006ebc 	.word	0x20006ebc
 8020084:	20006ebe 	.word	0x20006ebe
 8020088:	20006ae4 	.word	0x20006ae4
 802008c:	20006eb8 	.word	0x20006eb8
    if((BUF->flags & TCP_URG) != 0) {
 8020090:	0690      	lsls	r0, r2, #26
 8020092:	d50b      	bpl.n	80200ac <uip_process+0xa90>
 8020094:	f8bb 2034 	ldrh.w	r2, [fp, #52]	@ 0x34
      if(uip_len > 0) {
 8020098:	8838      	ldrh	r0, [r7, #0]
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
 802009a:	f8d9 1000 	ldr.w	r1, [r9]
 802009e:	ba52      	rev16	r2, r2
 80200a0:	fa11 f182 	uxtah	r1, r1, r2
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
 80200a4:	1a82      	subs	r2, r0, r2
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
 80200a6:	f8c9 1000 	str.w	r1, [r9]
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
 80200aa:	803a      	strh	r2, [r7, #0]
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
 80200ac:	8838      	ldrh	r0, [r7, #0]
 80200ae:	b150      	cbz	r0, 80200c6 <uip_process+0xaaa>
 80200b0:	f01c 0f10 	tst.w	ip, #16
 80200b4:	d107      	bne.n	80200c6 <uip_process+0xaaa>
      uip_flags |= UIP_NEWDATA;
 80200b6:	f89a 2000 	ldrb.w	r2, [sl]
 80200ba:	f042 0202 	orr.w	r2, r2, #2
 80200be:	f88a 2000 	strb.w	r2, [sl]
      uip_add_rcv_nxt(uip_len);
 80200c2:	f7ff f9eb 	bl	801f49c <uip_add_rcv_nxt>
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
 80200c6:	f8bb 0030 	ldrh.w	r0, [fp, #48]	@ 0x30
 80200ca:	4a44      	ldr	r2, [pc, #272]	@ (80201dc <uip_process+0xbc0>)
 80200cc:	ba41      	rev16	r1, r0
 80200ce:	b28d      	uxth	r5, r1
 80200d0:	8011      	strh	r1, [r2, #0]
    if(tmp16 > uip_connr->initialmss ||
 80200d2:	8aa1      	ldrh	r1, [r4, #20]
 80200d4:	428d      	cmp	r5, r1
 80200d6:	d800      	bhi.n	80200da <uip_process+0xabe>
 80200d8:	b900      	cbnz	r0, 80200dc <uip_process+0xac0>
      tmp16 = uip_connr->initialmss;
 80200da:	8011      	strh	r1, [r2, #0]
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
 80200dc:	f89a 3000 	ldrb.w	r3, [sl]
    uip_connr->mss = tmp16;
 80200e0:	8812      	ldrh	r2, [r2, #0]
 80200e2:	8262      	strh	r2, [r4, #18]
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
 80200e4:	0799      	lsls	r1, r3, #30
 80200e6:	f43f aae9 	beq.w	801f6bc <uip_process+0xa0>
 80200ea:	e724      	b.n	801ff36 <uip_process+0x91a>
      if(uip_flags & UIP_CLOSE) {
 80200ec:	f012 0010 	ands.w	r0, r2, #16
 80200f0:	d006      	beq.n	8020100 <uip_process+0xae4>
	uip_slen = 0;
 80200f2:	8019      	strh	r1, [r3, #0]
	uip_connr->len = 1;
 80200f4:	2301      	movs	r3, #1
 80200f6:	8223      	strh	r3, [r4, #16]
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
 80200f8:	2304      	movs	r3, #4
 80200fa:	7663      	strb	r3, [r4, #25]
	uip_connr->nrtx = 0;
 80200fc:	76e1      	strb	r1, [r4, #27]
 80200fe:	e7b6      	b.n	802006e <uip_process+0xa52>
      if(uip_slen > 0) {
 8020100:	8819      	ldrh	r1, [r3, #0]
 8020102:	b151      	cbz	r1, 802011a <uip_process+0xafe>
	if((uip_flags & UIP_ACKDATA) != 0) {
 8020104:	07d2      	lsls	r2, r2, #31
	  uip_connr->len = 0;
 8020106:	bf48      	it	mi
 8020108:	8220      	strhmi	r0, [r4, #16]
	if(uip_connr->len == 0) {
 802010a:	8a22      	ldrh	r2, [r4, #16]
 802010c:	b94a      	cbnz	r2, 8020122 <uip_process+0xb06>
	  if(uip_slen > uip_connr->mss) {
 802010e:	8a62      	ldrh	r2, [r4, #18]
 8020110:	4291      	cmp	r1, r2
	    uip_slen = uip_connr->mss;
 8020112:	bf88      	it	hi
 8020114:	801a      	strhhi	r2, [r3, #0]
	  uip_connr->len = uip_slen;
 8020116:	881b      	ldrh	r3, [r3, #0]
 8020118:	8223      	strh	r3, [r4, #16]
      uip_connr->nrtx = 0;
 802011a:	2300      	movs	r3, #0
 802011c:	76e3      	strb	r3, [r4, #27]
 802011e:	f7ff bb1b 	b.w	801f758 <uip_process+0x13c>
	  uip_slen = uip_connr->len;
 8020122:	801a      	strh	r2, [r3, #0]
 8020124:	e7f9      	b.n	802011a <uip_process+0xafe>
      if(uip_flags & UIP_NEWDATA) {
 8020126:	4b2e      	ldr	r3, [pc, #184]	@ (80201e0 <uip_process+0xbc4>)
 8020128:	781b      	ldrb	r3, [r3, #0]
 802012a:	079e      	lsls	r6, r3, #30
 802012c:	f57f aac6 	bpl.w	801f6bc <uip_process+0xa0>
 8020130:	2328      	movs	r3, #40	@ 0x28
 8020132:	2210      	movs	r2, #16
 8020134:	f7ff bb20 	b.w	801f778 <uip_process+0x15c>
    if(uip_flags & UIP_ACKDATA) {
 8020138:	f89a 2000 	ldrb.w	r2, [sl]
 802013c:	07d5      	lsls	r5, r2, #31
 802013e:	f57f aabd 	bpl.w	801f6bc <uip_process+0xa0>
      uip_connr->tcpstateflags = UIP_CLOSED;
 8020142:	2200      	movs	r2, #0
 8020144:	7662      	strb	r2, [r4, #25]
      uip_flags = UIP_CLOSE;
 8020146:	2210      	movs	r2, #16
 8020148:	f88a 2000 	strb.w	r2, [sl]
 802014c:	e55b      	b.n	801fc06 <uip_process+0x5ea>
    if(uip_len > 0) {
 802014e:	8838      	ldrh	r0, [r7, #0]
 8020150:	b108      	cbz	r0, 8020156 <uip_process+0xb3a>
      uip_add_rcv_nxt(uip_len);
 8020152:	f7ff f9a3 	bl	801f49c <uip_add_rcv_nxt>
    if(BUF->flags & TCP_FIN) {
 8020156:	4a23      	ldr	r2, [pc, #140]	@ (80201e4 <uip_process+0xbc8>)
 8020158:	4b21      	ldr	r3, [pc, #132]	@ (80201e0 <uip_process+0xbc4>)
 802015a:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
 802015e:	7819      	ldrb	r1, [r3, #0]
 8020160:	f012 0201 	ands.w	r2, r2, #1
 8020164:	f001 0101 	and.w	r1, r1, #1
 8020168:	d013      	beq.n	8020192 <uip_process+0xb76>
      if(uip_flags & UIP_ACKDATA) {
 802016a:	b179      	cbz	r1, 802018c <uip_process+0xb70>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
 802016c:	2207      	movs	r2, #7
 802016e:	7662      	strb	r2, [r4, #25]
	uip_connr->timer = 0;
 8020170:	2200      	movs	r2, #0
 8020172:	76a2      	strb	r2, [r4, #26]
	uip_connr->len = 0;
 8020174:	8222      	strh	r2, [r4, #16]
      uip_add_rcv_nxt(1);
 8020176:	2001      	movs	r0, #1
 8020178:	f7ff f990 	bl	801f49c <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
 802017c:	2210      	movs	r2, #16
 802017e:	f88a 2000 	strb.w	r2, [sl]
      UIP_APPCALL();
 8020182:	f000 fb1c 	bl	80207be <UIP_TASK_AppCall>
 tcp_send_ack:
 8020186:	2310      	movs	r3, #16
 8020188:	f7ff bab5 	b.w	801f6f6 <uip_process+0xda>
	uip_connr->tcpstateflags = UIP_CLOSING;
 802018c:	2206      	movs	r2, #6
 802018e:	7662      	strb	r2, [r4, #25]
      uip_add_rcv_nxt(1);
 8020190:	e7f1      	b.n	8020176 <uip_process+0xb5a>
    } else if(uip_flags & UIP_ACKDATA) {
 8020192:	b191      	cbz	r1, 80201ba <uip_process+0xb9e>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
 8020194:	2305      	movs	r3, #5
 8020196:	7663      	strb	r3, [r4, #25]
      uip_connr->len = 0;
 8020198:	8222      	strh	r2, [r4, #16]
      goto drop;
 802019a:	f7ff ba8f 	b.w	801f6bc <uip_process+0xa0>
    if(uip_len > 0) {
 802019e:	8838      	ldrh	r0, [r7, #0]
 80201a0:	b108      	cbz	r0, 80201a6 <uip_process+0xb8a>
      uip_add_rcv_nxt(uip_len);
 80201a2:	f7ff f97b 	bl	801f49c <uip_add_rcv_nxt>
    if(BUF->flags & TCP_FIN) {
 80201a6:	4a0f      	ldr	r2, [pc, #60]	@ (80201e4 <uip_process+0xbc8>)
 80201a8:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
 80201ac:	07d0      	lsls	r0, r2, #31
 80201ae:	d504      	bpl.n	80201ba <uip_process+0xb9e>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
 80201b0:	2207      	movs	r2, #7
 80201b2:	7662      	strb	r2, [r4, #25]
      uip_connr->timer = 0;
 80201b4:	2200      	movs	r2, #0
 80201b6:	76a2      	strb	r2, [r4, #26]
 80201b8:	e7dd      	b.n	8020176 <uip_process+0xb5a>
    if(uip_len > 0) {
 80201ba:	883b      	ldrh	r3, [r7, #0]
 80201bc:	2b00      	cmp	r3, #0
 80201be:	d1e2      	bne.n	8020186 <uip_process+0xb6a>
 80201c0:	f7ff ba7c 	b.w	801f6bc <uip_process+0xa0>
    if(uip_flags & UIP_ACKDATA) {
 80201c4:	f89a 3000 	ldrb.w	r3, [sl]
 80201c8:	07d9      	lsls	r1, r3, #31
 80201ca:	f57f aa77 	bpl.w	801f6bc <uip_process+0xa0>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
 80201ce:	2307      	movs	r3, #7
 80201d0:	7663      	strb	r3, [r4, #25]
      uip_connr->timer = 0;
 80201d2:	2300      	movs	r3, #0
 80201d4:	76a3      	strb	r3, [r4, #26]
 80201d6:	f7ff ba71 	b.w	801f6bc <uip_process+0xa0>
 80201da:	bf00      	nop
 80201dc:	20006ae4 	.word	0x20006ae4
 80201e0:	20006ebc 	.word	0x20006ebc
 80201e4:	20006ecc 	.word	0x20006ecc

080201e8 <htons>:
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
 80201e8:	ba40      	rev16	r0, r0
}
 80201ea:	b280      	uxth	r0, r0
 80201ec:	4770      	bx	lr
	...

080201f0 <uip_send>:
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
  uip_slen = len; // fix as per http://www.sics.se/~adam/uip/index.php/Known_bugs
 80201f0:	4a06      	ldr	r2, [pc, #24]	@ (802020c <uip_send+0x1c>)
  if(len > 0) {
 80201f2:	2900      	cmp	r1, #0
{
 80201f4:	4603      	mov	r3, r0
  uip_slen = len; // fix as per http://www.sics.se/~adam/uip/index.php/Known_bugs
 80201f6:	8011      	strh	r1, [r2, #0]
  if(len > 0) {
 80201f8:	dd07      	ble.n	802020a <uip_send+0x1a>
    if(data != uip_sappdata) {
 80201fa:	4a05      	ldr	r2, [pc, #20]	@ (8020210 <uip_send+0x20>)
 80201fc:	6810      	ldr	r0, [r2, #0]
 80201fe:	4298      	cmp	r0, r3
 8020200:	d003      	beq.n	802020a <uip_send+0x1a>
      memcpy(uip_sappdata, (data), uip_slen);
 8020202:	b28a      	uxth	r2, r1
 8020204:	4619      	mov	r1, r3
 8020206:	f003 ba0a 	b.w	802361e <memcpy>
    }
  }
}
 802020a:	4770      	bx	lr
 802020c:	20006ebe 	.word	0x20006ebe
 8020210:	20006ec4 	.word	0x20006ec4

08020214 <uip_arp_update.constprop.0>:
    if(tabptr->ipaddr[0] != 0 &&
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
 8020214:	4847      	ldr	r0, [pc, #284]	@ (8020334 <uip_arp_update.constprop.0+0x120>)
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
 8020216:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 802021a:	4d47      	ldr	r5, [pc, #284]	@ (8020338 <uip_arp_update.constprop.0+0x124>)
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802021c:	4c47      	ldr	r4, [pc, #284]	@ (802033c <uip_arp_update.constprop.0+0x128>)
      if(ipaddr[0] == tabptr->ipaddr[0] &&
 802021e:	f8b0 901c 	ldrh.w	r9, [r0, #28]
	 ipaddr[1] == tabptr->ipaddr[1]) {
 8020222:	f8b0 a01e 	ldrh.w	sl, [r0, #30]
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
 8020226:	2100      	movs	r1, #0
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020228:	7021      	strb	r1, [r4, #0]
 802022a:	462e      	mov	r6, r5
 802022c:	460a      	mov	r2, r1
 802022e:	468c      	mov	ip, r1
  register struct arp_entry *tabptr = NULL;
 8020230:	460b      	mov	r3, r1
 8020232:	462f      	mov	r7, r5
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020234:	2a08      	cmp	r2, #8
 8020236:	d10a      	bne.n	802024e <uip_arp_update.constprop.0+0x3a>
 8020238:	2200      	movs	r2, #0
 802023a:	4e3f      	ldr	r6, [pc, #252]	@ (8020338 <uip_arp_update.constprop.0+0x124>)
 802023c:	4694      	mov	ip, r2

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802023e:	2a08      	cmp	r2, #8
 8020240:	d12b      	bne.n	802029a <uip_arp_update.constprop.0+0x86>
 8020242:	f1bc 0f00 	cmp.w	ip, #0
 8020246:	d000      	beq.n	802024a <uip_arp_update.constprop.0+0x36>
 8020248:	7022      	strb	r2, [r4, #0]
 802024a:	2208      	movs	r2, #8
 802024c:	e035      	b.n	80202ba <uip_arp_update.constprop.0+0xa6>
    if(tabptr->ipaddr[0] != 0 &&
 802024e:	f8b6 8000 	ldrh.w	r8, [r6]
    tabptr = &arp_table[i];
 8020252:	4633      	mov	r3, r6
    if(tabptr->ipaddr[0] != 0 &&
 8020254:	f1b8 0f00 	cmp.w	r8, #0
 8020258:	d01a      	beq.n	8020290 <uip_arp_update.constprop.0+0x7c>
       tabptr->ipaddr[1] != 0) {
 802025a:	f8b6 e002 	ldrh.w	lr, [r6, #2]
    if(tabptr->ipaddr[0] != 0 &&
 802025e:	f1be 0f00 	cmp.w	lr, #0
 8020262:	d015      	beq.n	8020290 <uip_arp_update.constprop.0+0x7c>
      if(ipaddr[0] == tabptr->ipaddr[0] &&
 8020264:	45c8      	cmp	r8, r9
 8020266:	d113      	bne.n	8020290 <uip_arp_update.constprop.0+0x7c>
 8020268:	45d6      	cmp	lr, sl
 802026a:	d111      	bne.n	8020290 <uip_arp_update.constprop.0+0x7c>
 802026c:	f1bc 0f00 	cmp.w	ip, #0
 8020270:	d000      	beq.n	8020274 <uip_arp_update.constprop.0+0x60>
 8020272:	7022      	strb	r2, [r4, #0]
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
 8020274:	230c      	movs	r3, #12
 8020276:	fb03 7202 	mla	r2, r3, r2, r7
 802027a:	f8d0 3016 	ldr.w	r3, [r0, #22]
 802027e:	6053      	str	r3, [r2, #4]
 8020280:	4b2f      	ldr	r3, [pc, #188]	@ (8020340 <uip_arp_update.constprop.0+0x12c>)
 8020282:	889b      	ldrh	r3, [r3, #4]
 8020284:	8113      	strh	r3, [r2, #8]
	tabptr->time = arptime;
 8020286:	4b2f      	ldr	r3, [pc, #188]	@ (8020344 <uip_arp_update.constprop.0+0x130>)
 8020288:	781b      	ldrb	r3, [r3, #0]
 802028a:	7293      	strb	r3, [r2, #10]
  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
  tabptr->time = arptime;
}
 802028c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020290:	3201      	adds	r2, #1
 8020292:	360c      	adds	r6, #12
  register struct arp_entry *tabptr = NULL;
 8020294:	f04f 0c01 	mov.w	ip, #1
 8020298:	e7cc      	b.n	8020234 <uip_arp_update.constprop.0+0x20>
    if(tabptr->ipaddr[0] == 0 &&
 802029a:	f8b6 e000 	ldrh.w	lr, [r6]
    tabptr = &arp_table[i];
 802029e:	4633      	mov	r3, r6
    if(tabptr->ipaddr[0] == 0 &&
 80202a0:	f1be 0f00 	cmp.w	lr, #0
 80202a4:	d134      	bne.n	8020310 <uip_arp_update.constprop.0+0xfc>
 80202a6:	f8b6 e002 	ldrh.w	lr, [r6, #2]
 80202aa:	f1be 0f00 	cmp.w	lr, #0
 80202ae:	d12f      	bne.n	8020310 <uip_arp_update.constprop.0+0xfc>
 80202b0:	b2d2      	uxtb	r2, r2
 80202b2:	f1bc 0f00 	cmp.w	ip, #0
 80202b6:	d000      	beq.n	80202ba <uip_arp_update.constprop.0+0xa6>
 80202b8:	7022      	strb	r2, [r4, #0]
	tabptr->time = arptime;
 80202ba:	4e22      	ldr	r6, [pc, #136]	@ (8020344 <uip_arp_update.constprop.0+0x130>)
  if(i == UIP_ARPTAB_SIZE) {
 80202bc:	2a08      	cmp	r2, #8
	tabptr->time = arptime;
 80202be:	7836      	ldrb	r6, [r6, #0]
  if(i == UIP_ARPTAB_SIZE) {
 80202c0:	d11a      	bne.n	80202f8 <uip_arp_update.constprop.0+0xe4>
    tmpage = 0;
 80202c2:	f8df 8084 	ldr.w	r8, [pc, #132]	@ 8020348 <uip_arp_update.constprop.0+0x134>
    c = 0;
 80202c6:	f8df c084 	ldr.w	ip, [pc, #132]	@ 802034c <uip_arp_update.constprop.0+0x138>
    tmpage = 0;
 80202ca:	2300      	movs	r3, #0
 80202cc:	f888 3000 	strb.w	r3, [r8]
    c = 0;
 80202d0:	f88c 3000 	strb.w	r3, [ip]
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 80202d4:	4699      	mov	r9, r3
 80202d6:	469e      	mov	lr, r3
 80202d8:	2b08      	cmp	r3, #8
 80202da:	d11e      	bne.n	802031a <uip_arp_update.constprop.0+0x106>
 80202dc:	f1b9 0f00 	cmp.w	r9, #0
 80202e0:	d003      	beq.n	80202ea <uip_arp_update.constprop.0+0xd6>
 80202e2:	f88c 1000 	strb.w	r1, [ip]
 80202e6:	f888 e000 	strb.w	lr, [r8]
    i = c;
 80202ea:	f89c 3000 	ldrb.w	r3, [ip]
 80202ee:	7023      	strb	r3, [r4, #0]
    tabptr = &arp_table[i];
 80202f0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80202f4:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  memcpy(tabptr->ipaddr, ipaddr, 4);
 80202f8:	461a      	mov	r2, r3
 80202fa:	69c1      	ldr	r1, [r0, #28]
 80202fc:	f842 1b04 	str.w	r1, [r2], #4
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
 8020300:	f8d0 1016 	ldr.w	r1, [r0, #22]
 8020304:	6059      	str	r1, [r3, #4]
 8020306:	490e      	ldr	r1, [pc, #56]	@ (8020340 <uip_arp_update.constprop.0+0x12c>)
 8020308:	8889      	ldrh	r1, [r1, #4]
 802030a:	8091      	strh	r1, [r2, #4]
  tabptr->time = arptime;
 802030c:	729e      	strb	r6, [r3, #10]
 802030e:	e7bd      	b.n	802028c <uip_arp_update.constprop.0+0x78>
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020310:	3201      	adds	r2, #1
 8020312:	360c      	adds	r6, #12
 8020314:	f04f 0c01 	mov.w	ip, #1
 8020318:	e791      	b.n	802023e <uip_arp_update.constprop.0+0x2a>
      if(arptime - tabptr->time > tmpage) {
 802031a:	7aaa      	ldrb	r2, [r5, #10]
 802031c:	1ab2      	subs	r2, r6, r2
 802031e:	4572      	cmp	r2, lr
 8020320:	bfc2      	ittt	gt
 8020322:	b2d9      	uxtbgt	r1, r3
	tmpage = arptime - tabptr->time;
 8020324:	fa5f fe82 	uxtbgt.w	lr, r2
 8020328:	f04f 0901 	movgt.w	r9, #1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802032c:	3301      	adds	r3, #1
 802032e:	350c      	adds	r5, #12
 8020330:	e7d2      	b.n	80202d8 <uip_arp_update.constprop.0+0xc4>
 8020332:	bf00      	nop
 8020334:	20006ecc 	.word	0x20006ecc
 8020338:	200074d6 	.word	0x200074d6
 802033c:	200074d1 	.word	0x200074d1
 8020340:	20006ee2 	.word	0x20006ee2
 8020344:	200074cf 	.word	0x200074cf
 8020348:	200074ce 	.word	0x200074ce
 802034c:	200074d0 	.word	0x200074d0

08020350 <uip_arp_init>:
{
 8020350:	b510      	push	{r4, lr}
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020352:	2300      	movs	r3, #0
 8020354:	4a06      	ldr	r2, [pc, #24]	@ (8020370 <uip_arp_init+0x20>)
    memset(arp_table[i].ipaddr, 0, 4);
 8020356:	4907      	ldr	r1, [pc, #28]	@ (8020374 <uip_arp_init+0x24>)
 8020358:	4618      	mov	r0, r3
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802035a:	2b08      	cmp	r3, #8
 802035c:	7013      	strb	r3, [r2, #0]
 802035e:	d100      	bne.n	8020362 <uip_arp_init+0x12>
}
 8020360:	bd10      	pop	{r4, pc}
    memset(arp_table[i].ipaddr, 0, 4);
 8020362:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020366:	3301      	adds	r3, #1
    memset(arp_table[i].ipaddr, 0, 4);
 8020368:	f841 0024 	str.w	r0, [r1, r4, lsl #2]
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802036c:	b2db      	uxtb	r3, r3
 802036e:	e7f4      	b.n	802035a <uip_arp_init+0xa>
 8020370:	200074d1 	.word	0x200074d1
 8020374:	200074d6 	.word	0x200074d6

08020378 <uip_arp_timer>:
{
 8020378:	b5f0      	push	{r4, r5, r6, r7, lr}
  ++arptime;
 802037a:	4a11      	ldr	r2, [pc, #68]	@ (80203c0 <uip_arp_timer+0x48>)
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802037c:	4d11      	ldr	r5, [pc, #68]	@ (80203c4 <uip_arp_timer+0x4c>)
  ++arptime;
 802037e:	7813      	ldrb	r3, [r2, #0]
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
 8020380:	4c11      	ldr	r4, [pc, #68]	@ (80203c8 <uip_arp_timer+0x50>)
  ++arptime;
 8020382:	3301      	adds	r3, #1
 8020384:	b2d8      	uxtb	r0, r3
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 8020386:	2300      	movs	r3, #0
  ++arptime;
 8020388:	7010      	strb	r0, [r2, #0]
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
 802038a:	260c      	movs	r6, #12
      memset(tabptr->ipaddr, 0, 4);
 802038c:	461f      	mov	r7, r3
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802038e:	2b08      	cmp	r3, #8
 8020390:	702b      	strb	r3, [r5, #0]
 8020392:	d100      	bne.n	8020396 <uip_arp_timer+0x1e>
}
 8020394:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
 8020396:	fb06 f203 	mul.w	r2, r6, r3
 802039a:	18a1      	adds	r1, r4, r2
 802039c:	5aa2      	ldrh	r2, [r4, r2]
 802039e:	f8b1 c002 	ldrh.w	ip, [r1, #2]
 80203a2:	ea42 020c 	orr.w	r2, r2, ip
 80203a6:	b292      	uxth	r2, r2
 80203a8:	b13a      	cbz	r2, 80203ba <uip_arp_timer+0x42>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
 80203aa:	7a8a      	ldrb	r2, [r1, #10]
 80203ac:	1a82      	subs	r2, r0, r2
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
 80203ae:	2a77      	cmp	r2, #119	@ 0x77
      memset(tabptr->ipaddr, 0, 4);
 80203b0:	bfc4      	itt	gt
 80203b2:	eb03 0243 	addgt.w	r2, r3, r3, lsl #1
 80203b6:	f844 7022 	strgt.w	r7, [r4, r2, lsl #2]
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 80203ba:	3301      	adds	r3, #1
 80203bc:	b2db      	uxtb	r3, r3
 80203be:	e7e6      	b.n	802038e <uip_arp_timer+0x16>
 80203c0:	200074cf 	.word	0x200074cf
 80203c4:	200074d1 	.word	0x200074d1
 80203c8:	200074d6 	.word	0x200074d6

080203cc <uip_arp_arpin>:
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
 80203cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  if(uip_len < sizeof(struct arp_hdr)) {
 80203ce:	4d25      	ldr	r5, [pc, #148]	@ (8020464 <uip_arp_arpin+0x98>)
 80203d0:	882b      	ldrh	r3, [r5, #0]
 80203d2:	2700      	movs	r7, #0
 80203d4:	2b29      	cmp	r3, #41	@ 0x29
    uip_len = 0;
 80203d6:	802f      	strh	r7, [r5, #0]
  if(uip_len < sizeof(struct arp_hdr)) {
 80203d8:	d800      	bhi.n	80203dc <uip_arp_arpin+0x10>
    }
    break;
  }

  return;
}
 80203da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch(BUF->opcode) {
 80203dc:	4c22      	ldr	r4, [pc, #136]	@ (8020468 <uip_arp_arpin+0x9c>)
 80203de:	8aa3      	ldrh	r3, [r4, #20]
 80203e0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80203e4:	d00f      	beq.n	8020406 <uip_arp_arpin+0x3a>
 80203e6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 80203ea:	d1f6      	bne.n	80203da <uip_arp_arpin+0xe>
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
 80203ec:	4b1f      	ldr	r3, [pc, #124]	@ (802046c <uip_arp_arpin+0xa0>)
 80203ee:	8ce1      	ldrh	r1, [r4, #38]	@ 0x26
 80203f0:	881a      	ldrh	r2, [r3, #0]
 80203f2:	4291      	cmp	r1, r2
 80203f4:	d1f1      	bne.n	80203da <uip_arp_arpin+0xe>
 80203f6:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 80203f8:	885b      	ldrh	r3, [r3, #2]
 80203fa:	429a      	cmp	r2, r3
 80203fc:	d1ed      	bne.n	80203da <uip_arp_arpin+0xe>
}
 80203fe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
 8020402:	f7ff bf07 	b.w	8020214 <uip_arp_update.constprop.0>
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
 8020406:	4e19      	ldr	r6, [pc, #100]	@ (802046c <uip_arp_arpin+0xa0>)
 8020408:	8ce2      	ldrh	r2, [r4, #38]	@ 0x26
 802040a:	8833      	ldrh	r3, [r6, #0]
 802040c:	429a      	cmp	r2, r3
 802040e:	d1e4      	bne.n	80203da <uip_arp_arpin+0xe>
 8020410:	8d22      	ldrh	r2, [r4, #40]	@ 0x28
 8020412:	8873      	ldrh	r3, [r6, #2]
 8020414:	429a      	cmp	r2, r3
 8020416:	d1e0      	bne.n	80203da <uip_arp_arpin+0xe>
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
 8020418:	f7ff fefc 	bl	8020214 <uip_arp_update.constprop.0>
      BUF->opcode = HTONS(2);
 802041c:	2302      	movs	r3, #2
 802041e:	7563      	strb	r3, [r4, #21]
      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
 8020420:	f8d4 3016 	ldr.w	r3, [r4, #22]
 8020424:	6223      	str	r3, [r4, #32]
 8020426:	8b63      	ldrh	r3, [r4, #26]
 8020428:	84a3      	strh	r3, [r4, #36]	@ 0x24
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 802042a:	4b11      	ldr	r3, [pc, #68]	@ (8020470 <uip_arp_arpin+0xa4>)
      BUF->opcode = HTONS(2);
 802042c:	7527      	strb	r7, [r4, #20]
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 802042e:	681a      	ldr	r2, [r3, #0]
 8020430:	889b      	ldrh	r3, [r3, #4]
 8020432:	8363      	strh	r3, [r4, #26]
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 8020434:	8163      	strh	r3, [r4, #10]
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
 8020436:	6a23      	ldr	r3, [r4, #32]
 8020438:	6023      	str	r3, [r4, #0]
 802043a:	8ca3      	ldrh	r3, [r4, #36]	@ 0x24
 802043c:	80a3      	strh	r3, [r4, #4]
      BUF->dipaddr[0] = BUF->sipaddr[0];
 802043e:	8ba3      	ldrh	r3, [r4, #28]
 8020440:	84e3      	strh	r3, [r4, #38]	@ 0x26
      BUF->dipaddr[1] = BUF->sipaddr[1];
 8020442:	8be3      	ldrh	r3, [r4, #30]
 8020444:	8523      	strh	r3, [r4, #40]	@ 0x28
      BUF->sipaddr[0] = uip_hostaddr[0];
 8020446:	8833      	ldrh	r3, [r6, #0]
 8020448:	83a3      	strh	r3, [r4, #28]
      BUF->sipaddr[1] = uip_hostaddr[1];
 802044a:	8873      	ldrh	r3, [r6, #2]
 802044c:	83e3      	strh	r3, [r4, #30]
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
 802044e:	2308      	movs	r3, #8
 8020450:	7323      	strb	r3, [r4, #12]
 8020452:	2306      	movs	r3, #6
 8020454:	7363      	strb	r3, [r4, #13]
      uip_len = sizeof(struct arp_hdr);
 8020456:	232a      	movs	r3, #42	@ 0x2a
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 8020458:	f8c4 2016 	str.w	r2, [r4, #22]
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 802045c:	f8c4 2006 	str.w	r2, [r4, #6]
      uip_len = sizeof(struct arp_hdr);
 8020460:	802b      	strh	r3, [r5, #0]
 8020462:	e7ba      	b.n	80203da <uip_arp_arpin+0xe>
 8020464:	20006ec0 	.word	0x20006ec0
 8020468:	20006ecc 	.word	0x20006ecc
 802046c:	200074ca 	.word	0x200074ca
 8020470:	200074bc 	.word	0x200074bc

08020474 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
 8020474:	4b3f      	ldr	r3, [pc, #252]	@ (8020574 <uip_arp_out+0x100>)
{
 8020476:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
 8020478:	8c19      	ldrh	r1, [r3, #32]
 802047a:	8bdc      	ldrh	r4, [r3, #30]
 802047c:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8020480:	ea04 0001 	and.w	r0, r4, r1
 8020484:	4290      	cmp	r0, r2
 8020486:	d116      	bne.n	80204b6 <uip_arp_out+0x42>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
 8020488:	4a3b      	ldr	r2, [pc, #236]	@ (8020578 <uip_arp_out+0x104>)
 802048a:	6811      	ldr	r1, [r2, #0]
 802048c:	8892      	ldrh	r2, [r2, #4]
 802048e:	6019      	str	r1, [r3, #0]
      uip_len = sizeof(struct arp_hdr);
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
 8020490:	809a      	strh	r2, [r3, #4]
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 8020492:	4a3a      	ldr	r2, [pc, #232]	@ (802057c <uip_arp_out+0x108>)
 8020494:	6811      	ldr	r1, [r2, #0]
 8020496:	f8c3 1006 	str.w	r1, [r3, #6]
 802049a:	8891      	ldrh	r1, [r2, #4]
 802049c:	4a38      	ldr	r2, [pc, #224]	@ (8020580 <uip_arp_out+0x10c>)
 802049e:	8091      	strh	r1, [r2, #4]
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
 80204a0:	2208      	movs	r2, #8
 80204a2:	731a      	strb	r2, [r3, #12]
 80204a4:	2200      	movs	r2, #0
 80204a6:	735a      	strb	r2, [r3, #13]

  uip_len += sizeof(struct uip_eth_hdr);
 80204a8:	4b36      	ldr	r3, [pc, #216]	@ (8020584 <uip_arp_out+0x110>)
 80204aa:	881b      	ldrh	r3, [r3, #0]
 80204ac:	330e      	adds	r3, #14
 80204ae:	b29b      	uxth	r3, r3
      uip_len = sizeof(struct arp_hdr);
 80204b0:	4a34      	ldr	r2, [pc, #208]	@ (8020584 <uip_arp_out+0x110>)
 80204b2:	8013      	strh	r3, [r2, #0]
}
 80204b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
 80204b6:	4a34      	ldr	r2, [pc, #208]	@ (8020588 <uip_arp_out+0x114>)
 80204b8:	4f34      	ldr	r7, [pc, #208]	@ (802058c <uip_arp_out+0x118>)
 80204ba:	8816      	ldrh	r6, [r2, #0]
 80204bc:	8838      	ldrh	r0, [r7, #0]
 80204be:	8855      	ldrh	r5, [r2, #2]
 80204c0:	887f      	ldrh	r7, [r7, #2]
 80204c2:	ea84 0206 	eor.w	r2, r4, r6
 80204c6:	4002      	ands	r2, r0
 80204c8:	ea81 0005 	eor.w	r0, r1, r5
 80204cc:	4038      	ands	r0, r7
 80204ce:	4302      	orrs	r2, r0
      uip_ipaddr_copy(ipaddr, uip_draddr);
 80204d0:	bf18      	it	ne
 80204d2:	4a2f      	ldrne	r2, [pc, #188]	@ (8020590 <uip_arp_out+0x11c>)
 80204d4:	482f      	ldr	r0, [pc, #188]	@ (8020594 <uip_arp_out+0x120>)
 80204d6:	bf1b      	ittet	ne
 80204d8:	8811      	ldrhne	r1, [r2, #0]
 80204da:	8001      	strhne	r1, [r0, #0]
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
 80204dc:	8004      	strheq	r4, [r0, #0]
      uip_ipaddr_copy(ipaddr, uip_draddr);
 80204de:	8851      	ldrhne	r1, [r2, #2]
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 80204e0:	4c2d      	ldr	r4, [pc, #180]	@ (8020598 <uip_arp_out+0x124>)
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
 80204e2:	f8b0 c000 	ldrh.w	ip, [r0]
      uip_ipaddr_copy(ipaddr, uip_draddr);
 80204e6:	8041      	strh	r1, [r0, #2]
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 80204e8:	2200      	movs	r2, #0
 80204ea:	482c      	ldr	r0, [pc, #176]	@ (802059c <uip_arp_out+0x128>)
 80204ec:	7022      	strb	r2, [r4, #0]
 80204ee:	4617      	mov	r7, r2
 80204f0:	2a08      	cmp	r2, #8
 80204f2:	d12c      	bne.n	802054e <uip_arp_out+0xda>
 80204f4:	b107      	cbz	r7, 80204f8 <uip_arp_out+0x84>
 80204f6:	7022      	strb	r2, [r4, #0]
      memset(BUF->ethhdr.dest.addr, 0xff, 6);
 80204f8:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
 80204fc:	601a      	str	r2, [r3, #0]
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 80204fe:	4c1f      	ldr	r4, [pc, #124]	@ (802057c <uip_arp_out+0x108>)
      memset(BUF->ethhdr.dest.addr, 0xff, 6);
 8020500:	809a      	strh	r2, [r3, #4]
      memset(BUF->dhwaddr.addr, 0x00, 6);
 8020502:	4a27      	ldr	r2, [pc, #156]	@ (80205a0 <uip_arp_out+0x12c>)
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 8020504:	6827      	ldr	r7, [r4, #0]
 8020506:	88a4      	ldrh	r4, [r4, #4]
 8020508:	f8c3 7006 	str.w	r7, [r3, #6]
      memset(BUF->dhwaddr.addr, 0x00, 6);
 802050c:	2000      	movs	r0, #0
 802050e:	6218      	str	r0, [r3, #32]
 8020510:	8090      	strh	r0, [r2, #4]
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
 8020512:	8519      	strh	r1, [r3, #40]	@ 0x28
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
 8020514:	2101      	movs	r1, #1
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
 8020516:	f822 4c16 	strh.w	r4, [r2, #-22]
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 802051a:	f8c3 7016 	str.w	r7, [r3, #22]
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
 802051e:	7518      	strb	r0, [r3, #20]
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
 8020520:	f822 4c06 	strh.w	r4, [r2, #-6]
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
 8020524:	7559      	strb	r1, [r3, #21]
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
 8020526:	7398      	strb	r0, [r3, #14]
 8020528:	73d9      	strb	r1, [r3, #15]
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
 802052a:	2408      	movs	r4, #8
 802052c:	7458      	strb	r0, [r3, #17]
      BUF->hwlen = 6;
 802052e:	2106      	movs	r1, #6
      BUF->protolen = 4;
 8020530:	2004      	movs	r0, #4
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
 8020532:	f8a3 c026 	strh.w	ip, [r3, #38]	@ 0x26
      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
 8020536:	839e      	strh	r6, [r3, #28]
 8020538:	83dd      	strh	r5, [r3, #30]
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
 802053a:	741c      	strb	r4, [r3, #16]
      BUF->hwlen = 6;
 802053c:	7499      	strb	r1, [r3, #18]
      BUF->protolen = 4;
 802053e:	74d8      	strb	r0, [r3, #19]
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
 8020540:	731c      	strb	r4, [r3, #12]
 8020542:	7359      	strb	r1, [r3, #13]
      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
 8020544:	4b17      	ldr	r3, [pc, #92]	@ (80205a4 <uip_arp_out+0x130>)
 8020546:	3216      	adds	r2, #22
 8020548:	601a      	str	r2, [r3, #0]
      return;
 802054a:	232a      	movs	r3, #42	@ 0x2a
 802054c:	e7b0      	b.n	80204b0 <uip_arp_out+0x3c>
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
 802054e:	f8b0 e000 	ldrh.w	lr, [r0]
 8020552:	45e6      	cmp	lr, ip
 8020554:	d109      	bne.n	802056a <uip_arp_out+0xf6>
 8020556:	f8b0 e002 	ldrh.w	lr, [r0, #2]
 802055a:	458e      	cmp	lr, r1
 802055c:	d105      	bne.n	802056a <uip_arp_out+0xf6>
 802055e:	b107      	cbz	r7, 8020562 <uip_arp_out+0xee>
 8020560:	7022      	strb	r2, [r4, #0]
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
 8020562:	6842      	ldr	r2, [r0, #4]
 8020564:	601a      	str	r2, [r3, #0]
 8020566:	8902      	ldrh	r2, [r0, #8]
 8020568:	e792      	b.n	8020490 <uip_arp_out+0x1c>
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
 802056a:	3201      	adds	r2, #1
 802056c:	300c      	adds	r0, #12
 802056e:	2701      	movs	r7, #1
 8020570:	e7be      	b.n	80204f0 <uip_arp_out+0x7c>
 8020572:	bf00      	nop
 8020574:	20006ecc 	.word	0x20006ecc
 8020578:	08028166 	.word	0x08028166
 802057c:	200074bc 	.word	0x200074bc
 8020580:	20006ed2 	.word	0x20006ed2
 8020584:	20006ec0 	.word	0x20006ec0
 8020588:	200074ca 	.word	0x200074ca
 802058c:	200074c2 	.word	0x200074c2
 8020590:	200074c6 	.word	0x200074c6
 8020594:	200074d2 	.word	0x200074d2
 8020598:	200074d1 	.word	0x200074d1
 802059c:	200074d6 	.word	0x200074d6
 80205a0:	20006eec 	.word	0x20006eec
 80205a4:	20006ec8 	.word	0x20006ec8

080205a8 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
 80205a8:	b510      	push	{r4, lr}
  t->interval = interval;
 80205aa:	6041      	str	r1, [r0, #4]
{
 80205ac:	4604      	mov	r4, r0
  t->start = clock_time();
 80205ae:	f000 f81b 	bl	80205e8 <clock_time>
 80205b2:	6020      	str	r0, [r4, #0]
}
 80205b4:	bd10      	pop	{r4, pc}

080205b6 <timer_reset>:
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
  t->start += t->interval;
 80205b6:	e9d0 3200 	ldrd	r3, r2, [r0]
 80205ba:	4413      	add	r3, r2
 80205bc:	6003      	str	r3, [r0, #0]
}
 80205be:	4770      	bx	lr

080205c0 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
 80205c0:	b510      	push	{r4, lr}
 80205c2:	4604      	mov	r4, r0
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
 80205c4:	f000 f810 	bl	80205e8 <clock_time>
 80205c8:	6823      	ldr	r3, [r4, #0]
 80205ca:	1ac0      	subs	r0, r0, r3
 80205cc:	6863      	ldr	r3, [r4, #4]
}
 80205ce:	4298      	cmp	r0, r3
 80205d0:	bf34      	ite	cc
 80205d2:	2000      	movcc	r0, #0
 80205d4:	2001      	movcs	r0, #1
 80205d6:	bd10      	pop	{r4, pc}

080205d8 <clock_time_tick>:

// TMP
// has to be called each mS
clock_time_t clock_time_tick(void)
{
  return ++clock;
 80205d8:	4b02      	ldr	r3, [pc, #8]	@ (80205e4 <clock_time_tick+0xc>)
 80205da:	6818      	ldr	r0, [r3, #0]
 80205dc:	3001      	adds	r0, #1
 80205de:	6018      	str	r0, [r3, #0]
}
 80205e0:	4770      	bx	lr
 80205e2:	bf00      	nop
 80205e4:	20007538 	.word	0x20007538

080205e8 <clock_time>:
/*---------------------------------------------------------------------------*/
clock_time_t
clock_time(void)
{
  return clock; // TODO - take value from RTC
}
 80205e8:	4b01      	ldr	r3, [pc, #4]	@ (80205f0 <clock_time+0x8>)
 80205ea:	6818      	ldr	r0, [r3, #0]
 80205ec:	4770      	bx	lr
 80205ee:	bf00      	nop
 80205f0:	20007538 	.word	0x20007538

080205f4 <network_device_init>:
/////////////////////////////////////////////////////////////////////////////
// Network Device Functions
/////////////////////////////////////////////////////////////////////////////

void network_device_init(void)
{
 80205f4:	b508      	push	{r3, lr}
  s32 status;

  status = MIOS32_ENC28J60_Init(0);
 80205f6:	2000      	movs	r0, #0
 80205f8:	f7f5 fdde 	bl	80161b8 <MIOS32_ENC28J60_Init>
  netdev_available = (status >= 0);
 80205fc:	4b02      	ldr	r3, [pc, #8]	@ (8020608 <network_device_init+0x14>)
 80205fe:	43c0      	mvns	r0, r0
 8020600:	0fc0      	lsrs	r0, r0, #31
 8020602:	7018      	strb	r0, [r3, #0]
#if DEBUG_VERBOSE_LEVEL >= 1
  MIOS32_MIDI_SendDebugMessage("[network_device_init] status %d, available: %d\n", status, netdev_available);
  if( status >= 0 )
    MIOS32_MIDI_SendDebugMessage("[network_device_init] ENC28J60 RevID: 0x%02x\n", MIOS32_ENC28J60_RevIDGet());
#endif
}
 8020604:	bd08      	pop	{r3, pc}
 8020606:	bf00      	nop
 8020608:	2000753c 	.word	0x2000753c

0802060c <network_device_available>:
}

int network_device_available(void)
{
  return netdev_available;
}
 802060c:	4b01      	ldr	r3, [pc, #4]	@ (8020614 <network_device_available+0x8>)
 802060e:	7818      	ldrb	r0, [r3, #0]
 8020610:	4770      	bx	lr
 8020612:	bf00      	nop
 8020614:	2000753c 	.word	0x2000753c

08020618 <network_device_read>:

int network_device_read(void)
{
 8020618:	b508      	push	{r3, lr}
  s32 status;

  if( (status=MIOS32_ENC28J60_PackageReceive((u8 *)uip_buf, UIP_BUFSIZE)) < 0 ) {
 802061a:	f240 51ee 	movw	r1, #1518	@ 0x5ee
 802061e:	4804      	ldr	r0, [pc, #16]	@ (8020630 <network_device_read+0x18>)
 8020620:	f7f5 fde2 	bl	80161e8 <MIOS32_ENC28J60_PackageReceive>
 8020624:	2800      	cmp	r0, #0
    netdev_available = 0;
 8020626:	bfbe      	ittt	lt
 8020628:	4b02      	ldrlt	r3, [pc, #8]	@ (8020634 <network_device_read+0x1c>)
 802062a:	2000      	movlt	r0, #0
 802062c:	7018      	strblt	r0, [r3, #0]
    MIOS32_MIDI_SendDebugHexDump((u8 *)uip_buf, status);
  }
#endif

  return status;
}
 802062e:	bd08      	pop	{r3, pc}
 8020630:	20006ecc 	.word	0x20006ecc
 8020634:	2000753c 	.word	0x2000753c

08020638 <network_device_send>:

void network_device_send(void)
{
 8020638:	b508      	push	{r3, lr}
  u16 header_len = UIP_LLH_LEN + UIP_TCPIP_HLEN;
  s32 status = MIOS32_ENC28J60_PackageSend((u8 *)uip_buf, (uip_len >= header_len) ? header_len : uip_len,
 802063a:	4b0b      	ldr	r3, [pc, #44]	@ (8020668 <network_device_send+0x30>)
 802063c:	4a0b      	ldr	r2, [pc, #44]	@ (802066c <network_device_send+0x34>)
 802063e:	8819      	ldrh	r1, [r3, #0]
 8020640:	6812      	ldr	r2, [r2, #0]
 8020642:	480b      	ldr	r0, [pc, #44]	@ (8020670 <network_device_send+0x38>)
 8020644:	2936      	cmp	r1, #54	@ 0x36
 8020646:	460b      	mov	r3, r1
 8020648:	bf38      	it	cc
 802064a:	2336      	movcc	r3, #54	@ 0x36
 802064c:	3b36      	subs	r3, #54	@ 0x36
 802064e:	2936      	cmp	r1, #54	@ 0x36
 8020650:	b29b      	uxth	r3, r3
 8020652:	bf28      	it	cs
 8020654:	2136      	movcs	r1, #54	@ 0x36
 8020656:	f7f5 fe71 	bl	801633c <MIOS32_ENC28J60_PackageSend>
					   (u8 *)uip_appdata, (uip_len > header_len) ? (uip_len-header_len) : 0);

  if( status < 0 ) {
 802065a:	2800      	cmp	r0, #0
    netdev_available = 0;
 802065c:	bfbe      	ittt	lt
 802065e:	4b05      	ldrlt	r3, [pc, #20]	@ (8020674 <network_device_send+0x3c>)
 8020660:	2200      	movlt	r2, #0
 8020662:	701a      	strblt	r2, [r3, #0]
    if( status ) {
      MIOS32_MIDI_SendDebugMessage("[network_device_send] sent %d bytes\n", uip_len);
    }
#endif
  }
}
 8020664:	bd08      	pop	{r3, pc}
 8020666:	bf00      	nop
 8020668:	20006ec0 	.word	0x20006ec0
 802066c:	20006ec8 	.word	0x20006ec8
 8020670:	20006ecc 	.word	0x20006ecc
 8020674:	2000753c 	.word	0x2000753c

08020678 <network_device_mac_addr>:


unsigned char *network_device_mac_addr(void)
{
  return (unsigned char *)MIOS32_ENC28J60_MAC_AddrGet();
 8020678:	f7f5 bb12 	b.w	8015ca0 <MIOS32_ENC28J60_MAC_AddrGet>

0802067c <UIP_TASK_SendDebugMessage_IP.isra.0>:
// Prints current IP settings
/////////////////////////////////////////////////////////////////////////////
static s32 UIP_TASK_SendDebugMessage_IP(void)
{
  uip_ipaddr_t ipaddr;
  uip_gethostaddr(&ipaddr);
 802067c:	4b2b      	ldr	r3, [pc, #172]	@ (802072c <UIP_TASK_SendDebugMessage_IP.isra.0+0xb0>)
static s32 UIP_TASK_SendDebugMessage_IP(void)
 802067e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uip_gethostaddr(&ipaddr);
 8020680:	881d      	ldrh	r5, [r3, #0]
 8020682:	885f      	ldrh	r7, [r3, #2]

#if DEBUG_VERBOSE_LEVEL >= 1
  UIP_TASK_MUTEX_MIDIOUT_TAKE;
  DEBUG_MSG("[UIP_TASK] IP address: %d.%d.%d.%d\n",
	    uip_ipaddr1(ipaddr), uip_ipaddr2(ipaddr),
 8020684:	4628      	mov	r0, r5
 8020686:	f7ff fdaf 	bl	80201e8 <htons>
 802068a:	4604      	mov	r4, r0
 802068c:	4628      	mov	r0, r5
 802068e:	f7ff fdab 	bl	80201e8 <htons>
 8020692:	4605      	mov	r5, r0
	    uip_ipaddr3(ipaddr), uip_ipaddr4(ipaddr));
 8020694:	4638      	mov	r0, r7
 8020696:	f7ff fda7 	bl	80201e8 <htons>
 802069a:	4606      	mov	r6, r0
 802069c:	4638      	mov	r0, r7
 802069e:	f7ff fda3 	bl	80201e8 <htons>
  DEBUG_MSG("[UIP_TASK] IP address: %d.%d.%d.%d\n",
 80206a2:	b2c0      	uxtb	r0, r0
 80206a4:	b2ea      	uxtb	r2, r5
 80206a6:	f3c4 210f 	ubfx	r1, r4, #8, #16
 80206aa:	9000      	str	r0, [sp, #0]
 80206ac:	f3c6 230f 	ubfx	r3, r6, #8, #16
 80206b0:	481f      	ldr	r0, [pc, #124]	@ (8020730 <UIP_TASK_SendDebugMessage_IP.isra.0+0xb4>)
 80206b2:	f7f4 fa99 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>

  uip_ipaddr_t netmask;
  uip_getnetmask(&netmask);
 80206b6:	4b1f      	ldr	r3, [pc, #124]	@ (8020734 <UIP_TASK_SendDebugMessage_IP.isra.0+0xb8>)
 80206b8:	881d      	ldrh	r5, [r3, #0]
 80206ba:	885f      	ldrh	r7, [r3, #2]
  DEBUG_MSG("[UIP_TASK] Netmask: %d.%d.%d.%d\n",
	    uip_ipaddr1(netmask), uip_ipaddr2(netmask),
 80206bc:	4628      	mov	r0, r5
 80206be:	f7ff fd93 	bl	80201e8 <htons>
 80206c2:	4604      	mov	r4, r0
 80206c4:	4628      	mov	r0, r5
 80206c6:	f7ff fd8f 	bl	80201e8 <htons>
 80206ca:	4605      	mov	r5, r0
	    uip_ipaddr3(netmask), uip_ipaddr4(netmask));
 80206cc:	4638      	mov	r0, r7
 80206ce:	f7ff fd8b 	bl	80201e8 <htons>
 80206d2:	4606      	mov	r6, r0
 80206d4:	4638      	mov	r0, r7
 80206d6:	f7ff fd87 	bl	80201e8 <htons>
  DEBUG_MSG("[UIP_TASK] Netmask: %d.%d.%d.%d\n",
 80206da:	b2c0      	uxtb	r0, r0
 80206dc:	b2ea      	uxtb	r2, r5
 80206de:	f3c4 210f 	ubfx	r1, r4, #8, #16
 80206e2:	9000      	str	r0, [sp, #0]
 80206e4:	f3c6 230f 	ubfx	r3, r6, #8, #16
 80206e8:	4813      	ldr	r0, [pc, #76]	@ (8020738 <UIP_TASK_SendDebugMessage_IP.isra.0+0xbc>)
 80206ea:	f7f4 fa7d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>

  uip_ipaddr_t draddr;
  uip_getdraddr(&draddr);
 80206ee:	4b13      	ldr	r3, [pc, #76]	@ (802073c <UIP_TASK_SendDebugMessage_IP.isra.0+0xc0>)
 80206f0:	881d      	ldrh	r5, [r3, #0]
 80206f2:	885f      	ldrh	r7, [r3, #2]
  DEBUG_MSG("[UIP_TASK] Default Router (Gateway): %d.%d.%d.%d\n",
	    uip_ipaddr1(draddr), uip_ipaddr2(draddr),
 80206f4:	4628      	mov	r0, r5
 80206f6:	f7ff fd77 	bl	80201e8 <htons>
 80206fa:	4604      	mov	r4, r0
 80206fc:	4628      	mov	r0, r5
 80206fe:	f7ff fd73 	bl	80201e8 <htons>
 8020702:	4605      	mov	r5, r0
	    uip_ipaddr3(draddr), uip_ipaddr4(draddr));
 8020704:	4638      	mov	r0, r7
 8020706:	f7ff fd6f 	bl	80201e8 <htons>
 802070a:	4606      	mov	r6, r0
 802070c:	4638      	mov	r0, r7
 802070e:	f7ff fd6b 	bl	80201e8 <htons>
  DEBUG_MSG("[UIP_TASK] Default Router (Gateway): %d.%d.%d.%d\n",
 8020712:	b2c0      	uxtb	r0, r0
 8020714:	9000      	str	r0, [sp, #0]
 8020716:	f3c6 230f 	ubfx	r3, r6, #8, #16
 802071a:	b2ea      	uxtb	r2, r5
 802071c:	f3c4 210f 	ubfx	r1, r4, #8, #16
 8020720:	4807      	ldr	r0, [pc, #28]	@ (8020740 <UIP_TASK_SendDebugMessage_IP.isra.0+0xc4>)
 8020722:	f7f4 fa61 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  UIP_TASK_MUTEX_MIDIOUT_GIVE;
#endif

  return 0; // no error
}
 8020726:	b003      	add	sp, #12
 8020728:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802072a:	bf00      	nop
 802072c:	200074ca 	.word	0x200074ca
 8020730:	0802816d 	.word	0x0802816d
 8020734:	200074c2 	.word	0x200074c2
 8020738:	08028191 	.word	0x08028191
 802073c:	200074c6 	.word	0x200074c6
 8020740:	080281b2 	.word	0x080281b2

08020744 <UIP_TASK_Init>:
{
 8020744:	b513      	push	{r0, r1, r4, lr}
  if( mode > 0 )
 8020746:	4604      	mov	r4, r0
 8020748:	b9b8      	cbnz	r0, 802077a <UIP_TASK_Init+0x36>
  OSC_CLIENT_Init(0);
 802074a:	f000 ffcf 	bl	80216ec <OSC_CLIENT_Init>
  xUIPSemaphore = xSemaphoreCreateRecursiveMutex();
 802074e:	2004      	movs	r0, #4
 8020750:	f7f3 fadb 	bl	8013d0a <xQueueCreateMutex>
 8020754:	4b0a      	ldr	r3, [pc, #40]	@ (8020780 <UIP_TASK_Init+0x3c>)
  xTaskCreate(UIP_TASK_Handler, "uIP", UIP_TASK_STACK_SIZE/4, NULL, PRIORITY_TASK_UIP, NULL);
 8020756:	490b      	ldr	r1, [pc, #44]	@ (8020784 <UIP_TASK_Init+0x40>)
  xUIPSemaphore = xSemaphoreCreateRecursiveMutex();
 8020758:	6018      	str	r0, [r3, #0]
  xTaskCreate(UIP_TASK_Handler, "uIP", UIP_TASK_STACK_SIZE/4, NULL, PRIORITY_TASK_UIP, NULL);
 802075a:	2303      	movs	r3, #3
 802075c:	9300      	str	r3, [sp, #0]
 802075e:	480a      	ldr	r0, [pc, #40]	@ (8020788 <UIP_TASK_Init+0x44>)
 8020760:	9401      	str	r4, [sp, #4]
 8020762:	4623      	mov	r3, r4
 8020764:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8020768:	f7f2 fd82 	bl	8013270 <xTaskCreate>
  services_running = 0;
 802076c:	4b07      	ldr	r3, [pc, #28]	@ (802078c <UIP_TASK_Init+0x48>)
 802076e:	701c      	strb	r4, [r3, #0]
  udp_monitor_level = UDP_MONITOR_LEVEL_0_OFF;
 8020770:	4b07      	ldr	r3, [pc, #28]	@ (8020790 <UIP_TASK_Init+0x4c>)
  return 0; // no error
 8020772:	4620      	mov	r0, r4
  udp_monitor_level = UDP_MONITOR_LEVEL_0_OFF;
 8020774:	701c      	strb	r4, [r3, #0]
}
 8020776:	b002      	add	sp, #8
 8020778:	bd10      	pop	{r4, pc}
    return -1; // only mode 0 supported yet
 802077a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 802077e:	e7fa      	b.n	8020776 <UIP_TASK_Init+0x32>
 8020780:	20007540 	.word	0x20007540
 8020784:	080281e4 	.word	0x080281e4
 8020788:	0802087d 	.word	0x0802087d
 802078c:	2000753e 	.word	0x2000753e
 8020790:	2000753d 	.word	0x2000753d

08020794 <UIP_TASK_InitFromPresets>:
{
 8020794:	b510      	push	{r4, lr}
  dhcp_enabled = _dhcp_enabled;
 8020796:	4c05      	ldr	r4, [pc, #20]	@ (80207ac <UIP_TASK_InitFromPresets+0x18>)
 8020798:	7020      	strb	r0, [r4, #0]
  my_ip_address = _my_ip_address;
 802079a:	4805      	ldr	r0, [pc, #20]	@ (80207b0 <UIP_TASK_InitFromPresets+0x1c>)
 802079c:	6001      	str	r1, [r0, #0]
  my_netmask = _my_netmask;
 802079e:	4905      	ldr	r1, [pc, #20]	@ (80207b4 <UIP_TASK_InitFromPresets+0x20>)
 80207a0:	600a      	str	r2, [r1, #0]
  my_gateway = _my_gateway;
 80207a2:	4a05      	ldr	r2, [pc, #20]	@ (80207b8 <UIP_TASK_InitFromPresets+0x24>)
}
 80207a4:	2000      	movs	r0, #0
  my_gateway = _my_gateway;
 80207a6:	6013      	str	r3, [r2, #0]
}
 80207a8:	bd10      	pop	{r4, pc}
 80207aa:	bf00      	nop
 80207ac:	200000ac 	.word	0x200000ac
 80207b0:	200000a8 	.word	0x200000a8
 80207b4:	200000a4 	.word	0x200000a4
 80207b8:	200000a0 	.word	0x200000a0

080207bc <uip_log>:
}
 80207bc:	4770      	bx	lr

080207be <UIP_TASK_AppCall>:
}
 80207be:	2000      	movs	r0, #0
 80207c0:	4770      	bx	lr
	...

080207c4 <UIP_TASK_DHCP_EnableSet>:
/////////////////////////////////////////////////////////////////////////////
s32 UIP_TASK_DHCP_EnableSet(u8 _dhcp_enabled)
{
  uip_ipaddr_t ipaddr;

  dhcp_enabled = _dhcp_enabled;
 80207c4:	4b22      	ldr	r3, [pc, #136]	@ (8020850 <UIP_TASK_DHCP_EnableSet+0x8c>)
 80207c6:	4923      	ldr	r1, [pc, #140]	@ (8020854 <UIP_TASK_DHCP_EnableSet+0x90>)
 80207c8:	4a23      	ldr	r2, [pc, #140]	@ (8020858 <UIP_TASK_DHCP_EnableSet+0x94>)
{
 80207ca:	b570      	push	{r4, r5, r6, lr}
 80207cc:	4d23      	ldr	r5, [pc, #140]	@ (802085c <UIP_TASK_DHCP_EnableSet+0x98>)
 80207ce:	4c24      	ldr	r4, [pc, #144]	@ (8020860 <UIP_TASK_DHCP_EnableSet+0x9c>)
  dhcp_enabled = _dhcp_enabled;
 80207d0:	7018      	strb	r0, [r3, #0]

  // branch depending on DHCP mode
  if( dhcp_enabled ) {
 80207d2:	b198      	cbz	r0, 80207fc <UIP_TASK_DHCP_EnableSet+0x38>
// stop services
/////////////////////////////////////////////////////////////////////////////
static s32 UIP_TASK_StopServices(void)
{
  // stop all services
  services_running = 0;
 80207d4:	2300      	movs	r3, #0
    uip_setnetmask(ipaddr);
 80207d6:	800b      	strh	r3, [r1, #0]
 80207d8:	804b      	strh	r3, [r1, #2]
    dhcpc_init(uip_ethaddr.addr, sizeof(uip_ethaddr.addr));
 80207da:	4822      	ldr	r0, [pc, #136]	@ (8020864 <UIP_TASK_DHCP_EnableSet+0xa0>)
  services_running = 0;
 80207dc:	702b      	strb	r3, [r5, #0]
    dhcpc_init(uip_ethaddr.addr, sizeof(uip_ethaddr.addr));
 80207de:	2106      	movs	r1, #6
    uip_sethostaddr(ipaddr);
 80207e0:	8023      	strh	r3, [r4, #0]
 80207e2:	8063      	strh	r3, [r4, #2]
    uip_setdraddr(ipaddr);
 80207e4:	8013      	strh	r3, [r2, #0]
 80207e6:	8053      	strh	r3, [r2, #2]
    dhcpc_init(uip_ethaddr.addr, sizeof(uip_ethaddr.addr));
 80207e8:	f000 faaa 	bl	8020d40 <dhcpc_init>
    if( network_device_available() ) { // don't print message if ethernet device is not available, the message could confuse "normal users"
 80207ec:	f7ff ff0e 	bl	802060c <network_device_available>
 80207f0:	b110      	cbz	r0, 80207f8 <UIP_TASK_DHCP_EnableSet+0x34>
      DEBUG_MSG("[UIP_TASK] DHCP Client requests the IP settings...\n");
 80207f2:	481d      	ldr	r0, [pc, #116]	@ (8020868 <UIP_TASK_DHCP_EnableSet+0xa4>)
 80207f4:	f7f4 f9f8 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
}
 80207f8:	2000      	movs	r0, #0
 80207fa:	bd70      	pop	{r4, r5, r6, pc}
    uip_ipaddr(ipaddr,
 80207fc:	4b1b      	ldr	r3, [pc, #108]	@ (802086c <UIP_TASK_DHCP_EnableSet+0xa8>)
 80207fe:	885e      	ldrh	r6, [r3, #2]
 8020800:	881b      	ldrh	r3, [r3, #0]
 8020802:	ba5b      	rev16	r3, r3
    uip_sethostaddr(ipaddr);
 8020804:	8063      	strh	r3, [r4, #2]
    uip_ipaddr(ipaddr,
 8020806:	0230      	lsls	r0, r6, #8
    uip_ipaddr(ipaddr,
 8020808:	4b19      	ldr	r3, [pc, #100]	@ (8020870 <UIP_TASK_DHCP_EnableSet+0xac>)
    uip_ipaddr(ipaddr,
 802080a:	ea40 2016 	orr.w	r0, r0, r6, lsr #8
    uip_sethostaddr(ipaddr);
 802080e:	8020      	strh	r0, [r4, #0]
    uip_ipaddr(ipaddr,
 8020810:	885c      	ldrh	r4, [r3, #2]
 8020812:	881b      	ldrh	r3, [r3, #0]
 8020814:	ba5b      	rev16	r3, r3
    uip_setnetmask(ipaddr);
 8020816:	804b      	strh	r3, [r1, #2]
    uip_ipaddr(ipaddr,
 8020818:	0220      	lsls	r0, r4, #8
    uip_ipaddr(ipaddr,
 802081a:	4b16      	ldr	r3, [pc, #88]	@ (8020874 <UIP_TASK_DHCP_EnableSet+0xb0>)
    uip_ipaddr(ipaddr,
 802081c:	ea40 2014 	orr.w	r0, r0, r4, lsr #8
    uip_setnetmask(ipaddr);
 8020820:	8008      	strh	r0, [r1, #0]
    uip_ipaddr(ipaddr,
 8020822:	8858      	ldrh	r0, [r3, #2]
 8020824:	881b      	ldrh	r3, [r3, #0]
 8020826:	0201      	lsls	r1, r0, #8
 8020828:	ba5b      	rev16	r3, r3
 802082a:	ea41 2110 	orr.w	r1, r1, r0, lsr #8
    uip_setdraddr(ipaddr);
 802082e:	8011      	strh	r1, [r2, #0]
 8020830:	8053      	strh	r3, [r2, #2]
    if( network_device_available() ) { // don't print message if ethernet device is not available, the message could confuse "normal users"
 8020832:	f7ff feeb 	bl	802060c <network_device_available>
 8020836:	b110      	cbz	r0, 802083e <UIP_TASK_DHCP_EnableSet+0x7a>
      DEBUG_MSG("[UIP_TASK] IP Address statically set:\n");
 8020838:	480f      	ldr	r0, [pc, #60]	@ (8020878 <UIP_TASK_DHCP_EnableSet+0xb4>)
 802083a:	f7f4 f9d5 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  UIP_TASK_SendDebugMessage_IP();
 802083e:	f7ff ff1d 	bl	802067c <UIP_TASK_SendDebugMessage_IP.isra.0>
  OSC_SERVER_Init(0);
 8020842:	2000      	movs	r0, #0
 8020844:	f000 fdf2 	bl	802142c <OSC_SERVER_Init>
  services_running = 1;
 8020848:	2301      	movs	r3, #1
 802084a:	702b      	strb	r3, [r5, #0]
  return 0; // no error
 802084c:	e7d4      	b.n	80207f8 <UIP_TASK_DHCP_EnableSet+0x34>
 802084e:	bf00      	nop
 8020850:	200000ac 	.word	0x200000ac
 8020854:	200074c2 	.word	0x200074c2
 8020858:	200074c6 	.word	0x200074c6
 802085c:	2000753e 	.word	0x2000753e
 8020860:	200074ca 	.word	0x200074ca
 8020864:	200074bc 	.word	0x200074bc
 8020868:	080281e8 	.word	0x080281e8
 802086c:	200000a8 	.word	0x200000a8
 8020870:	200000a4 	.word	0x200000a4
 8020874:	200000a0 	.word	0x200000a0
 8020878:	0802821c 	.word	0x0802821c

0802087c <UIP_TASK_Handler>:
{
 802087c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  MUTEX_UIP_TAKE;
 8020880:	4e4b      	ldr	r6, [pc, #300]	@ (80209b0 <UIP_TASK_Handler+0x134>)
{
 8020882:	b086      	sub	sp, #24
  MUTEX_UIP_TAKE;
 8020884:	6830      	ldr	r0, [r6, #0]
 8020886:	2101      	movs	r1, #1
 8020888:	f7f3 fb02 	bl	8013e90 <xQueueTakeMutexRecursive>
 802088c:	2801      	cmp	r0, #1
 802088e:	d1f9      	bne.n	8020884 <UIP_TASK_Handler+0x8>
  timer_set(&periodic_timer, CLOCK_SECOND / 2);
 8020890:	f44f 71fa 	mov.w	r1, #500	@ 0x1f4
 8020894:	a802      	add	r0, sp, #8
 8020896:	f7ff fe87 	bl	80205a8 <timer_set>
  timer_set(&arp_timer, CLOCK_SECOND * 10);
 802089a:	f242 7110 	movw	r1, #10000	@ 0x2710
 802089e:	a804      	add	r0, sp, #16
 80208a0:	f7ff fe82 	bl	80205a8 <timer_set>
  network_device_init();
 80208a4:	f7ff fea6 	bl	80205f4 <network_device_init>
  uip_init();
 80208a8:	f7fe fe3c 	bl	801f524 <uip_init>
  uip_arp_init();
 80208ac:	f7ff fd50 	bl	8020350 <uip_arp_init>
  unsigned char *mac_addr = network_device_mac_addr();
 80208b0:	f7ff fee2 	bl	8020678 <network_device_mac_addr>
    for(i=0; i<6; ++i)
 80208b4:	4a3f      	ldr	r2, [pc, #252]	@ (80209b4 <UIP_TASK_Handler+0x138>)
 80208b6:	1e43      	subs	r3, r0, #1
 80208b8:	3005      	adds	r0, #5
      uip_ethaddr.addr[i] = mac_addr[i];
 80208ba:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 80208be:	f802 1b01 	strb.w	r1, [r2], #1
    for(i=0; i<6; ++i)
 80208c2:	4283      	cmp	r3, r0
 80208c4:	d1f9      	bne.n	80208ba <UIP_TASK_Handler+0x3e>
  UIP_TASK_DHCP_EnableSet(dhcp_enabled);
 80208c6:	4b3c      	ldr	r3, [pc, #240]	@ (80209b8 <UIP_TASK_Handler+0x13c>)
      uip_len = network_device_read();
 80208c8:	4d3c      	ldr	r5, [pc, #240]	@ (80209bc <UIP_TASK_Handler+0x140>)
  UIP_TASK_DHCP_EnableSet(dhcp_enabled);
 80208ca:	7818      	ldrb	r0, [r3, #0]
 80208cc:	f7ff ff7a 	bl	80207c4 <UIP_TASK_DHCP_EnableSet>
  MUTEX_UIP_GIVE;
 80208d0:	6830      	ldr	r0, [r6, #0]
 80208d2:	f7f3 fa2c 	bl	8013d2e <xQueueGiveMutexRecursive>
  portTickType xLastExecutionTime = xTaskGetTickCount();
 80208d6:	f7f2 fddb 	bl	8013490 <xTaskGetTickCount>
 80208da:	9001      	str	r0, [sp, #4]
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 80208dc:	2101      	movs	r1, #1
 80208de:	a801      	add	r0, sp, #4
 80208e0:	f7f2 fedc 	bl	801369c <vTaskDelayUntil>
    MUTEX_UIP_TAKE;
 80208e4:	6830      	ldr	r0, [r6, #0]
 80208e6:	2101      	movs	r1, #1
 80208e8:	f7f3 fad2 	bl	8013e90 <xQueueTakeMutexRecursive>
 80208ec:	2801      	cmp	r0, #1
 80208ee:	4607      	mov	r7, r0
 80208f0:	d1f8      	bne.n	80208e4 <UIP_TASK_Handler+0x68>
    if( !(clock_time_tick() % 100) ) {
 80208f2:	f7ff fe71 	bl	80205d8 <clock_time_tick>
    if( network_device_available() ) {
 80208f6:	f7ff fe89 	bl	802060c <network_device_available>
 80208fa:	b1d0      	cbz	r0, 8020932 <UIP_TASK_Handler+0xb6>
      uip_len = network_device_read();
 80208fc:	f7ff fe8c 	bl	8020618 <network_device_read>
 8020900:	b284      	uxth	r4, r0
 8020902:	802c      	strh	r4, [r5, #0]
      if( uip_len > 0 ) {
 8020904:	b1cc      	cbz	r4, 802093a <UIP_TASK_Handler+0xbe>
	if(BUF->type == HTONS(UIP_ETHTYPE_IP) ) {
 8020906:	4b2e      	ldr	r3, [pc, #184]	@ (80209c0 <UIP_TASK_Handler+0x144>)
 8020908:	899b      	ldrh	r3, [r3, #12]
 802090a:	2b08      	cmp	r3, #8
 802090c:	d109      	bne.n	8020922 <UIP_TASK_Handler+0xa6>
	  uip_input();
 802090e:	4638      	mov	r0, r7
 8020910:	f7fe fe84 	bl	801f61c <uip_process>
	  if( uip_len > 0 ) {
 8020914:	882b      	ldrh	r3, [r5, #0]
 8020916:	b163      	cbz	r3, 8020932 <UIP_TASK_Handler+0xb6>
	    uip_arp_out();
 8020918:	f7ff fdac 	bl	8020474 <uip_arp_out>
	    network_device_send();
 802091c:	f7ff fe8c 	bl	8020638 <network_device_send>
 8020920:	e007      	b.n	8020932 <UIP_TASK_Handler+0xb6>
	} else if(BUF->type == HTONS(UIP_ETHTYPE_ARP)) {
 8020922:	f5b3 6fc1 	cmp.w	r3, #1544	@ 0x608
 8020926:	d104      	bne.n	8020932 <UIP_TASK_Handler+0xb6>
	  uip_arp_arpin();
 8020928:	f7ff fd50 	bl	80203cc <uip_arp_arpin>
	  if(uip_len > 0) {
 802092c:	882b      	ldrh	r3, [r5, #0]
 802092e:	2b00      	cmp	r3, #0
 8020930:	d1f4      	bne.n	802091c <UIP_TASK_Handler+0xa0>
    MUTEX_UIP_GIVE;
 8020932:	6830      	ldr	r0, [r6, #0]
 8020934:	f7f3 f9fb 	bl	8013d2e <xQueueGiveMutexRecursive>
    vTaskDelayUntil(&xLastExecutionTime, 1 / portTICK_RATE_MS);
 8020938:	e7d0      	b.n	80208dc <UIP_TASK_Handler+0x60>
      } else if(timer_expired(&periodic_timer)) {
 802093a:	a802      	add	r0, sp, #8
 802093c:	f7ff fe40 	bl	80205c0 <timer_expired>
 8020940:	2800      	cmp	r0, #0
 8020942:	d0f6      	beq.n	8020932 <UIP_TASK_Handler+0xb6>
	timer_reset(&periodic_timer);
 8020944:	a802      	add	r0, sp, #8
 8020946:	f7ff fe36 	bl	80205b6 <timer_reset>
	for(i = 0; i < UIP_CONNS; i++) {
 802094a:	4f1e      	ldr	r7, [pc, #120]	@ (80209c4 <UIP_TASK_Handler+0x148>)
	  uip_periodic(i);
 802094c:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 80209c8 <UIP_TASK_Handler+0x14c>
 8020950:	f8c8 7000 	str.w	r7, [r8]
 8020954:	2002      	movs	r0, #2
 8020956:	f7fe fe61 	bl	801f61c <uip_process>
	  if(uip_len > 0) {
 802095a:	882b      	ldrh	r3, [r5, #0]
 802095c:	b11b      	cbz	r3, 8020966 <UIP_TASK_Handler+0xea>
	    uip_arp_out();
 802095e:	f7ff fd89 	bl	8020474 <uip_arp_out>
	    network_device_send();
 8020962:	f7ff fe69 	bl	8020638 <network_device_send>
	for(i = 0; i < UIP_CONNS; i++) {
 8020966:	3401      	adds	r4, #1
 8020968:	2c0a      	cmp	r4, #10
 802096a:	f107 071e 	add.w	r7, r7, #30
 802096e:	d1ef      	bne.n	8020950 <UIP_TASK_Handler+0xd4>
 8020970:	4f16      	ldr	r7, [pc, #88]	@ (80209cc <UIP_TASK_Handler+0x150>)
	  uip_udp_periodic(i);
 8020972:	f8df 805c 	ldr.w	r8, [pc, #92]	@ 80209d0 <UIP_TASK_Handler+0x154>
	for(i = 0; i < UIP_UDP_CONNS; i++) {
 8020976:	2400      	movs	r4, #0
	  uip_udp_periodic(i);
 8020978:	2005      	movs	r0, #5
 802097a:	f8c8 7000 	str.w	r7, [r8]
 802097e:	f7fe fe4d 	bl	801f61c <uip_process>
	  if(uip_len > 0) {
 8020982:	882b      	ldrh	r3, [r5, #0]
 8020984:	b11b      	cbz	r3, 802098e <UIP_TASK_Handler+0x112>
	    uip_arp_out();
 8020986:	f7ff fd75 	bl	8020474 <uip_arp_out>
	    network_device_send();
 802098a:	f7ff fe55 	bl	8020638 <network_device_send>
	for(i = 0; i < UIP_UDP_CONNS; i++) {
 802098e:	3401      	adds	r4, #1
 8020990:	2c0a      	cmp	r4, #10
 8020992:	f107 0740 	add.w	r7, r7, #64	@ 0x40
 8020996:	d1ef      	bne.n	8020978 <UIP_TASK_Handler+0xfc>
	if(timer_expired(&arp_timer)) {
 8020998:	a804      	add	r0, sp, #16
 802099a:	f7ff fe11 	bl	80205c0 <timer_expired>
 802099e:	2800      	cmp	r0, #0
 80209a0:	d0c7      	beq.n	8020932 <UIP_TASK_Handler+0xb6>
	  timer_reset(&arp_timer);
 80209a2:	a804      	add	r0, sp, #16
 80209a4:	f7ff fe07 	bl	80205b6 <timer_reset>
	  uip_arp_timer();
 80209a8:	f7ff fce6 	bl	8020378 <uip_arp_timer>
 80209ac:	e7c1      	b.n	8020932 <UIP_TASK_Handler+0xb6>
 80209ae:	bf00      	nop
 80209b0:	20007540 	.word	0x20007540
 80209b4:	200074bc 	.word	0x200074bc
 80209b8:	200000ac 	.word	0x200000ac
 80209bc:	20006ec0 	.word	0x20006ec0
 80209c0:	20006ecc 	.word	0x20006ecc
 80209c4:	20006d8c 	.word	0x20006d8c
 80209c8:	20006eb8 	.word	0x20006eb8
 80209cc:	20006af4 	.word	0x20006af4
 80209d0:	20006d74 	.word	0x20006d74

080209d4 <UIP_TASK_DHCP_EnableGet>:
}
 80209d4:	4b01      	ldr	r3, [pc, #4]	@ (80209dc <UIP_TASK_DHCP_EnableGet+0x8>)
 80209d6:	7818      	ldrb	r0, [r3, #0]
 80209d8:	4770      	bx	lr
 80209da:	bf00      	nop
 80209dc:	200000ac 	.word	0x200000ac

080209e0 <UIP_TASK_IP_AddressSet>:
  my_ip_address = ip;
 80209e0:	4b08      	ldr	r3, [pc, #32]	@ (8020a04 <UIP_TASK_IP_AddressSet+0x24>)
  uip_sethostaddr(ipaddr);
 80209e2:	4a09      	ldr	r2, [pc, #36]	@ (8020a08 <UIP_TASK_IP_AddressSet+0x28>)
  my_ip_address = ip;
 80209e4:	6018      	str	r0, [r3, #0]
  uip_ipaddr(ipaddr,
 80209e6:	0c03      	lsrs	r3, r0, #16
 80209e8:	021b      	lsls	r3, r3, #8
 80209ea:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
  uip_sethostaddr(ipaddr);
 80209ee:	8013      	strh	r3, [r2, #0]
  uip_ipaddr(ipaddr,
 80209f0:	4b06      	ldr	r3, [pc, #24]	@ (8020a0c <UIP_TASK_IP_AddressSet+0x2c>)
 80209f2:	ea03 2300 	and.w	r3, r3, r0, lsl #8
 80209f6:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80209fa:	4303      	orrs	r3, r0
  uip_sethostaddr(ipaddr);
 80209fc:	8053      	strh	r3, [r2, #2]
}
 80209fe:	2000      	movs	r0, #0
 8020a00:	4770      	bx	lr
 8020a02:	bf00      	nop
 8020a04:	200000a8 	.word	0x200000a8
 8020a08:	200074ca 	.word	0x200074ca
 8020a0c:	00ffff00 	.word	0x00ffff00

08020a10 <UIP_TASK_IP_AddressGet>:
}
 8020a10:	4b01      	ldr	r3, [pc, #4]	@ (8020a18 <UIP_TASK_IP_AddressGet+0x8>)
 8020a12:	6818      	ldr	r0, [r3, #0]
 8020a14:	4770      	bx	lr
 8020a16:	bf00      	nop
 8020a18:	200000a8 	.word	0x200000a8

08020a1c <UIP_TASK_NetmaskSet>:
  my_netmask = mask;
 8020a1c:	4b08      	ldr	r3, [pc, #32]	@ (8020a40 <UIP_TASK_NetmaskSet+0x24>)
  uip_setnetmask(ipaddr);
 8020a1e:	4a09      	ldr	r2, [pc, #36]	@ (8020a44 <UIP_TASK_NetmaskSet+0x28>)
  my_netmask = mask;
 8020a20:	6018      	str	r0, [r3, #0]
  uip_ipaddr(ipaddr,
 8020a22:	0c03      	lsrs	r3, r0, #16
 8020a24:	021b      	lsls	r3, r3, #8
 8020a26:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
  uip_setnetmask(ipaddr);
 8020a2a:	8013      	strh	r3, [r2, #0]
  uip_ipaddr(ipaddr,
 8020a2c:	4b06      	ldr	r3, [pc, #24]	@ (8020a48 <UIP_TASK_NetmaskSet+0x2c>)
 8020a2e:	ea03 2300 	and.w	r3, r3, r0, lsl #8
 8020a32:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8020a36:	4303      	orrs	r3, r0
  uip_setnetmask(ipaddr);
 8020a38:	8053      	strh	r3, [r2, #2]
}
 8020a3a:	2000      	movs	r0, #0
 8020a3c:	4770      	bx	lr
 8020a3e:	bf00      	nop
 8020a40:	200000a4 	.word	0x200000a4
 8020a44:	200074c2 	.word	0x200074c2
 8020a48:	00ffff00 	.word	0x00ffff00

08020a4c <UIP_TASK_NetmaskGet>:
}
 8020a4c:	4b01      	ldr	r3, [pc, #4]	@ (8020a54 <UIP_TASK_NetmaskGet+0x8>)
 8020a4e:	6818      	ldr	r0, [r3, #0]
 8020a50:	4770      	bx	lr
 8020a52:	bf00      	nop
 8020a54:	200000a4 	.word	0x200000a4

08020a58 <UIP_TASK_GatewaySet>:
  my_gateway = ip;
 8020a58:	4b08      	ldr	r3, [pc, #32]	@ (8020a7c <UIP_TASK_GatewaySet+0x24>)
  uip_setdraddr(ipaddr);
 8020a5a:	4a09      	ldr	r2, [pc, #36]	@ (8020a80 <UIP_TASK_GatewaySet+0x28>)
  my_gateway = ip;
 8020a5c:	6018      	str	r0, [r3, #0]
  uip_ipaddr(ipaddr,
 8020a5e:	0c03      	lsrs	r3, r0, #16
 8020a60:	021b      	lsls	r3, r3, #8
 8020a62:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
  uip_setdraddr(ipaddr);
 8020a66:	8013      	strh	r3, [r2, #0]
  uip_ipaddr(ipaddr,
 8020a68:	4b06      	ldr	r3, [pc, #24]	@ (8020a84 <UIP_TASK_GatewaySet+0x2c>)
 8020a6a:	ea03 2300 	and.w	r3, r3, r0, lsl #8
 8020a6e:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8020a72:	4303      	orrs	r3, r0
  uip_setdraddr(ipaddr);
 8020a74:	8053      	strh	r3, [r2, #2]
}
 8020a76:	2000      	movs	r0, #0
 8020a78:	4770      	bx	lr
 8020a7a:	bf00      	nop
 8020a7c:	200000a0 	.word	0x200000a0
 8020a80:	200074c6 	.word	0x200074c6
 8020a84:	00ffff00 	.word	0x00ffff00

08020a88 <UIP_TASK_GatewayGet>:
}
 8020a88:	4b01      	ldr	r3, [pc, #4]	@ (8020a90 <UIP_TASK_GatewayGet+0x8>)
 8020a8a:	6818      	ldr	r0, [r3, #0]
 8020a8c:	4770      	bx	lr
 8020a8e:	bf00      	nop
 8020a90:	200000a0 	.word	0x200000a0

08020a94 <UIP_TASK_ServicesRunning>:
// Status flag for external functions
/////////////////////////////////////////////////////////////////////////////
s32 UIP_TASK_ServicesRunning(void)
{
  return services_running;
}
 8020a94:	4b01      	ldr	r3, [pc, #4]	@ (8020a9c <UIP_TASK_ServicesRunning+0x8>)
 8020a96:	7818      	ldrb	r0, [r3, #0]
 8020a98:	4770      	bx	lr
 8020a9a:	bf00      	nop
 8020a9c:	2000753e 	.word	0x2000753e

08020aa0 <UIP_TASK_NetworkDeviceAvailable>:
/////////////////////////////////////////////////////////////////////////////
// network device connected to core?
/////////////////////////////////////////////////////////////////////////////
s32 UIP_TASK_NetworkDeviceAvailable(void)
{
  return network_device_available();
 8020aa0:	f7ff bdb4 	b.w	802060c <network_device_available>

08020aa4 <UIP_TASK_UDP_MonitorPacket>:
/////////////////////////////////////////////////////////////////////////////
extern u16_t uip_slen; // allows to access a variable which is part of uip.c
#define TCPIPBUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])
s32 UIP_TASK_UDP_MonitorPacket(u8 received, char* prefix)
{
 8020aa4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if( received ) {
    len = uip_len;

    DEBUG_MSG("[UDP:%s] from %d.%d.%d.%d:%d to port %d (%d bytes)\n", 
	      prefix,
	      (TCPIPBUF->srcipaddr[0]>>0)&0xff, (TCPIPBUF->srcipaddr[0]>>8)&0xff, (TCPIPBUF->srcipaddr[1]>>0)&0xff, (TCPIPBUF->srcipaddr[1]>>8)&0xff,
 8020aa6:	4d15      	ldr	r5, [pc, #84]	@ (8020afc <UIP_TASK_UDP_MonitorPacket+0x58>)
 8020aa8:	8b6b      	ldrh	r3, [r5, #26]
 8020aaa:	8bae      	ldrh	r6, [r5, #28]
    DEBUG_MSG("[UDP:%s] from %d.%d.%d.%d:%d to port %d (%d bytes)\n", 
 8020aac:	8cac      	ldrh	r4, [r5, #36]	@ 0x24
 8020aae:	8c6d      	ldrh	r5, [r5, #34]	@ 0x22
{
 8020ab0:	4607      	mov	r7, r0
    DEBUG_MSG("[UDP:%s] from %d.%d.%d.%d:%d to port %d (%d bytes)\n", 
 8020ab2:	ba64      	rev16	r4, r4
 8020ab4:	ba6d      	rev16	r5, r5
 8020ab6:	b2da      	uxtb	r2, r3
 8020ab8:	b2f0      	uxtb	r0, r6
{
 8020aba:	b087      	sub	sp, #28
    DEBUG_MSG("[UDP:%s] from %d.%d.%d.%d:%d to port %d (%d bytes)\n", 
 8020abc:	0a1b      	lsrs	r3, r3, #8
 8020abe:	0a36      	lsrs	r6, r6, #8
 8020ac0:	b2a4      	uxth	r4, r4
 8020ac2:	b2ad      	uxth	r5, r5
  if( received ) {
 8020ac4:	b18f      	cbz	r7, 8020aea <UIP_TASK_UDP_MonitorPacket+0x46>
    len = uip_len;
 8020ac6:	4f0e      	ldr	r7, [pc, #56]	@ (8020b00 <UIP_TASK_UDP_MonitorPacket+0x5c>)
 8020ac8:	883f      	ldrh	r7, [r7, #0]
    DEBUG_MSG("[UDP:%s] from %d.%d.%d.%d:%d to port %d (%d bytes)\n", 
 8020aca:	9000      	str	r0, [sp, #0]
 8020acc:	e9cd 4703 	strd	r4, r7, [sp, #12]
 8020ad0:	e9cd 6501 	strd	r6, r5, [sp, #4]
 8020ad4:	480b      	ldr	r0, [pc, #44]	@ (8020b04 <UIP_TASK_UDP_MonitorPacket+0x60>)
	      HTONS(UDPBUF->srcport), HTONS(UDPBUF->destport),
	      len);
  } else {
    len = uip_slen;

    DEBUG_MSG("[UDP:%s] to %d.%d.%d.%d:%d from port %d (%d bytes)\n", 
 8020ad6:	f7f4 f887 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
	      prefix,
	      (TCPIPBUF->srcipaddr[0]>>0)&0xff, (TCPIPBUF->srcipaddr[0]>>8)&0xff, (TCPIPBUF->srcipaddr[1]>>0)&0xff, (TCPIPBUF->srcipaddr[1]>>8)&0xff,
	      HTONS(UDPBUF->destport), HTONS(UDPBUF->srcport),
	      len);
  }
  MIOS32_MIDI_SendDebugHexDump((u8 *)uip_appdata, len);
 8020ada:	4b0b      	ldr	r3, [pc, #44]	@ (8020b08 <UIP_TASK_UDP_MonitorPacket+0x64>)
 8020adc:	4639      	mov	r1, r7
 8020ade:	6818      	ldr	r0, [r3, #0]
 8020ae0:	f7f4 f8d0 	bl	8014c84 <MIOS32_MIDI_SendDebugHexDump>
  UIP_TASK_MUTEX_MIDIOUT_GIVE;

  return 0; // no error
}
 8020ae4:	2000      	movs	r0, #0
 8020ae6:	b007      	add	sp, #28
 8020ae8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    len = uip_slen;
 8020aea:	4f08      	ldr	r7, [pc, #32]	@ (8020b0c <UIP_TASK_UDP_MonitorPacket+0x68>)
 8020aec:	883f      	ldrh	r7, [r7, #0]
    DEBUG_MSG("[UDP:%s] to %d.%d.%d.%d:%d from port %d (%d bytes)\n", 
 8020aee:	9000      	str	r0, [sp, #0]
 8020af0:	e9cd 5703 	strd	r5, r7, [sp, #12]
 8020af4:	e9cd 6401 	strd	r6, r4, [sp, #4]
 8020af8:	4805      	ldr	r0, [pc, #20]	@ (8020b10 <UIP_TASK_UDP_MonitorPacket+0x6c>)
 8020afa:	e7ec      	b.n	8020ad6 <UIP_TASK_UDP_MonitorPacket+0x32>
 8020afc:	20006ecc 	.word	0x20006ecc
 8020b00:	20006ec0 	.word	0x20006ec0
 8020b04:	08028243 	.word	0x08028243
 8020b08:	20006ec8 	.word	0x20006ec8
 8020b0c:	20006ebe 	.word	0x20006ebe
 8020b10:	08028277 	.word	0x08028277

08020b14 <UIP_TASK_UDP_AppCall>:
{
 8020b14:	b508      	push	{r3, lr}
  if( uip_udp_conn->rport == HTONS(DHCPC_SERVER_PORT) || uip_udp_conn->rport == HTONS(DHCPC_CLIENT_PORT) ) {
 8020b16:	4b0c      	ldr	r3, [pc, #48]	@ (8020b48 <UIP_TASK_UDP_AppCall+0x34>)
 8020b18:	681b      	ldr	r3, [r3, #0]
 8020b1a:	88db      	ldrh	r3, [r3, #6]
 8020b1c:	f5b3 4f86 	cmp.w	r3, #17152	@ 0x4300
 8020b20:	d002      	beq.n	8020b28 <UIP_TASK_UDP_AppCall+0x14>
 8020b22:	f5b3 4f88 	cmp.w	r3, #17408	@ 0x4400
 8020b26:	d10b      	bne.n	8020b40 <UIP_TASK_UDP_AppCall+0x2c>
    dhcpc_appcall();
 8020b28:	f000 f928 	bl	8020d7c <dhcpc_appcall>
    if( udp_monitor_level >= UDP_MONITOR_LEVEL_4_ALL )
 8020b2c:	4b07      	ldr	r3, [pc, #28]	@ (8020b4c <UIP_TASK_UDP_AppCall+0x38>)
 8020b2e:	781b      	ldrb	r3, [r3, #0]
 8020b30:	2b03      	cmp	r3, #3
 8020b32:	d903      	bls.n	8020b3c <UIP_TASK_UDP_AppCall+0x28>
      UIP_TASK_UDP_MonitorPacket(UDP_MONITOR_RECEIVED, "DHCP"); // should we differ between send/receive?
 8020b34:	4906      	ldr	r1, [pc, #24]	@ (8020b50 <UIP_TASK_UDP_AppCall+0x3c>)
 8020b36:	2001      	movs	r0, #1
 8020b38:	f7ff ffb4 	bl	8020aa4 <UIP_TASK_UDP_MonitorPacket>
}
 8020b3c:	2000      	movs	r0, #0
 8020b3e:	bd08      	pop	{r3, pc}
    OSC_SERVER_AppCall();
 8020b40:	f000 fd02 	bl	8021548 <OSC_SERVER_AppCall>
 8020b44:	e7fa      	b.n	8020b3c <UIP_TASK_UDP_AppCall+0x28>
 8020b46:	bf00      	nop
 8020b48:	20006d74 	.word	0x20006d74
 8020b4c:	2000753d 	.word	0x2000753d
 8020b50:	0802893a 	.word	0x0802893a

08020b54 <UIP_TASK_UDP_MonitorLevelSet>:
/////////////////////////////////////////////////////////////////////////////
// Sets/Returns the UDP/OSC monitor level
/////////////////////////////////////////////////////////////////////////////
s32 UIP_TASK_UDP_MonitorLevelSet(u8 level)
{
  udp_monitor_level = level;
 8020b54:	4b01      	ldr	r3, [pc, #4]	@ (8020b5c <UIP_TASK_UDP_MonitorLevelSet+0x8>)
 8020b56:	7018      	strb	r0, [r3, #0]
  return 0; // no error
}
 8020b58:	2000      	movs	r0, #0
 8020b5a:	4770      	bx	lr
 8020b5c:	2000753d 	.word	0x2000753d

08020b60 <UIP_TASK_UDP_MonitorLevelGet>:

s32 UIP_TASK_UDP_MonitorLevelGet(void)
{
  return udp_monitor_level;
}
 8020b60:	4b01      	ldr	r3, [pc, #4]	@ (8020b68 <UIP_TASK_UDP_MonitorLevelGet+0x8>)
 8020b62:	7818      	ldrb	r0, [r3, #0]
 8020b64:	4770      	bx	lr
 8020b66:	bf00      	nop
 8020b68:	2000753d 	.word	0x2000753d

08020b6c <dhcpc_configured>:
// Called by DHCP client once it got IP addresses
/////////////////////////////////////////////////////////////////////////////
void dhcpc_configured(const struct dhcpc_state *s)
{
  // set IP settings
  uip_sethostaddr(s->ipaddr);
 8020b6c:	4b22      	ldr	r3, [pc, #136]	@ (8020bf8 <dhcpc_configured+0x8c>)
{
 8020b6e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  uip_sethostaddr(s->ipaddr);
 8020b70:	8c82      	ldrh	r2, [r0, #36]	@ 0x24
 8020b72:	801a      	strh	r2, [r3, #0]
 8020b74:	8cc2      	ldrh	r2, [r0, #38]	@ 0x26
 8020b76:	805a      	strh	r2, [r3, #2]
  uip_setnetmask(s->netmask);
 8020b78:	4b20      	ldr	r3, [pc, #128]	@ (8020bfc <dhcpc_configured+0x90>)
 8020b7a:	8d02      	ldrh	r2, [r0, #40]	@ 0x28
 8020b7c:	801a      	strh	r2, [r3, #0]
 8020b7e:	8d42      	ldrh	r2, [r0, #42]	@ 0x2a
 8020b80:	805a      	strh	r2, [r3, #2]
  uip_setdraddr(s->default_router);
 8020b82:	4b1f      	ldr	r3, [pc, #124]	@ (8020c00 <dhcpc_configured+0x94>)
 8020b84:	8e02      	ldrh	r2, [r0, #48]	@ 0x30
 8020b86:	801a      	strh	r2, [r3, #0]
 8020b88:	8e42      	ldrh	r2, [r0, #50]	@ 0x32
 8020b8a:	805a      	strh	r2, [r3, #2]
{
 8020b8c:	4604      	mov	r4, r0
  UIP_TASK_SendDebugMessage_IP();
 8020b8e:	f7ff fd75 	bl	802067c <UIP_TASK_SendDebugMessage_IP.isra.0>
  OSC_SERVER_Init(0);
 8020b92:	2000      	movs	r0, #0
 8020b94:	f000 fc4a 	bl	802142c <OSC_SERVER_Init>
  services_running = 1;
 8020b98:	4b1a      	ldr	r3, [pc, #104]	@ (8020c04 <dhcpc_configured+0x98>)

  // print unused settings
#if DEBUG_VERBOSE_LEVEL >= 1
  UIP_TASK_MUTEX_MIDIOUT_TAKE;
  DEBUG_MSG("[UIP_TASK] Got DNS server %d.%d.%d.%d\n",
	    uip_ipaddr1(s->dnsaddr), uip_ipaddr2(s->dnsaddr),
 8020b9a:	8da0      	ldrh	r0, [r4, #44]	@ 0x2c
  services_running = 1;
 8020b9c:	2201      	movs	r2, #1
 8020b9e:	701a      	strb	r2, [r3, #0]
	    uip_ipaddr1(s->dnsaddr), uip_ipaddr2(s->dnsaddr),
 8020ba0:	f7ff fb22 	bl	80201e8 <htons>
 8020ba4:	4605      	mov	r5, r0
 8020ba6:	8da0      	ldrh	r0, [r4, #44]	@ 0x2c
 8020ba8:	f7ff fb1e 	bl	80201e8 <htons>
 8020bac:	4606      	mov	r6, r0
	    uip_ipaddr3(s->dnsaddr), uip_ipaddr4(s->dnsaddr));
 8020bae:	8de0      	ldrh	r0, [r4, #46]	@ 0x2e
 8020bb0:	f7ff fb1a 	bl	80201e8 <htons>
 8020bb4:	4607      	mov	r7, r0
 8020bb6:	8de0      	ldrh	r0, [r4, #46]	@ 0x2e
 8020bb8:	f7ff fb16 	bl	80201e8 <htons>
  DEBUG_MSG("[UIP_TASK] Got DNS server %d.%d.%d.%d\n",
 8020bbc:	b2c0      	uxtb	r0, r0
 8020bbe:	f3c5 210f 	ubfx	r1, r5, #8, #16
 8020bc2:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8020bc6:	b2f2      	uxtb	r2, r6
 8020bc8:	9000      	str	r0, [sp, #0]
 8020bca:	480f      	ldr	r0, [pc, #60]	@ (8020c08 <dhcpc_configured+0x9c>)
 8020bcc:	f7f4 f80c 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  DEBUG_MSG("[UIP_TASK] Lease expires in %d hours\n",
	    (ntohs(s->lease_time[0])*65536ul + ntohs(s->lease_time[1]))/3600);
 8020bd0:	8c20      	ldrh	r0, [r4, #32]
 8020bd2:	f7ff fb09 	bl	80201e8 <htons>
 8020bd6:	4605      	mov	r5, r0
 8020bd8:	8c60      	ldrh	r0, [r4, #34]	@ 0x22
 8020bda:	f7ff fb05 	bl	80201e8 <htons>
  DEBUG_MSG("[UIP_TASK] Lease expires in %d hours\n",
 8020bde:	f44f 6161 	mov.w	r1, #3600	@ 0xe10
	    (ntohs(s->lease_time[0])*65536ul + ntohs(s->lease_time[1]))/3600);
 8020be2:	eb00 4005 	add.w	r0, r0, r5, lsl #16
  DEBUG_MSG("[UIP_TASK] Lease expires in %d hours\n",
 8020be6:	fbb0 f1f1 	udiv	r1, r0, r1
 8020bea:	4808      	ldr	r0, [pc, #32]	@ (8020c0c <dhcpc_configured+0xa0>)
  UIP_TASK_MUTEX_MIDIOUT_GIVE;
#endif
}
 8020bec:	b003      	add	sp, #12
 8020bee:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  DEBUG_MSG("[UIP_TASK] Lease expires in %d hours\n",
 8020bf2:	f7f3 bff9 	b.w	8014be8 <MIOS32_MIDI_SendDebugMessage>
 8020bf6:	bf00      	nop
 8020bf8:	200074ca 	.word	0x200074ca
 8020bfc:	200074c2 	.word	0x200074c2
 8020c00:	200074c6 	.word	0x200074c6
 8020c04:	2000753e 	.word	0x2000753e
 8020c08:	080282ab 	.word	0x080282ab
 8020c0c:	080282d2 	.word	0x080282d2

08020c10 <create_msg>:
}
/*---------------------------------------------------------------------------*/
static void
create_msg(register struct dhcp_msg *m)
{
  m->op = DHCP_REQUEST;
 8020c10:	f240 1301 	movw	r3, #257	@ 0x101
{
 8020c14:	b570      	push	{r4, r5, r6, lr}
  m->op = DHCP_REQUEST;
 8020c16:	8003      	strh	r3, [r0, #0]
  m->htype = DHCP_HTYPE_ETHERNET;
  m->hlen = s.mac_len;
 8020c18:	4b19      	ldr	r3, [pc, #100]	@ (8020c80 <create_msg+0x70>)
 8020c1a:	699a      	ldr	r2, [r3, #24]
 8020c1c:	7082      	strb	r2, [r0, #2]
  m->hops = 0;
 8020c1e:	4a19      	ldr	r2, [pc, #100]	@ (8020c84 <create_msg+0x74>)
 8020c20:	6811      	ldr	r1, [r2, #0]
 8020c22:	f8c0 1003 	str.w	r1, [r0, #3]
 8020c26:	6851      	ldr	r1, [r2, #4]
 8020c28:	7a12      	ldrb	r2, [r2, #8]
 8020c2a:	72c2      	strb	r2, [r0, #11]
  m->secs = HTONS(10); // should be a secure value?
#endif

  m->flags = HTONS(BOOTP_BROADCAST); /*  Broadcast bit. */
  /*  uip_ipaddr_copy(m->ciaddr, uip_hostaddr);*/
  memcpy(m->ciaddr, uip_hostaddr, sizeof(m->ciaddr));
 8020c2c:	4a16      	ldr	r2, [pc, #88]	@ (8020c88 <create_msg+0x78>)
  m->hops = 0;
 8020c2e:	f8c0 1007 	str.w	r1, [r0, #7]
  memset(m->yiaddr, 0, sizeof(m->yiaddr));
 8020c32:	2500      	movs	r5, #0
  memcpy(m->ciaddr, uip_hostaddr, sizeof(m->ciaddr));
 8020c34:	6812      	ldr	r2, [r2, #0]
 8020c36:	60c2      	str	r2, [r0, #12]
  memset(m->yiaddr, 0, sizeof(m->yiaddr));
 8020c38:	6105      	str	r5, [r0, #16]
  memset(m->siaddr, 0, sizeof(m->siaddr));
 8020c3a:	6145      	str	r5, [r0, #20]
  memset(m->giaddr, 0, sizeof(m->giaddr));
 8020c3c:	6185      	str	r5, [r0, #24]
  memcpy(m->chaddr, s.mac_addr, s.mac_len);
 8020c3e:	699e      	ldr	r6, [r3, #24]
 8020c40:	6959      	ldr	r1, [r3, #20]
{
 8020c42:	4604      	mov	r4, r0
  memcpy(m->chaddr, s.mac_addr, s.mac_len);
 8020c44:	4632      	mov	r2, r6
 8020c46:	301c      	adds	r0, #28
 8020c48:	f002 fce9 	bl	802361e <memcpy>
  memset(&m->chaddr[s.mac_len], 0, sizeof(m->chaddr) - s.mac_len);
 8020c4c:	f106 001c 	add.w	r0, r6, #28
 8020c50:	f1c6 0210 	rsb	r2, r6, #16
 8020c54:	4629      	mov	r1, r5
 8020c56:	4420      	add	r0, r4
 8020c58:	f002 fc7b 	bl	8023552 <memset>
#ifndef UIP_CONF_DHCP_LIGHT
  memset(m->sname, 0, sizeof(m->sname));
 8020c5c:	2240      	movs	r2, #64	@ 0x40
 8020c5e:	4629      	mov	r1, r5
 8020c60:	f104 002c 	add.w	r0, r4, #44	@ 0x2c
 8020c64:	f002 fc75 	bl	8023552 <memset>
  memset(m->file, 0, sizeof(m->file));
 8020c68:	2280      	movs	r2, #128	@ 0x80
 8020c6a:	4629      	mov	r1, r5
 8020c6c:	f104 006c 	add.w	r0, r4, #108	@ 0x6c
 8020c70:	f002 fc6f 	bl	8023552 <memset>
#endif

  memcpy(m->options, magic_cookie, sizeof(magic_cookie));
 8020c74:	4b05      	ldr	r3, [pc, #20]	@ (8020c8c <create_msg+0x7c>)
 8020c76:	681b      	ldr	r3, [r3, #0]
 8020c78:	f8c4 30ec 	str.w	r3, [r4, #236]	@ 0xec
}
 8020c7c:	bd70      	pop	{r4, r5, r6, pc}
 8020c7e:	bf00      	nop
 8020c80:	20007544 	.word	0x20007544
 8020c84:	0802830c 	.word	0x0802830c
 8020c88:	200074ca 	.word	0x200074ca
 8020c8c:	080282f8 	.word	0x080282f8

08020c90 <parse_msg>:
  return type;
}
/*---------------------------------------------------------------------------*/
static u8_t
parse_msg(void)
{
 8020c90:	b570      	push	{r4, r5, r6, lr}
  struct dhcp_msg *m = (struct dhcp_msg *)uip_appdata;
 8020c92:	4b27      	ldr	r3, [pc, #156]	@ (8020d30 <parse_msg+0xa0>)
 8020c94:	681d      	ldr	r5, [r3, #0]

  if(m->op == DHCP_REPLY &&
 8020c96:	782b      	ldrb	r3, [r5, #0]
 8020c98:	2b02      	cmp	r3, #2
 8020c9a:	d144      	bne.n	8020d26 <parse_msg+0x96>
     memcmp(m->xid, xid, sizeof(xid)) == 0 &&
 8020c9c:	2204      	movs	r2, #4
 8020c9e:	4925      	ldr	r1, [pc, #148]	@ (8020d34 <parse_msg+0xa4>)
 8020ca0:	18a8      	adds	r0, r5, r2
 8020ca2:	f002 fc23 	bl	80234ec <memcmp>
  if(m->op == DHCP_REPLY &&
 8020ca6:	4604      	mov	r4, r0
 8020ca8:	2800      	cmp	r0, #0
 8020caa:	d13c      	bne.n	8020d26 <parse_msg+0x96>
     memcmp(m->chaddr, s.mac_addr, s.mac_len) == 0) {
 8020cac:	4e22      	ldr	r6, [pc, #136]	@ (8020d38 <parse_msg+0xa8>)
 8020cae:	f105 001c 	add.w	r0, r5, #28
 8020cb2:	e9d6 1205 	ldrd	r1, r2, [r6, #20]
 8020cb6:	f002 fc19 	bl	80234ec <memcmp>
     memcmp(m->xid, xid, sizeof(xid)) == 0 &&
 8020cba:	2800      	cmp	r0, #0
 8020cbc:	d135      	bne.n	8020d2a <parse_msg+0x9a>
    memcpy(s.ipaddr, m->yiaddr, 4);
    return parse_options(&m->options[4], uip_datalen());
 8020cbe:	4a1f      	ldr	r2, [pc, #124]	@ (8020d3c <parse_msg+0xac>)
    memcpy(s.ipaddr, m->yiaddr, 4);
 8020cc0:	692b      	ldr	r3, [r5, #16]
  u8_t *end = optptr + len;
 8020cc2:	8811      	ldrh	r1, [r2, #0]
    memcpy(s.ipaddr, m->yiaddr, 4);
 8020cc4:	6273      	str	r3, [r6, #36]	@ 0x24
    return parse_options(&m->options[4], uip_datalen());
 8020cc6:	f105 03f0 	add.w	r3, r5, #240	@ 0xf0
  u8_t *end = optptr + len;
 8020cca:	4419      	add	r1, r3
  while(optptr < end) {
 8020ccc:	4299      	cmp	r1, r3
 8020cce:	d800      	bhi.n	8020cd2 <parse_msg+0x42>
  }
  return 0;
}
 8020cd0:	bd70      	pop	{r4, r5, r6, pc}
    switch(*optptr) {
 8020cd2:	781a      	ldrb	r2, [r3, #0]
 8020cd4:	2a33      	cmp	r2, #51	@ 0x33
 8020cd6:	d022      	beq.n	8020d1e <parse_msg+0x8e>
 8020cd8:	d809      	bhi.n	8020cee <parse_msg+0x5e>
 8020cda:	2a03      	cmp	r2, #3
 8020cdc:	d013      	beq.n	8020d06 <parse_msg+0x76>
 8020cde:	2a06      	cmp	r2, #6
 8020ce0:	d015      	beq.n	8020d0e <parse_msg+0x7e>
 8020ce2:	2a01      	cmp	r2, #1
 8020ce4:	d00b      	beq.n	8020cfe <parse_msg+0x6e>
    optptr += optptr[1] + 2;
 8020ce6:	785a      	ldrb	r2, [r3, #1]
 8020ce8:	3202      	adds	r2, #2
 8020cea:	4413      	add	r3, r2
 8020cec:	e7ee      	b.n	8020ccc <parse_msg+0x3c>
    switch(*optptr) {
 8020cee:	2a36      	cmp	r2, #54	@ 0x36
 8020cf0:	d011      	beq.n	8020d16 <parse_msg+0x86>
 8020cf2:	2aff      	cmp	r2, #255	@ 0xff
 8020cf4:	d0ec      	beq.n	8020cd0 <parse_msg+0x40>
 8020cf6:	2a35      	cmp	r2, #53	@ 0x35
 8020cf8:	d1f5      	bne.n	8020ce6 <parse_msg+0x56>
      type = *(optptr + 2);
 8020cfa:	7898      	ldrb	r0, [r3, #2]
      break;
 8020cfc:	e7f3      	b.n	8020ce6 <parse_msg+0x56>
      memcpy(s.netmask, optptr + 2, 4);
 8020cfe:	f8d3 2002 	ldr.w	r2, [r3, #2]
 8020d02:	62b2      	str	r2, [r6, #40]	@ 0x28
      break;
 8020d04:	e7ef      	b.n	8020ce6 <parse_msg+0x56>
      memcpy(s.default_router, optptr + 2, 4);
 8020d06:	f8d3 2002 	ldr.w	r2, [r3, #2]
 8020d0a:	6332      	str	r2, [r6, #48]	@ 0x30
      break;
 8020d0c:	e7eb      	b.n	8020ce6 <parse_msg+0x56>
      memcpy(s.dnsaddr, optptr + 2, 4);
 8020d0e:	f8d3 2002 	ldr.w	r2, [r3, #2]
 8020d12:	62f2      	str	r2, [r6, #44]	@ 0x2c
      break;
 8020d14:	e7e7      	b.n	8020ce6 <parse_msg+0x56>
      memcpy(s.serverid, optptr + 2, 4);
 8020d16:	f8d3 2002 	ldr.w	r2, [r3, #2]
 8020d1a:	61f2      	str	r2, [r6, #28]
      break;
 8020d1c:	e7e3      	b.n	8020ce6 <parse_msg+0x56>
      memcpy(s.lease_time, optptr + 2, 4);
 8020d1e:	f8d3 2002 	ldr.w	r2, [r3, #2]
 8020d22:	6232      	str	r2, [r6, #32]
      break;
 8020d24:	e7df      	b.n	8020ce6 <parse_msg+0x56>
  return 0;
 8020d26:	2000      	movs	r0, #0
 8020d28:	e7d2      	b.n	8020cd0 <parse_msg+0x40>
 8020d2a:	4620      	mov	r0, r4
 8020d2c:	e7d0      	b.n	8020cd0 <parse_msg+0x40>
 8020d2e:	bf00      	nop
 8020d30:	20006ec8 	.word	0x20006ec8
 8020d34:	08028308 	.word	0x08028308
 8020d38:	20007544 	.word	0x20007544
 8020d3c:	20006ec0 	.word	0x20006ec0

08020d40 <dhcpc_init>:
  PT_END(&s.pt);
}
/*---------------------------------------------------------------------------*/
void
dhcpc_init(const void *mac_addr, int mac_len)
{
 8020d40:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uip_ipaddr_t addr;
  
  s.mac_addr = mac_addr;
 8020d42:	4c0c      	ldr	r4, [pc, #48]	@ (8020d74 <dhcpc_init+0x34>)
  s.mac_len  = mac_len;
 8020d44:	e9c4 0105 	strd	r0, r1, [r4, #20]
  MIOS32_MIDI_SendDebugMessage("Init DHCP\n");
 8020d48:	480b      	ldr	r0, [pc, #44]	@ (8020d78 <dhcpc_init+0x38>)
 8020d4a:	f7f3 ff4d 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
  s.state = STATE_INITIAL;
 8020d4e:	2500      	movs	r5, #0
  uip_ipaddr(addr, 255,255,255,255);
 8020d50:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
  s.conn = uip_udp_new(&addr, HTONS(DHCPC_SERVER_PORT));
 8020d54:	f44f 4186 	mov.w	r1, #17152	@ 0x4300
 8020d58:	a801      	add	r0, sp, #4
  s.state = STATE_INITIAL;
 8020d5a:	70a5      	strb	r5, [r4, #2]
  uip_ipaddr(addr, 255,255,255,255);
 8020d5c:	9301      	str	r3, [sp, #4]
  s.conn = uip_udp_new(&addr, HTONS(DHCPC_SERVER_PORT));
 8020d5e:	f7fe fc13 	bl	801f588 <uip_udp_new>
 8020d62:	6060      	str	r0, [r4, #4]
  if(s.conn != NULL) {
 8020d64:	b110      	cbz	r0, 8020d6c <dhcpc_init+0x2c>
    uip_udp_bind(s.conn, HTONS(DHCPC_CLIENT_PORT));
 8020d66:	f44f 4388 	mov.w	r3, #17408	@ 0x4400
 8020d6a:	8083      	strh	r3, [r0, #4]
  }
  PT_INIT(&s.pt);
 8020d6c:	8025      	strh	r5, [r4, #0]
}
 8020d6e:	b003      	add	sp, #12
 8020d70:	bd30      	pop	{r4, r5, pc}
 8020d72:	bf00      	nop
 8020d74:	20007544 	.word	0x20007544
 8020d78:	080282fd 	.word	0x080282fd

08020d7c <dhcpc_appcall>:
/*---------------------------------------------------------------------------*/
void
dhcpc_appcall(void)
{
 8020d7c:	b570      	push	{r4, r5, r6, lr}
  PT_BEGIN(&s.pt);
 8020d7e:	4c5d      	ldr	r4, [pc, #372]	@ (8020ef4 <dhcpc_appcall+0x178>)
 8020d80:	8823      	ldrh	r3, [r4, #0]
 8020d82:	f240 1201 	movw	r2, #257	@ 0x101
 8020d86:	4293      	cmp	r3, r2
 8020d88:	f000 808e 	beq.w	8020ea8 <dhcpc_appcall+0x12c>
 8020d8c:	f5b3 7f81 	cmp.w	r3, #258	@ 0x102
 8020d90:	d205      	bcs.n	8020d9e <dhcpc_appcall+0x22>
 8020d92:	2b00      	cmp	r3, #0
 8020d94:	d045      	beq.n	8020e22 <dhcpc_appcall+0xa6>
 8020d96:	2bf0      	cmp	r3, #240	@ 0xf0
 8020d98:	d008      	beq.n	8020dac <dhcpc_appcall+0x30>
  PT_END(&s.pt);
 8020d9a:	2300      	movs	r3, #0
 8020d9c:	e06e      	b.n	8020e7c <dhcpc_appcall+0x100>
  PT_BEGIN(&s.pt);
 8020d9e:	f240 1229 	movw	r2, #297	@ 0x129
 8020da2:	4293      	cmp	r3, r2
 8020da4:	d1f9      	bne.n	8020d9a <dhcpc_appcall+0x1e>
    PT_YIELD(&s.pt);
 8020da6:	f240 1329 	movw	r3, #297	@ 0x129
 8020daa:	e067      	b.n	8020e7c <dhcpc_appcall+0x100>
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020dac:	4d52      	ldr	r5, [pc, #328]	@ (8020ef8 <dhcpc_appcall+0x17c>)
 8020dae:	782b      	ldrb	r3, [r5, #0]
 8020db0:	0798      	lsls	r0, r3, #30
 8020db2:	d565      	bpl.n	8020e80 <dhcpc_appcall+0x104>
    if(uip_newdata() && parse_msg() == DHCPOFFER) {
 8020db4:	f7ff ff6c 	bl	8020c90 <parse_msg>
 8020db8:	2802      	cmp	r0, #2
 8020dba:	d16a      	bne.n	8020e92 <dhcpc_appcall+0x116>
      s.state = STATE_OFFER_RECEIVED;
 8020dbc:	70a0      	strb	r0, [r4, #2]
  s.ticks = CLOCK_SECOND;
 8020dbe:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8020dc2:	8223      	strh	r3, [r4, #16]
  struct dhcp_msg *m = (struct dhcp_msg *)uip_appdata;
 8020dc4:	4e4d      	ldr	r6, [pc, #308]	@ (8020efc <dhcpc_appcall+0x180>)
 8020dc6:	6835      	ldr	r5, [r6, #0]
  create_msg(m);
 8020dc8:	4628      	mov	r0, r5
 8020dca:	f7ff ff21 	bl	8020c10 <create_msg>
  *optptr++ = DHCP_OPTION_MSG_TYPE;
 8020dce:	2335      	movs	r3, #53	@ 0x35
 8020dd0:	f885 30f0 	strb.w	r3, [r5, #240]	@ 0xf0
  *optptr++ = 1;
 8020dd4:	2301      	movs	r3, #1
 8020dd6:	f885 30f1 	strb.w	r3, [r5, #241]	@ 0xf1
  *optptr++ = type;
 8020dda:	2303      	movs	r3, #3
 8020ddc:	f885 30f2 	strb.w	r3, [r5, #242]	@ 0xf2
  *optptr++ = DHCP_OPTION_SERVER_ID;
 8020de0:	2336      	movs	r3, #54	@ 0x36
 8020de2:	f885 30f3 	strb.w	r3, [r5, #243]	@ 0xf3
  *optptr++ = 4;
 8020de6:	2304      	movs	r3, #4
  memcpy(optptr, s.serverid, 4);
 8020de8:	69e2      	ldr	r2, [r4, #28]
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020dea:	6830      	ldr	r0, [r6, #0]
  *optptr++ = 4;
 8020dec:	f885 30f4 	strb.w	r3, [r5, #244]	@ 0xf4
  *optptr++ = 4;
 8020df0:	f885 30fa 	strb.w	r3, [r5, #250]	@ 0xfa
  memcpy(optptr, s.ipaddr, 4);
 8020df4:	6a63      	ldr	r3, [r4, #36]	@ 0x24
  memcpy(optptr, s.serverid, 4);
 8020df6:	f8c5 20f5 	str.w	r2, [r5, #245]	@ 0xf5
  memcpy(optptr, s.ipaddr, 4);
 8020dfa:	f8c5 30fb 	str.w	r3, [r5, #251]	@ 0xfb
  *optptr++ = DHCP_OPTION_REQ_IPADDR;
 8020dfe:	2232      	movs	r2, #50	@ 0x32
  *optptr++ = DHCP_OPTION_END;
 8020e00:	23ff      	movs	r3, #255	@ 0xff
 8020e02:	f505 7180 	add.w	r1, r5, #256	@ 0x100
 8020e06:	f885 30ff 	strb.w	r3, [r5, #255]	@ 0xff
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020e0a:	1a09      	subs	r1, r1, r0
  *optptr++ = DHCP_OPTION_REQ_IPADDR;
 8020e0c:	f885 20f9 	strb.w	r2, [r5, #249]	@ 0xf9
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020e10:	f7ff f9ee 	bl	80201f0 <uip_send>
    timer_set(&s.timer, s.ticks);
 8020e14:	8a21      	ldrh	r1, [r4, #16]
 8020e16:	483a      	ldr	r0, [pc, #232]	@ (8020f00 <dhcpc_appcall+0x184>)
 8020e18:	f7ff fbc6 	bl	80205a8 <timer_set>
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020e1c:	f240 1301 	movw	r3, #257	@ 0x101
 8020e20:	e02c      	b.n	8020e7c <dhcpc_appcall+0x100>
  s.state = STATE_SENDING;
 8020e22:	2301      	movs	r3, #1
 8020e24:	70a3      	strb	r3, [r4, #2]
  s.ticks = CLOCK_SECOND;
 8020e26:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
 8020e2a:	8223      	strh	r3, [r4, #16]
  struct dhcp_msg *m = (struct dhcp_msg *)uip_appdata;
 8020e2c:	4e33      	ldr	r6, [pc, #204]	@ (8020efc <dhcpc_appcall+0x180>)
 8020e2e:	6835      	ldr	r5, [r6, #0]
  create_msg(m);
 8020e30:	4628      	mov	r0, r5
 8020e32:	f7ff feed 	bl	8020c10 <create_msg>
  *optptr++ = DHCP_OPTION_MSG_TYPE;
 8020e36:	2335      	movs	r3, #53	@ 0x35
 8020e38:	f885 30f0 	strb.w	r3, [r5, #240]	@ 0xf0
  *optptr++ = 1;
 8020e3c:	2301      	movs	r3, #1
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020e3e:	6830      	ldr	r0, [r6, #0]
  *optptr++ = 1;
 8020e40:	f885 30f1 	strb.w	r3, [r5, #241]	@ 0xf1
  *optptr++ = type;
 8020e44:	f885 30f2 	strb.w	r3, [r5, #242]	@ 0xf2
  *optptr++ = DHCP_OPTION_REQ_LIST;
 8020e48:	2237      	movs	r2, #55	@ 0x37
  *optptr++ = DHCP_OPTION_SUBNET_MASK;
 8020e4a:	f885 30f5 	strb.w	r3, [r5, #245]	@ 0xf5
  *optptr++ = DHCP_OPTION_DNS_SERVER;
 8020e4e:	2306      	movs	r3, #6
  *optptr++ = DHCP_OPTION_REQ_LIST;
 8020e50:	f885 20f3 	strb.w	r2, [r5, #243]	@ 0xf3
  *optptr++ = DHCP_OPTION_DNS_SERVER;
 8020e54:	f885 30f7 	strb.w	r3, [r5, #247]	@ 0xf7
  *optptr++ = 3;
 8020e58:	2203      	movs	r2, #3
  *optptr++ = DHCP_OPTION_END;
 8020e5a:	23ff      	movs	r3, #255	@ 0xff
 8020e5c:	f105 01f9 	add.w	r1, r5, #249	@ 0xf9
 8020e60:	f885 30f8 	strb.w	r3, [r5, #248]	@ 0xf8
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020e64:	1a09      	subs	r1, r1, r0
  *optptr++ = 3;
 8020e66:	f885 20f4 	strb.w	r2, [r5, #244]	@ 0xf4
  *optptr++ = DHCP_OPTION_ROUTER;
 8020e6a:	f885 20f6 	strb.w	r2, [r5, #246]	@ 0xf6
  uip_send(uip_appdata, end - (u8_t *)uip_appdata);
 8020e6e:	f7ff f9bf 	bl	80201f0 <uip_send>
    timer_set(&s.timer, s.ticks);
 8020e72:	8a21      	ldrh	r1, [r4, #16]
 8020e74:	4822      	ldr	r0, [pc, #136]	@ (8020f00 <dhcpc_appcall+0x184>)
 8020e76:	f7ff fb97 	bl	80205a8 <timer_set>
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020e7a:	23f0      	movs	r3, #240	@ 0xf0
  PT_END(&s.pt);
 8020e7c:	8023      	strh	r3, [r4, #0]
  handle_dhcp();
}
 8020e7e:	bd70      	pop	{r4, r5, r6, pc}
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020e80:	f104 0008 	add.w	r0, r4, #8
 8020e84:	f7ff fb9c 	bl	80205c0 <timer_expired>
 8020e88:	2800      	cmp	r0, #0
 8020e8a:	d0f8      	beq.n	8020e7e <dhcpc_appcall+0x102>
    if(uip_newdata() && parse_msg() == DHCPOFFER) {
 8020e8c:	782b      	ldrb	r3, [r5, #0]
 8020e8e:	0799      	lsls	r1, r3, #30
 8020e90:	d490      	bmi.n	8020db4 <dhcpc_appcall+0x38>
    if(s.ticks < CLOCK_SECOND * 60) {
 8020e92:	8a23      	ldrh	r3, [r4, #16]
 8020e94:	f64e 225f 	movw	r2, #59999	@ 0xea5f
 8020e98:	4293      	cmp	r3, r2
      s.ticks *= 2;
 8020e9a:	bf9c      	itt	ls
 8020e9c:	005b      	lslls	r3, r3, #1
 8020e9e:	8223      	strhls	r3, [r4, #16]
  } while(s.state != STATE_OFFER_RECEIVED);
 8020ea0:	78a3      	ldrb	r3, [r4, #2]
 8020ea2:	2b02      	cmp	r3, #2
 8020ea4:	d1c2      	bne.n	8020e2c <dhcpc_appcall+0xb0>
 8020ea6:	e78a      	b.n	8020dbe <dhcpc_appcall+0x42>
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020ea8:	4d13      	ldr	r5, [pc, #76]	@ (8020ef8 <dhcpc_appcall+0x17c>)
 8020eaa:	782b      	ldrb	r3, [r5, #0]
 8020eac:	079a      	lsls	r2, r3, #30
 8020eae:	d509      	bpl.n	8020ec4 <dhcpc_appcall+0x148>
    if(uip_newdata() && parse_msg() == DHCPACK) {
 8020eb0:	f7ff feee 	bl	8020c90 <parse_msg>
 8020eb4:	2805      	cmp	r0, #5
 8020eb6:	d10e      	bne.n	8020ed6 <dhcpc_appcall+0x15a>
      s.state = STATE_CONFIG_RECEIVED;
 8020eb8:	2303      	movs	r3, #3
 8020eba:	70a3      	strb	r3, [r4, #2]
  dhcpc_configured(&s);
 8020ebc:	480d      	ldr	r0, [pc, #52]	@ (8020ef4 <dhcpc_appcall+0x178>)
 8020ebe:	f7ff fe55 	bl	8020b6c <dhcpc_configured>
 8020ec2:	e770      	b.n	8020da6 <dhcpc_appcall+0x2a>
    PT_YIELD_UNTIL(&s.pt, uip_newdata() || timer_expired(&s.timer));
 8020ec4:	f104 0008 	add.w	r0, r4, #8
 8020ec8:	f7ff fb7a 	bl	80205c0 <timer_expired>
 8020ecc:	2800      	cmp	r0, #0
 8020ece:	d0d6      	beq.n	8020e7e <dhcpc_appcall+0x102>
    if(uip_newdata() && parse_msg() == DHCPACK) {
 8020ed0:	782b      	ldrb	r3, [r5, #0]
 8020ed2:	079b      	lsls	r3, r3, #30
 8020ed4:	d4ec      	bmi.n	8020eb0 <dhcpc_appcall+0x134>
    if(s.ticks <= CLOCK_SECOND * 10) {
 8020ed6:	8a23      	ldrh	r3, [r4, #16]
 8020ed8:	f242 7210 	movw	r2, #10000	@ 0x2710
 8020edc:	4293      	cmp	r3, r2
 8020ede:	f63f af5c 	bhi.w	8020d9a <dhcpc_appcall+0x1e>
      s.ticks += CLOCK_SECOND;
 8020ee2:	f503 737a 	add.w	r3, r3, #1000	@ 0x3e8
 8020ee6:	8223      	strh	r3, [r4, #16]
  } while(s.state != STATE_CONFIG_RECEIVED);
 8020ee8:	78a3      	ldrb	r3, [r4, #2]
 8020eea:	2b03      	cmp	r3, #3
 8020eec:	f47f af6a 	bne.w	8020dc4 <dhcpc_appcall+0x48>
 8020ef0:	e7e4      	b.n	8020ebc <dhcpc_appcall+0x140>
 8020ef2:	bf00      	nop
 8020ef4:	20007544 	.word	0x20007544
 8020ef8:	20006ebc 	.word	0x20006ebc
 8020efc:	20006ec8 	.word	0x20006ec8
 8020f00:	2000754c 	.word	0x2000754c
 8020f04:	00000000 	.word	0x00000000

08020f08 <OSC_SERVER_Method_EventPB>:

  return 0; // no error
}

static s32 OSC_SERVER_Method_EventPB(mios32_osc_args_t *osc_args, u32 method_arg)
{
 8020f08:	b538      	push	{r3, r4, r5, lr}
  MIOS32_OSC_SendDebugMessage(osc_args, method_arg);
  UIP_TASK_MUTEX_MIDIOUT_GIVE;
#endif

  // we expect at least 1 argument
  if( osc_args->num_args < 1 )
 8020f0a:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
{
 8020f0e:	460d      	mov	r5, r1
  if( osc_args->num_args < 1 )
 8020f10:	2b00      	cmp	r3, #0
 8020f12:	d047      	beq.n	8020fa4 <OSC_SERVER_Method_EventPB+0x9c>
  // get channel and status nibble
  int evnt0 = method_arg & 0xff;

  // get pitchbender value
  int value = 8192;
  if( osc_args->arg_type[0] == 'i' )
 8020f14:	f890 3031 	ldrb.w	r3, [r0, #49]	@ 0x31
 8020f18:	2b69      	cmp	r3, #105	@ 0x69
 8020f1a:	d107      	bne.n	8020f2c <OSC_SERVER_Method_EventPB+0x24>
    value = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 8020f1c:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8020f1e:	f7f4 fbd3 	bl	80156c8 <MIOS32_OSC_GetInt>
  else if( osc_args->arg_type[0] == 'f' )
    value = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 8191.0);
  value += 8192;
  if( value < 0 ) value = 0; else if( value > 16383 ) value = 16383;
 8020f22:	f510 5000 	adds.w	r0, r0, #8192	@ 0x2000
 8020f26:	d512      	bpl.n	8020f4e <OSC_SERVER_Method_EventPB+0x46>
 8020f28:	2000      	movs	r0, #0
 8020f2a:	e015      	b.n	8020f58 <OSC_SERVER_Method_EventPB+0x50>
  else if( osc_args->arg_type[0] == 'f' )
 8020f2c:	2b66      	cmp	r3, #102	@ 0x66
 8020f2e:	d10c      	bne.n	8020f4a <OSC_SERVER_Method_EventPB+0x42>
    value = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 8191.0);
 8020f30:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8020f32:	f7f4 fbcd 	bl	80156d0 <MIOS32_OSC_GetFloat>
 8020f36:	f001 fd43 	bl	80229c0 <__aeabi_f2d>
 8020f3a:	a31d      	add	r3, pc, #116	@ (adr r3, 8020fb0 <OSC_SERVER_Method_EventPB+0xa8>)
 8020f3c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020f40:	f001 fd96 	bl	8022a70 <__aeabi_dmul>
 8020f44:	f001 ffa6 	bl	8022e94 <__aeabi_d2iz>
 8020f48:	e7eb      	b.n	8020f22 <OSC_SERVER_Method_EventPB+0x1a>
  value += 8192;
 8020f4a:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
  if( value < 0 ) value = 0; else if( value > 16383 ) value = 16383;
 8020f4e:	f643 73ff 	movw	r3, #16383	@ 0x3fff
 8020f52:	4298      	cmp	r0, r3
 8020f54:	bfa8      	it	ge
 8020f56:	4618      	movge	r0, r3

  // build MIDI package
  mios32_midi_package_t p;
  p.ALL = 0;
  p.type = evnt0 >> 4;
 8020f58:	112b      	asrs	r3, r5, #4
  p.ALL = 0;
 8020f5a:	2400      	movs	r4, #0
  p.type = evnt0 >> 4;
 8020f5c:	f363 0403 	bfi	r4, r3, #0, #4
  p.evnt0 = evnt0;
 8020f60:	f365 240f 	bfi	r4, r5, #8, #8
  p.evnt1 = value & 0x7f;
 8020f64:	f000 037f 	and.w	r3, r0, #127	@ 0x7f
  p.evnt2 = (value >> 7) & 0x7f;

  // propagate to application
  // search for ports which are assigned to the MIDI value protocol
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8020f68:	4d13      	ldr	r5, [pc, #76]	@ (8020fb8 <OSC_SERVER_Method_EventPB+0xb0>)
  p.evnt1 = value & 0x7f;
 8020f6a:	f363 4417 	bfi	r4, r3, #16, #8
  p.evnt2 = (value >> 7) & 0x7f;
 8020f6e:	11c0      	asrs	r0, r0, #7
 8020f70:	f360 641f 	bfi	r4, r0, #24, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8020f74:	7828      	ldrb	r0, [r5, #0]
 8020f76:	f000 fbd5 	bl	8021724 <OSC_CLIENT_TransferModeGet>
  if( OSC_IGNORE_TRANSFER_MODE ||
      transfer_mode == OSC_CLIENT_TRANSFER_MODE_INT ||
 8020f7a:	3801      	subs	r0, #1
  if( OSC_IGNORE_TRANSFER_MODE ||
 8020f7c:	b2c0      	uxtb	r0, r0
 8020f7e:	2801      	cmp	r0, #1
 8020f80:	d901      	bls.n	8020f86 <OSC_SERVER_Method_EventPB+0x7e>
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
    UIP_TASK_MUTEX_MIDIIN_GIVE;
  }

  return 0; // no error
 8020f82:	2000      	movs	r0, #0
}
 8020f84:	bd38      	pop	{r3, r4, r5, pc}
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 8020f86:	7828      	ldrb	r0, [r5, #0]
 8020f88:	3040      	adds	r0, #64	@ 0x40
 8020f8a:	4621      	mov	r1, r4
 8020f8c:	b2c0      	uxtb	r0, r0
 8020f8e:	f7f3 fef7 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8020f92:	2800      	cmp	r0, #0
 8020f94:	dcf5      	bgt.n	8020f82 <OSC_SERVER_Method_EventPB+0x7a>
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
 8020f96:	7828      	ldrb	r0, [r5, #0]
 8020f98:	3040      	adds	r0, #64	@ 0x40
 8020f9a:	4621      	mov	r1, r4
 8020f9c:	b2c0      	uxtb	r0, r0
 8020f9e:	f7ef f90e 	bl	80101be <APP_MIDI_NotifyPackage>
 8020fa2:	e7ee      	b.n	8020f82 <OSC_SERVER_Method_EventPB+0x7a>
    return -1; // wrong number of arguments
 8020fa4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8020fa8:	e7ec      	b.n	8020f84 <OSC_SERVER_Method_EventPB+0x7c>
 8020faa:	bf00      	nop
 8020fac:	f3af 8000 	nop.w
 8020fb0:	00000000 	.word	0x00000000
 8020fb4:	40bfff00 	.word	0x40bfff00
 8020fb8:	20007580 	.word	0x20007580

08020fbc <OSC_SERVER_Method_EventNRPN>:

static s32 OSC_SERVER_Method_EventNRPN(mios32_osc_args_t *osc_args, u32 method_arg)
{
 8020fbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  MIOS32_OSC_SendDebugMessage(osc_args, method_arg);
  UIP_TASK_MUTEX_MIDIOUT_GIVE;
#endif

  // we expect at least 2 arguments
  if( osc_args->num_args < 2 )
 8020fc0:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
 8020fc4:	2b01      	cmp	r3, #1
{
 8020fc6:	4604      	mov	r4, r0
 8020fc8:	460e      	mov	r6, r1
  if( osc_args->num_args < 2 )
 8020fca:	d963      	bls.n	8021094 <OSC_SERVER_Method_EventNRPN+0xd8>
  // get channel and status nibble
  int evnt0 = method_arg & 0xff;

  // get NRPN number
  int nrpn_number = 0;
  if( osc_args->arg_type[0] == 'i' )
 8020fcc:	f890 3031 	ldrb.w	r3, [r0, #49]	@ 0x31
 8020fd0:	2b69      	cmp	r3, #105	@ 0x69
 8020fd2:	d11e      	bne.n	8021012 <OSC_SERVER_Method_EventNRPN+0x56>
    nrpn_number = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 8020fd4:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8020fd6:	f7f4 fb77 	bl	80156c8 <MIOS32_OSC_GetInt>
  else if( osc_args->arg_type[0] == 'f' )
    nrpn_number = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]));
 8020fda:	4605      	mov	r5, r0

  // get NRPN value
  int nrpn_value = 0;
  if( osc_args->arg_type[0] == 'i' )
 8020fdc:	f894 3031 	ldrb.w	r3, [r4, #49]	@ 0x31
 8020fe0:	2b69      	cmp	r3, #105	@ 0x69
 8020fe2:	d120      	bne.n	8021026 <OSC_SERVER_Method_EventNRPN+0x6a>
    nrpn_value = MIOS32_OSC_GetInt(osc_args->arg_ptr[1]);
 8020fe4:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8020fe6:	f7f4 fb6f 	bl	80156c8 <MIOS32_OSC_GetInt>
  else if( osc_args->arg_type[0] == 'f' )
    nrpn_value = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[1]));
 8020fea:	4604      	mov	r4, r0
  p.type = evnt0 >> 4;
  p.evnt0 = evnt0;

  // propagate to application
  // search for ports which are assigned to the MIDI value protocol
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8020fec:	f8df 80ac 	ldr.w	r8, [pc, #172]	@ 802109c <OSC_SERVER_Method_EventNRPN+0xe0>
  p.type = evnt0 >> 4;
 8020ff0:	1133      	asrs	r3, r6, #4
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8020ff2:	f898 0000 	ldrb.w	r0, [r8]
  p.ALL = 0;
 8020ff6:	2700      	movs	r7, #0
  p.type = evnt0 >> 4;
 8020ff8:	f363 0703 	bfi	r7, r3, #0, #4
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8020ffc:	f000 fb92 	bl	8021724 <OSC_CLIENT_TransferModeGet>
  if( OSC_IGNORE_TRANSFER_MODE ||
      transfer_mode == OSC_CLIENT_TRANSFER_MODE_INT ||
 8021000:	3801      	subs	r0, #1
  if( OSC_IGNORE_TRANSFER_MODE ||
 8021002:	b2c0      	uxtb	r0, r0
 8021004:	2801      	cmp	r0, #1
  p.evnt0 = evnt0;
 8021006:	f366 270f 	bfi	r7, r6, #8, #8
  if( OSC_IGNORE_TRANSFER_MODE ||
 802100a:	d916      	bls.n	802103a <OSC_SERVER_Method_EventNRPN+0x7e>
    }
    
    UIP_TASK_MUTEX_MIDIIN_GIVE;
  }

  return 0; // no error
 802100c:	2000      	movs	r0, #0
}
 802100e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if( osc_args->arg_type[0] == 'f' )
 8021012:	2b66      	cmp	r3, #102	@ 0x66
 8021014:	d105      	bne.n	8021022 <OSC_SERVER_Method_EventNRPN+0x66>
    nrpn_number = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]));
 8021016:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 8021018:	f7f4 fb5a 	bl	80156d0 <MIOS32_OSC_GetFloat>
 802101c:	f002 fa10 	bl	8023440 <__aeabi_f2iz>
 8021020:	e7db      	b.n	8020fda <OSC_SERVER_Method_EventNRPN+0x1e>
  int nrpn_number = 0;
 8021022:	2500      	movs	r5, #0
 8021024:	e7da      	b.n	8020fdc <OSC_SERVER_Method_EventNRPN+0x20>
  else if( osc_args->arg_type[0] == 'f' )
 8021026:	2b66      	cmp	r3, #102	@ 0x66
 8021028:	d105      	bne.n	8021036 <OSC_SERVER_Method_EventNRPN+0x7a>
    nrpn_value = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[1]));
 802102a:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 802102c:	f7f4 fb50 	bl	80156d0 <MIOS32_OSC_GetFloat>
 8021030:	f002 fa06 	bl	8023440 <__aeabi_f2iz>
 8021034:	e7d9      	b.n	8020fea <OSC_SERVER_Method_EventNRPN+0x2e>
  int nrpn_value = 0;
 8021036:	2400      	movs	r4, #0
 8021038:	e7d8      	b.n	8020fec <OSC_SERVER_Method_EventNRPN+0x30>
    for(i=0; i<4; ++i) {
 802103a:	2600      	movs	r6, #0
      switch( i ) {
 802103c:	2e02      	cmp	r6, #2
 802103e:	d021      	beq.n	8021084 <OSC_SERVER_Method_EventNRPN+0xc8>
 8021040:	2e03      	cmp	r6, #3
 8021042:	d023      	beq.n	802108c <OSC_SERVER_Method_EventNRPN+0xd0>
 8021044:	2e01      	cmp	r6, #1
	p.evnt2 = (nrpn_number >> 7) & 0x7f;
 8021046:	bf19      	ittee	ne
 8021048:	f3c5 13c6 	ubfxne	r3, r5, #7, #7
	break;
 802104c:	2263      	movne	r2, #99	@ 0x63
	p.evnt2 = (nrpn_number >> 0) & 0x7f;
 802104e:	f005 037f 	andeq.w	r3, r5, #127	@ 0x7f
	break;
 8021052:	2262      	moveq	r2, #98	@ 0x62
      if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 8021054:	f898 0000 	ldrb.w	r0, [r8]
	p.evnt1 = 0x26;
 8021058:	f362 4717 	bfi	r7, r2, #16, #8
	p.evnt2 = (nrpn_value >> 0) & 0x7f;
 802105c:	f363 671f 	bfi	r7, r3, #24, #8
      if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 8021060:	3040      	adds	r0, #64	@ 0x40
 8021062:	4639      	mov	r1, r7
 8021064:	b2c0      	uxtb	r0, r0
 8021066:	f7f3 fe8b 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 802106a:	2800      	cmp	r0, #0
 802106c:	dc06      	bgt.n	802107c <OSC_SERVER_Method_EventNRPN+0xc0>
	APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
 802106e:	f898 0000 	ldrb.w	r0, [r8]
 8021072:	3040      	adds	r0, #64	@ 0x40
 8021074:	4639      	mov	r1, r7
 8021076:	b2c0      	uxtb	r0, r0
 8021078:	f7ef f8a1 	bl	80101be <APP_MIDI_NotifyPackage>
    for(i=0; i<4; ++i) {
 802107c:	3601      	adds	r6, #1
 802107e:	2e04      	cmp	r6, #4
 8021080:	d1dc      	bne.n	802103c <OSC_SERVER_Method_EventNRPN+0x80>
 8021082:	e7c3      	b.n	802100c <OSC_SERVER_Method_EventNRPN+0x50>
	p.evnt2 = (nrpn_value >> 7) & 0x7f;
 8021084:	f3c4 13c6 	ubfx	r3, r4, #7, #7
	break;
 8021088:	2206      	movs	r2, #6
 802108a:	e7e3      	b.n	8021054 <OSC_SERVER_Method_EventNRPN+0x98>
	p.evnt2 = (nrpn_value >> 0) & 0x7f;
 802108c:	f004 037f 	and.w	r3, r4, #127	@ 0x7f
	break;
 8021090:	2226      	movs	r2, #38	@ 0x26
 8021092:	e7df      	b.n	8021054 <OSC_SERVER_Method_EventNRPN+0x98>
    return -1; // wrong number of arguments
 8021094:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021098:	e7b9      	b.n	802100e <OSC_SERVER_Method_EventNRPN+0x52>
 802109a:	bf00      	nop
 802109c:	20007580 	.word	0x20007580

080210a0 <OSC_SERVER_Method_Event>:
{
 80210a0:	b570      	push	{r4, r5, r6, lr}
  if( osc_args->num_args < 1 )
 80210a2:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
{
 80210a6:	4604      	mov	r4, r0
 80210a8:	460e      	mov	r6, r1
  if( osc_args->num_args < 1 )
 80210aa:	2b00      	cmp	r3, #0
 80210ac:	d061      	beq.n	8021172 <OSC_SERVER_Method_Event+0xd2>
  if( osc_args->arg_type[0] == 'i' )
 80210ae:	f890 3031 	ldrb.w	r3, [r0, #49]	@ 0x31
 80210b2:	2b69      	cmp	r3, #105	@ 0x69
 80210b4:	d106      	bne.n	80210c4 <OSC_SERVER_Method_Event+0x24>
    note = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 80210b6:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 80210b8:	f7f4 fb06 	bl	80156c8 <MIOS32_OSC_GetInt>
  if( note < 0 ) note = 0; else if( note > 127 ) note = 127;
 80210bc:	2800      	cmp	r0, #0
 80210be:	da11      	bge.n	80210e4 <OSC_SERVER_Method_Event+0x44>
 80210c0:	2500      	movs	r5, #0
 80210c2:	e013      	b.n	80210ec <OSC_SERVER_Method_Event+0x4c>
  else if( osc_args->arg_type[0] == 'f' )
 80210c4:	2b66      	cmp	r3, #102	@ 0x66
 80210c6:	d10c      	bne.n	80210e2 <OSC_SERVER_Method_Event+0x42>
    note = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 127.0);
 80210c8:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 80210ca:	f7f4 fb01 	bl	80156d0 <MIOS32_OSC_GetFloat>
 80210ce:	f001 fc77 	bl	80229c0 <__aeabi_f2d>
 80210d2:	a329      	add	r3, pc, #164	@ (adr r3, 8021178 <OSC_SERVER_Method_Event+0xd8>)
 80210d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80210d8:	f001 fcca 	bl	8022a70 <__aeabi_dmul>
 80210dc:	f001 feda 	bl	8022e94 <__aeabi_d2iz>
 80210e0:	e7ec      	b.n	80210bc <OSC_SERVER_Method_Event+0x1c>
  int note = 60;
 80210e2:	203c      	movs	r0, #60	@ 0x3c
  if( note < 0 ) note = 0; else if( note > 127 ) note = 127;
 80210e4:	287f      	cmp	r0, #127	@ 0x7f
 80210e6:	bfa8      	it	ge
 80210e8:	207f      	movge	r0, #127	@ 0x7f
 80210ea:	4605      	mov	r5, r0
  if( osc_args->num_args >= 2 ) {
 80210ec:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 80210f0:	2b01      	cmp	r3, #1
 80210f2:	d92d      	bls.n	8021150 <OSC_SERVER_Method_Event+0xb0>
    if( osc_args->arg_type[1] == 'i' )
 80210f4:	f894 3032 	ldrb.w	r3, [r4, #50]	@ 0x32
 80210f8:	2b69      	cmp	r3, #105	@ 0x69
 80210fa:	d11a      	bne.n	8021132 <OSC_SERVER_Method_Event+0x92>
      velocity = MIOS32_OSC_GetInt(osc_args->arg_ptr[1]);
 80210fc:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 80210fe:	f7f4 fae3 	bl	80156c8 <MIOS32_OSC_GetInt>
    if( velocity < 0 ) velocity = 0; else if( velocity > 127 ) velocity = 127;
 8021102:	f380 0307 	usat	r3, #7, r0
  p.type = evnt0 >> 4;
 8021106:	1132      	asrs	r2, r6, #4
  p.ALL = 0;
 8021108:	2400      	movs	r4, #0
  p.type = evnt0 >> 4;
 802110a:	f362 0403 	bfi	r4, r2, #0, #4
  p.evnt0 = evnt0;
 802110e:	f366 240f 	bfi	r4, r6, #8, #8
  p.evnt1 = note;
 8021112:	f365 4417 	bfi	r4, r5, #16, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8021116:	4d1a      	ldr	r5, [pc, #104]	@ (8021180 <OSC_SERVER_Method_Event+0xe0>)
 8021118:	7828      	ldrb	r0, [r5, #0]
  p.evnt2 = velocity;
 802111a:	f363 641f 	bfi	r4, r3, #24, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 802111e:	f000 fb01 	bl	8021724 <OSC_CLIENT_TransferModeGet>
      transfer_mode == OSC_CLIENT_TRANSFER_MODE_INT ||
 8021122:	1e43      	subs	r3, r0, #1
  if( OSC_IGNORE_TRANSFER_MODE ||
 8021124:	b2db      	uxtb	r3, r3
 8021126:	2b01      	cmp	r3, #1
 8021128:	d914      	bls.n	8021154 <OSC_SERVER_Method_Event+0xb4>
      transfer_mode == OSC_CLIENT_TRANSFER_MODE_FLOAT ||
 802112a:	2804      	cmp	r0, #4
 802112c:	d012      	beq.n	8021154 <OSC_SERVER_Method_Event+0xb4>
  return 0; // no error
 802112e:	2000      	movs	r0, #0
}
 8021130:	bd70      	pop	{r4, r5, r6, pc}
    else if( osc_args->arg_type[1] == 'f' )
 8021132:	2b66      	cmp	r3, #102	@ 0x66
 8021134:	d10c      	bne.n	8021150 <OSC_SERVER_Method_Event+0xb0>
      velocity = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[1]) * 127.0);
 8021136:	6c20      	ldr	r0, [r4, #64]	@ 0x40
 8021138:	f7f4 faca 	bl	80156d0 <MIOS32_OSC_GetFloat>
 802113c:	f001 fc40 	bl	80229c0 <__aeabi_f2d>
 8021140:	a30d      	add	r3, pc, #52	@ (adr r3, 8021178 <OSC_SERVER_Method_Event+0xd8>)
 8021142:	e9d3 2300 	ldrd	r2, r3, [r3]
 8021146:	f001 fc93 	bl	8022a70 <__aeabi_dmul>
 802114a:	f001 fea3 	bl	8022e94 <__aeabi_d2iz>
 802114e:	e7d8      	b.n	8021102 <OSC_SERVER_Method_Event+0x62>
  int velocity = 127;
 8021150:	237f      	movs	r3, #127	@ 0x7f
 8021152:	e7d8      	b.n	8021106 <OSC_SERVER_Method_Event+0x66>
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 8021154:	7828      	ldrb	r0, [r5, #0]
 8021156:	3040      	adds	r0, #64	@ 0x40
 8021158:	4621      	mov	r1, r4
 802115a:	b2c0      	uxtb	r0, r0
 802115c:	f7f3 fe10 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8021160:	2800      	cmp	r0, #0
 8021162:	dce4      	bgt.n	802112e <OSC_SERVER_Method_Event+0x8e>
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
 8021164:	7828      	ldrb	r0, [r5, #0]
 8021166:	3040      	adds	r0, #64	@ 0x40
 8021168:	4621      	mov	r1, r4
 802116a:	b2c0      	uxtb	r0, r0
 802116c:	f7ef f827 	bl	80101be <APP_MIDI_NotifyPackage>
 8021170:	e7dd      	b.n	802112e <OSC_SERVER_Method_Event+0x8e>
    return -1; // wrong number of arguments
 8021172:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021176:	e7db      	b.n	8021130 <OSC_SERVER_Method_Event+0x90>
 8021178:	00000000 	.word	0x00000000
 802117c:	405fc000 	.word	0x405fc000
 8021180:	20007580 	.word	0x20007580
 8021184:	00000000 	.word	0x00000000

08021188 <OSC_SERVER_Method_EventTOSC>:

static s32 OSC_SERVER_Method_EventTOSC(mios32_osc_args_t *osc_args, u32 method_arg)
{
 8021188:	b570      	push	{r4, r5, r6, lr}
 802118a:	4604      	mov	r4, r0
  // check for TouchOSC format (note/CC number coded in path)
  // extract value and channel from original path
  // format: /<chn>/name_<value>
  // /<chn> and /name have already been parsed, we only need the last value
  char *path_values = (char *)osc_args->original_path;
  if( (path_values = strchr(path_values+1, '_')) == NULL )
 802118c:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
{
 802118e:	460d      	mov	r5, r1
  if( (path_values = strchr(path_values+1, '_')) == NULL )
 8021190:	3001      	adds	r0, #1
 8021192:	215f      	movs	r1, #95	@ 0x5f
 8021194:	f002 f97a 	bl	802348c <strchr>
 8021198:	2800      	cmp	r0, #0
 802119a:	d046      	beq.n	802122a <OSC_SERVER_Method_EventTOSC+0xa2>
    return -1;

  // get value
  int note = 60;
  note = atoi(path_values+1);
 802119c:	3001      	adds	r0, #1
 802119e:	f002 f9e0 	bl	8023562 <atoi>
  if( note < 0 ) note = 0; else if( note > 127 ) note = 127;

  // get velocity
  int velocity = 127;
  if( osc_args->num_args >= 1 ) {
 80211a2:	f894 3030 	ldrb.w	r3, [r4, #48]	@ 0x30
 80211a6:	f380 0607 	usat	r6, #7, r0
 80211aa:	b1cb      	cbz	r3, 80211e0 <OSC_SERVER_Method_EventTOSC+0x58>
    if( osc_args->arg_type[0] == 'i' )
 80211ac:	f894 3031 	ldrb.w	r3, [r4, #49]	@ 0x31
 80211b0:	2b69      	cmp	r3, #105	@ 0x69
 80211b2:	d106      	bne.n	80211c2 <OSC_SERVER_Method_EventTOSC+0x3a>
      velocity = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 80211b4:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 80211b6:	f7f4 fa87 	bl	80156c8 <MIOS32_OSC_GetInt>
    else if( osc_args->arg_type[0] == 'f' )
      velocity = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 127.0);
  }
  if( velocity < 0 ) velocity = 0; else if( velocity > 127 ) velocity = 127;
 80211ba:	2800      	cmp	r0, #0
 80211bc:	da11      	bge.n	80211e2 <OSC_SERVER_Method_EventTOSC+0x5a>
 80211be:	2000      	movs	r0, #0
 80211c0:	e012      	b.n	80211e8 <OSC_SERVER_Method_EventTOSC+0x60>
    else if( osc_args->arg_type[0] == 'f' )
 80211c2:	2b66      	cmp	r3, #102	@ 0x66
 80211c4:	d10c      	bne.n	80211e0 <OSC_SERVER_Method_EventTOSC+0x58>
      velocity = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 127.0);
 80211c6:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 80211c8:	f7f4 fa82 	bl	80156d0 <MIOS32_OSC_GetFloat>
 80211cc:	f001 fbf8 	bl	80229c0 <__aeabi_f2d>
 80211d0:	a317      	add	r3, pc, #92	@ (adr r3, 8021230 <OSC_SERVER_Method_EventTOSC+0xa8>)
 80211d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80211d6:	f001 fc4b 	bl	8022a70 <__aeabi_dmul>
 80211da:	f001 fe5b 	bl	8022e94 <__aeabi_d2iz>
 80211de:	e7ec      	b.n	80211ba <OSC_SERVER_Method_EventTOSC+0x32>
  int velocity = 127;
 80211e0:	207f      	movs	r0, #127	@ 0x7f
  if( velocity < 0 ) velocity = 0; else if( velocity > 127 ) velocity = 127;
 80211e2:	287f      	cmp	r0, #127	@ 0x7f
 80211e4:	bfa8      	it	ge
 80211e6:	207f      	movge	r0, #127	@ 0x7f

  // build MIDI package
  mios32_midi_package_t p;
  p.ALL = 0;
  p.type = evnt0 >> 4;
 80211e8:	112b      	asrs	r3, r5, #4
  p.ALL = 0;
 80211ea:	2400      	movs	r4, #0
  p.type = evnt0 >> 4;
 80211ec:	f363 0403 	bfi	r4, r3, #0, #4
  p.evnt0 = evnt0;
 80211f0:	f365 240f 	bfi	r4, r5, #8, #8
  p.evnt1 = note;
  p.evnt2 = velocity;

  // propagate to application
  // search for ports which are assigned to the MIDI value protocol
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 80211f4:	4d10      	ldr	r5, [pc, #64]	@ (8021238 <OSC_SERVER_Method_EventTOSC+0xb0>)
  p.evnt1 = note;
 80211f6:	f366 4417 	bfi	r4, r6, #16, #8
  p.evnt2 = velocity;
 80211fa:	f360 641f 	bfi	r4, r0, #24, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 80211fe:	7828      	ldrb	r0, [r5, #0]
 8021200:	f000 fa90 	bl	8021724 <OSC_CLIENT_TransferModeGet>
  if( OSC_IGNORE_TRANSFER_MODE ||
 8021204:	2804      	cmp	r0, #4
 8021206:	d001      	beq.n	802120c <OSC_SERVER_Method_EventTOSC+0x84>
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
    UIP_TASK_MUTEX_MIDIIN_GIVE;
  }

  return 0; // no error
 8021208:	2000      	movs	r0, #0
}
 802120a:	bd70      	pop	{r4, r5, r6, pc}
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 802120c:	7828      	ldrb	r0, [r5, #0]
 802120e:	3040      	adds	r0, #64	@ 0x40
 8021210:	4621      	mov	r1, r4
 8021212:	b2c0      	uxtb	r0, r0
 8021214:	f7f3 fdb4 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8021218:	2800      	cmp	r0, #0
 802121a:	dcf5      	bgt.n	8021208 <OSC_SERVER_Method_EventTOSC+0x80>
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
 802121c:	7828      	ldrb	r0, [r5, #0]
 802121e:	3040      	adds	r0, #64	@ 0x40
 8021220:	4621      	mov	r1, r4
 8021222:	b2c0      	uxtb	r0, r0
 8021224:	f7ee ffcb 	bl	80101be <APP_MIDI_NotifyPackage>
 8021228:	e7ee      	b.n	8021208 <OSC_SERVER_Method_EventTOSC+0x80>
    return -1;
 802122a:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 802122e:	e7ec      	b.n	802120a <OSC_SERVER_Method_EventTOSC+0x82>
 8021230:	00000000 	.word	0x00000000
 8021234:	405fc000 	.word	0x405fc000
 8021238:	20007580 	.word	0x20007580
 802123c:	00000000 	.word	0x00000000

08021240 <OSC_SERVER_Method_MCMPP>:
{
 8021240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if( osc_args->num_args < 1 )
 8021242:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
{
 8021246:	4606      	mov	r6, r0
 8021248:	460c      	mov	r4, r1
  if( osc_args->num_args < 1 )
 802124a:	2b00      	cmp	r3, #0
 802124c:	f000 8092 	beq.w	8021374 <OSC_SERVER_Method_MCMPP+0x134>
    if( (path_values = strchr(path_values+1, '/')) == NULL )
 8021250:	6ac0      	ldr	r0, [r0, #44]	@ 0x2c
 8021252:	212f      	movs	r1, #47	@ 0x2f
 8021254:	3001      	adds	r0, #1
 8021256:	f002 f919 	bl	802348c <strchr>
 802125a:	b910      	cbnz	r0, 8021262 <OSC_SERVER_Method_MCMPP+0x22>
      return -2; // invalid format
 802125c:	f06f 0001 	mvn.w	r0, #1
}
 8021260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( (path_values = strchr(path_values+1, '/')) == NULL )
 8021262:	212f      	movs	r1, #47	@ 0x2f
 8021264:	3001      	adds	r0, #1
 8021266:	f002 f911 	bl	802348c <strchr>
 802126a:	4607      	mov	r7, r0
 802126c:	2800      	cmp	r0, #0
 802126e:	d0f5      	beq.n	802125c <OSC_SERVER_Method_MCMPP+0x1c>
  if( method_arg < 0xc0 ) {
 8021270:	2cbf      	cmp	r4, #191	@ 0xbf
  ++path_values;
 8021272:	f100 0001 	add.w	r0, r0, #1
  if( method_arg < 0xc0 ) {
 8021276:	d827      	bhi.n	80212c8 <OSC_SERVER_Method_MCMPP+0x88>
    note = atoi(path_values);
 8021278:	f002 f973 	bl	8023562 <atoi>
    if( (path_values = strchr(path_values+1, '/')) == NULL )
 802127c:	212f      	movs	r1, #47	@ 0x2f
    note = atoi(path_values);
 802127e:	4605      	mov	r5, r0
    if( (path_values = strchr(path_values+1, '/')) == NULL )
 8021280:	1cb8      	adds	r0, r7, #2
 8021282:	f002 f903 	bl	802348c <strchr>
 8021286:	2800      	cmp	r0, #0
 8021288:	d0e8      	beq.n	802125c <OSC_SERVER_Method_MCMPP+0x1c>
    ++path_values;
 802128a:	3001      	adds	r0, #1
  int chn = atoi(path_values) - 1;
 802128c:	f002 f969 	bl	8023562 <atoi>
 8021290:	3801      	subs	r0, #1
  if( chn < 0 || chn >= 15 )
 8021292:	280e      	cmp	r0, #14
 8021294:	d871      	bhi.n	802137a <OSC_SERVER_Method_MCMPP+0x13a>
  int evnt0 = (method_arg & 0xf0) | chn;
 8021296:	f004 01f0 	and.w	r1, r4, #240	@ 0xf0
 802129a:	4301      	orrs	r1, r0
  p.type = evnt0 >> 4;
 802129c:	110b      	asrs	r3, r1, #4
  p.ALL = 0;
 802129e:	2400      	movs	r4, #0
  p.type = evnt0 >> 4;
 80212a0:	f363 0403 	bfi	r4, r3, #0, #4
  p.evnt0 = evnt0;
 80212a4:	f361 240f 	bfi	r4, r1, #8, #8
  if( (evnt0 & 0xf0) == 0xe0 ) {
 80212a8:	f001 01f0 	and.w	r1, r1, #240	@ 0xf0
 80212ac:	29e0      	cmp	r1, #224	@ 0xe0
    if( osc_args->arg_type[0] == 'i' )
 80212ae:	f896 3031 	ldrb.w	r3, [r6, #49]	@ 0x31
  if( (evnt0 & 0xf0) == 0xe0 ) {
 80212b2:	d131      	bne.n	8021318 <OSC_SERVER_Method_MCMPP+0xd8>
    if( osc_args->arg_type[0] == 'i' )
 80212b4:	2b69      	cmp	r3, #105	@ 0x69
 80212b6:	d109      	bne.n	80212cc <OSC_SERVER_Method_MCMPP+0x8c>
      pitch = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 80212b8:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 80212ba:	f7f4 fa05 	bl	80156c8 <MIOS32_OSC_GetInt>
    if( pitch < 0 ) pitch = 0; else if( pitch > 16383 ) pitch = 16383;
 80212be:	f510 5000 	adds.w	r0, r0, #8192	@ 0x2000
 80212c2:	d514      	bpl.n	80212ee <OSC_SERVER_Method_MCMPP+0xae>
 80212c4:	2000      	movs	r0, #0
 80212c6:	e017      	b.n	80212f8 <OSC_SERVER_Method_MCMPP+0xb8>
  int note = 0;
 80212c8:	2500      	movs	r5, #0
 80212ca:	e7df      	b.n	802128c <OSC_SERVER_Method_MCMPP+0x4c>
    else if( osc_args->arg_type[0] == 'f' )
 80212cc:	2b66      	cmp	r3, #102	@ 0x66
 80212ce:	d10c      	bne.n	80212ea <OSC_SERVER_Method_MCMPP+0xaa>
      pitch = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 8191.0);
 80212d0:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 80212d2:	f7f4 f9fd 	bl	80156d0 <MIOS32_OSC_GetFloat>
 80212d6:	f001 fb73 	bl	80229c0 <__aeabi_f2d>
 80212da:	a329      	add	r3, pc, #164	@ (adr r3, 8021380 <OSC_SERVER_Method_MCMPP+0x140>)
 80212dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 80212e0:	f001 fbc6 	bl	8022a70 <__aeabi_dmul>
 80212e4:	f001 fdd6 	bl	8022e94 <__aeabi_d2iz>
 80212e8:	e7e9      	b.n	80212be <OSC_SERVER_Method_MCMPP+0x7e>
    pitch += 8192;
 80212ea:	f44f 4080 	mov.w	r0, #16384	@ 0x4000
    if( pitch < 0 ) pitch = 0; else if( pitch > 16383 ) pitch = 16383;
 80212ee:	f643 73ff 	movw	r3, #16383	@ 0x3fff
 80212f2:	4298      	cmp	r0, r3
 80212f4:	bfa8      	it	ge
 80212f6:	4618      	movge	r0, r3
    p.evnt1 = pitch & 0x7f;
 80212f8:	f000 057f 	and.w	r5, r0, #127	@ 0x7f
    p.evnt2 = (pitch >> 7) & 0x7f;
 80212fc:	f3c0 10c7 	ubfx	r0, r0, #7, #8
    p.evnt1 = pitch & 0x7f;
 8021300:	f365 4417 	bfi	r4, r5, #16, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 8021304:	4d22      	ldr	r5, [pc, #136]	@ (8021390 <OSC_SERVER_Method_MCMPP+0x150>)
    p.evnt2 = (pitch >> 7) & 0x7f;
 8021306:	f360 641f 	bfi	r4, r0, #24, #8
  u8 transfer_mode = OSC_CLIENT_TransferModeGet(osc_parsed_from_con);
 802130a:	7828      	ldrb	r0, [r5, #0]
 802130c:	f000 fa0a 	bl	8021724 <OSC_CLIENT_TransferModeGet>
  if( OSC_IGNORE_TRANSFER_MODE || transfer_mode == OSC_CLIENT_TRANSFER_MODE_MCMPP ) {
 8021310:	2803      	cmp	r0, #3
 8021312:	d020      	beq.n	8021356 <OSC_SERVER_Method_MCMPP+0x116>
  return 0; // no error
 8021314:	2000      	movs	r0, #0
 8021316:	e7a3      	b.n	8021260 <OSC_SERVER_Method_MCMPP+0x20>
    if( osc_args->arg_type[0] == 'i' )
 8021318:	2b69      	cmp	r3, #105	@ 0x69
 802131a:	d106      	bne.n	802132a <OSC_SERVER_Method_MCMPP+0xea>
      velocity = MIOS32_OSC_GetInt(osc_args->arg_ptr[0]);
 802131c:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 802131e:	f7f4 f9d3 	bl	80156c8 <MIOS32_OSC_GetInt>
    if( velocity < 0 ) velocity = 0; else if( velocity > 127 ) velocity = 127;
 8021322:	2800      	cmp	r0, #0
 8021324:	da11      	bge.n	802134a <OSC_SERVER_Method_MCMPP+0x10a>
 8021326:	2000      	movs	r0, #0
 8021328:	e012      	b.n	8021350 <OSC_SERVER_Method_MCMPP+0x110>
    else if( osc_args->arg_type[0] == 'f' )
 802132a:	2b66      	cmp	r3, #102	@ 0x66
 802132c:	d10c      	bne.n	8021348 <OSC_SERVER_Method_MCMPP+0x108>
      velocity = (int)(MIOS32_OSC_GetFloat(osc_args->arg_ptr[0]) * 127.0);
 802132e:	6bf0      	ldr	r0, [r6, #60]	@ 0x3c
 8021330:	f7f4 f9ce 	bl	80156d0 <MIOS32_OSC_GetFloat>
 8021334:	f001 fb44 	bl	80229c0 <__aeabi_f2d>
 8021338:	a313      	add	r3, pc, #76	@ (adr r3, 8021388 <OSC_SERVER_Method_MCMPP+0x148>)
 802133a:	e9d3 2300 	ldrd	r2, r3, [r3]
 802133e:	f001 fb97 	bl	8022a70 <__aeabi_dmul>
 8021342:	f001 fda7 	bl	8022e94 <__aeabi_d2iz>
 8021346:	e7ec      	b.n	8021322 <OSC_SERVER_Method_MCMPP+0xe2>
    int velocity = 127;
 8021348:	207f      	movs	r0, #127	@ 0x7f
    if( velocity < 0 ) velocity = 0; else if( velocity > 127 ) velocity = 127;
 802134a:	287f      	cmp	r0, #127	@ 0x7f
 802134c:	bfa8      	it	ge
 802134e:	207f      	movge	r0, #127	@ 0x7f
    p.evnt1 = note;
 8021350:	b2ed      	uxtb	r5, r5
    p.evnt2 = velocity;
 8021352:	b2c0      	uxtb	r0, r0
 8021354:	e7d4      	b.n	8021300 <OSC_SERVER_Method_MCMPP+0xc0>
    if( MIOS32_MIDI_SendPackageToRxCallback(OSC0 + osc_parsed_from_con, p) < 1 )
 8021356:	7828      	ldrb	r0, [r5, #0]
 8021358:	3040      	adds	r0, #64	@ 0x40
 802135a:	4621      	mov	r1, r4
 802135c:	b2c0      	uxtb	r0, r0
 802135e:	f7f3 fd0f 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 8021362:	2800      	cmp	r0, #0
 8021364:	dcd6      	bgt.n	8021314 <OSC_SERVER_Method_MCMPP+0xd4>
      APP_MIDI_NotifyPackage(OSC0 + osc_parsed_from_con, p);
 8021366:	7828      	ldrb	r0, [r5, #0]
 8021368:	3040      	adds	r0, #64	@ 0x40
 802136a:	4621      	mov	r1, r4
 802136c:	b2c0      	uxtb	r0, r0
 802136e:	f7ee ff26 	bl	80101be <APP_MIDI_NotifyPackage>
 8021372:	e7cf      	b.n	8021314 <OSC_SERVER_Method_MCMPP+0xd4>
    return -1; // wrong number of arguments
 8021374:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021378:	e772      	b.n	8021260 <OSC_SERVER_Method_MCMPP+0x20>
    return -3; // invalid channel
 802137a:	f06f 0002 	mvn.w	r0, #2
 802137e:	e76f      	b.n	8021260 <OSC_SERVER_Method_MCMPP+0x20>
 8021380:	00000000 	.word	0x00000000
 8021384:	40bfff00 	.word	0x40bfff00
 8021388:	00000000 	.word	0x00000000
 802138c:	405fc000 	.word	0x405fc000
 8021390:	20007580 	.word	0x20007580

08021394 <OSC_SERVER_Method_MIDI>:
{
 8021394:	b570      	push	{r4, r5, r6, lr}
  u8 con = method_arg & 0xf;
 8021396:	b2cd      	uxtb	r5, r1
  if( con > OSC_SERVER_NUM_CONNECTIONS )
 8021398:	f001 010f 	and.w	r1, r1, #15
 802139c:	2904      	cmp	r1, #4
{
 802139e:	4604      	mov	r4, r0
  if( con > OSC_SERVER_NUM_CONNECTIONS )
 80213a0:	d83d      	bhi.n	802141e <OSC_SERVER_Method_MIDI+0x8a>
  if( osc_args->num_args < 1 )
 80213a2:	f890 3030 	ldrb.w	r3, [r0, #48]	@ 0x30
 80213a6:	2b00      	cmp	r3, #0
 80213a8:	d03c      	beq.n	8021424 <OSC_SERVER_Method_MIDI+0x90>
  if( osc_args->arg_type[0] == 'm' ) {
 80213aa:	f890 3031 	ldrb.w	r3, [r0, #49]	@ 0x31
 80213ae:	2b6d      	cmp	r3, #109	@ 0x6d
 80213b0:	d11f      	bne.n	80213f2 <OSC_SERVER_Method_MIDI+0x5e>
    mios32_midi_package_t p = MIOS32_OSC_GetMIDI(osc_args->arg_ptr[0]);
 80213b2:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 80213b4:	f7f4 f9bc 	bl	8015730 <MIOS32_OSC_GetMIDI>
 80213b8:	f3c0 2307 	ubfx	r3, r0, #8, #8
    if( p.evnt0 >= 0xf0 || p.evnt0 < 0x80 ) {
 80213bc:	f083 0280 	eor.w	r2, r3, #128	@ 0x80
 80213c0:	2a6f      	cmp	r2, #111	@ 0x6f
    mios32_midi_package_t p = MIOS32_OSC_GetMIDI(osc_args->arg_ptr[0]);
 80213c2:	4604      	mov	r4, r0
    if( p.evnt0 >= 0xf0 || p.evnt0 < 0x80 ) {
 80213c4:	d913      	bls.n	80213ee <OSC_SERVER_Method_MIDI+0x5a>
      if( p.evnt0 == 0xf1 || p.evnt0 == 0xf3 )
 80213c6:	f003 03fd 	and.w	r3, r3, #253	@ 0xfd
 80213ca:	2bf1      	cmp	r3, #241	@ 0xf1
 80213cc:	bf0c      	ite	eq
 80213ce:	2302      	moveq	r3, #2
 80213d0:	2303      	movne	r3, #3
	p.cin = 3; // three byte system common message
 80213d2:	f363 0403 	bfi	r4, r3, #0, #4
    if( MIOS32_MIDI_SendPackageToRxCallback(method_arg, p) < 1 )
 80213d6:	4621      	mov	r1, r4
 80213d8:	4628      	mov	r0, r5
 80213da:	f7f3 fcd1 	bl	8014d80 <MIOS32_MIDI_SendPackageToRxCallback>
 80213de:	2800      	cmp	r0, #0
 80213e0:	dc03      	bgt.n	80213ea <OSC_SERVER_Method_MIDI+0x56>
      APP_MIDI_NotifyPackage(method_arg, p);
 80213e2:	4621      	mov	r1, r4
 80213e4:	4628      	mov	r0, r5
 80213e6:	f7ee feea 	bl	80101be <APP_MIDI_NotifyPackage>
  return 0; // no error
 80213ea:	2000      	movs	r0, #0
}
 80213ec:	bd70      	pop	{r4, r5, r6, pc}
      p.cin = p.evnt0 >> 4;
 80213ee:	091b      	lsrs	r3, r3, #4
 80213f0:	e7ef      	b.n	80213d2 <OSC_SERVER_Method_MIDI+0x3e>
  } else  if( osc_args->arg_type[0] == 'b' ) {
 80213f2:	2b62      	cmp	r3, #98	@ 0x62
 80213f4:	d116      	bne.n	8021424 <OSC_SERVER_Method_MIDI+0x90>
    u32 len = MIOS32_OSC_GetBlobLength(osc_args->arg_ptr[0]);
 80213f6:	6bc0      	ldr	r0, [r0, #60]	@ 0x3c
 80213f8:	f7f4 f97b 	bl	80156f2 <MIOS32_OSC_GetBlobLength>
 80213fc:	4606      	mov	r6, r0
    u8 *blob = MIOS32_OSC_GetBlobData(osc_args->arg_ptr[0]);
 80213fe:	6be0      	ldr	r0, [r4, #60]	@ 0x3c
 8021400:	f7f4 f979 	bl	80156f6 <MIOS32_OSC_GetBlobData>
 8021404:	4604      	mov	r4, r0
    for(i=0; i<len; ++i, blob++) {
 8021406:	4406      	add	r6, r0
 8021408:	42b4      	cmp	r4, r6
 802140a:	d0ee      	beq.n	80213ea <OSC_SERVER_Method_MIDI+0x56>
      APP_SYSEX_Parser(method_arg, *blob);
 802140c:	7821      	ldrb	r1, [r4, #0]
 802140e:	4628      	mov	r0, r5
 8021410:	f7ee fe23 	bl	801005a <APP_SYSEX_Parser>
      if( *blob == 0xf7 )
 8021414:	f814 3b01 	ldrb.w	r3, [r4], #1
 8021418:	2bf7      	cmp	r3, #247	@ 0xf7
 802141a:	d1f5      	bne.n	8021408 <OSC_SERVER_Method_MIDI+0x74>
 802141c:	e7e5      	b.n	80213ea <OSC_SERVER_Method_MIDI+0x56>
    return -1; // wrong port
 802141e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021422:	e7e3      	b.n	80213ec <OSC_SERVER_Method_MIDI+0x58>
    return -2; // wrong number of arguments
 8021424:	f06f 0001 	mvn.w	r0, #1
 8021428:	e7e0      	b.n	80213ec <OSC_SERVER_Method_MIDI+0x58>
	...

0802142c <OSC_SERVER_Init>:
{
 802142c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  osc_send_packet = NULL;
 802142e:	4a1a      	ldr	r2, [pc, #104]	@ (8021498 <OSC_SERVER_Init+0x6c>)
 8021430:	4e1a      	ldr	r6, [pc, #104]	@ (802149c <OSC_SERVER_Init+0x70>)
 8021432:	2300      	movs	r3, #0
 8021434:	6013      	str	r3, [r2, #0]
      uip_udp_remove(osc_conn[con]);
 8021436:	4618      	mov	r0, r3
  osc_send_packet = NULL;
 8021438:	4632      	mov	r2, r6
    if( osc_conn[con] != NULL )
 802143a:	f852 1b04 	ldr.w	r1, [r2], #4
 802143e:	b101      	cbz	r1, 8021442 <OSC_SERVER_Init+0x16>
      uip_udp_remove(osc_conn[con]);
 8021440:	8088      	strh	r0, [r1, #4]
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con)
 8021442:	3301      	adds	r3, #1
 8021444:	2b04      	cmp	r3, #4
 8021446:	d1f8      	bne.n	802143a <OSC_SERVER_Init+0xe>
 8021448:	4d15      	ldr	r5, [pc, #84]	@ (80214a0 <OSC_SERVER_Init+0x74>)
 802144a:	4f16      	ldr	r7, [pc, #88]	@ (80214a4 <OSC_SERVER_Init+0x78>)
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 802144c:	2400      	movs	r4, #0
    uip_ipaddr(ripaddr,
 802144e:	8869      	ldrh	r1, [r5, #2]
 8021450:	882b      	ldrh	r3, [r5, #0]
 8021452:	020a      	lsls	r2, r1, #8
 8021454:	ea42 2211 	orr.w	r2, r2, r1, lsr #8
 8021458:	ba5b      	rev16	r3, r3
    if( (osc_conn[con]=uip_udp_new(&ripaddr, remote_port)) != NULL ) {
 802145a:	2100      	movs	r1, #0
 802145c:	a801      	add	r0, sp, #4
    uip_ipaddr(ripaddr,
 802145e:	f8ad 2004 	strh.w	r2, [sp, #4]
 8021462:	f8ad 3006 	strh.w	r3, [sp, #6]
    if( (osc_conn[con]=uip_udp_new(&ripaddr, remote_port)) != NULL ) {
 8021466:	f7fe f88f 	bl	801f588 <uip_udp_new>
 802146a:	f846 0b04 	str.w	r0, [r6], #4
 802146e:	b158      	cbz	r0, 8021488 <OSC_SERVER_Init+0x5c>
      uip_udp_bind(osc_conn[con], HTONS(osc_local_port[con]));
 8021470:	f837 3b02 	ldrh.w	r3, [r7], #2
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 8021474:	3401      	adds	r4, #1
      uip_udp_bind(osc_conn[con], HTONS(osc_local_port[con]));
 8021476:	ba5b      	rev16	r3, r3
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 8021478:	2c04      	cmp	r4, #4
      uip_udp_bind(osc_conn[con], HTONS(osc_local_port[con]));
 802147a:	8083      	strh	r3, [r0, #4]
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 802147c:	f105 0504 	add.w	r5, r5, #4
 8021480:	d1e5      	bne.n	802144e <OSC_SERVER_Init+0x22>
  return 0; // no error
 8021482:	2000      	movs	r0, #0
}
 8021484:	b003      	add	sp, #12
 8021486:	bdf0      	pop	{r4, r5, r6, r7, pc}
      DEBUG_MSG("[OSC_SERVER] FAILED to create connection #%d (no free ports)\n", con);
 8021488:	4807      	ldr	r0, [pc, #28]	@ (80214a8 <OSC_SERVER_Init+0x7c>)
 802148a:	4621      	mov	r1, r4
 802148c:	f7f3 fbac 	bl	8014be8 <MIOS32_MIDI_SendDebugMessage>
      return -1;
 8021490:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021494:	e7f6      	b.n	8021484 <OSC_SERVER_Init+0x58>
 8021496:	bf00      	nop
 8021498:	2000757c 	.word	0x2000757c
 802149c:	20007584 	.word	0x20007584
 80214a0:	200000c0 	.word	0x200000c0
 80214a4:	200000ae 	.word	0x200000ae
 80214a8:	08028315 	.word	0x08028315

080214ac <OSC_SERVER_InitFromPresets>:
  if( con >= OSC_SERVER_NUM_CONNECTIONS )
 80214ac:	2803      	cmp	r0, #3
{
 80214ae:	b510      	push	{r4, lr}
  osc_remote_ip[con] = _osc_remote_ip;
 80214b0:	bf9f      	itttt	ls
 80214b2:	4c07      	ldrls	r4, [pc, #28]	@ (80214d0 <OSC_SERVER_InitFromPresets+0x24>)
 80214b4:	f844 1020 	strls.w	r1, [r4, r0, lsl #2]
  osc_remote_port[con] = _osc_remote_port;
 80214b8:	4906      	ldrls	r1, [pc, #24]	@ (80214d4 <OSC_SERVER_InitFromPresets+0x28>)
 80214ba:	f821 2010 	strhls.w	r2, [r1, r0, lsl #1]
  osc_local_port[con] = _osc_local_port;
 80214be:	bf97      	itett	ls
 80214c0:	4a05      	ldrls	r2, [pc, #20]	@ (80214d8 <OSC_SERVER_InitFromPresets+0x2c>)
    return -1; // invalid connection
 80214c2:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
  osc_local_port[con] = _osc_local_port;
 80214c6:	f822 3010 	strhls.w	r3, [r2, r0, lsl #1]
  return 0; // no error
 80214ca:	2000      	movls	r0, #0
}
 80214cc:	bd10      	pop	{r4, pc}
 80214ce:	bf00      	nop
 80214d0:	200000c0 	.word	0x200000c0
 80214d4:	200000b6 	.word	0x200000b6
 80214d8:	200000ae 	.word	0x200000ae

080214dc <OSC_SERVER_RemoteIP_Set>:
  if( con >= OSC_SERVER_NUM_CONNECTIONS )
 80214dc:	2803      	cmp	r0, #3
  osc_remote_ip[con] = ip;
 80214de:	bf9d      	ittte	ls
 80214e0:	4b03      	ldrls	r3, [pc, #12]	@ (80214f0 <OSC_SERVER_RemoteIP_Set+0x14>)
 80214e2:	f843 1020 	strls.w	r1, [r3, r0, lsl #2]
  return 0; // OSC_SERVER_Init(0) has to be called after all settings have been done
 80214e6:	2000      	movls	r0, #0
    return -1; // invalid connection
 80214e8:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
}
 80214ec:	4770      	bx	lr
 80214ee:	bf00      	nop
 80214f0:	200000c0 	.word	0x200000c0

080214f4 <OSC_SERVER_RemoteIP_Get>:
}
 80214f4:	4b01      	ldr	r3, [pc, #4]	@ (80214fc <OSC_SERVER_RemoteIP_Get+0x8>)
 80214f6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80214fa:	4770      	bx	lr
 80214fc:	200000c0 	.word	0x200000c0

08021500 <OSC_SERVER_RemotePortSet>:
  if( con >= OSC_SERVER_NUM_CONNECTIONS )
 8021500:	2803      	cmp	r0, #3
  osc_remote_port[con] = port;
 8021502:	bf9d      	ittte	ls
 8021504:	4b03      	ldrls	r3, [pc, #12]	@ (8021514 <OSC_SERVER_RemotePortSet+0x14>)
 8021506:	f823 1010 	strhls.w	r1, [r3, r0, lsl #1]
  return 0; // OSC_SERVER_Init(0) has to be called after all settings have been done
 802150a:	2000      	movls	r0, #0
    return -1; // invalid connection
 802150c:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
}
 8021510:	4770      	bx	lr
 8021512:	bf00      	nop
 8021514:	200000b6 	.word	0x200000b6

08021518 <OSC_SERVER_RemotePortGet>:
}
 8021518:	4b01      	ldr	r3, [pc, #4]	@ (8021520 <OSC_SERVER_RemotePortGet+0x8>)
 802151a:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 802151e:	4770      	bx	lr
 8021520:	200000b6 	.word	0x200000b6

08021524 <OSC_SERVER_LocalPortSet>:
  if( con >= OSC_SERVER_NUM_CONNECTIONS )
 8021524:	2803      	cmp	r0, #3
  osc_local_port[con] = port;
 8021526:	bf9d      	ittte	ls
 8021528:	4b03      	ldrls	r3, [pc, #12]	@ (8021538 <OSC_SERVER_LocalPortSet+0x14>)
 802152a:	f823 1010 	strhls.w	r1, [r3, r0, lsl #1]
  return 0; // OSC_SERVER_Init(0) has to be called after all settings have been done
 802152e:	2000      	movls	r0, #0
    return -1; // invalid connection
 8021530:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
}
 8021534:	4770      	bx	lr
 8021536:	bf00      	nop
 8021538:	200000ae 	.word	0x200000ae

0802153c <OSC_SERVER_LocalPortGet>:
}
 802153c:	4b01      	ldr	r3, [pc, #4]	@ (8021544 <OSC_SERVER_LocalPortGet+0x8>)
 802153e:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 8021542:	4770      	bx	lr
 8021544:	200000ae 	.word	0x200000ae

08021548 <OSC_SERVER_AppCall>:
{
 8021548:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if( uip_poll() ) {
 802154c:	4c36      	ldr	r4, [pc, #216]	@ (8021628 <OSC_SERVER_AppCall+0xe0>)
  u8 udp_monitor_level = UIP_TASK_UDP_MonitorLevelGet();
 802154e:	f7ff fb07 	bl	8020b60 <UIP_TASK_UDP_MonitorLevelGet>
  if( uip_poll() ) {
 8021552:	7823      	ldrb	r3, [r4, #0]
 8021554:	071b      	lsls	r3, r3, #28
  u8 udp_monitor_level = UIP_TASK_UDP_MonitorLevelGet();
 8021556:	b2c6      	uxtb	r6, r0
  if( uip_poll() ) {
 8021558:	d50d      	bpl.n	8021576 <OSC_SERVER_AppCall+0x2e>
    if( osc_send_packet != NULL ) {
 802155a:	4d34      	ldr	r5, [pc, #208]	@ (802162c <OSC_SERVER_AppCall+0xe4>)
 802155c:	6828      	ldr	r0, [r5, #0]
 802155e:	b150      	cbz	r0, 8021576 <OSC_SERVER_AppCall+0x2e>
      uip_send(osc_send_packet, osc_send_len);
 8021560:	4b33      	ldr	r3, [pc, #204]	@ (8021630 <OSC_SERVER_AppCall+0xe8>)
 8021562:	6819      	ldr	r1, [r3, #0]
 8021564:	f7fe fe44 	bl	80201f0 <uip_send>
      osc_send_packet = NULL;
 8021568:	2000      	movs	r0, #0
      if( udp_monitor_level >= UDP_MONITOR_LEVEL_2_OSC_REC_AND_SEND )
 802156a:	2e01      	cmp	r6, #1
      osc_send_packet = NULL;
 802156c:	6028      	str	r0, [r5, #0]
      if( udp_monitor_level >= UDP_MONITOR_LEVEL_2_OSC_REC_AND_SEND )
 802156e:	d902      	bls.n	8021576 <OSC_SERVER_AppCall+0x2e>
	UIP_TASK_UDP_MonitorPacket(UDP_MONITOR_SEND, "OSC_SEND");
 8021570:	4930      	ldr	r1, [pc, #192]	@ (8021634 <OSC_SERVER_AppCall+0xec>)
 8021572:	f7ff fa97 	bl	8020aa4 <UIP_TASK_UDP_MonitorPacket>
  if( uip_newdata() ) {    
 8021576:	7823      	ldrb	r3, [r4, #0]
 8021578:	079f      	lsls	r7, r3, #30
 802157a:	d542      	bpl.n	8021602 <OSC_SERVER_AppCall+0xba>
    u16 search_port = HTONS(uip_udp_conn->lport); // (no error: use lport instead of rport, since UIP inserts it there)
 802157c:	f8df 80b8 	ldr.w	r8, [pc, #184]	@ 8021638 <OSC_SERVER_AppCall+0xf0>
 8021580:	f8d8 3000 	ldr.w	r3, [r8]
      ((u32)uip_ipaddr1(uip_udp_conn->ripaddr) << 24) |
 8021584:	8818      	ldrh	r0, [r3, #0]
 8021586:	889f      	ldrh	r7, [r3, #4]
 8021588:	f7fe fe2e 	bl	80201e8 <htons>
      ((u32)uip_ipaddr2(uip_udp_conn->ripaddr) << 16) |
 802158c:	f8d8 3000 	ldr.w	r3, [r8]
      ((u32)uip_ipaddr1(uip_udp_conn->ripaddr) << 24) |
 8021590:	4604      	mov	r4, r0
      ((u32)uip_ipaddr2(uip_udp_conn->ripaddr) << 16) |
 8021592:	8818      	ldrh	r0, [r3, #0]
 8021594:	f7fe fe28 	bl	80201e8 <htons>
      ((u32)uip_ipaddr3(uip_udp_conn->ripaddr) <<  8) |
 8021598:	f8d8 3000 	ldr.w	r3, [r8]
      ((u32)uip_ipaddr2(uip_udp_conn->ripaddr) << 16) |
 802159c:	0405      	lsls	r5, r0, #16
      ((u32)uip_ipaddr3(uip_udp_conn->ripaddr) <<  8) |
 802159e:	8858      	ldrh	r0, [r3, #2]
 80215a0:	f7fe fe22 	bl	80201e8 <htons>
      ((u32)uip_ipaddr4(uip_udp_conn->ripaddr) <<  0);
 80215a4:	f8d8 3000 	ldr.w	r3, [r8]
      ((u32)uip_ipaddr1(uip_udp_conn->ripaddr) << 24) |
 80215a8:	f3c4 240f 	ubfx	r4, r4, #8, #16
      ((u32)uip_ipaddr2(uip_udp_conn->ripaddr) << 16) |
 80215ac:	f405 057f 	and.w	r5, r5, #16711680	@ 0xff0000
      ((u32)uip_ipaddr1(uip_udp_conn->ripaddr) << 24) |
 80215b0:	ea45 6504 	orr.w	r5, r5, r4, lsl #24
      ((u32)uip_ipaddr3(uip_udp_conn->ripaddr) <<  8) |
 80215b4:	4604      	mov	r4, r0
      ((u32)uip_ipaddr4(uip_udp_conn->ripaddr) <<  0);
 80215b6:	8858      	ldrh	r0, [r3, #2]
 80215b8:	f7fe fe16 	bl	80201e8 <htons>
      ((u32)uip_ipaddr3(uip_udp_conn->ripaddr) <<  8) |
 80215bc:	f024 437f 	bic.w	r3, r4, #4278190080	@ 0xff000000
      ((u32)uip_ipaddr4(uip_udp_conn->ripaddr) <<  0);
 80215c0:	b2c0      	uxtb	r0, r0
    u32 search_ip =
 80215c2:	4328      	orrs	r0, r5
      ((u32)uip_ipaddr3(uip_udp_conn->ripaddr) <<  8) |
 80215c4:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 80215c8:	ba7f      	rev16	r7, r7
    u32 search_ip =
 80215ca:	4303      	orrs	r3, r0
 80215cc:	4a1b      	ldr	r2, [pc, #108]	@ (802163c <OSC_SERVER_AppCall+0xf4>)
	  (osc_remote_ip[con] == 0xffffffff || osc_remote_ip[con] == search_ip) // check for matching IP as well if != 0xffffffff (broadcast IP)
 80215ce:	481c      	ldr	r0, [pc, #112]	@ (8021640 <OSC_SERVER_AppCall+0xf8>)
 80215d0:	b2bf      	uxth	r7, r7
    for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 80215d2:	2400      	movs	r4, #0
      if( osc_local_port[con] == search_port &&
 80215d4:	f832 1b02 	ldrh.w	r1, [r2], #2
 80215d8:	42b9      	cmp	r1, r7
 80215da:	d105      	bne.n	80215e8 <OSC_SERVER_AppCall+0xa0>
	  (osc_remote_ip[con] == 0xffffffff || osc_remote_ip[con] == search_ip) // check for matching IP as well if != 0xffffffff (broadcast IP)
 80215dc:	f850 1024 	ldr.w	r1, [r0, r4, lsl #2]
      if( osc_local_port[con] == search_port &&
 80215e0:	1c4d      	adds	r5, r1, #1
 80215e2:	d011      	beq.n	8021608 <OSC_SERVER_AppCall+0xc0>
	  (osc_remote_ip[con] == 0xffffffff || osc_remote_ip[con] == search_ip) // check for matching IP as well if != 0xffffffff (broadcast IP)
 80215e4:	4299      	cmp	r1, r3
 80215e6:	d00f      	beq.n	8021608 <OSC_SERVER_AppCall+0xc0>
    for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 80215e8:	3401      	adds	r4, #1
 80215ea:	2c04      	cmp	r4, #4
 80215ec:	d1f2      	bne.n	80215d4 <OSC_SERVER_AppCall+0x8c>
      if( udp_monitor_level >= UDP_MONITOR_LEVEL_4_ALL ||
 80215ee:	2e03      	cmp	r6, #3
 80215f0:	d803      	bhi.n	80215fa <OSC_SERVER_AppCall+0xb2>
 80215f2:	d106      	bne.n	8021602 <OSC_SERVER_AppCall+0xba>
	  (udp_monitor_level >= UDP_MONITOR_LEVEL_3_ALL_GEQ_1024 && search_port >= 1024) )
 80215f4:	f5b7 6f80 	cmp.w	r7, #1024	@ 0x400
 80215f8:	d303      	bcc.n	8021602 <OSC_SERVER_AppCall+0xba>
	UIP_TASK_UDP_MonitorPacket(UDP_MONITOR_RECEIVED, "UNMATCHED_PORT");
 80215fa:	4912      	ldr	r1, [pc, #72]	@ (8021644 <OSC_SERVER_AppCall+0xfc>)
 80215fc:	2001      	movs	r0, #1
 80215fe:	f7ff fa51 	bl	8020aa4 <UIP_TASK_UDP_MonitorPacket>
}
 8021602:	2000      	movs	r0, #0
 8021604:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if( udp_monitor_level >= UDP_MONITOR_LEVEL_1_OSC_REC )
 8021608:	b11e      	cbz	r6, 8021612 <OSC_SERVER_AppCall+0xca>
	UIP_TASK_UDP_MonitorPacket(UDP_MONITOR_RECEIVED, "OSC_RECEIVED");
 802160a:	490f      	ldr	r1, [pc, #60]	@ (8021648 <OSC_SERVER_AppCall+0x100>)
 802160c:	2001      	movs	r0, #1
 802160e:	f7ff fa49 	bl	8020aa4 <UIP_TASK_UDP_MonitorPacket>
      osc_parsed_from_con = con; // used by event propagation
 8021612:	4b0e      	ldr	r3, [pc, #56]	@ (802164c <OSC_SERVER_AppCall+0x104>)
      s32 status = MIOS32_OSC_ParsePacket((u8 *)uip_appdata, uip_len, parse_root);
 8021614:	4a0e      	ldr	r2, [pc, #56]	@ (8021650 <OSC_SERVER_AppCall+0x108>)
      osc_parsed_from_con = con; // used by event propagation
 8021616:	701c      	strb	r4, [r3, #0]
      s32 status = MIOS32_OSC_ParsePacket((u8 *)uip_appdata, uip_len, parse_root);
 8021618:	4b0e      	ldr	r3, [pc, #56]	@ (8021654 <OSC_SERVER_AppCall+0x10c>)
 802161a:	8819      	ldrh	r1, [r3, #0]
 802161c:	4b0e      	ldr	r3, [pc, #56]	@ (8021658 <OSC_SERVER_AppCall+0x110>)
 802161e:	6818      	ldr	r0, [r3, #0]
 8021620:	f7f4 f8a0 	bl	8015764 <MIOS32_OSC_ParsePacket>
  return 0; // no error
 8021624:	e7ed      	b.n	8021602 <OSC_SERVER_AppCall+0xba>
 8021626:	bf00      	nop
 8021628:	20006ebc 	.word	0x20006ebc
 802162c:	2000757c 	.word	0x2000757c
 8021630:	20007578 	.word	0x20007578
 8021634:	08028353 	.word	0x08028353
 8021638:	20006d74 	.word	0x20006d74
 802163c:	200000ae 	.word	0x200000ae
 8021640:	200000c0 	.word	0x200000c0
 8021644:	0802835c 	.word	0x0802835c
 8021648:	0802836b 	.word	0x0802836b
 802164c:	20007580 	.word	0x20007580
 8021650:	0802853c 	.word	0x0802853c
 8021654:	20006ec0 	.word	0x20006ec0
 8021658:	20006ec8 	.word	0x20006ec8

0802165c <OSC_SERVER_SendPacket>:
{
 802165c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8021660:	4604      	mov	r4, r0
 8021662:	460f      	mov	r7, r1
  if( len == 0 )
 8021664:	4615      	mov	r5, r2
 8021666:	b36a      	cbz	r2, 80216c4 <OSC_SERVER_SendPacket+0x68>
  if( osc_conn[con] == NULL ) {
 8021668:	4e19      	ldr	r6, [pc, #100]	@ (80216d0 <OSC_SERVER_SendPacket+0x74>)
 802166a:	f856 3020 	ldr.w	r3, [r6, r0, lsl #2]
 802166e:	b363      	cbz	r3, 80216ca <OSC_SERVER_SendPacket+0x6e>
  MUTEX_UIP_TAKE;
 8021670:	f8df 8060 	ldr.w	r8, [pc, #96]	@ 80216d4 <OSC_SERVER_SendPacket+0x78>
 8021674:	f8d8 0000 	ldr.w	r0, [r8]
 8021678:	2101      	movs	r1, #1
 802167a:	f7f2 fc09 	bl	8013e90 <xQueueTakeMutexRecursive>
 802167e:	2801      	cmp	r0, #1
 8021680:	d1f8      	bne.n	8021674 <OSC_SERVER_SendPacket+0x18>
  osc_conn[con]->rport = HTONS(osc_remote_port[con]);
 8021682:	4b15      	ldr	r3, [pc, #84]	@ (80216d8 <OSC_SERVER_SendPacket+0x7c>)
 8021684:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 8021688:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
 802168c:	ba5b      	rev16	r3, r3
 802168e:	80d3      	strh	r3, [r2, #6]
    osc_send_packet = packet;
 8021690:	4b12      	ldr	r3, [pc, #72]	@ (80216dc <OSC_SERVER_SendPacket+0x80>)
 8021692:	601f      	str	r7, [r3, #0]
    osc_send_len = len;
 8021694:	4b12      	ldr	r3, [pc, #72]	@ (80216e0 <OSC_SERVER_SendPacket+0x84>)
 8021696:	601d      	str	r5, [r3, #0]
    uip_udp_periodic_conn(osc_conn[con]);
 8021698:	4b12      	ldr	r3, [pc, #72]	@ (80216e4 <OSC_SERVER_SendPacket+0x88>)
    if(uip_len > 0) {
 802169a:	4d13      	ldr	r5, [pc, #76]	@ (80216e8 <OSC_SERVER_SendPacket+0x8c>)
    uip_udp_periodic_conn(osc_conn[con]);
 802169c:	601a      	str	r2, [r3, #0]
 802169e:	2005      	movs	r0, #5
 80216a0:	f7fd ffbc 	bl	801f61c <uip_process>
    if(uip_len > 0) {
 80216a4:	882b      	ldrh	r3, [r5, #0]
 80216a6:	b12b      	cbz	r3, 80216b4 <OSC_SERVER_SendPacket+0x58>
      uip_arp_out();
 80216a8:	f7fe fee4 	bl	8020474 <uip_arp_out>
      network_device_send();
 80216ac:	f7fe ffc4 	bl	8020638 <network_device_send>
      uip_len = 0;
 80216b0:	2300      	movs	r3, #0
 80216b2:	802b      	strh	r3, [r5, #0]
  osc_conn[con]->rport = 0;
 80216b4:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
  MUTEX_UIP_GIVE;
 80216b8:	f8d8 0000 	ldr.w	r0, [r8]
  osc_conn[con]->rport = 0;
 80216bc:	2200      	movs	r2, #0
 80216be:	80da      	strh	r2, [r3, #6]
  MUTEX_UIP_GIVE;
 80216c0:	f7f2 fb35 	bl	8013d2e <xQueueGiveMutexRecursive>
    return 0;
 80216c4:	2000      	movs	r0, #0
}
 80216c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return -1; // connection not established
 80216ca:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80216ce:	e7fa      	b.n	80216c6 <OSC_SERVER_SendPacket+0x6a>
 80216d0:	20007584 	.word	0x20007584
 80216d4:	20007540 	.word	0x20007540
 80216d8:	200000b6 	.word	0x200000b6
 80216dc:	2000757c 	.word	0x2000757c
 80216e0:	20007578 	.word	0x20007578
 80216e4:	20006d74 	.word	0x20006d74
 80216e8:	20006ec0 	.word	0x20006ec0

080216ec <OSC_CLIENT_Init>:
s32 OSC_CLIENT_Init(u32 mode)
{
  int i;

  for(i=0; i<OSC_CLIENT_NUM_PORTS; ++i) {
    osc_transfer_mode[i] = OSC_CLIENT_TRANSFER_MODE_MIDI;
 80216ec:	4a05      	ldr	r2, [pc, #20]	@ (8021704 <OSC_CLIENT_Init+0x18>)
    sysex_buffer_len[i] = 0;
 80216ee:	4b06      	ldr	r3, [pc, #24]	@ (8021708 <OSC_CLIENT_Init+0x1c>)
    osc_transfer_mode[i] = OSC_CLIENT_TRANSFER_MODE_MIDI;
 80216f0:	2000      	movs	r0, #0
 80216f2:	8010      	strh	r0, [r2, #0]
    sysex_buffer_len[i] = 0;
 80216f4:	7018      	strb	r0, [r3, #0]
    osc_transfer_mode[i] = OSC_CLIENT_TRANSFER_MODE_MIDI;
 80216f6:	8050      	strh	r0, [r2, #2]
    sysex_buffer_len[i] = 0;
 80216f8:	7058      	strb	r0, [r3, #1]
    osc_transfer_mode[i] = OSC_CLIENT_TRANSFER_MODE_MIDI;
 80216fa:	8090      	strh	r0, [r2, #4]
    sysex_buffer_len[i] = 0;
 80216fc:	7098      	strb	r0, [r3, #2]
    osc_transfer_mode[i] = OSC_CLIENT_TRANSFER_MODE_MIDI;
 80216fe:	80d0      	strh	r0, [r2, #6]
    sysex_buffer_len[i] = 0;
 8021700:	70d8      	strb	r0, [r3, #3]
  }

  return 0; // no error
}
 8021702:	4770      	bx	lr
 8021704:	20007698 	.word	0x20007698
 8021708:	20007594 	.word	0x20007594

0802170c <OSC_CLIENT_TransferModeSet>:
/////////////////////////////////////////////////////////////////////////////
// Transfer Mode Set/Get functions
/////////////////////////////////////////////////////////////////////////////
s32 OSC_CLIENT_TransferModeSet(u8 osc_port, u8 mode)
{
  if( osc_port >= OSC_CLIENT_NUM_PORTS )
 802170c:	2803      	cmp	r0, #3
    return -1; // invalid connection

  osc_transfer_mode[osc_port] = mode;
 802170e:	bf9d      	ittte	ls
 8021710:	4b03      	ldrls	r3, [pc, #12]	@ (8021720 <OSC_CLIENT_TransferModeSet+0x14>)
 8021712:	f823 1010 	strhls.w	r1, [r3, r0, lsl #1]
  return 0;
 8021716:	2000      	movls	r0, #0
    return -1; // invalid connection
 8021718:	f04f 30ff 	movhi.w	r0, #4294967295	@ 0xffffffff
}
 802171c:	4770      	bx	lr
 802171e:	bf00      	nop
 8021720:	20007698 	.word	0x20007698

08021724 <OSC_CLIENT_TransferModeGet>:

u8 OSC_CLIENT_TransferModeGet(u8 osc_port)
{
  return osc_transfer_mode[osc_port];
}
 8021724:	4b01      	ldr	r3, [pc, #4]	@ (802172c <OSC_CLIENT_TransferModeGet+0x8>)
 8021726:	f813 0010 	ldrb.w	r0, [r3, r0, lsl #1]
 802172a:	4770      	bx	lr
 802172c:	20007698 	.word	0x20007698

08021730 <OSC_CLIENT_TransferModeFullNameGet>:
/////////////////////////////////////////////////////////////////////////////
// returns the full name of the transfer mode (up to 20 chars)
/////////////////////////////////////////////////////////////////////////////
const char* OSC_CLIENT_TransferModeFullNameGet(u8 mode)
{
  return (const char*)&full_mode_names[(mode >= OSC_CLIENT_NUM_TRANSFER_MODES) ? OSC_CLIENT_NUM_TRANSFER_MODES : mode];
 8021730:	2805      	cmp	r0, #5
 8021732:	bf28      	it	cs
 8021734:	2005      	movcs	r0, #5
}
 8021736:	4b03      	ldr	r3, [pc, #12]	@ (8021744 <OSC_CLIENT_TransferModeFullNameGet+0x14>)
  return (const char*)&full_mode_names[(mode >= OSC_CLIENT_NUM_TRANSFER_MODES) ? OSC_CLIENT_NUM_TRANSFER_MODES : mode];
 8021738:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 802173c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
}
 8021740:	4418      	add	r0, r3
 8021742:	4770      	bx	lr
 8021744:	080287fd 	.word	0x080287fd

08021748 <OSC_CLIENT_SendMIDIEvent>:
/////////////////////////////////////////////////////////////////////////////
// Send a MIDI event
// Path: /midi <midi-package>
/////////////////////////////////////////////////////////////////////////////
s32 OSC_CLIENT_SendMIDIEvent(u8 osc_port, mios32_midi_package_t package)
{
 8021748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if( osc_port >= OSC_CLIENT_NUM_PORTS )
 802174c:	2803      	cmp	r0, #3
{
 802174e:	b0a9      	sub	sp, #164	@ 0xa4
 8021750:	4607      	mov	r7, r0
 8021752:	460c      	mov	r4, r1
 8021754:	f001 0a0f 	and.w	sl, r1, #15
 8021758:	f3c1 4807 	ubfx	r8, r1, #16, #8
 802175c:	ea4f 6511 	mov.w	r5, r1, lsr #24
  if( osc_port >= OSC_CLIENT_NUM_PORTS )
 8021760:	f200 81cb 	bhi.w	8021afa <OSC_CLIENT_SendMIDIEvent+0x3b2>
    return -1; // invalid port

#if !defined(MIOS32_FAMILY_EMULATION)
  // check if server is running
  if( !UIP_TASK_ServicesRunning() )
 8021764:	f7ff f996 	bl	8020a94 <UIP_TASK_ServicesRunning>
 8021768:	2800      	cmp	r0, #0
 802176a:	f000 81c9 	beq.w	8021b00 <OSC_CLIENT_SendMIDIEvent+0x3b8>

  // create the OSC packet
  u8 packet[128];
  u8 *end_ptr = packet;

  if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_MCMPP &&
 802176e:	f8df 9284 	ldr.w	r9, [pc, #644]	@ 80219f4 <OSC_CLIENT_SendMIDIEvent+0x2ac>
 8021772:	f839 3017 	ldrh.w	r3, [r9, r7, lsl #1]
 8021776:	2b03      	cmp	r3, #3
      package.type >= NoteOff && package.type <= PitchBend ) {
 8021778:	4656      	mov	r6, sl
  if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_MCMPP &&
 802177a:	d168      	bne.n	802184e <OSC_CLIENT_SendMIDIEvent+0x106>
 802177c:	f1ba 0f07 	cmp.w	sl, #7
 8021780:	f240 8111 	bls.w	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
      package.type >= NoteOff && package.type <= PitchBend ) {
 8021784:	2e0f      	cmp	r6, #15
 8021786:	f000 810e 	beq.w	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
    switch( package.type ) {
    case NoteOff:
      package.velocity = 0;
      // fall through
    case NoteOn:
      sprintf(event_path, "/mcmpp/key/%d/%d", package.note, package.chn+1);
 802178a:	f3c4 2403 	ubfx	r4, r4, #8, #4
    switch( package.type ) {
 802178e:	f1aa 0a08 	sub.w	sl, sl, #8
      sprintf(event_path, "/mcmpp/key/%d/%d", package.note, package.chn+1);
 8021792:	1c63      	adds	r3, r4, #1
    switch( package.type ) {
 8021794:	f1ba 0f06 	cmp.w	sl, #6
 8021798:	d853      	bhi.n	8021842 <OSC_CLIENT_SendMIDIEvent+0xfa>
 802179a:	e8df f00a 	tbb	[pc, sl]
 802179e:	0504      	.short	0x0504
 80217a0:	22181512 	.word	0x22181512
 80217a4:	28          	.byte	0x28
 80217a5:	00          	.byte	0x00
 80217a6:	2500      	movs	r5, #0
      sprintf(event_path, "/mcmpp/key/%d/%d", package.note, package.chn+1);
 80217a8:	4993      	ldr	r1, [pc, #588]	@ (80219f8 <OSC_CLIENT_SendMIDIEvent+0x2b0>)
 80217aa:	4642      	mov	r2, r8
      end_ptr = MIOS32_OSC_PutString(end_ptr, ",f");
      end_ptr = MIOS32_OSC_PutFloat(end_ptr, (float)package.velocity/127.0);
      break;

    case PolyPressure:
      sprintf(event_path, "/mcmpp/polypressure/%d/%d", package.note, package.chn+1);
 80217ac:	4668      	mov	r0, sp
 80217ae:	f7f7 fb09 	bl	8018dc4 <sprintf>
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 80217b2:	4669      	mov	r1, sp
 80217b4:	a808      	add	r0, sp, #32
 80217b6:	f7f3 ff91 	bl	80156dc <MIOS32_OSC_PutString>

    case Aftertouch:
      sprintf(event_path, "/%d/aftertouch", package.chn+1);
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",f");
 80217ba:	4990      	ldr	r1, [pc, #576]	@ (80219fc <OSC_CLIENT_SendMIDIEvent+0x2b4>)
 80217bc:	f7f3 ff8e 	bl	80156dc <MIOS32_OSC_PutString>
 80217c0:	e095      	b.n	80218ee <OSC_CLIENT_SendMIDIEvent+0x1a6>
      sprintf(event_path, "/mcmpp/polypressure/%d/%d", package.note, package.chn+1);
 80217c2:	498f      	ldr	r1, [pc, #572]	@ (8021a00 <OSC_CLIENT_SendMIDIEvent+0x2b8>)
 80217c4:	4642      	mov	r2, r8
 80217c6:	e7f1      	b.n	80217ac <OSC_CLIENT_SendMIDIEvent+0x64>
      sprintf(event_path, "/mcmpp/cc/%d/%d", package.cc_number, package.chn+1);
 80217c8:	498e      	ldr	r1, [pc, #568]	@ (8021a04 <OSC_CLIENT_SendMIDIEvent+0x2bc>)
 80217ca:	4642      	mov	r2, r8
 80217cc:	e7ee      	b.n	80217ac <OSC_CLIENT_SendMIDIEvent+0x64>
      sprintf(event_path, "/mcmpp/programchange/%d/%d", package.program_change, package.chn+1);
 80217ce:	498e      	ldr	r1, [pc, #568]	@ (8021a08 <OSC_CLIENT_SendMIDIEvent+0x2c0>)
 80217d0:	4642      	mov	r2, r8
      sprintf(event_path, "/%d/programchange_%d", package.chn+1, package.program_change);
 80217d2:	4668      	mov	r0, sp
 80217d4:	f7f7 faf6 	bl	8018dc4 <sprintf>
      }
    } break;

    default:
      sprintf(event_path, "/%d/invalid", package.chn);
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 80217d8:	4669      	mov	r1, sp
 80217da:	a808      	add	r0, sp, #32
 80217dc:	f7f3 ff7e 	bl	80156dc <MIOS32_OSC_PutString>
 80217e0:	e028      	b.n	8021834 <OSC_CLIENT_SendMIDIEvent+0xec>
      sprintf(event_path, "/mcmpp/aftertouch/%d", package.chn+1);
 80217e2:	498a      	ldr	r1, [pc, #552]	@ (8021a0c <OSC_CLIENT_SendMIDIEvent+0x2c4>)
 80217e4:	461a      	mov	r2, r3
      sprintf(event_path, "/%d/aftertouch", package.chn+1);
 80217e6:	4668      	mov	r0, sp
 80217e8:	f7f7 faec 	bl	8018dc4 <sprintf>
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 80217ec:	e7e1      	b.n	80217b2 <OSC_CLIENT_SendMIDIEvent+0x6a>
      sprintf(event_path, "/mcmpp/pitch/%d", package.chn+1);
 80217ee:	4988      	ldr	r1, [pc, #544]	@ (8021a10 <OSC_CLIENT_SendMIDIEvent+0x2c8>)
 80217f0:	461a      	mov	r2, r3
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 80217f2:	01ed      	lsls	r5, r5, #7
 80217f4:	f405 557e 	and.w	r5, r5, #16256	@ 0x3f80
 80217f8:	f008 087f 	and.w	r8, r8, #127	@ 0x7f
      sprintf(event_path, "/%d/pitch", package.chn+1);
 80217fc:	4668      	mov	r0, sp
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 80217fe:	ea45 0508 	orr.w	r5, r5, r8
      sprintf(event_path, "/%d/pitch", package.chn+1);
 8021802:	f7f7 fadf 	bl	8018dc4 <sprintf>
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 8021806:	f5a5 5500 	sub.w	r5, r5, #8192	@ 0x2000
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 802180a:	4669      	mov	r1, sp
 802180c:	a808      	add	r0, sp, #32
 802180e:	f7f3 ff65 	bl	80156dc <MIOS32_OSC_PutString>
	value = 0;
 8021812:	2d7f      	cmp	r5, #127	@ 0x7f
 8021814:	bf98      	it	ls
 8021816:	2500      	movls	r5, #0
      end_ptr = MIOS32_OSC_PutString(end_ptr, ",f");
 8021818:	4978      	ldr	r1, [pc, #480]	@ (80219fc <OSC_CLIENT_SendMIDIEvent+0x2b4>)
 802181a:	f7f3 ff5f 	bl	80156dc <MIOS32_OSC_PutString>
 802181e:	4604      	mov	r4, r0
      end_ptr = MIOS32_OSC_PutFloat(end_ptr, (float)value/8191.0);
 8021820:	4628      	mov	r0, r5
 8021822:	f001 fc69 	bl	80230f8 <__aeabi_i2f>
 8021826:	497b      	ldr	r1, [pc, #492]	@ (8021a14 <OSC_CLIENT_SendMIDIEvent+0x2cc>)
 8021828:	f001 fd6e 	bl	8023308 <__aeabi_fdiv>
 802182c:	4601      	mov	r1, r0
 802182e:	4620      	mov	r0, r4
 8021830:	f7f3 ff52 	bl	80156d8 <MIOS32_OSC_PutFloat>
 8021834:	4604      	mov	r4, r0
      end_ptr = MIOS32_OSC_PutMIDI(end_ptr, package);
    }
  }

  // send packet and exit
  return OSC_SERVER_SendPacket(osc_port, packet, (u32)(end_ptr-packet));
 8021836:	a908      	add	r1, sp, #32
 8021838:	1a62      	subs	r2, r4, r1
 802183a:	4638      	mov	r0, r7
 802183c:	f7ff ff0e 	bl	802165c <OSC_SERVER_SendPacket>
 8021840:	e152      	b.n	8021ae8 <OSC_CLIENT_SendMIDIEvent+0x3a0>
      sprintf(event_path, "/mcmpp/invalid/%d", package.chn+1);
 8021842:	4975      	ldr	r1, [pc, #468]	@ (8021a18 <OSC_CLIENT_SendMIDIEvent+0x2d0>)
 8021844:	461a      	mov	r2, r3
      sprintf(event_path, "/%d/invalid", package.chn);
 8021846:	4668      	mov	r0, sp
 8021848:	f7f7 fabc 	bl	8018dc4 <sprintf>
 802184c:	e7c4      	b.n	80217d8 <OSC_CLIENT_SendMIDIEvent+0x90>
  } else if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_TOSC &&
 802184e:	2b04      	cmp	r3, #4
 8021850:	d125      	bne.n	802189e <OSC_CLIENT_SendMIDIEvent+0x156>
 8021852:	f1ba 0f07 	cmp.w	sl, #7
 8021856:	f240 80a6 	bls.w	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
      package.type >= NoteOff && package.type <= PitchBend ) {
 802185a:	2e0f      	cmp	r6, #15
 802185c:	f000 80a3 	beq.w	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
      sprintf(event_path, "/%d/note_%d", package.chn+1, package.note);
 8021860:	f3c4 2203 	ubfx	r2, r4, #8, #4
    switch( package.type ) {
 8021864:	f1aa 0308 	sub.w	r3, sl, #8
      sprintf(event_path, "/%d/note_%d", package.chn+1, package.note);
 8021868:	3201      	adds	r2, #1
    switch( package.type ) {
 802186a:	2b06      	cmp	r3, #6
 802186c:	f200 8099 	bhi.w	80219a2 <OSC_CLIENT_SendMIDIEvent+0x25a>
 8021870:	e8df f003 	tbb	[pc, r3]
 8021874:	0b080504 	.word	0x0b080504
 8021878:	110e      	.short	0x110e
 802187a:	13          	.byte	0x13
 802187b:	00          	.byte	0x00
 802187c:	2500      	movs	r5, #0
      sprintf(event_path, "/%d/note_%d", package.chn+1, package.note);
 802187e:	4967      	ldr	r1, [pc, #412]	@ (8021a1c <OSC_CLIENT_SendMIDIEvent+0x2d4>)
 8021880:	4643      	mov	r3, r8
 8021882:	e793      	b.n	80217ac <OSC_CLIENT_SendMIDIEvent+0x64>
      sprintf(event_path, "/%d/polypressure_%d", package.chn+1, package.note);
 8021884:	4966      	ldr	r1, [pc, #408]	@ (8021a20 <OSC_CLIENT_SendMIDIEvent+0x2d8>)
 8021886:	4643      	mov	r3, r8
 8021888:	e790      	b.n	80217ac <OSC_CLIENT_SendMIDIEvent+0x64>
      sprintf(event_path, "/%d/cc_%d", package.chn+1, package.cc_number);
 802188a:	4966      	ldr	r1, [pc, #408]	@ (8021a24 <OSC_CLIENT_SendMIDIEvent+0x2dc>)
 802188c:	4643      	mov	r3, r8
 802188e:	e78d      	b.n	80217ac <OSC_CLIENT_SendMIDIEvent+0x64>
      sprintf(event_path, "/%d/programchange_%d", package.chn+1, package.program_change);
 8021890:	4965      	ldr	r1, [pc, #404]	@ (8021a28 <OSC_CLIENT_SendMIDIEvent+0x2e0>)
 8021892:	4643      	mov	r3, r8
 8021894:	e79d      	b.n	80217d2 <OSC_CLIENT_SendMIDIEvent+0x8a>
      sprintf(event_path, "/%d/aftertouch", package.chn+1);
 8021896:	4965      	ldr	r1, [pc, #404]	@ (8021a2c <OSC_CLIENT_SendMIDIEvent+0x2e4>)
 8021898:	e7a5      	b.n	80217e6 <OSC_CLIENT_SendMIDIEvent+0x9e>
      sprintf(event_path, "/%d/pitch", package.chn+1);
 802189a:	4965      	ldr	r1, [pc, #404]	@ (8021a30 <OSC_CLIENT_SendMIDIEvent+0x2e8>)
 802189c:	e7a9      	b.n	80217f2 <OSC_CLIENT_SendMIDIEvent+0xaa>
  } else if( osc_transfer_mode[osc_port] != OSC_CLIENT_TRANSFER_MODE_MIDI &&
 802189e:	2b00      	cmp	r3, #0
 80218a0:	f000 8081 	beq.w	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
 80218a4:	f1ba 0f07 	cmp.w	sl, #7
 80218a8:	d97d      	bls.n	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
      package.type >= NoteOff && package.type <= PitchBend ) {
 80218aa:	2e0f      	cmp	r6, #15
 80218ac:	d07b      	beq.n	80219a6 <OSC_CLIENT_SendMIDIEvent+0x25e>
    switch( package.type ) {
 80218ae:	f1aa 0308 	sub.w	r3, sl, #8
      sprintf(event_path, "/%d/note", package.chn+1);
 80218b2:	f3c4 2203 	ubfx	r2, r4, #8, #4
    switch( package.type ) {
 80218b6:	2b06      	cmp	r3, #6
 80218b8:	d873      	bhi.n	80219a2 <OSC_CLIENT_SendMIDIEvent+0x25a>
 80218ba:	e8df f003 	tbb	[pc, r3]
 80218be:	0504      	.short	0x0504
 80218c0:	46291e1b 	.word	0x46291e1b
 80218c4:	58          	.byte	0x58
 80218c5:	00          	.byte	0x00
 80218c6:	2500      	movs	r5, #0
      sprintf(event_path, "/%d/note", package.chn+1);
 80218c8:	495a      	ldr	r1, [pc, #360]	@ (8021a34 <OSC_CLIENT_SendMIDIEvent+0x2ec>)
 80218ca:	3201      	adds	r2, #1
      sprintf(event_path, "/%d/cc", package.chn+1);
 80218cc:	4668      	mov	r0, sp
 80218ce:	f7f7 fa79 	bl	8018dc4 <sprintf>
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 80218d2:	4669      	mov	r1, sp
 80218d4:	a808      	add	r0, sp, #32
 80218d6:	f7f3 ff01 	bl	80156dc <MIOS32_OSC_PutString>
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
 80218da:	f839 3017 	ldrh.w	r3, [r9, r7, lsl #1]
 80218de:	2b02      	cmp	r3, #2
 80218e0:	d10e      	bne.n	8021900 <OSC_CLIENT_SendMIDIEvent+0x1b8>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",if");
 80218e2:	4955      	ldr	r1, [pc, #340]	@ (8021a38 <OSC_CLIENT_SendMIDIEvent+0x2f0>)
 80218e4:	f7f3 fefa 	bl	80156dc <MIOS32_OSC_PutString>
	end_ptr = MIOS32_OSC_PutInt(end_ptr, package.cc_number);
 80218e8:	4641      	mov	r1, r8
 80218ea:	f7f3 feef 	bl	80156cc <MIOS32_OSC_PutInt>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",f");
 80218ee:	4604      	mov	r4, r0
	end_ptr = MIOS32_OSC_PutFloat(end_ptr, (float)package.velocity/127.0);
 80218f0:	4628      	mov	r0, r5
 80218f2:	e01f      	b.n	8021934 <OSC_CLIENT_SendMIDIEvent+0x1ec>
      sprintf(event_path, "/%d/polypressure", package.chn+1);
 80218f4:	4951      	ldr	r1, [pc, #324]	@ (8021a3c <OSC_CLIENT_SendMIDIEvent+0x2f4>)
 80218f6:	3201      	adds	r2, #1
 80218f8:	e7e8      	b.n	80218cc <OSC_CLIENT_SendMIDIEvent+0x184>
      sprintf(event_path, "/%d/cc", package.chn+1);
 80218fa:	4951      	ldr	r1, [pc, #324]	@ (8021a40 <OSC_CLIENT_SendMIDIEvent+0x2f8>)
 80218fc:	3201      	adds	r2, #1
 80218fe:	e7e5      	b.n	80218cc <OSC_CLIENT_SendMIDIEvent+0x184>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",ii");
 8021900:	4950      	ldr	r1, [pc, #320]	@ (8021a44 <OSC_CLIENT_SendMIDIEvent+0x2fc>)
 8021902:	f7f3 feeb 	bl	80156dc <MIOS32_OSC_PutString>
	end_ptr = MIOS32_OSC_PutInt(end_ptr, package.cc_number);
 8021906:	4641      	mov	r1, r8
 8021908:	f7f3 fee0 	bl	80156cc <MIOS32_OSC_PutInt>
	end_ptr = MIOS32_OSC_PutInt(end_ptr, value);
 802190c:	4629      	mov	r1, r5
 802190e:	e019      	b.n	8021944 <OSC_CLIENT_SendMIDIEvent+0x1fc>
      sprintf(event_path, "/%d/programchange", package.chn+1);
 8021910:	494d      	ldr	r1, [pc, #308]	@ (8021a48 <OSC_CLIENT_SendMIDIEvent+0x300>)
 8021912:	3201      	adds	r2, #1
 8021914:	4668      	mov	r0, sp
 8021916:	f7f7 fa55 	bl	8018dc4 <sprintf>
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 802191a:	4669      	mov	r1, sp
 802191c:	a808      	add	r0, sp, #32
 802191e:	f7f3 fedd 	bl	80156dc <MIOS32_OSC_PutString>
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
 8021922:	f839 3017 	ldrh.w	r3, [r9, r7, lsl #1]
 8021926:	2b02      	cmp	r3, #2
 8021928:	d108      	bne.n	802193c <OSC_CLIENT_SendMIDIEvent+0x1f4>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",f");
 802192a:	4934      	ldr	r1, [pc, #208]	@ (80219fc <OSC_CLIENT_SendMIDIEvent+0x2b4>)
 802192c:	f7f3 fed6 	bl	80156dc <MIOS32_OSC_PutString>
 8021930:	4604      	mov	r4, r0
	end_ptr = MIOS32_OSC_PutFloat(end_ptr, (float)package.program_change/127.0);
 8021932:	4640      	mov	r0, r8
	end_ptr = MIOS32_OSC_PutFloat(end_ptr, (float)package.velocity/127.0);
 8021934:	f001 fbdc 	bl	80230f0 <__aeabi_ui2f>
 8021938:	4944      	ldr	r1, [pc, #272]	@ (8021a4c <OSC_CLIENT_SendMIDIEvent+0x304>)
 802193a:	e775      	b.n	8021828 <OSC_CLIENT_SendMIDIEvent+0xe0>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",i");
 802193c:	4944      	ldr	r1, [pc, #272]	@ (8021a50 <OSC_CLIENT_SendMIDIEvent+0x308>)
 802193e:	f7f3 fecd 	bl	80156dc <MIOS32_OSC_PutString>
	end_ptr = MIOS32_OSC_PutInt(end_ptr, package.program_change);
 8021942:	4641      	mov	r1, r8
	end_ptr = MIOS32_OSC_PutInt(end_ptr, value);
 8021944:	f7f3 fec2 	bl	80156cc <MIOS32_OSC_PutInt>
 8021948:	e774      	b.n	8021834 <OSC_CLIENT_SendMIDIEvent+0xec>
      sprintf(event_path, "/%d/aftertouch", package.chn+1);
 802194a:	4938      	ldr	r1, [pc, #224]	@ (8021a2c <OSC_CLIENT_SendMIDIEvent+0x2e4>)
 802194c:	3201      	adds	r2, #1
 802194e:	4668      	mov	r0, sp
 8021950:	f7f7 fa38 	bl	8018dc4 <sprintf>
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 8021954:	4669      	mov	r1, sp
 8021956:	a808      	add	r0, sp, #32
 8021958:	f7f3 fec0 	bl	80156dc <MIOS32_OSC_PutString>
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
 802195c:	f839 3017 	ldrh.w	r3, [r9, r7, lsl #1]
 8021960:	2b02      	cmp	r3, #2
 8021962:	f43f af2a 	beq.w	80217ba <OSC_CLIENT_SendMIDIEvent+0x72>
	end_ptr = MIOS32_OSC_PutString(end_ptr, ",i");
 8021966:	493a      	ldr	r1, [pc, #232]	@ (8021a50 <OSC_CLIENT_SendMIDIEvent+0x308>)
 8021968:	f7f3 feb8 	bl	80156dc <MIOS32_OSC_PutString>
 802196c:	e7ce      	b.n	802190c <OSC_CLIENT_SendMIDIEvent+0x1c4>
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 802196e:	01ed      	lsls	r5, r5, #7
      sprintf(event_path, "/%d/pitchbend", package.chn+1);
 8021970:	4938      	ldr	r1, [pc, #224]	@ (8021a54 <OSC_CLIENT_SendMIDIEvent+0x30c>)
 8021972:	3201      	adds	r2, #1
 8021974:	4668      	mov	r0, sp
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 8021976:	f405 557e 	and.w	r5, r5, #16256	@ 0x3f80
 802197a:	f008 087f 	and.w	r8, r8, #127	@ 0x7f
      sprintf(event_path, "/%d/pitchbend", package.chn+1);
 802197e:	f7f7 fa21 	bl	8018dc4 <sprintf>
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 8021982:	ea45 0508 	orr.w	r5, r5, r8
      end_ptr = MIOS32_OSC_PutString(end_ptr, event_path);
 8021986:	4669      	mov	r1, sp
 8021988:	a808      	add	r0, sp, #32
 802198a:	f7f3 fea7 	bl	80156dc <MIOS32_OSC_PutString>
      int value = ((package.evnt1 & 0x7f) | (int)((package.evnt2 & 0x7f) << 7)) - 8192;
 802198e:	f5a5 5500 	sub.w	r5, r5, #8192	@ 0x2000
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
 8021992:	f839 3017 	ldrh.w	r3, [r9, r7, lsl #1]
	value = 0;
 8021996:	2d7f      	cmp	r5, #127	@ 0x7f
 8021998:	bf98      	it	ls
 802199a:	2500      	movls	r5, #0
      if( osc_transfer_mode[osc_port] == OSC_CLIENT_TRANSFER_MODE_FLOAT ) {
 802199c:	2b02      	cmp	r3, #2
 802199e:	d1e2      	bne.n	8021966 <OSC_CLIENT_SendMIDIEvent+0x21e>
 80219a0:	e73a      	b.n	8021818 <OSC_CLIENT_SendMIDIEvent+0xd0>
      sprintf(event_path, "/%d/invalid", package.chn);
 80219a2:	492d      	ldr	r1, [pc, #180]	@ (8021a58 <OSC_CLIENT_SendMIDIEvent+0x310>)
 80219a4:	e74f      	b.n	8021846 <OSC_CLIENT_SendMIDIEvent+0xfe>
    if( package.evnt0 == 0xf0 )
 80219a6:	f3c4 2207 	ubfx	r2, r4, #8, #8
 80219aa:	2af0      	cmp	r2, #240	@ 0xf0
 80219ac:	d10a      	bne.n	80219c4 <OSC_CLIENT_SendMIDIEvent+0x27c>
      sysex_buffer_len[osc_port] = 0;
 80219ae:	4b2b      	ldr	r3, [pc, #172]	@ (8021a5c <OSC_CLIENT_SendMIDIEvent+0x314>)
 80219b0:	2100      	movs	r1, #0
    if( package.type == 0xf && package.evnt0 < 0xf8 )
 80219b2:	2e0f      	cmp	r6, #15
      sysex_buffer_len[osc_port] = 0;
 80219b4:	55d9      	strb	r1, [r3, r7]
    if( package.type == 0xf && package.evnt0 < 0xf8 )
 80219b6:	d159      	bne.n	8021a6c <OSC_CLIENT_SendMIDIEvent+0x324>
      u8 *buffer = (u8 *)&sysex_buffer[osc_port];
 80219b8:	4e29      	ldr	r6, [pc, #164]	@ (8021a60 <OSC_CLIENT_SendMIDIEvent+0x318>)
      sysex_len = 1;
 80219ba:	f04f 0b01 	mov.w	fp, #1
      u8 *buffer = (u8 *)&sysex_buffer[osc_port];
 80219be:	eb06 1687 	add.w	r6, r6, r7, lsl #6
      for(i=0; i<sysex_len; ++i) {
 80219c2:	e060      	b.n	8021a86 <OSC_CLIENT_SendMIDIEvent+0x33e>
    if( package.type == 0xf && package.evnt0 < 0xf8 )
 80219c4:	2e0f      	cmp	r6, #15
 80219c6:	d151      	bne.n	8021a6c <OSC_CLIENT_SendMIDIEvent+0x324>
 80219c8:	2af7      	cmp	r2, #247	@ 0xf7
 80219ca:	d9f5      	bls.n	80219b8 <OSC_CLIENT_SendMIDIEvent+0x270>
      strcpy(midi_path, "/midiX");
 80219cc:	4925      	ldr	r1, [pc, #148]	@ (8021a64 <OSC_CLIENT_SendMIDIEvent+0x31c>)
 80219ce:	4668      	mov	r0, sp
 80219d0:	f001 fd84 	bl	80234dc <strcpy>
      midi_path[5] = '1' + osc_port;
 80219d4:	f107 0331 	add.w	r3, r7, #49	@ 0x31
      end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 80219d8:	4669      	mov	r1, sp
 80219da:	a808      	add	r0, sp, #32
      midi_path[5] = '1' + osc_port;
 80219dc:	f88d 3005 	strb.w	r3, [sp, #5]
      end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 80219e0:	f7f3 fe7c 	bl	80156dc <MIOS32_OSC_PutString>
      end_ptr = MIOS32_OSC_PutString(end_ptr, ",m");
 80219e4:	4920      	ldr	r1, [pc, #128]	@ (8021a68 <OSC_CLIENT_SendMIDIEvent+0x320>)
 80219e6:	f7f3 fe79 	bl	80156dc <MIOS32_OSC_PutString>
      end_ptr = MIOS32_OSC_PutMIDI(end_ptr, package);
 80219ea:	4621      	mov	r1, r4
 80219ec:	f7f3 feaf 	bl	801574e <MIOS32_OSC_PutMIDI>
 80219f0:	e720      	b.n	8021834 <OSC_CLIENT_SendMIDIEvent+0xec>
 80219f2:	bf00      	nop
 80219f4:	20007698 	.word	0x20007698
 80219f8:	080286ac 	.word	0x080286ac
 80219fc:	080286bd 	.word	0x080286bd
 8021a00:	080286c0 	.word	0x080286c0
 8021a04:	080286da 	.word	0x080286da
 8021a08:	080286ea 	.word	0x080286ea
 8021a0c:	08028705 	.word	0x08028705
 8021a10:	0802871a 	.word	0x0802871a
 8021a14:	45fff800 	.word	0x45fff800
 8021a18:	0802872a 	.word	0x0802872a
 8021a1c:	0802873c 	.word	0x0802873c
 8021a20:	08028748 	.word	0x08028748
 8021a24:	0802875c 	.word	0x0802875c
 8021a28:	08028766 	.word	0x08028766
 8021a2c:	0802877b 	.word	0x0802877b
 8021a30:	0802878a 	.word	0x0802878a
 8021a34:	080287a0 	.word	0x080287a0
 8021a38:	080287a9 	.word	0x080287a9
 8021a3c:	080287b1 	.word	0x080287b1
 8021a40:	080287c2 	.word	0x080287c2
 8021a44:	080287ad 	.word	0x080287ad
 8021a48:	080287c9 	.word	0x080287c9
 8021a4c:	42fe0000 	.word	0x42fe0000
 8021a50:	080287db 	.word	0x080287db
 8021a54:	080287de 	.word	0x080287de
 8021a58:	08028794 	.word	0x08028794
 8021a5c:	20007594 	.word	0x20007594
 8021a60:	20007598 	.word	0x20007598
 8021a64:	080287ec 	.word	0x080287ec
 8021a68:	080287f3 	.word	0x080287f3
    else if( package.type == 0x4 || package.type == 0x7 )
 8021a6c:	3e04      	subs	r6, #4
 8021a6e:	b2f6      	uxtb	r6, r6
 8021a70:	2e03      	cmp	r6, #3
 8021a72:	d8ab      	bhi.n	80219cc <OSC_CLIENT_SendMIDIEvent+0x284>
 8021a74:	4b24      	ldr	r3, [pc, #144]	@ (8021b08 <OSC_CLIENT_SendMIDIEvent+0x3c0>)
 8021a76:	f913 b006 	ldrsb.w	fp, [r3, r6]
      for(i=0; i<sysex_len; ++i) {
 8021a7a:	f1bb 0f00 	cmp.w	fp, #0
 8021a7e:	dd32      	ble.n	8021ae6 <OSC_CLIENT_SendMIDIEvent+0x39e>
      u8 *buffer = (u8 *)&sysex_buffer[osc_port];
 8021a80:	4e22      	ldr	r6, [pc, #136]	@ (8021b0c <OSC_CLIENT_SendMIDIEvent+0x3c4>)
 8021a82:	eb06 1687 	add.w	r6, r6, r7, lsl #6
      u8 send_sysex = 0;
 8021a86:	2000      	movs	r0, #0
	buffer[*buffer_len] = evnt;
 8021a88:	f8df a084 	ldr.w	sl, [pc, #132]	@ 8021b10 <OSC_CLIENT_SendMIDIEvent+0x3c8>
      for(i=0; i<sysex_len; ++i) {
 8021a8c:	4681      	mov	r9, r0
  u8 *end_ptr = packet;
 8021a8e:	ac08      	add	r4, sp, #32
	buffer[*buffer_len] = evnt;
 8021a90:	f81a 1007 	ldrb.w	r1, [sl, r7]
 8021a94:	5472      	strb	r2, [r6, r1]
	*buffer_len += 1;
 8021a96:	3101      	adds	r1, #1
 8021a98:	b2c9      	uxtb	r1, r1
	if( evnt == 0xf7 || *buffer_len >= OSC_CLIENT_SYSEX_BUFFER_SIZE ) {
 8021a9a:	2af7      	cmp	r2, #247	@ 0xf7
	*buffer_len += 1;
 8021a9c:	f80a 1007 	strb.w	r1, [sl, r7]
	if( evnt == 0xf7 || *buffer_len >= OSC_CLIENT_SYSEX_BUFFER_SIZE ) {
 8021aa0:	d001      	beq.n	8021aa6 <OSC_CLIENT_SendMIDIEvent+0x35e>
 8021aa2:	293f      	cmp	r1, #63	@ 0x3f
 8021aa4:	d918      	bls.n	8021ad8 <OSC_CLIENT_SendMIDIEvent+0x390>
	  strcpy(midi_path, "/midiX");
 8021aa6:	491b      	ldr	r1, [pc, #108]	@ (8021b14 <OSC_CLIENT_SendMIDIEvent+0x3cc>)
 8021aa8:	4668      	mov	r0, sp
 8021aaa:	f001 fd17 	bl	80234dc <strcpy>
	  midi_path[5] = '1' + osc_port;
 8021aae:	f107 0231 	add.w	r2, r7, #49	@ 0x31
	  end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 8021ab2:	4669      	mov	r1, sp
 8021ab4:	4620      	mov	r0, r4
	  midi_path[5] = '1' + osc_port;
 8021ab6:	f88d 2005 	strb.w	r2, [sp, #5]
	  end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 8021aba:	f7f3 fe0f 	bl	80156dc <MIOS32_OSC_PutString>
	  end_ptr = MIOS32_OSC_PutString(end_ptr, ",b");
 8021abe:	4916      	ldr	r1, [pc, #88]	@ (8021b18 <OSC_CLIENT_SendMIDIEvent+0x3d0>)
 8021ac0:	f7f3 fe0c 	bl	80156dc <MIOS32_OSC_PutString>
	  end_ptr = MIOS32_OSC_PutBlob(end_ptr, buffer, *buffer_len);
 8021ac4:	f81a 2007 	ldrb.w	r2, [sl, r7]
 8021ac8:	4631      	mov	r1, r6
 8021aca:	f7f3 fe16 	bl	80156fa <MIOS32_OSC_PutBlob>
	  *buffer_len = 0;
 8021ace:	2200      	movs	r2, #0
 8021ad0:	f80a 2007 	strb.w	r2, [sl, r7]
	  end_ptr = MIOS32_OSC_PutBlob(end_ptr, buffer, *buffer_len);
 8021ad4:	4604      	mov	r4, r0
	  send_sysex = 1;
 8021ad6:	2001      	movs	r0, #1
      for(i=0; i<sysex_len; ++i) {
 8021ad8:	f109 0901 	add.w	r9, r9, #1
 8021adc:	45d9      	cmp	r9, fp
 8021ade:	d106      	bne.n	8021aee <OSC_CLIENT_SendMIDIEvent+0x3a6>
      if( !send_sysex )
 8021ae0:	2800      	cmp	r0, #0
 8021ae2:	f47f aea8 	bne.w	8021836 <OSC_CLIENT_SendMIDIEvent+0xee>
	return 0; // wait until sysex stream is terminated (or buffer is full)
 8021ae6:	2000      	movs	r0, #0
}
 8021ae8:	b029      	add	sp, #164	@ 0xa4
 8021aea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  evnt = package.evnt2;
 8021aee:	f1b9 0f01 	cmp.w	r9, #1
 8021af2:	bf0c      	ite	eq
 8021af4:	4642      	moveq	r2, r8
 8021af6:	462a      	movne	r2, r5
 8021af8:	e7ca      	b.n	8021a90 <OSC_CLIENT_SendMIDIEvent+0x348>
    return -1; // invalid port
 8021afa:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021afe:	e7f3      	b.n	8021ae8 <OSC_CLIENT_SendMIDIEvent+0x3a0>
    return -2; 
 8021b00:	f06f 0001 	mvn.w	r0, #1
 8021b04:	e7f0      	b.n	8021ae8 <OSC_CLIENT_SendMIDIEvent+0x3a0>
 8021b06:	bf00      	nop
 8021b08:	080287f9 	.word	0x080287f9
 8021b0c:	20007598 	.word	0x20007598
 8021b10:	20007594 	.word	0x20007594
 8021b14:	080287ec 	.word	0x080287ec
 8021b18:	080287f6 	.word	0x080287f6

08021b1c <OSC_CLIENT_SendSysEx>:
/////////////////////////////////////////////////////////////////////////////
// Send a SysEx stream
// Path: /midi <midi-package>
/////////////////////////////////////////////////////////////////////////////
s32 OSC_CLIENT_SendSysEx(u8 osc_port, u8 *stream, u32 count)
{
 8021b1c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if( osc_port >= OSC_CLIENT_NUM_PORTS )
 8021b20:	2803      	cmp	r0, #3
{
 8021b22:	b0a3      	sub	sp, #140	@ 0x8c
 8021b24:	4606      	mov	r6, r0
 8021b26:	460f      	mov	r7, r1
 8021b28:	4615      	mov	r5, r2
  if( osc_port >= OSC_CLIENT_NUM_PORTS )
 8021b2a:	d832      	bhi.n	8021b92 <OSC_CLIENT_SendSysEx+0x76>
    return -1; // invalid port

#if !defined(MIOS32_FAMILY_EMULATION)
  // check if server is running
  if( !UIP_TASK_ServicesRunning() )
 8021b2c:	f7fe ffb2 	bl	8020a94 <UIP_TASK_ServicesRunning>
 8021b30:	b390      	cbz	r0, 8021b98 <OSC_CLIENT_SendSysEx+0x7c>
    // create the OSC packet
    u8 packet[128];
    u8 *end_ptr = packet;

    char midi_path[8];
    strcpy(midi_path, "/midiX");
 8021b32:	f8df a06c 	ldr.w	sl, [pc, #108]	@ 8021ba0 <OSC_CLIENT_SendSysEx+0x84>
    midi_path[5] = '1' + osc_port;
    end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
    end_ptr = MIOS32_OSC_PutString(end_ptr, ",b");
 8021b36:	f8df b06c 	ldr.w	fp, [pc, #108]	@ 8021ba4 <OSC_CLIENT_SendSysEx+0x88>
  int send_offset = 0;
 8021b3a:	2400      	movs	r4, #0
  while( send_offset < count ) {
 8021b3c:	42ac      	cmp	r4, r5
 8021b3e:	d303      	bcc.n	8021b48 <OSC_CLIENT_SendSysEx+0x2c>
    OSC_SERVER_SendPacket(osc_port, packet, (u32)(end_ptr-packet));

    send_offset += bytes_to_send;
  };

  return 0; // no error
 8021b40:	2000      	movs	r0, #0
}
 8021b42:	b023      	add	sp, #140	@ 0x8c
 8021b44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    u32 bytes_to_send = ((send_offset + max_bytes) > count) ? (count-send_offset) : max_bytes;
 8021b48:	f104 0340 	add.w	r3, r4, #64	@ 0x40
 8021b4c:	42ab      	cmp	r3, r5
    end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 8021b4e:	f10d 0908 	add.w	r9, sp, #8
    strcpy(midi_path, "/midiX");
 8021b52:	4651      	mov	r1, sl
 8021b54:	4668      	mov	r0, sp
    u32 bytes_to_send = ((send_offset + max_bytes) > count) ? (count-send_offset) : max_bytes;
 8021b56:	bf8c      	ite	hi
 8021b58:	eba5 0804 	subhi.w	r8, r5, r4
 8021b5c:	f04f 0840 	movls.w	r8, #64	@ 0x40
    strcpy(midi_path, "/midiX");
 8021b60:	f001 fcbc 	bl	80234dc <strcpy>
    midi_path[5] = '1' + osc_port;
 8021b64:	f106 0331 	add.w	r3, r6, #49	@ 0x31
    end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 8021b68:	4669      	mov	r1, sp
 8021b6a:	4648      	mov	r0, r9
    midi_path[5] = '1' + osc_port;
 8021b6c:	f88d 3005 	strb.w	r3, [sp, #5]
    end_ptr = MIOS32_OSC_PutString(end_ptr, midi_path);
 8021b70:	f7f3 fdb4 	bl	80156dc <MIOS32_OSC_PutString>
    end_ptr = MIOS32_OSC_PutString(end_ptr, ",b");
 8021b74:	4659      	mov	r1, fp
 8021b76:	f7f3 fdb1 	bl	80156dc <MIOS32_OSC_PutString>
    end_ptr = MIOS32_OSC_PutBlob(end_ptr, (u8 *)&stream[send_offset], bytes_to_send);
 8021b7a:	1939      	adds	r1, r7, r4
 8021b7c:	4642      	mov	r2, r8
 8021b7e:	f7f3 fdbc 	bl	80156fa <MIOS32_OSC_PutBlob>
    OSC_SERVER_SendPacket(osc_port, packet, (u32)(end_ptr-packet));
 8021b82:	4649      	mov	r1, r9
 8021b84:	eba0 0209 	sub.w	r2, r0, r9
 8021b88:	4630      	mov	r0, r6
 8021b8a:	f7ff fd67 	bl	802165c <OSC_SERVER_SendPacket>
    send_offset += bytes_to_send;
 8021b8e:	4444      	add	r4, r8
 8021b90:	e7d4      	b.n	8021b3c <OSC_CLIENT_SendSysEx+0x20>
    return -1; // invalid port
 8021b92:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8021b96:	e7d4      	b.n	8021b42 <OSC_CLIENT_SendSysEx+0x26>
    return -2; 
 8021b98:	f06f 0001 	mvn.w	r0, #1
 8021b9c:	e7d1      	b.n	8021b42 <OSC_CLIENT_SendSysEx+0x26>
 8021b9e:	bf00      	nop
 8021ba0:	080287ec 	.word	0x080287ec
 8021ba4:	080287f6 	.word	0x080287f6

08021ba8 <get_dec>:
// help function which parses a decimal or hex value
// returns >= 0 if value is valid
// returns -1 if value is invalid
/////////////////////////////////////////////////////////////////////////////
static s32 get_dec(char *word)
{
 8021ba8:	b513      	push	{r0, r1, r4, lr}
  if( word == NULL )
 8021baa:	4604      	mov	r4, r0
 8021bac:	b918      	cbnz	r0, 8021bb6 <get_dec+0xe>
    return -1;
 8021bae:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff

  if( word == next )
    return -1;

  return l; // value is valid
}
 8021bb2:	b002      	add	sp, #8
 8021bb4:	bd10      	pop	{r4, pc}
  long l = strtol(word, &next, 0);
 8021bb6:	2200      	movs	r2, #0
 8021bb8:	a901      	add	r1, sp, #4
 8021bba:	f7f1 faf9 	bl	80131b0 <strtol>
  if( word == next )
 8021bbe:	9b01      	ldr	r3, [sp, #4]
 8021bc0:	42a3      	cmp	r3, r4
 8021bc2:	d1f6      	bne.n	8021bb2 <get_dec+0xa>
 8021bc4:	e7f3      	b.n	8021bae <get_dec+0x6>
	...

08021bc8 <get_ip>:
// help function which parses an IP value
// returns > 0 if value is valid
// returns 0 if value is invalid
/////////////////////////////////////////////////////////////////////////////
static u32 get_ip(char *word)
{
 8021bc8:	b573      	push	{r0, r1, r4, r5, r6, lr}
  char *brkt;
  u8 ip[4];

  int i;
  for(i=0; i<4; ++i) {
    if( (word = strtok_r((i == 0) ? word : NULL, ".", &brkt)) ) {
 8021bca:	4d0c      	ldr	r5, [pc, #48]	@ (8021bfc <get_ip+0x34>)
  for(i=0; i<4; ++i) {
 8021bcc:	2400      	movs	r4, #0
      s32 value = get_dec(word);
      if( value >= 0 && value <= 255 )
	ip[i] = value;
 8021bce:	ae01      	add	r6, sp, #4
    if( (word = strtok_r((i == 0) ? word : NULL, ".", &brkt)) ) {
 8021bd0:	466a      	mov	r2, sp
 8021bd2:	4629      	mov	r1, r5
 8021bd4:	f001 fd16 	bl	8023604 <strtok_r>
 8021bd8:	b120      	cbz	r0, 8021be4 <get_ip+0x1c>
      s32 value = get_dec(word);
 8021bda:	f7ff ffe5 	bl	8021ba8 <get_dec>
      if( value >= 0 && value <= 255 )
 8021bde:	28ff      	cmp	r0, #255	@ 0xff
 8021be0:	d809      	bhi.n	8021bf6 <get_ip+0x2e>
	ip[i] = value;
 8021be2:	55a0      	strb	r0, [r4, r6]
  for(i=0; i<4; ++i) {
 8021be4:	3401      	adds	r4, #1
 8021be6:	2c04      	cmp	r4, #4
    if( (word = strtok_r((i == 0) ? word : NULL, ".", &brkt)) ) {
 8021be8:	f04f 0000 	mov.w	r0, #0
  for(i=0; i<4; ++i) {
 8021bec:	d1f0      	bne.n	8021bd0 <get_ip+0x8>
	return 0;
    }
  }

  if( i == 4 )
    return (ip[0]<<24)|(ip[1]<<16)|(ip[2]<<8)|(ip[3]<<0);
 8021bee:	9801      	ldr	r0, [sp, #4]
 8021bf0:	ba00      	rev	r0, r0
  else
    return 0; // invalid IP
}
 8021bf2:	b002      	add	sp, #8
 8021bf4:	bd70      	pop	{r4, r5, r6, pc}
	return 0;
 8021bf6:	2000      	movs	r0, #0
 8021bf8:	e7fb      	b.n	8021bf2 <get_ip+0x2a>
 8021bfa:	bf00      	nop
 8021bfc:	080262f8 	.word	0x080262f8

08021c00 <UIP_TERMINAL_PrintIPs.isra.0>:
static s32 UIP_TERMINAL_PrintIPs(void *_output_function)
{
  void (*out)(char *format, ...) = _output_function;

  uip_ipaddr_t ipaddr;
  uip_gethostaddr(&ipaddr);
 8021c00:	4b2c      	ldr	r3, [pc, #176]	@ (8021cb4 <UIP_TERMINAL_PrintIPs.isra.0+0xb4>)
static s32 UIP_TERMINAL_PrintIPs(void *_output_function)
 8021c02:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  uip_gethostaddr(&ipaddr);
 8021c06:	881e      	ldrh	r6, [r3, #0]
 8021c08:	f8b3 8002 	ldrh.w	r8, [r3, #2]
static s32 UIP_TERMINAL_PrintIPs(void *_output_function)
 8021c0c:	4604      	mov	r4, r0
  out("IP address: %d.%d.%d.%d",
      uip_ipaddr1(ipaddr), uip_ipaddr2(ipaddr),
 8021c0e:	4630      	mov	r0, r6
 8021c10:	f7fe faea 	bl	80201e8 <htons>
 8021c14:	4605      	mov	r5, r0
 8021c16:	4630      	mov	r0, r6
 8021c18:	f7fe fae6 	bl	80201e8 <htons>
 8021c1c:	4606      	mov	r6, r0
      uip_ipaddr3(ipaddr), uip_ipaddr4(ipaddr));
 8021c1e:	4640      	mov	r0, r8
 8021c20:	f7fe fae2 	bl	80201e8 <htons>
 8021c24:	4607      	mov	r7, r0
 8021c26:	4640      	mov	r0, r8
 8021c28:	f7fe fade 	bl	80201e8 <htons>
  out("IP address: %d.%d.%d.%d",
 8021c2c:	b2c0      	uxtb	r0, r0
 8021c2e:	b2f2      	uxtb	r2, r6
 8021c30:	f3c5 210f 	ubfx	r1, r5, #8, #16
 8021c34:	9000      	str	r0, [sp, #0]
 8021c36:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8021c3a:	481f      	ldr	r0, [pc, #124]	@ (8021cb8 <UIP_TERMINAL_PrintIPs.isra.0+0xb8>)
 8021c3c:	47a0      	blx	r4

  uip_ipaddr_t netmask;
  uip_getnetmask(&netmask);
 8021c3e:	4b1f      	ldr	r3, [pc, #124]	@ (8021cbc <UIP_TERMINAL_PrintIPs.isra.0+0xbc>)
 8021c40:	881e      	ldrh	r6, [r3, #0]
 8021c42:	f8b3 8002 	ldrh.w	r8, [r3, #2]
  out("Netmask: %d.%d.%d.%d",
      uip_ipaddr1(netmask), uip_ipaddr2(netmask),
 8021c46:	4630      	mov	r0, r6
 8021c48:	f7fe face 	bl	80201e8 <htons>
 8021c4c:	4605      	mov	r5, r0
 8021c4e:	4630      	mov	r0, r6
 8021c50:	f7fe faca 	bl	80201e8 <htons>
 8021c54:	4606      	mov	r6, r0
      uip_ipaddr3(netmask), uip_ipaddr4(netmask));
 8021c56:	4640      	mov	r0, r8
 8021c58:	f7fe fac6 	bl	80201e8 <htons>
 8021c5c:	4607      	mov	r7, r0
 8021c5e:	4640      	mov	r0, r8
 8021c60:	f7fe fac2 	bl	80201e8 <htons>
  out("Netmask: %d.%d.%d.%d",
 8021c64:	b2c0      	uxtb	r0, r0
 8021c66:	b2f2      	uxtb	r2, r6
 8021c68:	f3c5 210f 	ubfx	r1, r5, #8, #16
 8021c6c:	9000      	str	r0, [sp, #0]
 8021c6e:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8021c72:	4813      	ldr	r0, [pc, #76]	@ (8021cc0 <UIP_TERMINAL_PrintIPs.isra.0+0xc0>)
 8021c74:	47a0      	blx	r4

  uip_ipaddr_t draddr;
  uip_getdraddr(&draddr);
 8021c76:	4b13      	ldr	r3, [pc, #76]	@ (8021cc4 <UIP_TERMINAL_PrintIPs.isra.0+0xc4>)
 8021c78:	881e      	ldrh	r6, [r3, #0]
 8021c7a:	f8b3 8002 	ldrh.w	r8, [r3, #2]
  out("Default Router (Gateway): %d.%d.%d.%d",
      uip_ipaddr1(draddr), uip_ipaddr2(draddr),
 8021c7e:	4630      	mov	r0, r6
 8021c80:	f7fe fab2 	bl	80201e8 <htons>
 8021c84:	4605      	mov	r5, r0
 8021c86:	4630      	mov	r0, r6
 8021c88:	f7fe faae 	bl	80201e8 <htons>
 8021c8c:	4606      	mov	r6, r0
      uip_ipaddr3(draddr), uip_ipaddr4(draddr));
 8021c8e:	4640      	mov	r0, r8
 8021c90:	f7fe faaa 	bl	80201e8 <htons>
 8021c94:	4607      	mov	r7, r0
 8021c96:	4640      	mov	r0, r8
 8021c98:	f7fe faa6 	bl	80201e8 <htons>
  out("Default Router (Gateway): %d.%d.%d.%d",
 8021c9c:	b2c0      	uxtb	r0, r0
 8021c9e:	9000      	str	r0, [sp, #0]
 8021ca0:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8021ca4:	4808      	ldr	r0, [pc, #32]	@ (8021cc8 <UIP_TERMINAL_PrintIPs.isra.0+0xc8>)
 8021ca6:	b2f2      	uxtb	r2, r6
 8021ca8:	f3c5 210f 	ubfx	r1, r5, #8, #16
 8021cac:	47a0      	blx	r4

  return 0; // no error
}
 8021cae:	b002      	add	sp, #8
 8021cb0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8021cb4:	200074ca 	.word	0x200074ca
 8021cb8:	0802887b 	.word	0x0802887b
 8021cbc:	200074c2 	.word	0x200074c2
 8021cc0:	08028893 	.word	0x08028893
 8021cc4:	200074c6 	.word	0x200074c6
 8021cc8:	080288a8 	.word	0x080288a8

08021ccc <UIP_TERMINAL_Help>:
{
 8021ccc:	b510      	push	{r4, lr}
 8021cce:	4604      	mov	r4, r0
  out("  network:                          print network info");
 8021cd0:	480c      	ldr	r0, [pc, #48]	@ (8021d04 <UIP_TERMINAL_Help+0x38>)
 8021cd2:	47a0      	blx	r4
  out("  set dhcp <on|off>:                enables/disables DHCP");
 8021cd4:	480c      	ldr	r0, [pc, #48]	@ (8021d08 <UIP_TERMINAL_Help+0x3c>)
 8021cd6:	47a0      	blx	r4
  out("  set ip <address>:                 changes IP address");
 8021cd8:	480c      	ldr	r0, [pc, #48]	@ (8021d0c <UIP_TERMINAL_Help+0x40>)
 8021cda:	47a0      	blx	r4
  out("  set netmask <mask>:               changes netmask");
 8021cdc:	480c      	ldr	r0, [pc, #48]	@ (8021d10 <UIP_TERMINAL_Help+0x44>)
 8021cde:	47a0      	blx	r4
  out("  set gateway <address>:            changes gateway address");
 8021ce0:	480c      	ldr	r0, [pc, #48]	@ (8021d14 <UIP_TERMINAL_Help+0x48>)
 8021ce2:	47a0      	blx	r4
  out("  set osc_remote <con> <address>:   changes OSC Remote Address");
 8021ce4:	480c      	ldr	r0, [pc, #48]	@ (8021d18 <UIP_TERMINAL_Help+0x4c>)
 8021ce6:	47a0      	blx	r4
  out("  set osc_remote_port <con> <port>: changes OSC Remote Port (1024..65535)");
 8021ce8:	480c      	ldr	r0, [pc, #48]	@ (8021d1c <UIP_TERMINAL_Help+0x50>)
 8021cea:	47a0      	blx	r4
  out("  set osc_local_port <con> <port>:  changes OSC Local Port (1024..65535)");
 8021cec:	480c      	ldr	r0, [pc, #48]	@ (8021d20 <UIP_TERMINAL_Help+0x54>)
 8021cee:	47a0      	blx	r4
  out("  set osc_mode <con> <mode>:        changes OSC Transfer Mode (0..%d)", OSC_CLIENT_NUM_TRANSFER_MODES-1);
 8021cf0:	2104      	movs	r1, #4
 8021cf2:	480c      	ldr	r0, [pc, #48]	@ (8021d24 <UIP_TERMINAL_Help+0x58>)
 8021cf4:	47a0      	blx	r4
  out("  set udpmon <0..4>:                enables UDP monitor (verbose level: %d)\n", UIP_TASK_UDP_MonitorLevelGet());
 8021cf6:	f7fe ff33 	bl	8020b60 <UIP_TASK_UDP_MonitorLevelGet>
 8021cfa:	4601      	mov	r1, r0
 8021cfc:	480a      	ldr	r0, [pc, #40]	@ (8021d28 <UIP_TERMINAL_Help+0x5c>)
 8021cfe:	47a0      	blx	r4
}
 8021d00:	2000      	movs	r0, #0
 8021d02:	bd10      	pop	{r4, pc}
 8021d04:	080288ce 	.word	0x080288ce
 8021d08:	08028905 	.word	0x08028905
 8021d0c:	0802893f 	.word	0x0802893f
 8021d10:	08028976 	.word	0x08028976
 8021d14:	080289aa 	.word	0x080289aa
 8021d18:	080289e6 	.word	0x080289e6
 8021d1c:	08028a25 	.word	0x08028a25
 8021d20:	08028a6f 	.word	0x08028a6f
 8021d24:	08028ab8 	.word	0x08028ab8
 8021d28:	08028afe 	.word	0x08028afe

08021d2c <UIP_TERMINAL_PrintNetwork>:
{
 8021d2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8021d30:	b085      	sub	sp, #20
 8021d32:	4604      	mov	r4, r0
  out("Ethernet cable connected: %s", UIP_TASK_NetworkDeviceAvailable() ? "yes" : "no");
 8021d34:	f7fe feb4 	bl	8020aa0 <UIP_TASK_NetworkDeviceAvailable>
 8021d38:	4e38      	ldr	r6, [pc, #224]	@ (8021e1c <UIP_TERMINAL_PrintNetwork+0xf0>)
 8021d3a:	4d39      	ldr	r5, [pc, #228]	@ (8021e20 <UIP_TERMINAL_PrintNetwork+0xf4>)
 8021d3c:	2800      	cmp	r0, #0
 8021d3e:	bf0c      	ite	eq
 8021d40:	4631      	moveq	r1, r6
 8021d42:	4629      	movne	r1, r5
 8021d44:	4837      	ldr	r0, [pc, #220]	@ (8021e24 <UIP_TERMINAL_PrintNetwork+0xf8>)
 8021d46:	47a0      	blx	r4
      uip_ethaddr.addr[0], uip_ethaddr.addr[1], uip_ethaddr.addr[2],
 8021d48:	4937      	ldr	r1, [pc, #220]	@ (8021e28 <UIP_TERMINAL_PrintNetwork+0xfc>)
  out("Ethernet MAC address: %02X:%02X:%02X:%02X:%02X:%02X\n",
 8021d4a:	4838      	ldr	r0, [pc, #224]	@ (8021e2c <UIP_TERMINAL_PrintNetwork+0x100>)
 8021d4c:	794b      	ldrb	r3, [r1, #5]
 8021d4e:	9302      	str	r3, [sp, #8]
 8021d50:	790b      	ldrb	r3, [r1, #4]
 8021d52:	9301      	str	r3, [sp, #4]
 8021d54:	78cb      	ldrb	r3, [r1, #3]
 8021d56:	9300      	str	r3, [sp, #0]
 8021d58:	788b      	ldrb	r3, [r1, #2]
 8021d5a:	784a      	ldrb	r2, [r1, #1]
 8021d5c:	7809      	ldrb	r1, [r1, #0]
 8021d5e:	47a0      	blx	r4
  out("Ethernet services running: %s", UIP_TASK_ServicesRunning() ? "yes" : "no");
 8021d60:	f7fe fe98 	bl	8020a94 <UIP_TASK_ServicesRunning>
 8021d64:	2800      	cmp	r0, #0
 8021d66:	bf0c      	ite	eq
 8021d68:	4631      	moveq	r1, r6
 8021d6a:	4629      	movne	r1, r5
 8021d6c:	4830      	ldr	r0, [pc, #192]	@ (8021e30 <UIP_TERMINAL_PrintNetwork+0x104>)
 8021d6e:	47a0      	blx	r4
  out("DHCP: %s", UIP_TASK_DHCP_EnableGet() ? "enabled" : "disabled");
 8021d70:	f7fe fe30 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021d74:	4a2f      	ldr	r2, [pc, #188]	@ (8021e34 <UIP_TERMINAL_PrintNetwork+0x108>)
 8021d76:	4930      	ldr	r1, [pc, #192]	@ (8021e38 <UIP_TERMINAL_PrintNetwork+0x10c>)
 8021d78:	2800      	cmp	r0, #0
 8021d7a:	bf08      	it	eq
 8021d7c:	4611      	moveq	r1, r2
 8021d7e:	482f      	ldr	r0, [pc, #188]	@ (8021e3c <UIP_TERMINAL_PrintNetwork+0x110>)
 8021d80:	47a0      	blx	r4
  if( UIP_TASK_DHCP_EnableGet() && !UIP_TASK_ServicesRunning() ) {
 8021d82:	f7fe fe27 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021d86:	2800      	cmp	r0, #0
 8021d88:	d043      	beq.n	8021e12 <UIP_TERMINAL_PrintNetwork+0xe6>
 8021d8a:	f7fe fe83 	bl	8020a94 <UIP_TASK_ServicesRunning>
 8021d8e:	2800      	cmp	r0, #0
 8021d90:	d13f      	bne.n	8021e12 <UIP_TERMINAL_PrintNetwork+0xe6>
    out("IP address: not available yet");
 8021d92:	482b      	ldr	r0, [pc, #172]	@ (8021e40 <UIP_TERMINAL_PrintNetwork+0x114>)
 8021d94:	47a0      	blx	r4
    out("Netmask: not available yet");
 8021d96:	482b      	ldr	r0, [pc, #172]	@ (8021e44 <UIP_TERMINAL_PrintNetwork+0x118>)
 8021d98:	47a0      	blx	r4
    out("Default Router (Gateway): not available yet");
 8021d9a:	482b      	ldr	r0, [pc, #172]	@ (8021e48 <UIP_TERMINAL_PrintNetwork+0x11c>)
 8021d9c:	47a0      	blx	r4
    out("OSC%d Remote address: %d.%d.%d.%d",
 8021d9e:	f8df 90ac 	ldr.w	r9, [pc, #172]	@ 8021e4c <UIP_TERMINAL_PrintNetwork+0x120>
    out("OSC%d Remote port: %d", con+1, OSC_SERVER_RemotePortGet(con));
 8021da2:	f8df 80ac 	ldr.w	r8, [pc, #172]	@ 8021e50 <UIP_TERMINAL_PrintNetwork+0x124>
    out("OSC%d Local port: %d", con+1, OSC_SERVER_LocalPortGet(con));
 8021da6:	4f2b      	ldr	r7, [pc, #172]	@ (8021e54 <UIP_TERMINAL_PrintNetwork+0x128>)
  out("DHCP: %s", UIP_TASK_DHCP_EnableGet() ? "enabled" : "disabled");
 8021da8:	2500      	movs	r5, #0
    u32 osc_remote_ip = OSC_SERVER_RemoteIP_Get(con);
 8021daa:	b2ee      	uxtb	r6, r5
 8021dac:	4630      	mov	r0, r6
 8021dae:	f7ff fba1 	bl	80214f4 <OSC_SERVER_RemoteIP_Get>
    out("OSC%d Remote address: %d.%d.%d.%d",
 8021db2:	b2c3      	uxtb	r3, r0
 8021db4:	3501      	adds	r5, #1
 8021db6:	9301      	str	r3, [sp, #4]
 8021db8:	f3c0 2307 	ubfx	r3, r0, #8, #8
 8021dbc:	0e02      	lsrs	r2, r0, #24
 8021dbe:	4629      	mov	r1, r5
 8021dc0:	9300      	str	r3, [sp, #0]
 8021dc2:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8021dc6:	4648      	mov	r0, r9
 8021dc8:	47a0      	blx	r4
    out("OSC%d Remote port: %d", con+1, OSC_SERVER_RemotePortGet(con));
 8021dca:	4630      	mov	r0, r6
 8021dcc:	f7ff fba4 	bl	8021518 <OSC_SERVER_RemotePortGet>
 8021dd0:	4629      	mov	r1, r5
 8021dd2:	4602      	mov	r2, r0
 8021dd4:	4640      	mov	r0, r8
 8021dd6:	47a0      	blx	r4
    out("OSC%d Local port: %d", con+1, OSC_SERVER_LocalPortGet(con));
 8021dd8:	4630      	mov	r0, r6
 8021dda:	f7ff fbaf 	bl	802153c <OSC_SERVER_LocalPortGet>
 8021dde:	4629      	mov	r1, r5
 8021de0:	4602      	mov	r2, r0
 8021de2:	4638      	mov	r0, r7
 8021de4:	47a0      	blx	r4
    s32 mode = OSC_CLIENT_TransferModeGet(con);
 8021de6:	4630      	mov	r0, r6
 8021de8:	f7ff fc9c 	bl	8021724 <OSC_CLIENT_TransferModeGet>
 8021dec:	4606      	mov	r6, r0
    out("OSC%d Transfer Mode: %d - %s", con+1, mode, OSC_CLIENT_TransferModeFullNameGet(mode));
 8021dee:	f7ff fc9f 	bl	8021730 <OSC_CLIENT_TransferModeFullNameGet>
 8021df2:	4632      	mov	r2, r6
 8021df4:	4603      	mov	r3, r0
 8021df6:	4629      	mov	r1, r5
 8021df8:	4817      	ldr	r0, [pc, #92]	@ (8021e58 <UIP_TERMINAL_PrintNetwork+0x12c>)
 8021dfa:	47a0      	blx	r4
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 8021dfc:	2d04      	cmp	r5, #4
 8021dfe:	d1d4      	bne.n	8021daa <UIP_TERMINAL_PrintNetwork+0x7e>
  out("UDP Monitor: verbose level #%d\n", UIP_TASK_UDP_MonitorLevelGet());
 8021e00:	f7fe feae 	bl	8020b60 <UIP_TASK_UDP_MonitorLevelGet>
 8021e04:	4601      	mov	r1, r0
 8021e06:	4815      	ldr	r0, [pc, #84]	@ (8021e5c <UIP_TERMINAL_PrintNetwork+0x130>)
 8021e08:	47a0      	blx	r4
}
 8021e0a:	2000      	movs	r0, #0
 8021e0c:	b005      	add	sp, #20
 8021e0e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UIP_TERMINAL_PrintIPs(_output_function);
 8021e12:	4620      	mov	r0, r4
 8021e14:	f7ff fef4 	bl	8021c00 <UIP_TERMINAL_PrintIPs.isra.0>
  for(con=0; con<OSC_SERVER_NUM_CONNECTIONS; ++con) {
 8021e18:	e7c1      	b.n	8021d9e <UIP_TERMINAL_PrintNetwork+0x72>
 8021e1a:	bf00      	nop
 8021e1c:	08028b4f 	.word	0x08028b4f
 8021e20:	08028b4b 	.word	0x08028b4b
 8021e24:	08028b52 	.word	0x08028b52
 8021e28:	200074bc 	.word	0x200074bc
 8021e2c:	08028b6f 	.word	0x08028b6f
 8021e30:	08028ba4 	.word	0x08028ba4
 8021e34:	080254c5 	.word	0x080254c5
 8021e38:	080254bd 	.word	0x080254bd
 8021e3c:	08028bc2 	.word	0x08028bc2
 8021e40:	08028bcb 	.word	0x08028bcb
 8021e44:	08028be9 	.word	0x08028be9
 8021e48:	08028c04 	.word	0x08028c04
 8021e4c:	08028c30 	.word	0x08028c30
 8021e50:	08028c52 	.word	0x08028c52
 8021e54:	08028c68 	.word	0x08028c68
 8021e58:	08028c7d 	.word	0x08028c7d
 8021e5c:	08028c9a 	.word	0x08028c9a

08021e60 <UIP_TERMINAL_ParseLine>:
{
 8021e60:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8021e64:	4607      	mov	r7, r0
 8021e66:	460c      	mov	r4, r1
  int input_len = strlen(input);
 8021e68:	f001 fb50 	bl	802350c <strlen>
  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 8021e6c:	4999      	ldr	r1, [pc, #612]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
  int input_len = strlen(input);
 8021e6e:	4680      	mov	r8, r0
  if( (parameter = strtok_r(input, separators, &brkt)) ) {
 8021e70:	aa03      	add	r2, sp, #12
 8021e72:	4638      	mov	r0, r7
 8021e74:	f001 fbc6 	bl	8023604 <strtok_r>
 8021e78:	4605      	mov	r5, r0
 8021e7a:	b948      	cbnz	r0, 8021e90 <UIP_TERMINAL_ParseLine+0x30>
 8021e7c:	1e7b      	subs	r3, r7, #1
      *input_ptr = ' ';
 8021e7e:	2120      	movs	r1, #32
  for(i=0; i<input_len; ++i, ++input_ptr)
 8021e80:	f1c7 0701 	rsb	r7, r7, #1
 8021e84:	18fa      	adds	r2, r7, r3
 8021e86:	4542      	cmp	r2, r8
 8021e88:	f2c0 825f 	blt.w	802234a <UIP_TERMINAL_ParseLine+0x4ea>
  return 0; // command not taken
 8021e8c:	2000      	movs	r0, #0
 8021e8e:	e007      	b.n	8021ea0 <UIP_TERMINAL_ParseLine+0x40>
    if( strcmp(parameter, "network") == 0 ) {
 8021e90:	4991      	ldr	r1, [pc, #580]	@ (80220d8 <UIP_TERMINAL_ParseLine+0x278>)
 8021e92:	f001 fbba 	bl	802360a <strcmp>
 8021e96:	b930      	cbnz	r0, 8021ea6 <UIP_TERMINAL_ParseLine+0x46>
      UIP_TERMINAL_PrintNetwork(_output_function);
 8021e98:	4620      	mov	r0, r4
 8021e9a:	f7ff ff47 	bl	8021d2c <UIP_TERMINAL_PrintNetwork>
      return 1; // command taken
 8021e9e:	2001      	movs	r0, #1
}
 8021ea0:	b004      	add	sp, #16
 8021ea2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    } else if( strcmp(parameter, "set") == 0 ) {
 8021ea6:	498d      	ldr	r1, [pc, #564]	@ (80220dc <UIP_TERMINAL_ParseLine+0x27c>)
 8021ea8:	4628      	mov	r0, r5
 8021eaa:	f001 fbae 	bl	802360a <strcmp>
 8021eae:	2800      	cmp	r0, #0
 8021eb0:	d1e4      	bne.n	8021e7c <UIP_TERMINAL_ParseLine+0x1c>
      if( !(parameter = strtok_r(NULL, separators, &brkt)) ) {
 8021eb2:	4988      	ldr	r1, [pc, #544]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8021eb4:	aa03      	add	r2, sp, #12
 8021eb6:	f001 fba5 	bl	8023604 <strtok_r>
 8021eba:	4605      	mov	r5, r0
 8021ebc:	b910      	cbnz	r0, 8021ec4 <UIP_TERMINAL_ParseLine+0x64>
	out("Missing parameter after 'set'!");
 8021ebe:	4888      	ldr	r0, [pc, #544]	@ (80220e0 <UIP_TERMINAL_ParseLine+0x280>)
 8021ec0:	47a0      	blx	r4
	return 1; // command taken
 8021ec2:	e7ec      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
      if( strcmp(parameter, "dhcp") == 0 ) {
 8021ec4:	4987      	ldr	r1, [pc, #540]	@ (80220e4 <UIP_TERMINAL_ParseLine+0x284>)
 8021ec6:	f001 fba0 	bl	802360a <strcmp>
 8021eca:	bb48      	cbnz	r0, 8021f20 <UIP_TERMINAL_ParseLine+0xc0>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8021ecc:	4981      	ldr	r1, [pc, #516]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8021ece:	aa03      	add	r2, sp, #12
 8021ed0:	f001 fb98 	bl	8023604 <strtok_r>
 8021ed4:	4605      	mov	r5, r0
 8021ed6:	b190      	cbz	r0, 8021efe <UIP_TERMINAL_ParseLine+0x9e>
  if( strcmp(word, "on") == 0 || strcmp(word, "1") == 0 )
 8021ed8:	4983      	ldr	r1, [pc, #524]	@ (80220e8 <UIP_TERMINAL_ParseLine+0x288>)
 8021eda:	f001 fb96 	bl	802360a <strcmp>
 8021ede:	b180      	cbz	r0, 8021f02 <UIP_TERMINAL_ParseLine+0xa2>
 8021ee0:	4982      	ldr	r1, [pc, #520]	@ (80220ec <UIP_TERMINAL_ParseLine+0x28c>)
 8021ee2:	4628      	mov	r0, r5
 8021ee4:	f001 fb91 	bl	802360a <strcmp>
 8021ee8:	b158      	cbz	r0, 8021f02 <UIP_TERMINAL_ParseLine+0xa2>
  if( strcmp(word, "off") == 0 || strcmp(word, "0") == 0 )
 8021eea:	4981      	ldr	r1, [pc, #516]	@ (80220f0 <UIP_TERMINAL_ParseLine+0x290>)
 8021eec:	4628      	mov	r0, r5
 8021eee:	f001 fb8c 	bl	802360a <strcmp>
 8021ef2:	b138      	cbz	r0, 8021f04 <UIP_TERMINAL_ParseLine+0xa4>
 8021ef4:	497f      	ldr	r1, [pc, #508]	@ (80220f4 <UIP_TERMINAL_ParseLine+0x294>)
 8021ef6:	4628      	mov	r0, r5
 8021ef8:	f001 fb87 	bl	802360a <strcmp>
 8021efc:	b110      	cbz	r0, 8021f04 <UIP_TERMINAL_ParseLine+0xa4>
	  out("Expecting 'on' or 'off'!");
 8021efe:	487e      	ldr	r0, [pc, #504]	@ (80220f8 <UIP_TERMINAL_ParseLine+0x298>)
 8021f00:	e7de      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
    return 1;
 8021f02:	2001      	movs	r0, #1
	UIP_TASK_DHCP_EnableSet(on_off);
 8021f04:	b2c0      	uxtb	r0, r0
 8021f06:	f7fe fc5d 	bl	80207c4 <UIP_TASK_DHCP_EnableSet>
	if( UIP_TASK_DHCP_EnableGet() ) {
 8021f0a:	f7fe fd63 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021f0e:	b108      	cbz	r0, 8021f14 <UIP_TERMINAL_ParseLine+0xb4>
	  out("DHCP enabled - waiting for IP address from server!\n");
 8021f10:	487a      	ldr	r0, [pc, #488]	@ (80220fc <UIP_TERMINAL_ParseLine+0x29c>)
 8021f12:	e7d5      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	  out("DHCP disabled - using predefined values:");
 8021f14:	487a      	ldr	r0, [pc, #488]	@ (8022100 <UIP_TERMINAL_ParseLine+0x2a0>)
 8021f16:	47a0      	blx	r4
	  UIP_TERMINAL_PrintIPs(_output_function);
 8021f18:	4620      	mov	r0, r4
 8021f1a:	f7ff fe71 	bl	8021c00 <UIP_TERMINAL_PrintIPs.isra.0>
 8021f1e:	e7be      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
      } else if( strcmp(parameter, "ip") == 0 ) {
 8021f20:	4978      	ldr	r1, [pc, #480]	@ (8022104 <UIP_TERMINAL_ParseLine+0x2a4>)
 8021f22:	4628      	mov	r0, r5
 8021f24:	f001 fb71 	bl	802360a <strcmp>
 8021f28:	bb70      	cbnz	r0, 8021f88 <UIP_TERMINAL_ParseLine+0x128>
	if( UIP_TASK_DHCP_EnableGet() ) {
 8021f2a:	f7fe fd53 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021f2e:	b108      	cbz	r0, 8021f34 <UIP_TERMINAL_ParseLine+0xd4>
	  out("ERROR: DHCP enabled - please disable it first via 'set dhcp off'");
 8021f30:	4875      	ldr	r0, [pc, #468]	@ (8022108 <UIP_TERMINAL_ParseLine+0x2a8>)
 8021f32:	e7c5      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8021f34:	4967      	ldr	r1, [pc, #412]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8021f36:	aa03      	add	r2, sp, #12
 8021f38:	f001 fb64 	bl	8023604 <strtok_r>
 8021f3c:	b908      	cbnz	r0, 8021f42 <UIP_TERMINAL_ParseLine+0xe2>
	  out("Expecting IP address in format a.b.c.d!");
 8021f3e:	4873      	ldr	r0, [pc, #460]	@ (802210c <UIP_TERMINAL_ParseLine+0x2ac>)
 8021f40:	e7be      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	  ip = get_ip(parameter);
 8021f42:	f7ff fe41 	bl	8021bc8 <get_ip>
	if( !ip ) {
 8021f46:	2800      	cmp	r0, #0
 8021f48:	d0f9      	beq.n	8021f3e <UIP_TERMINAL_ParseLine+0xde>
	UIP_TASK_IP_AddressSet(ip);
 8021f4a:	f7fe fd49 	bl	80209e0 <UIP_TASK_IP_AddressSet>
	uip_gethostaddr(&ipaddr);
 8021f4e:	4b70      	ldr	r3, [pc, #448]	@ (8022110 <UIP_TERMINAL_ParseLine+0x2b0>)
 8021f50:	881e      	ldrh	r6, [r3, #0]
 8021f52:	f8b3 8002 	ldrh.w	r8, [r3, #2]
	    uip_ipaddr1(ipaddr), uip_ipaddr2(ipaddr),
 8021f56:	4630      	mov	r0, r6
 8021f58:	f7fe f946 	bl	80201e8 <htons>
 8021f5c:	4605      	mov	r5, r0
 8021f5e:	4630      	mov	r0, r6
 8021f60:	f7fe f942 	bl	80201e8 <htons>
 8021f64:	4606      	mov	r6, r0
	    uip_ipaddr3(ipaddr), uip_ipaddr4(ipaddr));
 8021f66:	4640      	mov	r0, r8
 8021f68:	f7fe f93e 	bl	80201e8 <htons>
 8021f6c:	4607      	mov	r7, r0
 8021f6e:	4640      	mov	r0, r8
 8021f70:	f7fe f93a 	bl	80201e8 <htons>
	out("Set IP address to %d.%d.%d.%d",
 8021f74:	b2c0      	uxtb	r0, r0
 8021f76:	9000      	str	r0, [sp, #0]
 8021f78:	4866      	ldr	r0, [pc, #408]	@ (8022114 <UIP_TERMINAL_ParseLine+0x2b4>)
 8021f7a:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8021f7e:	b2f2      	uxtb	r2, r6
 8021f80:	f3c5 210f 	ubfx	r1, r5, #8, #16
	out("Set gateway to %d.%d.%d.%d",
 8021f84:	47a0      	blx	r4
	return 1; // command taken
 8021f86:	e78a      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
      } else if( strcmp(parameter, "netmask") == 0 ) {
 8021f88:	4963      	ldr	r1, [pc, #396]	@ (8022118 <UIP_TERMINAL_ParseLine+0x2b8>)
 8021f8a:	4628      	mov	r0, r5
 8021f8c:	f001 fb3d 	bl	802360a <strcmp>
 8021f90:	bb60      	cbnz	r0, 8021fec <UIP_TERMINAL_ParseLine+0x18c>
	if( UIP_TASK_DHCP_EnableGet() ) {
 8021f92:	f7fe fd1f 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021f96:	2800      	cmp	r0, #0
 8021f98:	d1ca      	bne.n	8021f30 <UIP_TERMINAL_ParseLine+0xd0>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8021f9a:	494e      	ldr	r1, [pc, #312]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8021f9c:	aa03      	add	r2, sp, #12
 8021f9e:	f001 fb31 	bl	8023604 <strtok_r>
 8021fa2:	b908      	cbnz	r0, 8021fa8 <UIP_TERMINAL_ParseLine+0x148>
	  out("Expecting netmask in format a.b.c.d!");
 8021fa4:	485d      	ldr	r0, [pc, #372]	@ (802211c <UIP_TERMINAL_ParseLine+0x2bc>)
 8021fa6:	e78b      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	  ip = get_ip(parameter);
 8021fa8:	f7ff fe0e 	bl	8021bc8 <get_ip>
	if( !ip ) {
 8021fac:	2800      	cmp	r0, #0
 8021fae:	d0f9      	beq.n	8021fa4 <UIP_TERMINAL_ParseLine+0x144>
	UIP_TASK_NetmaskSet(ip);
 8021fb0:	f7fe fd34 	bl	8020a1c <UIP_TASK_NetmaskSet>
	uip_getnetmask(&ipaddr);
 8021fb4:	4b5a      	ldr	r3, [pc, #360]	@ (8022120 <UIP_TERMINAL_ParseLine+0x2c0>)
 8021fb6:	881e      	ldrh	r6, [r3, #0]
 8021fb8:	f8b3 8002 	ldrh.w	r8, [r3, #2]
	    uip_ipaddr1(ipaddr), uip_ipaddr2(ipaddr),
 8021fbc:	4630      	mov	r0, r6
 8021fbe:	f7fe f913 	bl	80201e8 <htons>
 8021fc2:	4605      	mov	r5, r0
 8021fc4:	4630      	mov	r0, r6
 8021fc6:	f7fe f90f 	bl	80201e8 <htons>
 8021fca:	4606      	mov	r6, r0
	    uip_ipaddr3(ipaddr), uip_ipaddr4(ipaddr));
 8021fcc:	4640      	mov	r0, r8
 8021fce:	f7fe f90b 	bl	80201e8 <htons>
 8021fd2:	4607      	mov	r7, r0
 8021fd4:	4640      	mov	r0, r8
 8021fd6:	f7fe f907 	bl	80201e8 <htons>
	out("Set netmask to %d.%d.%d.%d",
 8021fda:	b2c0      	uxtb	r0, r0
 8021fdc:	9000      	str	r0, [sp, #0]
 8021fde:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8021fe2:	4850      	ldr	r0, [pc, #320]	@ (8022124 <UIP_TERMINAL_ParseLine+0x2c4>)
 8021fe4:	b2f2      	uxtb	r2, r6
 8021fe6:	f3c5 210f 	ubfx	r1, r5, #8, #16
 8021fea:	e7cb      	b.n	8021f84 <UIP_TERMINAL_ParseLine+0x124>
      } else if( strcmp(parameter, "gateway") == 0 ) {
 8021fec:	494e      	ldr	r1, [pc, #312]	@ (8022128 <UIP_TERMINAL_ParseLine+0x2c8>)
 8021fee:	4628      	mov	r0, r5
 8021ff0:	f001 fb0b 	bl	802360a <strcmp>
 8021ff4:	bb60      	cbnz	r0, 8022050 <UIP_TERMINAL_ParseLine+0x1f0>
	if( UIP_TASK_DHCP_EnableGet() ) {
 8021ff6:	f7fe fced 	bl	80209d4 <UIP_TASK_DHCP_EnableGet>
 8021ffa:	2800      	cmp	r0, #0
 8021ffc:	d198      	bne.n	8021f30 <UIP_TERMINAL_ParseLine+0xd0>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8021ffe:	4935      	ldr	r1, [pc, #212]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8022000:	aa03      	add	r2, sp, #12
 8022002:	f001 faff 	bl	8023604 <strtok_r>
 8022006:	b908      	cbnz	r0, 802200c <UIP_TERMINAL_ParseLine+0x1ac>
	  out("Expecting gateway address in format a.b.c.d!");
 8022008:	4848      	ldr	r0, [pc, #288]	@ (802212c <UIP_TERMINAL_ParseLine+0x2cc>)
 802200a:	e759      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	  ip = get_ip(parameter);
 802200c:	f7ff fddc 	bl	8021bc8 <get_ip>
	if( !ip ) {
 8022010:	2800      	cmp	r0, #0
 8022012:	d0f9      	beq.n	8022008 <UIP_TERMINAL_ParseLine+0x1a8>
	UIP_TASK_GatewaySet(ip);
 8022014:	f7fe fd20 	bl	8020a58 <UIP_TASK_GatewaySet>
	uip_getdraddr(&ipaddr);
 8022018:	4b45      	ldr	r3, [pc, #276]	@ (8022130 <UIP_TERMINAL_ParseLine+0x2d0>)
 802201a:	881e      	ldrh	r6, [r3, #0]
 802201c:	f8b3 8002 	ldrh.w	r8, [r3, #2]
	    uip_ipaddr1(ipaddr), uip_ipaddr2(ipaddr),
 8022020:	4630      	mov	r0, r6
 8022022:	f7fe f8e1 	bl	80201e8 <htons>
 8022026:	4605      	mov	r5, r0
 8022028:	4630      	mov	r0, r6
 802202a:	f7fe f8dd 	bl	80201e8 <htons>
 802202e:	4606      	mov	r6, r0
	    uip_ipaddr3(ipaddr), uip_ipaddr4(ipaddr));
 8022030:	4640      	mov	r0, r8
 8022032:	f7fe f8d9 	bl	80201e8 <htons>
 8022036:	4607      	mov	r7, r0
 8022038:	4640      	mov	r0, r8
 802203a:	f7fe f8d5 	bl	80201e8 <htons>
	out("Set gateway to %d.%d.%d.%d",
 802203e:	b2c0      	uxtb	r0, r0
 8022040:	9000      	str	r0, [sp, #0]
 8022042:	f3c7 230f 	ubfx	r3, r7, #8, #16
 8022046:	483b      	ldr	r0, [pc, #236]	@ (8022134 <UIP_TERMINAL_ParseLine+0x2d4>)
 8022048:	b2f2      	uxtb	r2, r6
 802204a:	f3c5 210f 	ubfx	r1, r5, #8, #16
 802204e:	e799      	b.n	8021f84 <UIP_TERMINAL_ParseLine+0x124>
      } else if( strcmp(parameter, "osc_remote") == 0 ) {
 8022050:	4939      	ldr	r1, [pc, #228]	@ (8022138 <UIP_TERMINAL_ParseLine+0x2d8>)
 8022052:	4628      	mov	r0, r5
 8022054:	f001 fad9 	bl	802360a <strcmp>
 8022058:	2800      	cmp	r0, #0
 802205a:	d179      	bne.n	8022150 <UIP_TERMINAL_ParseLine+0x2f0>
	if( !UIP_TASK_ServicesRunning() ) {
 802205c:	f7fe fd1a 	bl	8020a94 <UIP_TASK_ServicesRunning>
 8022060:	b908      	cbnz	r0, 8022066 <UIP_TERMINAL_ParseLine+0x206>
	  out("ERROR: Ethernet services not running yet!");
 8022062:	4836      	ldr	r0, [pc, #216]	@ (802213c <UIP_TERMINAL_ParseLine+0x2dc>)
 8022064:	e72c      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022066:	491b      	ldr	r1, [pc, #108]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8022068:	aa03      	add	r2, sp, #12
 802206a:	2000      	movs	r0, #0
 802206c:	f001 faca 	bl	8023604 <strtok_r>
 8022070:	b910      	cbnz	r0, 8022078 <UIP_TERMINAL_ParseLine+0x218>
	  out("Invalid OSC connection specified as first parameter (expecting 1..%d)!", OSC_SERVER_NUM_CONNECTIONS);
 8022072:	4833      	ldr	r0, [pc, #204]	@ (8022140 <UIP_TERMINAL_ParseLine+0x2e0>)
 8022074:	2104      	movs	r1, #4
 8022076:	e00d      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
	  con = get_dec(parameter);
 8022078:	f7ff fd96 	bl	8021ba8 <get_dec>
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 802207c:	1e47      	subs	r7, r0, #1
 802207e:	2f03      	cmp	r7, #3
	  con = get_dec(parameter);
 8022080:	4606      	mov	r6, r0
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 8022082:	d8f6      	bhi.n	8022072 <UIP_TERMINAL_ParseLine+0x212>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022084:	4913      	ldr	r1, [pc, #76]	@ (80220d4 <UIP_TERMINAL_ParseLine+0x274>)
 8022086:	aa03      	add	r2, sp, #12
 8022088:	2000      	movs	r0, #0
 802208a:	f001 fabb 	bl	8023604 <strtok_r>
 802208e:	b918      	cbnz	r0, 8022098 <UIP_TERMINAL_ParseLine+0x238>
	  out("Expecting OSC connection <1..%d> and remote address in format a.b.c.d!", OSC_SERVER_NUM_CONNECTIONS);
 8022090:	482c      	ldr	r0, [pc, #176]	@ (8022144 <UIP_TERMINAL_ParseLine+0x2e4>)
 8022092:	2104      	movs	r1, #4
 8022094:	47a0      	blx	r4
	  return 1; // command taken
 8022096:	e702      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
	  ip = get_ip(parameter);
 8022098:	f7ff fd96 	bl	8021bc8 <get_ip>
	if( !ip ) {
 802209c:	4605      	mov	r5, r0
 802209e:	2800      	cmp	r0, #0
 80220a0:	d0f6      	beq.n	8022090 <UIP_TERMINAL_ParseLine+0x230>
	if( OSC_SERVER_RemoteIP_Set(con, ip) >= 0 ) {
 80220a2:	4601      	mov	r1, r0
 80220a4:	b2f8      	uxtb	r0, r7
 80220a6:	f7ff fa19 	bl	80214dc <OSC_SERVER_RemoteIP_Set>
 80220aa:	2800      	cmp	r0, #0
 80220ac:	db0e      	blt.n	80220cc <UIP_TERMINAL_ParseLine+0x26c>
	  out("Set OSC%d Remote address to %d.%d.%d.%d",
 80220ae:	b2eb      	uxtb	r3, r5
 80220b0:	9301      	str	r3, [sp, #4]
 80220b2:	f3c5 2307 	ubfx	r3, r5, #8, #8
 80220b6:	9300      	str	r3, [sp, #0]
 80220b8:	4823      	ldr	r0, [pc, #140]	@ (8022148 <UIP_TERMINAL_ParseLine+0x2e8>)
 80220ba:	f3c5 4307 	ubfx	r3, r5, #16, #8
 80220be:	0e2a      	lsrs	r2, r5, #24
 80220c0:	4631      	mov	r1, r6
 80220c2:	47a0      	blx	r4
	  OSC_SERVER_Init(0);
 80220c4:	2000      	movs	r0, #0
 80220c6:	f7ff f9b1 	bl	802142c <OSC_SERVER_Init>
 80220ca:	e6e8      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
	  out("ERROR: failed to set OSC%d Remote address!", con+1);
 80220cc:	481f      	ldr	r0, [pc, #124]	@ (802214c <UIP_TERMINAL_ParseLine+0x2ec>)
 80220ce:	4631      	mov	r1, r6
 80220d0:	e7e0      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
 80220d2:	bf00      	nop
 80220d4:	080237ba 	.word	0x080237ba
 80220d8:	08028cbf 	.word	0x08028cbf
 80220dc:	0802391b 	.word	0x0802391b
 80220e0:	08023b98 	.word	0x08023b98
 80220e4:	08028cc7 	.word	0x08028cc7
 80220e8:	08024c4d 	.word	0x08024c4d
 80220ec:	080283d9 	.word	0x080283d9
 80220f0:	0802531e 	.word	0x0802531e
 80220f4:	080283d6 	.word	0x080283d6
 80220f8:	08027f63 	.word	0x08027f63
 80220fc:	08028ccc 	.word	0x08028ccc
 8022100:	08028d00 	.word	0x08028d00
 8022104:	08028d29 	.word	0x08028d29
 8022108:	08028d2c 	.word	0x08028d2c
 802210c:	08028d6d 	.word	0x08028d6d
 8022110:	200074ca 	.word	0x200074ca
 8022114:	08028d95 	.word	0x08028d95
 8022118:	080289a2 	.word	0x080289a2
 802211c:	08028db3 	.word	0x08028db3
 8022120:	200074c2 	.word	0x200074c2
 8022124:	08028dd8 	.word	0x08028dd8
 8022128:	08028df3 	.word	0x08028df3
 802212c:	08028dfb 	.word	0x08028dfb
 8022130:	200074c6 	.word	0x200074c6
 8022134:	08028e28 	.word	0x08028e28
 8022138:	08028e43 	.word	0x08028e43
 802213c:	08028e4e 	.word	0x08028e4e
 8022140:	08028e78 	.word	0x08028e78
 8022144:	08028ebf 	.word	0x08028ebf
 8022148:	08028f06 	.word	0x08028f06
 802214c:	08028f2e 	.word	0x08028f2e
      } else if( strcmp(parameter, "osc_remote_port") == 0 ) {
 8022150:	4981      	ldr	r1, [pc, #516]	@ (8022358 <UIP_TERMINAL_ParseLine+0x4f8>)
 8022152:	4628      	mov	r0, r5
 8022154:	f001 fa59 	bl	802360a <strcmp>
 8022158:	bb98      	cbnz	r0, 80221c2 <UIP_TERMINAL_ParseLine+0x362>
	if( !UIP_TASK_ServicesRunning() ) {
 802215a:	f7fe fc9b 	bl	8020a94 <UIP_TASK_ServicesRunning>
 802215e:	2800      	cmp	r0, #0
 8022160:	f43f af7f 	beq.w	8022062 <UIP_TERMINAL_ParseLine+0x202>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022164:	497d      	ldr	r1, [pc, #500]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 8022166:	aa03      	add	r2, sp, #12
 8022168:	2000      	movs	r0, #0
 802216a:	f001 fa4b 	bl	8023604 <strtok_r>
 802216e:	2800      	cmp	r0, #0
 8022170:	f43f af7f 	beq.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	  con = get_dec(parameter);
 8022174:	f7ff fd18 	bl	8021ba8 <get_dec>
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 8022178:	1e47      	subs	r7, r0, #1
 802217a:	2f03      	cmp	r7, #3
	  con = get_dec(parameter);
 802217c:	4605      	mov	r5, r0
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 802217e:	f63f af78 	bhi.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022182:	4976      	ldr	r1, [pc, #472]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 8022184:	aa03      	add	r2, sp, #12
 8022186:	2000      	movs	r0, #0
 8022188:	f001 fa3c 	bl	8023604 <strtok_r>
 802218c:	b910      	cbnz	r0, 8022194 <UIP_TERMINAL_ParseLine+0x334>
	  out("Expecting OSC connection (1..%d) and remote port value in range 1024..65535", OSC_SERVER_NUM_CONNECTIONS);
 802218e:	4874      	ldr	r0, [pc, #464]	@ (8022360 <UIP_TERMINAL_ParseLine+0x500>)
 8022190:	2104      	movs	r1, #4
 8022192:	e77f      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
	  value = get_dec(parameter);
 8022194:	f7ff fd08 	bl	8021ba8 <get_dec>
	if( value < 1024 || value >= 65535) {
 8022198:	f64f 33fe 	movw	r3, #64510	@ 0xfbfe
 802219c:	f5a0 6280 	sub.w	r2, r0, #1024	@ 0x400
 80221a0:	429a      	cmp	r2, r3
	  value = get_dec(parameter);
 80221a2:	4606      	mov	r6, r0
	if( value < 1024 || value >= 65535) {
 80221a4:	d8f3      	bhi.n	802218e <UIP_TERMINAL_ParseLine+0x32e>
	  if( OSC_SERVER_RemotePortSet(con, value) >= 0 ) {
 80221a6:	b281      	uxth	r1, r0
 80221a8:	b2f8      	uxtb	r0, r7
 80221aa:	f7ff f9a9 	bl	8021500 <OSC_SERVER_RemotePortSet>
 80221ae:	2800      	cmp	r0, #0
 80221b0:	db04      	blt.n	80221bc <UIP_TERMINAL_ParseLine+0x35c>
	    out("Set OSC%d Remote port to %d", con+1, value);
 80221b2:	486c      	ldr	r0, [pc, #432]	@ (8022364 <UIP_TERMINAL_ParseLine+0x504>)
 80221b4:	4632      	mov	r2, r6
 80221b6:	4629      	mov	r1, r5
	  out("Set OSC%d Local port to %d", con+1, value);
 80221b8:	47a0      	blx	r4
	  OSC_SERVER_Init(0);
 80221ba:	e783      	b.n	80220c4 <UIP_TERMINAL_ParseLine+0x264>
	    out("ERROR: failed to set OSC%d remote port!", con+1);
 80221bc:	486a      	ldr	r0, [pc, #424]	@ (8022368 <UIP_TERMINAL_ParseLine+0x508>)
 80221be:	4629      	mov	r1, r5
 80221c0:	e768      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
      } else if( strcmp(parameter, "osc_local_port") == 0 ) {
 80221c2:	496a      	ldr	r1, [pc, #424]	@ (802236c <UIP_TERMINAL_ParseLine+0x50c>)
 80221c4:	4628      	mov	r0, r5
 80221c6:	f001 fa20 	bl	802360a <strcmp>
 80221ca:	4606      	mov	r6, r0
 80221cc:	bba8      	cbnz	r0, 802223a <UIP_TERMINAL_ParseLine+0x3da>
	if( !UIP_TASK_ServicesRunning() ) {
 80221ce:	f7fe fc61 	bl	8020a94 <UIP_TASK_ServicesRunning>
 80221d2:	2800      	cmp	r0, #0
 80221d4:	f43f af45 	beq.w	8022062 <UIP_TERMINAL_ParseLine+0x202>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 80221d8:	4960      	ldr	r1, [pc, #384]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 80221da:	aa03      	add	r2, sp, #12
 80221dc:	4630      	mov	r0, r6
 80221de:	f001 fa11 	bl	8023604 <strtok_r>
 80221e2:	2800      	cmp	r0, #0
 80221e4:	f43f af45 	beq.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	  con = get_dec(parameter);
 80221e8:	f7ff fcde 	bl	8021ba8 <get_dec>
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 80221ec:	f100 38ff 	add.w	r8, r0, #4294967295	@ 0xffffffff
 80221f0:	f1b8 0f03 	cmp.w	r8, #3
	  con = get_dec(parameter);
 80221f4:	4605      	mov	r5, r0
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 80221f6:	f63f af3c 	bhi.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 80221fa:	4958      	ldr	r1, [pc, #352]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 80221fc:	aa03      	add	r2, sp, #12
 80221fe:	4630      	mov	r0, r6
 8022200:	f001 fa00 	bl	8023604 <strtok_r>
 8022204:	b910      	cbnz	r0, 802220c <UIP_TERMINAL_ParseLine+0x3ac>
	  out("Expecting OSC connection (1..%d) and local port value in range 1024..65535", OSC_SERVER_NUM_CONNECTIONS);
 8022206:	485a      	ldr	r0, [pc, #360]	@ (8022370 <UIP_TERMINAL_ParseLine+0x510>)
 8022208:	2104      	movs	r1, #4
 802220a:	e743      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
	  value = get_dec(parameter);
 802220c:	f7ff fccc 	bl	8021ba8 <get_dec>
	if( value < 1024 || value >= 65535) {
 8022210:	f64f 33fe 	movw	r3, #64510	@ 0xfbfe
 8022214:	f5a0 6280 	sub.w	r2, r0, #1024	@ 0x400
 8022218:	429a      	cmp	r2, r3
	  value = get_dec(parameter);
 802221a:	4607      	mov	r7, r0
	if( value < 1024 || value >= 65535) {
 802221c:	d8f3      	bhi.n	8022206 <UIP_TERMINAL_ParseLine+0x3a6>
	if( OSC_SERVER_LocalPortSet(con, value) >= 0 ) {
 802221e:	b281      	uxth	r1, r0
 8022220:	fa5f f088 	uxtb.w	r0, r8
 8022224:	f7ff f97e 	bl	8021524 <OSC_SERVER_LocalPortSet>
 8022228:	2800      	cmp	r0, #0
 802222a:	db03      	blt.n	8022234 <UIP_TERMINAL_ParseLine+0x3d4>
	  out("Set OSC%d Local port to %d", con+1, value);
 802222c:	4851      	ldr	r0, [pc, #324]	@ (8022374 <UIP_TERMINAL_ParseLine+0x514>)
 802222e:	463a      	mov	r2, r7
 8022230:	4629      	mov	r1, r5
 8022232:	e7c1      	b.n	80221b8 <UIP_TERMINAL_ParseLine+0x358>
	  out("ERROR: failed to set OSC%d local port!", con+1);
 8022234:	4850      	ldr	r0, [pc, #320]	@ (8022378 <UIP_TERMINAL_ParseLine+0x518>)
 8022236:	4629      	mov	r1, r5
 8022238:	e72c      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
      } else if( strcmp(parameter, "osc_mode") == 0 ) {
 802223a:	4950      	ldr	r1, [pc, #320]	@ (802237c <UIP_TERMINAL_ParseLine+0x51c>)
 802223c:	4628      	mov	r0, r5
 802223e:	f001 f9e4 	bl	802360a <strcmp>
 8022242:	4606      	mov	r6, r0
 8022244:	2800      	cmp	r0, #0
 8022246:	d152      	bne.n	80222ee <UIP_TERMINAL_ParseLine+0x48e>
	if( !UIP_TASK_ServicesRunning() ) {
 8022248:	f7fe fc24 	bl	8020a94 <UIP_TASK_ServicesRunning>
 802224c:	2800      	cmp	r0, #0
 802224e:	f43f af08 	beq.w	8022062 <UIP_TERMINAL_ParseLine+0x202>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022252:	4942      	ldr	r1, [pc, #264]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 8022254:	aa03      	add	r2, sp, #12
 8022256:	4630      	mov	r0, r6
 8022258:	f001 f9d4 	bl	8023604 <strtok_r>
 802225c:	2800      	cmp	r0, #0
 802225e:	f43f af08 	beq.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	  con = get_dec(parameter);
 8022262:	f7ff fca1 	bl	8021ba8 <get_dec>
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 8022266:	f100 38ff 	add.w	r8, r0, #4294967295	@ 0xffffffff
 802226a:	f1b8 0f03 	cmp.w	r8, #3
	  con = get_dec(parameter);
 802226e:	4605      	mov	r5, r0
	if( con < 1 || con > OSC_SERVER_NUM_CONNECTIONS) {
 8022270:	f63f aeff 	bhi.w	8022072 <UIP_TERMINAL_ParseLine+0x212>
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022274:	4939      	ldr	r1, [pc, #228]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 8022276:	aa03      	add	r2, sp, #12
 8022278:	4630      	mov	r0, r6
 802227a:	f001 f9c3 	bl	8023604 <strtok_r>
	  if( OSC_CLIENT_TransferModeSet(con, mode) >= 0 ) {
 802227e:	fa5f f888 	uxtb.w	r8, r8
	if( (parameter = strtok_r(NULL, separators, &brkt)) )
 8022282:	b9e0      	cbnz	r0, 80222be <UIP_TERMINAL_ParseLine+0x45e>
	  out("Expecting OSC transfer mode 0..%d", OSC_CLIENT_NUM_TRANSFER_MODES-1);
 8022284:	483e      	ldr	r0, [pc, #248]	@ (8022380 <UIP_TERMINAL_ParseLine+0x520>)
	    out("%d: %s%s\n",
 8022286:	f8df a0fc 	ldr.w	sl, [pc, #252]	@ 8022384 <UIP_TERMINAL_ParseLine+0x524>
 802228a:	f8df 90fc 	ldr.w	r9, [pc, #252]	@ 8022388 <UIP_TERMINAL_ParseLine+0x528>
 802228e:	4f3f      	ldr	r7, [pc, #252]	@ (802238c <UIP_TERMINAL_ParseLine+0x52c>)
	  out("Expecting OSC transfer mode 0..%d", OSC_CLIENT_NUM_TRANSFER_MODES-1);
 8022290:	2104      	movs	r1, #4
 8022292:	47a0      	blx	r4
	  out("Transfer Mode Mapping:");
 8022294:	483e      	ldr	r0, [pc, #248]	@ (8022390 <UIP_TERMINAL_ParseLine+0x530>)
 8022296:	47a0      	blx	r4
	    out("%d: %s%s\n",
 8022298:	b2f0      	uxtb	r0, r6
 802229a:	f7ff fa49 	bl	8021730 <OSC_CLIENT_TransferModeFullNameGet>
 802229e:	4605      	mov	r5, r0
		(OSC_CLIENT_TransferModeGet(con) == mode) ? " (*)" : "");
 80222a0:	4640      	mov	r0, r8
 80222a2:	f7ff fa3f 	bl	8021724 <OSC_CLIENT_TransferModeGet>
	    out("%d: %s%s\n",
 80222a6:	4631      	mov	r1, r6
 80222a8:	42b0      	cmp	r0, r6
 80222aa:	bf0c      	ite	eq
 80222ac:	4653      	moveq	r3, sl
 80222ae:	464b      	movne	r3, r9
 80222b0:	462a      	mov	r2, r5
 80222b2:	4638      	mov	r0, r7
	  for(mode=0; mode<OSC_CLIENT_NUM_TRANSFER_MODES; ++mode)
 80222b4:	3601      	adds	r6, #1
	    out("%d: %s%s\n",
 80222b6:	47a0      	blx	r4
	  for(mode=0; mode<OSC_CLIENT_NUM_TRANSFER_MODES; ++mode)
 80222b8:	2e05      	cmp	r6, #5
 80222ba:	d1ed      	bne.n	8022298 <UIP_TERMINAL_ParseLine+0x438>
 80222bc:	e5ef      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
	  mode = get_dec(parameter);
 80222be:	f7ff fc73 	bl	8021ba8 <get_dec>
	if( mode < 0 || mode >= OSC_CLIENT_NUM_TRANSFER_MODES) {
 80222c2:	2804      	cmp	r0, #4
	  mode = get_dec(parameter);
 80222c4:	4607      	mov	r7, r0
	if( mode < 0 || mode >= OSC_CLIENT_NUM_TRANSFER_MODES) {
 80222c6:	d8dd      	bhi.n	8022284 <UIP_TERMINAL_ParseLine+0x424>
	  if( OSC_CLIENT_TransferModeSet(con, mode) >= 0 ) {
 80222c8:	b2c6      	uxtb	r6, r0
 80222ca:	4631      	mov	r1, r6
 80222cc:	4640      	mov	r0, r8
 80222ce:	f7ff fa1d 	bl	802170c <OSC_CLIENT_TransferModeSet>
 80222d2:	2800      	cmp	r0, #0
 80222d4:	db08      	blt.n	80222e8 <UIP_TERMINAL_ParseLine+0x488>
	    out("Set OSC%d transfer mode to %d: %s", con+1, mode, OSC_CLIENT_TransferModeFullNameGet(mode));
 80222d6:	4630      	mov	r0, r6
 80222d8:	f7ff fa2a 	bl	8021730 <OSC_CLIENT_TransferModeFullNameGet>
 80222dc:	463a      	mov	r2, r7
 80222de:	4603      	mov	r3, r0
 80222e0:	4629      	mov	r1, r5
 80222e2:	482c      	ldr	r0, [pc, #176]	@ (8022394 <UIP_TERMINAL_ParseLine+0x534>)
 80222e4:	47a0      	blx	r4
 80222e6:	e5da      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
	    out("ERROR: failed to set OSC%d transfer mode!", con+1);
 80222e8:	482b      	ldr	r0, [pc, #172]	@ (8022398 <UIP_TERMINAL_ParseLine+0x538>)
 80222ea:	4629      	mov	r1, r5
 80222ec:	e6d2      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
      } else if( strcmp(parameter, "udpmon") == 0 ) {
 80222ee:	492b      	ldr	r1, [pc, #172]	@ (802239c <UIP_TERMINAL_ParseLine+0x53c>)
 80222f0:	4628      	mov	r0, r5
 80222f2:	f001 f98a 	bl	802360a <strcmp>
 80222f6:	2800      	cmp	r0, #0
 80222f8:	f47f adc0 	bne.w	8021e7c <UIP_TERMINAL_ParseLine+0x1c>
	if( (arg = strtok_r(NULL, separators, &brkt)) ) {
 80222fc:	4917      	ldr	r1, [pc, #92]	@ (802235c <UIP_TERMINAL_ParseLine+0x4fc>)
 80222fe:	aa03      	add	r2, sp, #12
 8022300:	f001 f980 	bl	8023604 <strtok_r>
 8022304:	b1f8      	cbz	r0, 8022346 <UIP_TERMINAL_ParseLine+0x4e6>
	  int level = get_dec(arg);
 8022306:	f7ff fc4f 	bl	8021ba8 <get_dec>
 802230a:	4605      	mov	r5, r0
	  switch( level ) {
 802230c:	2804      	cmp	r0, #4
 802230e:	d817      	bhi.n	8022340 <UIP_TERMINAL_ParseLine+0x4e0>
 8022310:	e8df f000 	tbb	[pc, r0]
 8022314:	100d0a03 	.word	0x100d0a03
 8022318:	13          	.byte	0x13
 8022319:	00          	.byte	0x00
	    out("Set UDP monitor level to %d (off)\n", level);
 802231a:	4821      	ldr	r0, [pc, #132]	@ (80223a0 <UIP_TERMINAL_ParseLine+0x540>)
 802231c:	2100      	movs	r1, #0
	    out("Set UDP monitor level to %d (all received and sent packets with port number >= 1024)\n", level);
 802231e:	47a0      	blx	r4
	    UIP_TASK_UDP_MonitorLevelSet(level);
 8022320:	b2e8      	uxtb	r0, r5
 8022322:	f7fe fc17 	bl	8020b54 <UIP_TASK_UDP_MonitorLevelSet>
 8022326:	e5ba      	b.n	8021e9e <UIP_TERMINAL_ParseLine+0x3e>
	    out("Set UDP monitor level to %d (received packets assigned to a OSC1..4 port)\n", level);
 8022328:	481e      	ldr	r0, [pc, #120]	@ (80223a4 <UIP_TERMINAL_ParseLine+0x544>)
 802232a:	2101      	movs	r1, #1
 802232c:	e7f7      	b.n	802231e <UIP_TERMINAL_ParseLine+0x4be>
	    out("Set UDP monitor level to %d (received and sent packets assigned to a OSC1..4 port)\n", level);
 802232e:	481e      	ldr	r0, [pc, #120]	@ (80223a8 <UIP_TERMINAL_ParseLine+0x548>)
 8022330:	2102      	movs	r1, #2
 8022332:	e7f4      	b.n	802231e <UIP_TERMINAL_ParseLine+0x4be>
	    out("Set UDP monitor level to %d (all received and sent packets with port number >= 1024)\n", level);
 8022334:	481d      	ldr	r0, [pc, #116]	@ (80223ac <UIP_TERMINAL_ParseLine+0x54c>)
 8022336:	2103      	movs	r1, #3
 8022338:	e7f1      	b.n	802231e <UIP_TERMINAL_ParseLine+0x4be>
	    out("Set UDP monitor level to %d (all received and sent packets)\n", level);
 802233a:	481d      	ldr	r0, [pc, #116]	@ (80223b0 <UIP_TERMINAL_ParseLine+0x550>)
 802233c:	2104      	movs	r1, #4
 802233e:	e7ee      	b.n	802231e <UIP_TERMINAL_ParseLine+0x4be>
	    out("Invalid level %d - please specify monitor level 0..4\n", level);
 8022340:	4601      	mov	r1, r0
 8022342:	481c      	ldr	r0, [pc, #112]	@ (80223b4 <UIP_TERMINAL_ParseLine+0x554>)
 8022344:	e6a6      	b.n	8022094 <UIP_TERMINAL_ParseLine+0x234>
	  out("Please specify monitor level (0..4)\n");
 8022346:	481c      	ldr	r0, [pc, #112]	@ (80223b8 <UIP_TERMINAL_ParseLine+0x558>)
 8022348:	e5ba      	b.n	8021ec0 <UIP_TERMINAL_ParseLine+0x60>
    if( !*input_ptr )
 802234a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 802234e:	2a00      	cmp	r2, #0
 8022350:	f47f ad98 	bne.w	8021e84 <UIP_TERMINAL_ParseLine+0x24>
      *input_ptr = ' ';
 8022354:	7019      	strb	r1, [r3, #0]
  for(i=0; i<input_len; ++i, ++input_ptr)
 8022356:	e595      	b.n	8021e84 <UIP_TERMINAL_ParseLine+0x24>
 8022358:	08028f59 	.word	0x08028f59
 802235c:	080237ba 	.word	0x080237ba
 8022360:	08028f69 	.word	0x08028f69
 8022364:	08028fb5 	.word	0x08028fb5
 8022368:	08028fd1 	.word	0x08028fd1
 802236c:	08028ff9 	.word	0x08028ff9
 8022370:	08029008 	.word	0x08029008
 8022374:	08029053 	.word	0x08029053
 8022378:	0802906e 	.word	0x0802906e
 802237c:	08029095 	.word	0x08029095
 8022380:	0802909e 	.word	0x0802909e
 8022384:	08028cba 	.word	0x08028cba
 8022388:	080237bc 	.word	0x080237bc
 802238c:	080290d7 	.word	0x080290d7
 8022390:	080290c0 	.word	0x080290c0
 8022394:	080290e1 	.word	0x080290e1
 8022398:	08029103 	.word	0x08029103
 802239c:	0802912d 	.word	0x0802912d
 80223a0:	08029134 	.word	0x08029134
 80223a4:	08029157 	.word	0x08029157
 80223a8:	080291a2 	.word	0x080291a2
 80223ac:	080291f6 	.word	0x080291f6
 80223b0:	0802924c 	.word	0x0802924c
 80223b4:	08029289 	.word	0x08029289
 80223b8:	080292bf 	.word	0x080292bf

080223bc <EE_VerifyPageFullWriteVariable>:
static uint16_t EE_FindValidPage(uint8_t Operation)
{
  uint16_t PageStatus0 = 6, PageStatus1 = 6;

  /* Get Page0 actual status */
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80223bc:	4b1a      	ldr	r3, [pc, #104]	@ (8022428 <EE_VerifyPageFullWriteVariable+0x6c>)
 80223be:	881a      	ldrh	r2, [r3, #0]

  /* Get Page1 actual status */
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80223c0:	f503 4380 	add.w	r3, r3, #16384	@ 0x4000
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 80223c4:	b570      	push	{r4, r5, r6, lr}
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80223c6:	881b      	ldrh	r3, [r3, #0]
 80223c8:	b29b      	uxth	r3, r3
{
 80223ca:	4604      	mov	r4, r0
 80223cc:	460e      	mov	r6, r1
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80223ce:	b292      	uxth	r2, r2
      if (PageStatus1 == VALID_PAGE)
 80223d0:	b97b      	cbnz	r3, 80223f2 <EE_VerifyPageFullWriteVariable+0x36>
        if (PageStatus0 == RECEIVE_DATA)
 80223d2:	f64e 63ee 	movw	r3, #61166	@ 0xeeee
 80223d6:	1ad3      	subs	r3, r2, r3
 80223d8:	bf18      	it	ne
 80223da:	2301      	movne	r3, #1
  {
    return  NO_VALID_PAGE;
  }

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80223dc:	039b      	lsls	r3, r3, #14

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 80223de:	4a13      	ldr	r2, [pc, #76]	@ (802242c <EE_VerifyPageFullWriteVariable+0x70>)
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80223e0:	f103 6500 	add.w	r5, r3, #134217728	@ 0x8000000
 80223e4:	f505 4500 	add.w	r5, r5, #32768	@ 0x8000
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 80223e8:	441a      	add	r2, r3

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 80223ea:	4295      	cmp	r5, r2
 80223ec:	d308      	bcc.n	8022400 <EE_VerifyPageFullWriteVariable+0x44>
      Address = Address + 4;
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
 80223ee:	2080      	movs	r0, #128	@ 0x80
 80223f0:	e015      	b.n	802241e <EE_VerifyPageFullWriteVariable+0x62>
      else if (PageStatus0 == VALID_PAGE)
 80223f2:	b9ba      	cbnz	r2, 8022424 <EE_VerifyPageFullWriteVariable+0x68>
        if (PageStatus1 == RECEIVE_DATA)
 80223f4:	f64e 62ee 	movw	r2, #61166	@ 0xeeee
 80223f8:	1a9a      	subs	r2, r3, r2
 80223fa:	4253      	negs	r3, r2
 80223fc:	4153      	adcs	r3, r2
 80223fe:	e7ed      	b.n	80223dc <EE_VerifyPageFullWriteVariable+0x20>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8022400:	6828      	ldr	r0, [r5, #0]
 8022402:	1c43      	adds	r3, r0, #1
 8022404:	d10c      	bne.n	8022420 <EE_VerifyPageFullWriteVariable+0x64>
      FLASH_ClearFlag(0xffffffff);
 8022406:	f7f6 fe51 	bl	80190ac <FLASH_ClearFlag>
      FlashStatus = FLASH_ProgramHalfWord(Address, Data);
 802240a:	4631      	mov	r1, r6
 802240c:	4628      	mov	r0, r5
 802240e:	f7f6 fead 	bl	801916c <FLASH_ProgramHalfWord>
      if (FlashStatus != FLASH_COMPLETE)
 8022412:	2808      	cmp	r0, #8
 8022414:	d103      	bne.n	802241e <EE_VerifyPageFullWriteVariable+0x62>
      FlashStatus = FLASH_ProgramHalfWord(Address + 2, VirtAddress);
 8022416:	4621      	mov	r1, r4
 8022418:	1ca8      	adds	r0, r5, #2
 802241a:	f7f6 fea7 	bl	801916c <FLASH_ProgramHalfWord>
}
 802241e:	bd70      	pop	{r4, r5, r6, pc}
      Address = Address + 4;
 8022420:	3504      	adds	r5, #4
 8022422:	e7e2      	b.n	80223ea <EE_VerifyPageFullWriteVariable+0x2e>
    return  NO_VALID_PAGE;
 8022424:	20ab      	movs	r0, #171	@ 0xab
 8022426:	e7fa      	b.n	802241e <EE_VerifyPageFullWriteVariable+0x62>
 8022428:	08008000 	.word	0x08008000
 802242c:	0800bffe 	.word	0x0800bffe

08022430 <EE_Format>:
{
 8022430:	b508      	push	{r3, lr}
  FLASH_ClearFlag(0xffffffff);
 8022432:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022436:	f7f6 fe39 	bl	80190ac <FLASH_ClearFlag>
  FlashStatus = FLASH_EraseSector(EEPROM_PAGE0_SECTOR, VoltageRange_3);
 802243a:	2102      	movs	r1, #2
 802243c:	2010      	movs	r0, #16
 802243e:	f7f6 fe67 	bl	8019110 <FLASH_EraseSector>
  if (FlashStatus != FLASH_COMPLETE)
 8022442:	2808      	cmp	r0, #8
 8022444:	d10b      	bne.n	802245e <EE_Format+0x2e>
  FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8022446:	4806      	ldr	r0, [pc, #24]	@ (8022460 <EE_Format+0x30>)
 8022448:	2100      	movs	r1, #0
 802244a:	f7f6 fe8f 	bl	801916c <FLASH_ProgramHalfWord>
  if (FlashStatus != FLASH_COMPLETE)
 802244e:	2808      	cmp	r0, #8
 8022450:	d105      	bne.n	802245e <EE_Format+0x2e>
}
 8022452:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  FlashStatus = FLASH_EraseSector(EEPROM_PAGE1_SECTOR, VoltageRange_3);
 8022456:	2102      	movs	r1, #2
 8022458:	2018      	movs	r0, #24
 802245a:	f7f6 be59 	b.w	8019110 <FLASH_EraseSector>
}
 802245e:	bd08      	pop	{r3, pc}
 8022460:	08008000 	.word	0x08008000

08022464 <EEPROM_Read>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8022464:	4b10      	ldr	r3, [pc, #64]	@ (80224a8 <EEPROM_Read+0x44>)
 8022466:	881a      	ldrh	r2, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8022468:	f503 4380 	add.w	r3, r3, #16384	@ 0x4000
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 802246c:	b292      	uxth	r2, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 802246e:	881b      	ldrh	r3, [r3, #0]
 8022470:	b29b      	uxth	r3, r3
      if (PageStatus0 == VALID_PAGE)
 8022472:	b10a      	cbz	r2, 8022478 <EEPROM_Read+0x14>
      else if (PageStatus1 == VALID_PAGE)
 8022474:	b9ab      	cbnz	r3, 80224a2 <EEPROM_Read+0x3e>
          return PAGE1;         /* Page1 valid */
 8022476:	2201      	movs	r2, #1
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 8022478:	4b0c      	ldr	r3, [pc, #48]	@ (80224ac <EEPROM_Read+0x48>)
  while (Address > (PageStartAddress + 2))
 802247a:	490d      	ldr	r1, [pc, #52]	@ (80224b0 <EEPROM_Read+0x4c>)
  Address = (uint32_t)((EEPROM_START_ADDRESS - 2) + (uint32_t)((1 + ValidPage) * PAGE_SIZE));
 802247c:	eb03 3382 	add.w	r3, r3, r2, lsl #14
  while (Address > (PageStartAddress + 2))
 8022480:	eb01 3282 	add.w	r2, r1, r2, lsl #14
 8022484:	429a      	cmp	r2, r3
 8022486:	d302      	bcc.n	802248e <EEPROM_Read+0x2a>
  s32 ReadStatus = -1;
 8022488:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 802248c:	4770      	bx	lr
    AddressValue = (*(__IO uint16_t*)Address);
 802248e:	8819      	ldrh	r1, [r3, #0]
 8022490:	b289      	uxth	r1, r1
    if (AddressValue == VirtAddress)
 8022492:	4281      	cmp	r1, r0
 8022494:	d103      	bne.n	802249e <EEPROM_Read+0x3a>
      Data = (*(__IO uint16_t*)(Address - 2));
 8022496:	f833 0c02 	ldrh.w	r0, [r3, #-2]
 802249a:	b280      	uxth	r0, r0
  return Data; // return value of variable
 802249c:	4770      	bx	lr
      Address = Address - 4;
 802249e:	3b04      	subs	r3, #4
 80224a0:	e7f0      	b.n	8022484 <EEPROM_Read+0x20>
    return -2; // no valid page
 80224a2:	f06f 0001 	mvn.w	r0, #1
}
 80224a6:	4770      	bx	lr
 80224a8:	08008000 	.word	0x08008000
 80224ac:	0800bffe 	.word	0x0800bffe
 80224b0:	08008002 	.word	0x08008002

080224b4 <EEPROM_Init>:
  if( mode != 0 && mode != 1 )
 80224b4:	2801      	cmp	r0, #1
{
 80224b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80224b8:	4604      	mov	r4, r0
  if( mode != 0 && mode != 1 )
 80224ba:	f200 80a2 	bhi.w	8022602 <EEPROM_Init+0x14e>
  FLASH_Unlock();
 80224be:	f7f6 fddf 	bl	8019080 <FLASH_Unlock>
  if( mode == 1 ) {
 80224c2:	2c01      	cmp	r4, #1
 80224c4:	d10a      	bne.n	80224dc <EEPROM_Init+0x28>
    FlashStatus = EE_Format();
 80224c6:	f7ff ffb3 	bl	8022430 <EE_Format>
    if (FlashStatus != FLASH_COMPLETE)
 80224ca:	2808      	cmp	r0, #8
 80224cc:	d002      	beq.n	80224d4 <EEPROM_Init+0x20>
      return -2; // FlashStatus;
 80224ce:	f06f 0001 	mvn.w	r0, #1
}
 80224d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    FLASH_Lock();
 80224d4:	f7f6 fde2 	bl	801909c <FLASH_Lock>
    return 0; // no error
 80224d8:	2000      	movs	r0, #0
 80224da:	e7fa      	b.n	80224d2 <EEPROM_Init+0x1e>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80224dc:	4d4a      	ldr	r5, [pc, #296]	@ (8022608 <EEPROM_Init+0x154>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80224de:	4e4b      	ldr	r6, [pc, #300]	@ (802260c <EEPROM_Init+0x158>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80224e0:	882c      	ldrh	r4, [r5, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80224e2:	8833      	ldrh	r3, [r6, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80224e4:	b2a4      	uxth	r4, r4
  switch (PageStatus0)
 80224e6:	f64e 61ee 	movw	r1, #61166	@ 0xeeee
 80224ea:	428c      	cmp	r4, r1
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80224ec:	b29b      	uxth	r3, r3
  switch (PageStatus0)
 80224ee:	d027      	beq.n	8022540 <EEPROM_Init+0x8c>
 80224f0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 80224f4:	4294      	cmp	r4, r2
 80224f6:	d00a      	beq.n	802250e <EEPROM_Init+0x5a>
 80224f8:	2c00      	cmp	r4, #0
 80224fa:	d1e4      	bne.n	80224c6 <EEPROM_Init+0x12>
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 80224fc:	2b00      	cmp	r3, #0
 80224fe:	d0e2      	beq.n	80224c6 <EEPROM_Init+0x12>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 8022500:	4293      	cmp	r3, r2
 8022502:	d159      	bne.n	80225b8 <EEPROM_Init+0x104>
	FLASH_ClearFlag(0xffffffff);
 8022504:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022508:	f7f6 fdd0 	bl	80190ac <FLASH_ClearFlag>
	FlashStatus = FLASH_EraseSector(EEPROM_PAGE1_SECTOR, VoltageRange_3);
 802250c:	e032      	b.n	8022574 <EEPROM_Init+0xc0>
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 802250e:	b933      	cbnz	r3, 802251e <EEPROM_Init+0x6a>
	FLASH_ClearFlag(0xffffffff);
 8022510:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022514:	f7f6 fdca 	bl	80190ac <FLASH_ClearFlag>
	FlashStatus = FLASH_EraseSector(EEPROM_PAGE0_SECTOR, VoltageRange_3);
 8022518:	2102      	movs	r1, #2
 802251a:	2010      	movs	r0, #16
 802251c:	e02c      	b.n	8022578 <EEPROM_Init+0xc4>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 802251e:	428b      	cmp	r3, r1
 8022520:	d1d1      	bne.n	80224c6 <EEPROM_Init+0x12>
	FLASH_ClearFlag(0xffffffff);
 8022522:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022526:	f7f6 fdc1 	bl	80190ac <FLASH_ClearFlag>
	FlashStatus = FLASH_EraseSector(EEPROM_PAGE0_SECTOR, VoltageRange_3);
 802252a:	2102      	movs	r1, #2
 802252c:	2010      	movs	r0, #16
 802252e:	f7f6 fdef 	bl	8019110 <FLASH_EraseSector>
        if (FlashStatus != FLASH_COMPLETE)
 8022532:	2808      	cmp	r0, #8
 8022534:	d1cb      	bne.n	80224ce <EEPROM_Init+0x1a>
        FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 8022536:	2100      	movs	r1, #0
 8022538:	4630      	mov	r0, r6
        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 802253a:	f7f6 fe17 	bl	801916c <FLASH_ProgramHalfWord>
 802253e:	e7c4      	b.n	80224ca <EEPROM_Init+0x16>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 8022540:	bb4b      	cbnz	r3, 8022596 <EEPROM_Init+0xe2>
 8022542:	461c      	mov	r4, r3
  int16_t x = -1;
 8022544:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VarIdx)
 8022548:	88eb      	ldrh	r3, [r5, #6]
 802254a:	b2a6      	uxth	r6, r4
 802254c:	b29b      	uxth	r3, r3
 802254e:	42b3      	cmp	r3, r6
            x = VarIdx;
 8022550:	bf08      	it	eq
 8022552:	b227      	sxtheq	r7, r4
          if (VarIdx != x)
 8022554:	42a7      	cmp	r7, r4
 8022556:	d112      	bne.n	802257e <EEPROM_Init+0xca>
        for (VarIdx = 0; VarIdx < EEPROM_EMULATED_SIZE; VarIdx++)
 8022558:	3401      	adds	r4, #1
 802255a:	f5b4 6f00 	cmp.w	r4, #2048	@ 0x800
 802255e:	d1f3      	bne.n	8022548 <EEPROM_Init+0x94>
	FLASH_ClearFlag(0xffffffff);
 8022560:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022564:	f7f6 fda2 	bl	80190ac <FLASH_ClearFlag>
        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 8022568:	4827      	ldr	r0, [pc, #156]	@ (8022608 <EEPROM_Init+0x154>)
 802256a:	2100      	movs	r1, #0
 802256c:	f7f6 fdfe 	bl	801916c <FLASH_ProgramHalfWord>
        if (FlashStatus != FLASH_COMPLETE)
 8022570:	2808      	cmp	r0, #8
 8022572:	d1ac      	bne.n	80224ce <EEPROM_Init+0x1a>
	FlashStatus = FLASH_EraseSector(EEPROM_PAGE1_SECTOR, VoltageRange_3);
 8022574:	2102      	movs	r1, #2
 8022576:	2018      	movs	r0, #24
 8022578:	f7f6 fdca 	bl	8019110 <FLASH_EraseSector>
 802257c:	e7a5      	b.n	80224ca <EEPROM_Init+0x16>
            ReadStatus = EEPROM_Read(VarIdx);
 802257e:	4630      	mov	r0, r6
 8022580:	f7ff ff70 	bl	8022464 <EEPROM_Read>
            if (ReadStatus >= 0)
 8022584:	1e01      	subs	r1, r0, #0
 8022586:	dbe7      	blt.n	8022558 <EEPROM_Init+0xa4>
              EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, ReadStatus);
 8022588:	b289      	uxth	r1, r1
 802258a:	4630      	mov	r0, r6
 802258c:	f7ff ff16 	bl	80223bc <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != FLASH_COMPLETE)
 8022590:	2808      	cmp	r0, #8
 8022592:	d0e1      	beq.n	8022558 <EEPROM_Init+0xa4>
 8022594:	e79b      	b.n	80224ce <EEPROM_Init+0x1a>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 8022596:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 802259a:	4293      	cmp	r3, r2
 802259c:	d193      	bne.n	80224c6 <EEPROM_Init+0x12>
	FLASH_ClearFlag(0xffffffff);
 802259e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80225a2:	f7f6 fd83 	bl	80190ac <FLASH_ClearFlag>
	FlashStatus = FLASH_EraseSector(EEPROM_PAGE1_SECTOR, VoltageRange_3);
 80225a6:	2102      	movs	r1, #2
 80225a8:	2018      	movs	r0, #24
 80225aa:	f7f6 fdb1 	bl	8019110 <FLASH_EraseSector>
        if (FlashStatus != FLASH_COMPLETE)
 80225ae:	2808      	cmp	r0, #8
 80225b0:	d18d      	bne.n	80224ce <EEPROM_Init+0x1a>
        FlashStatus = FLASH_ProgramHalfWord(PAGE0_BASE_ADDRESS, VALID_PAGE);
 80225b2:	2100      	movs	r1, #0
 80225b4:	4628      	mov	r0, r5
 80225b6:	e7c0      	b.n	802253a <EEPROM_Init+0x86>
  int16_t x = -1;
 80225b8:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VarIdx)
 80225bc:	88f3      	ldrh	r3, [r6, #6]
 80225be:	b2a5      	uxth	r5, r4
 80225c0:	b29b      	uxth	r3, r3
 80225c2:	42ab      	cmp	r3, r5
            x = VarIdx;
 80225c4:	bf08      	it	eq
 80225c6:	b227      	sxtheq	r7, r4
          if (VarIdx != x)
 80225c8:	42a7      	cmp	r7, r4
 80225ca:	d10e      	bne.n	80225ea <EEPROM_Init+0x136>
        for (VarIdx = 0; VarIdx < EEPROM_EMULATED_SIZE; VarIdx++)
 80225cc:	3401      	adds	r4, #1
 80225ce:	f5b4 6f00 	cmp.w	r4, #2048	@ 0x800
 80225d2:	d1f3      	bne.n	80225bc <EEPROM_Init+0x108>
	FLASH_ClearFlag(0xffffffff);
 80225d4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80225d8:	f7f6 fd68 	bl	80190ac <FLASH_ClearFlag>
        FlashStatus = FLASH_ProgramHalfWord(PAGE1_BASE_ADDRESS, VALID_PAGE);
 80225dc:	480b      	ldr	r0, [pc, #44]	@ (802260c <EEPROM_Init+0x158>)
 80225de:	2100      	movs	r1, #0
 80225e0:	f7f6 fdc4 	bl	801916c <FLASH_ProgramHalfWord>
        if (FlashStatus != FLASH_COMPLETE)
 80225e4:	2808      	cmp	r0, #8
 80225e6:	d097      	beq.n	8022518 <EEPROM_Init+0x64>
 80225e8:	e771      	b.n	80224ce <EEPROM_Init+0x1a>
            ReadStatus = EEPROM_Read(VarIdx);
 80225ea:	4628      	mov	r0, r5
 80225ec:	f7ff ff3a 	bl	8022464 <EEPROM_Read>
            if (ReadStatus >= 0)
 80225f0:	1e01      	subs	r1, r0, #0
 80225f2:	dbeb      	blt.n	80225cc <EEPROM_Init+0x118>
              EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, ReadStatus);
 80225f4:	b289      	uxth	r1, r1
 80225f6:	4628      	mov	r0, r5
 80225f8:	f7ff fee0 	bl	80223bc <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != FLASH_COMPLETE)
 80225fc:	2808      	cmp	r0, #8
 80225fe:	d0e5      	beq.n	80225cc <EEPROM_Init+0x118>
 8022600:	e765      	b.n	80224ce <EEPROM_Init+0x1a>
    return -1; // currently only mode 0 and 1 are supported
 8022602:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 8022606:	e764      	b.n	80224d2 <EEPROM_Init+0x1e>
 8022608:	08008000 	.word	0x08008000
 802260c:	0800c000 	.word	0x0800c000

08022610 <EEPROM_Write>:
{
 8022610:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8022614:	4606      	mov	r6, r0
 8022616:	4688      	mov	r8, r1
  if( ((ReadStatus=EEPROM_Read(VirtAddress)) >= 0) && ReadStatus == Data )
 8022618:	f7ff ff24 	bl	8022464 <EEPROM_Read>
 802261c:	2800      	cmp	r0, #0
 802261e:	db01      	blt.n	8022624 <EEPROM_Write+0x14>
 8022620:	4580      	cmp	r8, r0
 8022622:	d050      	beq.n	80226c6 <EEPROM_Write+0xb6>
  FLASH_Unlock();
 8022624:	f7f6 fd2c 	bl	8019080 <FLASH_Unlock>
  Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8022628:	4641      	mov	r1, r8
 802262a:	4630      	mov	r0, r6
 802262c:	f7ff fec6 	bl	80223bc <EE_VerifyPageFullWriteVariable>
  if (Status == PAGE_FULL)
 8022630:	2880      	cmp	r0, #128	@ 0x80
  Status = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8022632:	4604      	mov	r4, r0
  if (Status == PAGE_FULL)
 8022634:	d008      	beq.n	8022648 <EEPROM_Write+0x38>
  FLASH_Lock();
 8022636:	f7f6 fd31 	bl	801909c <FLASH_Lock>
  switch( Status ) {
 802263a:	2cab      	cmp	r4, #171	@ 0xab
 802263c:	d00e      	beq.n	802265c <EEPROM_Write+0x4c>
 802263e:	2c08      	cmp	r4, #8
 8022640:	d041      	beq.n	80226c6 <EEPROM_Write+0xb6>
  return -3; // flash write error
 8022642:	f06f 0002 	mvn.w	r0, #2
 8022646:	e00b      	b.n	8022660 <EEPROM_Write+0x50>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8022648:	4d29      	ldr	r5, [pc, #164]	@ (80226f0 <EEPROM_Write+0xe0>)
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 802264a:	492a      	ldr	r1, [pc, #168]	@ (80226f4 <EEPROM_Write+0xe4>)
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 802264c:	882a      	ldrh	r2, [r5, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 802264e:	880b      	ldrh	r3, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8022650:	b292      	uxth	r2, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8022652:	b29b      	uxth	r3, r3
      if (PageStatus0 == VALID_PAGE)
 8022654:	b132      	cbz	r2, 8022664 <EEPROM_Write+0x54>
      else if (PageStatus1 == VALID_PAGE)
 8022656:	b183      	cbz	r3, 802267a <EEPROM_Write+0x6a>
  FLASH_Lock();
 8022658:	f7f6 fd20 	bl	801909c <FLASH_Lock>
    case NO_VALID_PAGE: return -2;
 802265c:	f06f 0001 	mvn.w	r0, #1
}
 8022660:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  {
    /* New page address where variable will be moved to */
    NewPageAddress = PAGE1_BASE_ADDRESS;

    /* Old page address where variable will be taken from */
    OldPageSector = EEPROM_PAGE0_SECTOR;
 8022664:	2710      	movs	r7, #16
    NewPageAddress = PAGE1_BASE_ADDRESS;
 8022666:	460d      	mov	r5, r1
  {
    return NO_VALID_PAGE;       /* No valid Page */
  }

  /* Set the new Page status to RECEIVE_DATA status */
  FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, RECEIVE_DATA);
 8022668:	f64e 61ee 	movw	r1, #61166	@ 0xeeee
 802266c:	4628      	mov	r0, r5
 802266e:	f7f6 fd7d 	bl	801916c <FLASH_ProgramHalfWord>
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
 8022672:	2808      	cmp	r0, #8
 8022674:	d003      	beq.n	802267e <EEPROM_Write+0x6e>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != FLASH_COMPLETE)
  {
    return FlashStatus;
 8022676:	4604      	mov	r4, r0
 8022678:	e033      	b.n	80226e2 <EEPROM_Write+0xd2>
    OldPageSector = EEPROM_PAGE1_SECTOR;
 802267a:	2718      	movs	r7, #24
 802267c:	e7f4      	b.n	8022668 <EEPROM_Write+0x58>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 802267e:	4641      	mov	r1, r8
 8022680:	4630      	mov	r0, r6
 8022682:	f7ff fe9b 	bl	80223bc <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != FLASH_COMPLETE)
 8022686:	2808      	cmp	r0, #8
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8022688:	4604      	mov	r4, r0
  if (EepromStatus != FLASH_COMPLETE)
 802268a:	d12a      	bne.n	80226e2 <EEPROM_Write+0xd2>
 802268c:	f04f 0800 	mov.w	r8, #0
 8022690:	fa1f f488 	uxth.w	r4, r8
    if (VarIdx != VirtAddress)  /* Check each variable except the one passed as parameter */
 8022694:	42a6      	cmp	r6, r4
 8022696:	d118      	bne.n	80226ca <EEPROM_Write+0xba>
  for (VarIdx = 0; VarIdx < EEPROM_EMULATED_SIZE; VarIdx++)
 8022698:	f108 0801 	add.w	r8, r8, #1
 802269c:	f5b8 6f00 	cmp.w	r8, #2048	@ 0x800
 80226a0:	d1f6      	bne.n	8022690 <EEPROM_Write+0x80>
  FLASH_ClearFlag(0xffffffff);
 80226a2:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80226a6:	f7f6 fd01 	bl	80190ac <FLASH_ClearFlag>
  FlashStatus = FLASH_EraseSector(OldPageSector, VoltageRange_3);
 80226aa:	2102      	movs	r1, #2
 80226ac:	4638      	mov	r0, r7
 80226ae:	f7f6 fd2f 	bl	8019110 <FLASH_EraseSector>
  if (FlashStatus != FLASH_COMPLETE)
 80226b2:	2808      	cmp	r0, #8
 80226b4:	d1df      	bne.n	8022676 <EEPROM_Write+0x66>
  FlashStatus = FLASH_ProgramHalfWord(NewPageAddress, VALID_PAGE);
 80226b6:	2100      	movs	r1, #0
 80226b8:	4628      	mov	r0, r5
 80226ba:	f7f6 fd57 	bl	801916c <FLASH_ProgramHalfWord>
  if (FlashStatus != FLASH_COMPLETE)
 80226be:	2808      	cmp	r0, #8
 80226c0:	d1d9      	bne.n	8022676 <EEPROM_Write+0x66>
  FLASH_Lock();
 80226c2:	f7f6 fceb 	bl	801909c <FLASH_Lock>
    return 0; // programming not required
 80226c6:	2000      	movs	r0, #0
 80226c8:	e7ca      	b.n	8022660 <EEPROM_Write+0x50>
      ReadStatus = EEPROM_Read(VarIdx);
 80226ca:	4620      	mov	r0, r4
 80226cc:	f7ff feca 	bl	8022464 <EEPROM_Read>
      if (ReadStatus >= 0)
 80226d0:	1e01      	subs	r1, r0, #0
 80226d2:	dbe1      	blt.n	8022698 <EEPROM_Write+0x88>
        EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, ReadStatus);
 80226d4:	4620      	mov	r0, r4
 80226d6:	b289      	uxth	r1, r1
 80226d8:	f7ff fe70 	bl	80223bc <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != FLASH_COMPLETE)
 80226dc:	2808      	cmp	r0, #8
        EepromStatus = EE_VerifyPageFullWriteVariable(VarIdx, ReadStatus);
 80226de:	4604      	mov	r4, r0
        if (EepromStatus != FLASH_COMPLETE)
 80226e0:	d0da      	beq.n	8022698 <EEPROM_Write+0x88>
  FLASH_Lock();
 80226e2:	f7f6 fcdb 	bl	801909c <FLASH_Lock>
  switch( Status ) {
 80226e6:	2c80      	cmp	r4, #128	@ 0x80
 80226e8:	d1a7      	bne.n	802263a <EEPROM_Write+0x2a>
 80226ea:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
 80226ee:	e7b7      	b.n	8022660 <EEPROM_Write+0x50>
 80226f0:	08008000 	.word	0x08008000
 80226f4:	0800c000 	.word	0x0800c000

080226f8 <__aeabi_drsub>:
#ifdef L_arm_addsubdf3

ARM_FUNC_START aeabi_drsub
	CFI_START_FUNCTION

	eor	xh, xh, #0x80000000	@ flip sign bit of first arg
 80226f8:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
	b	1f	
 80226fc:	e002      	b.n	8022704 <__adddf3>
 80226fe:	bf00      	nop

08022700 <__aeabi_dsub>:

ARM_FUNC_START subdf3
ARM_FUNC_ALIAS aeabi_dsub subdf3

	eor	yh, yh, #0x80000000	@ flip sign bit of second arg
 8022700:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

08022704 <__adddf3>:
#endif

ARM_FUNC_START adddf3
ARM_FUNC_ALIAS aeabi_dadd adddf3

1:  do_push {r4, r5, lr}        @ sp -= 12
 8022704:	b530      	push	{r4, r5, lr}
	.cfi_rel_offset r4, 0       @ Registers are saved from sp to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	@ Look for zeroes, equal values, INF, or NAN.
	shift1	lsl, r4, xh, #1
 8022706:	ea4f 0441 	mov.w	r4, r1, lsl #1
	shift1	lsl, r5, yh, #1
 802270a:	ea4f 0543 	mov.w	r5, r3, lsl #1
	teq	r4, r5
 802270e:	ea94 0f05 	teq	r4, r5
	do_it	eq
 8022712:	bf08      	it	eq
	teqeq	xl, yl
 8022714:	ea90 0f02 	teqeq	r0, r2
	do_it	ne, ttt
 8022718:	bf1f      	itttt	ne
	COND(orr,s,ne)	ip, r4, xl
 802271a:	ea54 0c00 	orrsne.w	ip, r4, r0
	COND(orr,s,ne)	ip, r5, yl
 802271e:	ea55 0c02 	orrsne.w	ip, r5, r2
	COND(mvn,s,ne)	ip, r4, asr #21
 8022722:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
	COND(mvn,s,ne)	ip, r5, asr #21
 8022726:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
	beq	LSYM(Lad_s)
 802272a:	f000 80e2 	beq.w	80228f2 <__adddf3+0x1ee>

	@ Compute exponent difference.  Make largest exponent in r4,
	@ corresponding arg in xh-xl, and positive exponent difference in r5.
	shift1	lsr, r4, r4, #21
 802272e:	ea4f 5454 	mov.w	r4, r4, lsr #21
	rsbs	r5, r4, r5, lsr #21
 8022732:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
	do_it	lt
 8022736:	bfb8      	it	lt
	rsblt	r5, r5, #0
 8022738:	426d      	neglt	r5, r5
	ble	1f
 802273a:	dd0c      	ble.n	8022756 <__adddf3+0x52>
	add	r4, r4, r5
 802273c:	442c      	add	r4, r5
	eor	yl, xl, yl
 802273e:	ea80 0202 	eor.w	r2, r0, r2
	eor	yh, xh, yh
 8022742:	ea81 0303 	eor.w	r3, r1, r3
	eor	xl, yl, xl
 8022746:	ea82 0000 	eor.w	r0, r2, r0
	eor	xh, yh, xh
 802274a:	ea83 0101 	eor.w	r1, r3, r1
	eor	yl, xl, yl
 802274e:	ea80 0202 	eor.w	r2, r0, r2
	eor	yh, xh, yh
 8022752:	ea81 0303 	eor.w	r3, r1, r3
1:
	@ If exponent difference is too large, return largest argument
	@ already in xh-xl.  We need up to 54 bit to handle proper rounding
	@ of 0x1p54 - 1.1.
	cmp	r5, #54
 8022756:	2d36      	cmp	r5, #54	@ 0x36
	do_it	hi
 8022758:	bf88      	it	hi
	RETLDM	"r4, r5" hi
 802275a:	bd30      	pophi	{r4, r5, pc}

	@ Convert mantissa to signed integer.
	tst	xh, #0x80000000
 802275c:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
	mov	xh, xh, lsl #12
 8022760:	ea4f 3101 	mov.w	r1, r1, lsl #12
	mov	ip, #0x00100000
 8022764:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
	orr	xh, ip, xh, lsr #12
 8022768:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
	beq	1f
 802276c:	d002      	beq.n	8022774 <__adddf3+0x70>
#if defined(__thumb2__)
	negs	xl, xl
 802276e:	4240      	negs	r0, r0
	sbc	xh, xh, xh, lsl #1
 8022770:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
#else
	rsbs	xl, xl, #0
	rsc	xh, xh, #0
#endif
1:
	tst	yh, #0x80000000
 8022774:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
	mov	yh, yh, lsl #12
 8022778:	ea4f 3303 	mov.w	r3, r3, lsl #12
	orr	yh, ip, yh, lsr #12
 802277c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
	beq	1f
 8022780:	d002      	beq.n	8022788 <__adddf3+0x84>
#if defined(__thumb2__)
	negs	yl, yl
 8022782:	4252      	negs	r2, r2
	sbc	yh, yh, yh, lsl #1
 8022784:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
	rsc	yh, yh, #0
#endif
1:
	@ If exponent == difference, one or both args were denormalized.
	@ Since this is not common case, rescale them off line.
	teq	r4, r5
 8022788:	ea94 0f05 	teq	r4, r5
	beq	LSYM(Lad_d)
 802278c:	f000 80a7 	beq.w	80228de <__adddf3+0x1da>
@ point. Otherwise the CFI would change to a different state after the branch,
@ which would be disastrous for backtracing.
LSYM(Lad_x):

	@ Compensate for the exponent overlapping the mantissa MSB added later
	sub	r4, r4, #1
 8022790:	f1a4 0401 	sub.w	r4, r4, #1

	@ Shift yh-yl right per r5, add to xh-xl, keep leftover bits into ip.
	rsbs	lr, r5, #32
 8022794:	f1d5 0e20 	rsbs	lr, r5, #32
	blt	1f
 8022798:	db0d      	blt.n	80227b6 <__adddf3+0xb2>
	shift1	lsl, ip, yl, lr
 802279a:	fa02 fc0e 	lsl.w	ip, r2, lr
	shiftop adds xl xl yl lsr r5 yl
 802279e:	fa22 f205 	lsr.w	r2, r2, r5
 80227a2:	1880      	adds	r0, r0, r2
	adc	xh, xh, #0
 80227a4:	f141 0100 	adc.w	r1, r1, #0
	shiftop adds xl xl yh lsl lr yl
 80227a8:	fa03 f20e 	lsl.w	r2, r3, lr
 80227ac:	1880      	adds	r0, r0, r2
	shiftop adcs xh xh yh asr r5 yh
 80227ae:	fa43 f305 	asr.w	r3, r3, r5
 80227b2:	4159      	adcs	r1, r3
	b	2f
 80227b4:	e00e      	b.n	80227d4 <__adddf3+0xd0>
1:	sub	r5, r5, #32
 80227b6:	f1a5 0520 	sub.w	r5, r5, #32
	add	lr, lr, #32
 80227ba:	f10e 0e20 	add.w	lr, lr, #32
	cmp	yl, #1
 80227be:	2a01      	cmp	r2, #1
	shift1	lsl,ip, yh, lr
 80227c0:	fa03 fc0e 	lsl.w	ip, r3, lr
	do_it	cs
 80227c4:	bf28      	it	cs
	orrcs	ip, ip, #2		@ 2 not 1, to allow lsr #1 later
 80227c6:	f04c 0c02 	orrcs.w	ip, ip, #2
	shiftop adds xl xl yh asr r5 yh
 80227ca:	fa43 f305 	asr.w	r3, r3, r5
 80227ce:	18c0      	adds	r0, r0, r3
	adcs	xh, xh, yh, asr #31
 80227d0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
2:
	@ We now have a result in xh-xl-ip.
	@ Keep absolute value in xh-xl-ip, sign in r5 (the n bit was set above)
	and	r5, xh, #0x80000000
 80227d4:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
	bpl	LSYM(Lad_p)
 80227d8:	d507      	bpl.n	80227ea <__adddf3+0xe6>
#if defined(__thumb2__)
	mov	lr, #0
 80227da:	f04f 0e00 	mov.w	lr, #0
	negs	ip, ip
 80227de:	f1dc 0c00 	rsbs	ip, ip, #0
	sbcs	xl, lr, xl
 80227e2:	eb7e 0000 	sbcs.w	r0, lr, r0
	sbc	xh, lr, xh
 80227e6:	eb6e 0101 	sbc.w	r1, lr, r1
	rsc	xh, xh, #0
#endif

	@ Determine how to normalize the result.
LSYM(Lad_p):
	cmp	xh, #0x00100000
 80227ea:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
	bcc	LSYM(Lad_a)
 80227ee:	d31b      	bcc.n	8022828 <__adddf3+0x124>
	cmp	xh, #0x00200000
 80227f0:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
	bcc	LSYM(Lad_e)
 80227f4:	d30c      	bcc.n	8022810 <__adddf3+0x10c>

	@ Result needs to be shifted right.
	movs	xh, xh, lsr #1
 80227f6:	0849      	lsrs	r1, r1, #1
	movs	xl, xl, rrx
 80227f8:	ea5f 0030 	movs.w	r0, r0, rrx
	mov	ip, ip, rrx
 80227fc:	ea4f 0c3c 	mov.w	ip, ip, rrx
	add	r4, r4, #1
 8022800:	f104 0401 	add.w	r4, r4, #1

	@ Make sure we did not bust our exponent.
	mov	r2, r4, lsl #21
 8022804:	ea4f 5244 	mov.w	r2, r4, lsl #21
	cmn	r2, #(2 << 21)
 8022808:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
	bcs	LSYM(Lad_o)
 802280c:	f080 809a 	bcs.w	8022944 <__adddf3+0x240>
	@ Our result is now properly aligned into xh-xl, remaining bits in ip.
	@ Round with MSB of ip. If halfway between two numbers, round towards
	@ LSB of xl = 0.
	@ Pack final result together.
LSYM(Lad_e):
	cmp	ip, #0x80000000
 8022810:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
	do_it	eq
 8022814:	bf08      	it	eq
	COND(mov,s,eq)	ip, xl, lsr #1
 8022816:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
	adcs	xl, xl, #0
 802281a:	f150 0000 	adcs.w	r0, r0, #0
	adc	xh, xh, r4, lsl #20
 802281e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
	orr	xh, xh, r5
 8022822:	ea41 0105 	orr.w	r1, r1, r5
	RETLDM	"r4, r5"
 8022826:	bd30      	pop	{r4, r5, pc}

	@ Result must be shifted left and exponent adjusted.
LSYM(Lad_a):
	movs	ip, ip, lsl #1
 8022828:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
	adcs	xl, xl, xl
 802282c:	4140      	adcs	r0, r0
	adc	xh, xh, xh
 802282e:	eb41 0101 	adc.w	r1, r1, r1
	subs	r4, r4, #1
 8022832:	3c01      	subs	r4, #1
	do_it	hs
 8022834:	bf28      	it	cs
	cmphs	xh, #0x00100000
 8022836:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
	bhs	LSYM(Lad_e)
 802283a:	d2e9      	bcs.n	8022810 <__adddf3+0x10c>
	sublo	r3, r3, r2, lsr #1
	sub	r3, r3, r2, lsr #3

#else

	teq	xh, #0
 802283c:	f091 0f00 	teq	r1, #0
	do_it	eq, t
 8022840:	bf04      	itt	eq
	moveq	xh, xl
 8022842:	4601      	moveq	r1, r0
	moveq	xl, #0
 8022844:	2000      	moveq	r0, #0
	clz	r3, xh
 8022846:	fab1 f381 	clz	r3, r1
	do_it	eq
 802284a:	bf08      	it	eq
	addeq	r3, r3, #32
 802284c:	3320      	addeq	r3, #32
	sub	r3, r3, #11
 802284e:	f1a3 030b 	sub.w	r3, r3, #11

#endif

	@ determine how to shift the value.
	subs	r2, r3, #32
 8022852:	f1b3 0220 	subs.w	r2, r3, #32
	bge	2f
 8022856:	da0c      	bge.n	8022872 <__adddf3+0x16e>
	adds	r2, r2, #12
 8022858:	320c      	adds	r2, #12
	ble	1f
 802285a:	dd08      	ble.n	802286e <__adddf3+0x16a>

	@ shift value left 21 to 31 bits, or actually right 11 to 1 bits
	@ since a register switch happened above.
	add	ip, r2, #20
 802285c:	f102 0c14 	add.w	ip, r2, #20
	rsb	r2, r2, #12
 8022860:	f1c2 020c 	rsb	r2, r2, #12
	shift1	lsl, xl, xh, ip
 8022864:	fa01 f00c 	lsl.w	r0, r1, ip
	shift1	lsr, xh, xh, r2
 8022868:	fa21 f102 	lsr.w	r1, r1, r2
	b	3f
 802286c:	e00c      	b.n	8022888 <__adddf3+0x184>

	@ actually shift value left 1 to 20 bits, which might also represent
	@ 32 to 52 bits if counting the register switch that happened earlier.
1:	add	r2, r2, #20
 802286e:	f102 0214 	add.w	r2, r2, #20
2:	do_it	le
 8022872:	bfd8      	it	le
	rsble	ip, r2, #32
 8022874:	f1c2 0c20 	rsble	ip, r2, #32
	shift1	lsl, xh, xh, r2
 8022878:	fa01 f102 	lsl.w	r1, r1, r2
#if defined(__thumb2__)
	lsr	ip, xl, ip
 802287c:	fa20 fc0c 	lsr.w	ip, r0, ip
	itt	le
 8022880:	bfdc      	itt	le
	orrle	xh, xh, ip
 8022882:	ea41 010c 	orrle.w	r1, r1, ip
	lslle	xl, xl, r2
 8022886:	4090      	lslle	r0, r2
	orrle	xh, xh, xl, lsr ip
	movle	xl, xl, lsl r2
#endif

	@ adjust exponent accordingly.
3:	subs	r4, r4, r3
 8022888:	1ae4      	subs	r4, r4, r3
	do_it	ge, tt
 802288a:	bfa2      	ittt	ge
	addge	xh, xh, r4, lsl #20
 802288c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
	orrge	xh, xh, r5
 8022890:	4329      	orrge	r1, r5
	RETLDM	"r4, r5" ge
 8022892:	bd30      	popge	{r4, r5, pc}

	@ Exponent too small, denormalize result.
	@ Find out proper shift value.
	mvn	r4, r4
 8022894:	ea6f 0404 	mvn.w	r4, r4
	subs	r4, r4, #31
 8022898:	3c1f      	subs	r4, #31
	bge	2f
 802289a:	da1c      	bge.n	80228d6 <__adddf3+0x1d2>
	adds	r4, r4, #12
 802289c:	340c      	adds	r4, #12
	bgt	1f
 802289e:	dc0e      	bgt.n	80228be <__adddf3+0x1ba>

	@ shift result right of 1 to 20 bits, sign is in r5.
	add	r4, r4, #20
 80228a0:	f104 0414 	add.w	r4, r4, #20
	rsb	r2, r4, #32
 80228a4:	f1c4 0220 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r4
 80228a8:	fa20 f004 	lsr.w	r0, r0, r4
	shiftop orr xl xl xh lsl r2 yh
 80228ac:	fa01 f302 	lsl.w	r3, r1, r2
 80228b0:	ea40 0003 	orr.w	r0, r0, r3
	shiftop orr xh r5 xh lsr r4 yh
 80228b4:	fa21 f304 	lsr.w	r3, r1, r4
 80228b8:	ea45 0103 	orr.w	r1, r5, r3
	RETLDM	"r4, r5"
 80228bc:	bd30      	pop	{r4, r5, pc}

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl.
1:	rsb	r4, r4, #12
 80228be:	f1c4 040c 	rsb	r4, r4, #12
	rsb	r2, r4, #32
 80228c2:	f1c4 0220 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r2
 80228c6:	fa20 f002 	lsr.w	r0, r0, r2
	shiftop orr xl xl xh lsl r4 yh
 80228ca:	fa01 f304 	lsl.w	r3, r1, r4
 80228ce:	ea40 0003 	orr.w	r0, r0, r3
	mov	xh, r5
 80228d2:	4629      	mov	r1, r5
	RETLDM	"r4, r5"
 80228d4:	bd30      	pop	{r4, r5, pc}

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.
2:	shift1	lsr, xl, xh, r4
 80228d6:	fa21 f004 	lsr.w	r0, r1, r4
	mov	xh, r5
 80228da:	4629      	mov	r1, r5
	RETLDM	"r4, r5"
 80228dc:	bd30      	pop	{r4, r5, pc}

	@ Adjust exponents for denormalized arguments.
	@ Note that r4 must not remain equal to 0.
LSYM(Lad_d):
	teq	r4, #0
 80228de:	f094 0f00 	teq	r4, #0
	eor	yh, yh, #0x00100000
 80228e2:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
	do_it	eq, te
 80228e6:	bf06      	itte	eq
	eoreq	xh, xh, #0x00100000
 80228e8:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
	addeq	r4, r4, #1
 80228ec:	3401      	addeq	r4, #1
	subne	r5, r5, #1
 80228ee:	3d01      	subne	r5, #1
	b	LSYM(Lad_x)
 80228f0:	e74e      	b.n	8022790 <__adddf3+0x8c>


LSYM(Lad_s):
	mvns	ip, r4, asr #21
 80228f2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
	do_it	ne
 80228f6:	bf18      	it	ne
	COND(mvn,s,ne)	ip, r5, asr #21
 80228f8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
	beq	LSYM(Lad_i)
 80228fc:	d029      	beq.n	8022952 <__adddf3+0x24e>

	teq	r4, r5
 80228fe:	ea94 0f05 	teq	r4, r5
	do_it	eq
 8022902:	bf08      	it	eq
	teqeq	xl, yl
 8022904:	ea90 0f02 	teqeq	r0, r2
	beq	1f
 8022908:	d005      	beq.n	8022916 <__adddf3+0x212>

	@ Result is x + 0.0 = x or 0.0 + y = y.
	orrs	ip, r4, xl
 802290a:	ea54 0c00 	orrs.w	ip, r4, r0
	do_it	eq, t
 802290e:	bf04      	itt	eq
	moveq	xh, yh
 8022910:	4619      	moveq	r1, r3
	moveq	xl, yl
 8022912:	4610      	moveq	r0, r2
	RETLDM	"r4, r5"
 8022914:	bd30      	pop	{r4, r5, pc}

1:	teq	xh, yh
 8022916:	ea91 0f03 	teq	r1, r3

	@ Result is x - x = 0.
	do_it	ne, tt
 802291a:	bf1e      	ittt	ne
	movne	xh, #0
 802291c:	2100      	movne	r1, #0
	movne	xl, #0
 802291e:	2000      	movne	r0, #0
	RETLDM	"r4, r5" ne
 8022920:	bd30      	popne	{r4, r5, pc}

	@ Result is x + x = 2x.
	movs	ip, r4, lsr #21
 8022922:	ea5f 5c54 	movs.w	ip, r4, lsr #21
	bne	2f
 8022926:	d105      	bne.n	8022934 <__adddf3+0x230>
	movs	xl, xl, lsl #1
 8022928:	0040      	lsls	r0, r0, #1
	adcs	xh, xh, xh
 802292a:	4149      	adcs	r1, r1
	do_it	cs
 802292c:	bf28      	it	cs
	orrcs	xh, xh, #0x80000000
 802292e:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
	RETLDM	"r4, r5"
 8022932:	bd30      	pop	{r4, r5, pc}
2:	adds	r4, r4, #(2 << 21)
 8022934:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
	do_it	cc, t
 8022938:	bf3c      	itt	cc
	addcc	xh, xh, #(1 << 20)
 802293a:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
	RETLDM	"r4, r5" cc
 802293e:	bd30      	popcc	{r4, r5, pc}
	and	r5, xh, #0x80000000
 8022940:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000

	@ Overflow: return INF.
LSYM(Lad_o):
	orr	xh, r5, #0x7f000000
 8022944:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
	orr	xh, xh, #0x00f00000
 8022948:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
	mov	xl, #0
 802294c:	f04f 0000 	mov.w	r0, #0
	RETLDM	"r4, r5"
 8022950:	bd30      	pop	{r4, r5, pc}
	@   if yh-yl != INF/NAN: return xh-xl (which is INF/NAN)
	@   if either is NAN: return NAN
	@   if opposite sign: return NAN
	@   otherwise return xh-xl (which is INF or -INF)
LSYM(Lad_i):
	mvns	ip, r4, asr #21
 8022952:	ea7f 5c64 	mvns.w	ip, r4, asr #21
	do_it	ne, te
 8022956:	bf1a      	itte	ne
	movne	xh, yh
 8022958:	4619      	movne	r1, r3
	movne	xl, yl
 802295a:	4610      	movne	r0, r2
	COND(mvn,s,eq)	ip, r5, asr #21
 802295c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
	do_it	ne, t
 8022960:	bf1c      	itt	ne
	movne	yh, xh
 8022962:	460b      	movne	r3, r1
	movne	yl, xl
 8022964:	4602      	movne	r2, r0
	orrs	r4, xl, xh, lsl #12
 8022966:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
	do_it	eq, te
 802296a:	bf06      	itte	eq
	COND(orr,s,eq)	r5, yl, yh, lsl #12
 802296c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
	teqeq	xh, yh
 8022970:	ea91 0f03 	teqeq	r1, r3
	orrne	xh, xh, #0x00080000	@ quiet NAN
 8022974:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
	RETLDM	"r4, r5"
 8022978:	bd30      	pop	{r4, r5, pc}
 802297a:	bf00      	nop

0802297c <__aeabi_ui2d>:

ARM_FUNC_START floatunsidf
ARM_FUNC_ALIAS aeabi_ui2d floatunsidf
	CFI_START_FUNCTION

	teq	r0, #0
 802297c:	f090 0f00 	teq	r0, #0
	do_it	eq, t
 8022980:	bf04      	itt	eq
	moveq	r1, #0
 8022982:	2100      	moveq	r1, #0
	RETc(eq)
 8022984:	4770      	bxeq	lr

	do_push {r4, r5, lr}        @ sp -= 12
 8022986:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x400		@ initial exponent
 8022988:	f44f 6480 	mov.w	r4, #1024	@ 0x400
	add	r4, r4, #(52-1 - 1)
 802298c:	f104 0432 	add.w	r4, r4, #50	@ 0x32
	mov	r5, #0			@ sign bit is 0
 8022990:	f04f 0500 	mov.w	r5, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
 8022994:	f04f 0100 	mov.w	r1, #0
	b	LSYM(Lad_l)
 8022998:	e750      	b.n	802283c <__adddf3+0x138>
 802299a:	bf00      	nop

0802299c <__aeabi_i2d>:

ARM_FUNC_START floatsidf
ARM_FUNC_ALIAS aeabi_i2d floatsidf
	CFI_START_FUNCTION

	teq	r0, #0
 802299c:	f090 0f00 	teq	r0, #0
	do_it	eq, t
 80229a0:	bf04      	itt	eq
	moveq	r1, #0
 80229a2:	2100      	moveq	r1, #0
	RETc(eq)
 80229a4:	4770      	bxeq	lr

	do_push {r4, r5, lr}        @ sp -= 12
 80229a6:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x400		@ initial exponent
 80229a8:	f44f 6480 	mov.w	r4, #1024	@ 0x400
	add	r4, r4, #(52-1 - 1)
 80229ac:	f104 0432 	add.w	r4, r4, #50	@ 0x32
	ands	r5, r0, #0x80000000	@ sign bit in r5
 80229b0:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
	do_it	mi
 80229b4:	bf48      	it	mi
	rsbmi	r0, r0, #0		@ absolute value
 80229b6:	4240      	negmi	r0, r0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
 80229b8:	f04f 0100 	mov.w	r1, #0
	b	LSYM(Lad_l)
 80229bc:	e73e      	b.n	802283c <__adddf3+0x138>
 80229be:	bf00      	nop

080229c0 <__aeabi_f2d>:

ARM_FUNC_START extendsfdf2
ARM_FUNC_ALIAS aeabi_f2d extendsfdf2
	CFI_START_FUNCTION

	movs	r2, r0, lsl #1		@ toss sign bit
 80229c0:	0042      	lsls	r2, r0, #1
	mov	xh, r2, asr #3		@ stretch exponent
 80229c2:	ea4f 01e2 	mov.w	r1, r2, asr #3
	mov	xh, xh, rrx		@ retrieve sign bit
 80229c6:	ea4f 0131 	mov.w	r1, r1, rrx
	mov	xl, r2, lsl #28		@ retrieve remaining bits
 80229ca:	ea4f 7002 	mov.w	r0, r2, lsl #28
	do_it	ne, ttt
 80229ce:	bf1f      	itttt	ne
	COND(and,s,ne)	r3, r2, #0xff000000	@ isolate exponent
 80229d0:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
	teqne	r3, #0xff000000		@ if not 0, check if INF or NAN
 80229d4:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
	eorne	xh, xh, #0x38000000	@ fixup exponent otherwise.
 80229d8:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
	RETc(ne)			@ and return it.
 80229dc:	4770      	bxne	lr

	bics	r2, r2, #0xff000000	@ isolate mantissa
 80229de:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
	do_it	eq			@ if 0, that is ZERO or INF,
 80229e2:	bf08      	it	eq
	RETc(eq)			@ we are done already.
 80229e4:	4770      	bxeq	lr

	teq	r3, #0xff000000		@ check for NAN
 80229e6:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
	do_it	eq, t
 80229ea:	bf04      	itt	eq
	orreq	xh, xh, #0x00080000	@ change to quiet NAN
 80229ec:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
	RETc(eq)			@ and return it.
 80229f0:	4770      	bxeq	lr

	@ value was denormalized.  We can normalize it now.
	do_push	{r4, r5, lr}
 80229f2:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12   @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0       @ Registers are saved from sp + 0 to sp + 8.
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r4, #0x380		@ setup corresponding exponent
 80229f4:	f44f 7460 	mov.w	r4, #896	@ 0x380
	and	r5, xh, #0x80000000	@ move sign bit in r5
 80229f8:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
	bic	xh, xh, #0x80000000
 80229fc:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
	b	LSYM(Lad_l)
 8022a00:	e71c      	b.n	802283c <__adddf3+0x138>
 8022a02:	bf00      	nop

08022a04 <__aeabi_ul2d>:
ARM_FUNC_START floatundidf
ARM_FUNC_ALIAS aeabi_ul2d floatundidf
	CFI_START_FUNCTION
	.cfi_remember_state        @ Save the current CFA state.

	orrs	r2, r0, r1
 8022a04:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
 8022a08:	bf08      	it	eq
	RETc(eq)
 8022a0a:	4770      	bxeq	lr

	do_push {r4, r5, lr}       @ sp -= 12
 8022a0c:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0      @ Registers are saved from sp + 0 to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	mov	r5, #0
 8022a0e:	f04f 0500 	mov.w	r5, #0
	b	2f
 8022a12:	e00a      	b.n	8022a2a <__aeabi_l2d+0x16>

08022a14 <__aeabi_l2d>:
	.cfi_restore_state
	@ Restore the CFI state we saved above. If we didn't do this then the
	@ following instructions would have the CFI state that was set by the
	@ offset adjustments made in floatundidf.

	orrs	r2, r0, r1
 8022a14:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
 8022a18:	bf08      	it	eq
	RETc(eq)
 8022a1a:	4770      	bxeq	lr

	do_push {r4, r5, lr}       @ sp -= 12
 8022a1c:	b530      	push	{r4, r5, lr}
	.cfi_adjust_cfa_offset 12  @ CFA is now sp + previousOffset + 12
	.cfi_rel_offset r4, 0      @ Registers are saved from sp to sp + 8
	.cfi_rel_offset r5, 4
	.cfi_rel_offset lr, 8

	ands	r5, ah, #0x80000000	@ sign bit in r5
 8022a1e:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
	bpl	2f
 8022a22:	d502      	bpl.n	8022a2a <__aeabi_l2d+0x16>
#if defined(__thumb2__)
	negs	al, al
 8022a24:	4240      	negs	r0, r0
	sbc	ah, ah, ah, lsl #1
 8022a26:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
#else
	rsbs	al, al, #0
	rsc	ah, ah, #0
#endif
2:
	mov	r4, #0x400		@ initial exponent
 8022a2a:	f44f 6480 	mov.w	r4, #1024	@ 0x400
	add	r4, r4, #(52-1 - 1)
 8022a2e:	f104 0432 	add.w	r4, r4, #50	@ 0x32
	mov	ip, al
	mov	xh, ah
	mov	xl, ip
	.endif

	movs	ip, xh, lsr #22
 8022a32:	ea5f 5c91 	movs.w	ip, r1, lsr #22
	beq	LSYM(Lad_p)
 8022a36:	f43f aed8 	beq.w	80227ea <__adddf3+0xe6>

	@ The value is too big.  Scale it down a bit...
	mov	r2, #3
 8022a3a:	f04f 0203 	mov.w	r2, #3
	movs	ip, ip, lsr #3
 8022a3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
	do_it	ne
 8022a42:	bf18      	it	ne
	addne	r2, r2, #3
 8022a44:	3203      	addne	r2, #3
	movs	ip, ip, lsr #3
 8022a46:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
	do_it	ne
 8022a4a:	bf18      	it	ne
	addne	r2, r2, #3
 8022a4c:	3203      	addne	r2, #3
	add	r2, r2, ip, lsr #3
 8022a4e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3

	rsb	r3, r2, #32
 8022a52:	f1c2 0320 	rsb	r3, r2, #32
	shift1	lsl, ip, xl, r3
 8022a56:	fa00 fc03 	lsl.w	ip, r0, r3
	shift1	lsr, xl, xl, r2
 8022a5a:	fa20 f002 	lsr.w	r0, r0, r2
	shiftop orr xl xl xh lsl r3 lr
 8022a5e:	fa01 fe03 	lsl.w	lr, r1, r3
 8022a62:	ea40 000e 	orr.w	r0, r0, lr
	shift1	lsr, xh, xh, r2
 8022a66:	fa21 f102 	lsr.w	r1, r1, r2
	add	r4, r4, r2
 8022a6a:	4414      	add	r4, r2
	b	LSYM(Lad_p)
 8022a6c:	e6bd      	b.n	80227ea <__adddf3+0xe6>
 8022a6e:	bf00      	nop

08022a70 <__aeabi_dmul>:

ARM_FUNC_START muldf3
ARM_FUNC_ALIAS aeabi_dmul muldf3
	CFI_START_FUNCTION

	do_push {r4, r5, r6, lr}    @ sp -= 16
 8022a70:	b570      	push	{r4, r5, r6, lr}
	.cfi_rel_offset r5, 4
	.cfi_rel_offset r6, 8
	.cfi_rel_offset lr, 12

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
 8022a72:	f04f 0cff 	mov.w	ip, #255	@ 0xff
	orr	ip, ip, #0x700
 8022a76:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
	ands	r4, ip, xh, lsr #20
 8022a7a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
	do_it	ne, tte
 8022a7e:	bf1d      	ittte	ne
	COND(and,s,ne)	r5, ip, yh, lsr #20
 8022a80:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
	teqne	r4, ip
 8022a84:	ea94 0f0c 	teqne	r4, ip
	teqne	r5, ip
 8022a88:	ea95 0f0c 	teqne	r5, ip
	bleq	LSYM(Lml_s)
 8022a8c:	f000 f8de 	bleq	8022c4c <__aeabi_dmul+0x1dc>

	@ Add exponents together
	add	r4, r4, r5
 8022a90:	442c      	add	r4, r5

	@ Determine final sign.
	eor	r6, xh, yh
 8022a92:	ea81 0603 	eor.w	r6, r1, r3

	@ Convert mantissa to unsigned integer.
	@ If power of two, branch to a separate path.
	bic	xh, xh, ip, lsl #21
 8022a96:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
	bic	yh, yh, ip, lsl #21
 8022a9a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
	orrs	r5, xl, xh, lsl #12
 8022a9e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
	do_it	ne
 8022aa2:	bf18      	it	ne
	COND(orr,s,ne)	r5, yl, yh, lsl #12
 8022aa4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
	orr	xh, xh, #0x00100000
 8022aa8:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
	orr	yh, yh, #0x00100000
 8022aac:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
	beq	LSYM(Lml_1)
 8022ab0:	d038      	beq.n	8022b24 <__aeabi_dmul+0xb4>

	@ Here is the actual multiplication.
	@ This code works on architecture versions >= 4
	umull	ip, lr, xl, yl
 8022ab2:	fba0 ce02 	umull	ip, lr, r0, r2
	mov	r5, #0
 8022ab6:	f04f 0500 	mov.w	r5, #0
	umlal	lr, r5, xh, yl
 8022aba:	fbe1 e502 	umlal	lr, r5, r1, r2
	and	yl, r6, #0x80000000
 8022abe:	f006 4200 	and.w	r2, r6, #2147483648	@ 0x80000000
	umlal	lr, r5, xl, yh
 8022ac2:	fbe0 e503 	umlal	lr, r5, r0, r3
	mov	r6, #0
 8022ac6:	f04f 0600 	mov.w	r6, #0
	umlal	r5, r6, xh, yh
 8022aca:	fbe1 5603 	umlal	r5, r6, r1, r3

	@ The LSBs in ip are only significant for the final rounding.
	@ Fold them into lr.
	teq	ip, #0
 8022ace:	f09c 0f00 	teq	ip, #0
	do_it	ne
 8022ad2:	bf18      	it	ne
	orrne	lr, lr, #1
 8022ad4:	f04e 0e01 	orrne.w	lr, lr, #1

	@ Adjust result upon the MSB position.
	sub	r4, r4, #0xff
 8022ad8:	f1a4 04ff 	sub.w	r4, r4, #255	@ 0xff
	cmp	r6, #(1 << (20-11))
 8022adc:	f5b6 7f00 	cmp.w	r6, #512	@ 0x200
	sbc	r4, r4, #0x300
 8022ae0:	f564 7440 	sbc.w	r4, r4, #768	@ 0x300
	bcs	1f
 8022ae4:	d204      	bcs.n	8022af0 <__aeabi_dmul+0x80>
	movs	lr, lr, lsl #1
 8022ae6:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
	adcs	r5, r5, r5
 8022aea:	416d      	adcs	r5, r5
	adc	r6, r6, r6
 8022aec:	eb46 0606 	adc.w	r6, r6, r6
1:
	@ Shift to final position, add sign to result.
	orr	xh, yl, r6, lsl #11
 8022af0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
	orr	xh, xh, r5, lsr #21
 8022af4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
	mov	xl, r5, lsl #11
 8022af8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
	orr	xl, xl, lr, lsr #21
 8022afc:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
	mov	lr, lr, lsl #11
 8022b00:	ea4f 2ece 	mov.w	lr, lr, lsl #11

	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
 8022b04:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
	do_it	hi
 8022b08:	bf88      	it	hi
	cmphi	ip, #0x700
 8022b0a:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
	bhi	LSYM(Lml_u)
 8022b0e:	d81e      	bhi.n	8022b4e <__aeabi_dmul+0xde>

	@ Round the result, merge final exponent.
	cmp	lr, #0x80000000
 8022b10:	f1be 4f00 	cmp.w	lr, #2147483648	@ 0x80000000
	do_it	eq
 8022b14:	bf08      	it	eq
	COND(mov,s,eq)	lr, xl, lsr #1
 8022b16:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
	adcs	xl, xl, #0
 8022b1a:	f150 0000 	adcs.w	r0, r0, #0
	adc	xh, xh, r4, lsl #20
 8022b1e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
 8022b22:	bd70      	pop	{r4, r5, r6, pc}

	@ Multiplication by 0x1p*: let''s shortcut a lot of code.
LSYM(Lml_1):
	and	r6, r6, #0x80000000
 8022b24:	f006 4600 	and.w	r6, r6, #2147483648	@ 0x80000000
	orr	xh, r6, xh
 8022b28:	ea46 0101 	orr.w	r1, r6, r1
	orr	xl, xl, yl
 8022b2c:	ea40 0002 	orr.w	r0, r0, r2
	eor	xh, xh, yh
 8022b30:	ea81 0103 	eor.w	r1, r1, r3
	subs	r4, r4, ip, lsr #1
 8022b34:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
	do_it	gt, tt
 8022b38:	bfc2      	ittt	gt
	COND(rsb,s,gt)	r5, r4, ip
 8022b3a:	ebd4 050c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
 8022b3e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
 8022b42:	bd70      	popgt	{r4, r5, r6, pc}

	@ Under/overflow: fix things up for the code below.
	orr	xh, xh, #0x00100000
 8022b44:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
	mov	lr, #0
 8022b48:	f04f 0e00 	mov.w	lr, #0
	subs	r4, r4, #1
 8022b4c:	3c01      	subs	r4, #1
LSYM(Lml_u):
	@ Overflow?
	bgt	LSYM(Lml_o)
 8022b4e:	f300 80ab 	bgt.w	8022ca8 <__aeabi_dmul+0x238>

	@ Check if denormalized result is possible, otherwise return signed 0.
	cmn	r4, #(53 + 1)
 8022b52:	f114 0f36 	cmn.w	r4, #54	@ 0x36
	do_it	le, tt
 8022b56:	bfde      	ittt	le
	movle	xl, #0
 8022b58:	2000      	movle	r0, #0
	bicle	xh, xh, #0x7fffffff
 8022b5a:	f001 4100 	andle.w	r1, r1, #2147483648	@ 0x80000000
	RETLDM	"r4, r5, r6" le
 8022b5e:	bd70      	pople	{r4, r5, r6, pc}

	@ Find out proper shift value.
	rsb	r4, r4, #0
 8022b60:	f1c4 0400 	rsb	r4, r4, #0
	subs	r4, r4, #32
 8022b64:	3c20      	subs	r4, #32
	bge	2f
 8022b66:	da35      	bge.n	8022bd4 <__aeabi_dmul+0x164>
	adds	r4, r4, #12
 8022b68:	340c      	adds	r4, #12
	bgt	1f
 8022b6a:	dc1b      	bgt.n	8022ba4 <__aeabi_dmul+0x134>

	@ shift result right of 1 to 20 bits, preserve sign bit, round, etc.
	add	r4, r4, #20
 8022b6c:	f104 0414 	add.w	r4, r4, #20
	rsb	r5, r4, #32
 8022b70:	f1c4 0520 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r5
 8022b74:	fa00 f305 	lsl.w	r3, r0, r5
	shift1	lsr, xl, xl, r4
 8022b78:	fa20 f004 	lsr.w	r0, r0, r4
	shiftop orr xl xl xh lsl r5 r2
 8022b7c:	fa01 f205 	lsl.w	r2, r1, r5
 8022b80:	ea40 0002 	orr.w	r0, r0, r2
	and	r2, xh, #0x80000000
 8022b84:	f001 4200 	and.w	r2, r1, #2147483648	@ 0x80000000
	bic	xh, xh, #0x80000000
 8022b88:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
	adds	xl, xl, r3, lsr #31
 8022b8c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
	shiftop adc xh r2 xh lsr r4 r6
 8022b90:	fa21 f604 	lsr.w	r6, r1, r4
 8022b94:	eb42 0106 	adc.w	r1, r2, r6
	orrs	lr, lr, r3, lsl #1
 8022b98:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
	do_it	eq
 8022b9c:	bf08      	it	eq
	biceq	xl, xl, r3, lsr #31
 8022b9e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
 8022ba2:	bd70      	pop	{r4, r5, r6, pc}

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl. Then round.
1:	rsb	r4, r4, #12
 8022ba4:	f1c4 040c 	rsb	r4, r4, #12
	rsb	r5, r4, #32
 8022ba8:	f1c4 0520 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r4
 8022bac:	fa00 f304 	lsl.w	r3, r0, r4
	shift1	lsr, xl, xl, r5
 8022bb0:	fa20 f005 	lsr.w	r0, r0, r5
	shiftop orr xl xl xh lsl r4 r2
 8022bb4:	fa01 f204 	lsl.w	r2, r1, r4
 8022bb8:	ea40 0002 	orr.w	r0, r0, r2
	bic	xh, xh, #0x7fffffff
 8022bbc:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
	adds	xl, xl, r3, lsr #31
 8022bc0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
	adc	xh, xh, #0
 8022bc4:	f141 0100 	adc.w	r1, r1, #0
	orrs	lr, lr, r3, lsl #1
 8022bc8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
	do_it	eq
 8022bcc:	bf08      	it	eq
	biceq	xl, xl, r3, lsr #31
 8022bce:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
 8022bd2:	bd70      	pop	{r4, r5, r6, pc}

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.  Leftover bits are in r3-r6-lr for rounding.
2:	rsb	r5, r4, #32
 8022bd4:	f1c4 0520 	rsb	r5, r4, #32
	shiftop orr lr lr xl lsl r5 r2
 8022bd8:	fa00 f205 	lsl.w	r2, r0, r5
 8022bdc:	ea4e 0e02 	orr.w	lr, lr, r2
	shift1	lsr, r3, xl, r4
 8022be0:	fa20 f304 	lsr.w	r3, r0, r4
	shiftop orr r3 r3 xh lsl r5 r2
 8022be4:	fa01 f205 	lsl.w	r2, r1, r5
 8022be8:	ea43 0302 	orr.w	r3, r3, r2
	shift1	lsr, xl, xh, r4
 8022bec:	fa21 f004 	lsr.w	r0, r1, r4
	bic	xh, xh, #0x7fffffff
 8022bf0:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
	shiftop bic xl xl xh lsr r4 r2
 8022bf4:	fa21 f204 	lsr.w	r2, r1, r4
 8022bf8:	ea20 0002 	bic.w	r0, r0, r2
	add	xl, xl, r3, lsr #31
 8022bfc:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
	orrs	lr, lr, r3, lsl #1
 8022c00:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
	do_it	eq
 8022c04:	bf08      	it	eq
	biceq	xl, xl, r3, lsr #31
 8022c06:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
 8022c0a:	bd70      	pop	{r4, r5, r6, pc}

	@ One or both arguments are denormalized.
	@ Scale them leftwards and preserve sign bit.
LSYM(Lml_d):
	teq	r4, #0
 8022c0c:	f094 0f00 	teq	r4, #0
	bne	2f
 8022c10:	d10f      	bne.n	8022c32 <__aeabi_dmul+0x1c2>
	and	r6, xh, #0x80000000
 8022c12:	f001 4600 	and.w	r6, r1, #2147483648	@ 0x80000000
1:	movs	xl, xl, lsl #1
 8022c16:	0040      	lsls	r0, r0, #1
	adc	xh, xh, xh
 8022c18:	eb41 0101 	adc.w	r1, r1, r1
	tst	xh, #0x00100000
 8022c1c:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
	do_it	eq
 8022c20:	bf08      	it	eq
	subeq	r4, r4, #1
 8022c22:	3c01      	subeq	r4, #1
	beq	1b
 8022c24:	d0f7      	beq.n	8022c16 <__aeabi_dmul+0x1a6>
	orr	xh, xh, r6
 8022c26:	ea41 0106 	orr.w	r1, r1, r6
	teq	r5, #0
 8022c2a:	f095 0f00 	teq	r5, #0
	do_it	ne
 8022c2e:	bf18      	it	ne
	RETc(ne)
 8022c30:	4770      	bxne	lr
2:	and	r6, yh, #0x80000000
 8022c32:	f003 4600 	and.w	r6, r3, #2147483648	@ 0x80000000
3:	movs	yl, yl, lsl #1
 8022c36:	0052      	lsls	r2, r2, #1
	adc	yh, yh, yh
 8022c38:	eb43 0303 	adc.w	r3, r3, r3
	tst	yh, #0x00100000
 8022c3c:	f413 1f80 	tst.w	r3, #1048576	@ 0x100000
	do_it	eq
 8022c40:	bf08      	it	eq
	subeq	r5, r5, #1
 8022c42:	3d01      	subeq	r5, #1
	beq	3b
 8022c44:	d0f7      	beq.n	8022c36 <__aeabi_dmul+0x1c6>
	orr	yh, yh, r6
 8022c46:	ea43 0306 	orr.w	r3, r3, r6
	RET
 8022c4a:	4770      	bx	lr

LSYM(Lml_s):
	@ Isolate the INF and NAN cases away
	teq	r4, ip
 8022c4c:	ea94 0f0c 	teq	r4, ip
	and	r5, ip, yh, lsr #20
 8022c50:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
	do_it	ne
 8022c54:	bf18      	it	ne
	teqne	r5, ip
 8022c56:	ea95 0f0c 	teqne	r5, ip
	beq	1f
 8022c5a:	d00c      	beq.n	8022c76 <__aeabi_dmul+0x206>

	@ Here, one or more arguments are either denormalized or zero.
	orrs	r6, xl, xh, lsl #1
 8022c5c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
	do_it	ne
 8022c60:	bf18      	it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
 8022c62:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
 8022c66:	d1d1      	bne.n	8022c0c <__aeabi_dmul+0x19c>

	@ Result is 0, but determine sign anyway.
LSYM(Lml_z):
	eor	xh, xh, yh
 8022c68:	ea81 0103 	eor.w	r1, r1, r3
	and	xh, xh, #0x80000000
 8022c6c:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
	mov	xl, #0
 8022c70:	f04f 0000 	mov.w	r0, #0
	RETLDM	"r4, r5, r6"
 8022c74:	bd70      	pop	{r4, r5, r6, pc}

1:	@ One or both args are INF or NAN.
	orrs	r6, xl, xh, lsl #1
 8022c76:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
	do_it	eq, te
 8022c7a:	bf06      	itte	eq
	moveq	xl, yl
 8022c7c:	4610      	moveq	r0, r2
	moveq	xh, yh
 8022c7e:	4619      	moveq	r1, r3
	COND(orr,s,ne)	r6, yl, yh, lsl #1
 8022c80:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
	beq	LSYM(Lml_n)		@ 0 * INF or INF * 0 -> NAN
 8022c84:	d019      	beq.n	8022cba <__aeabi_dmul+0x24a>
	teq	r4, ip
 8022c86:	ea94 0f0c 	teq	r4, ip
	bne	1f
 8022c8a:	d102      	bne.n	8022c92 <__aeabi_dmul+0x222>
	orrs	r6, xl, xh, lsl #12
 8022c8c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN * <anything> -> NAN
 8022c90:	d113      	bne.n	8022cba <__aeabi_dmul+0x24a>
1:	teq	r5, ip
 8022c92:	ea95 0f0c 	teq	r5, ip
	bne	LSYM(Lml_i)
 8022c96:	d105      	bne.n	8022ca4 <__aeabi_dmul+0x234>
	orrs	r6, yl, yh, lsl #12
 8022c98:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
	do_it	ne, t
 8022c9c:	bf1c      	itt	ne
	movne	xl, yl
 8022c9e:	4610      	movne	r0, r2
	movne	xh, yh
 8022ca0:	4619      	movne	r1, r3
	bne	LSYM(Lml_n)		@ <anything> * NAN -> NAN
 8022ca2:	d10a      	bne.n	8022cba <__aeabi_dmul+0x24a>

	@ Result is INF, but we need to determine its sign.
LSYM(Lml_i):
	eor	xh, xh, yh
 8022ca4:	ea81 0103 	eor.w	r1, r1, r3

	@ Overflow: return INF (sign already in xh).
LSYM(Lml_o):
	and	xh, xh, #0x80000000
 8022ca8:	f001 4100 	and.w	r1, r1, #2147483648	@ 0x80000000
	orr	xh, xh, #0x7f000000
 8022cac:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
	orr	xh, xh, #0x00f00000
 8022cb0:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
	mov	xl, #0
 8022cb4:	f04f 0000 	mov.w	r0, #0
	RETLDM	"r4, r5, r6"
 8022cb8:	bd70      	pop	{r4, r5, r6, pc}

	@ Return a quiet NAN.
LSYM(Lml_n):
	orr	xh, xh, #0x7f000000
 8022cba:	f041 41fe 	orr.w	r1, r1, #2130706432	@ 0x7f000000
	orr	xh, xh, #0x00f80000
 8022cbe:	f441 0178 	orr.w	r1, r1, #16252928	@ 0xf80000
	RETLDM	"r4, r5, r6"
 8022cc2:	bd70      	pop	{r4, r5, r6, pc}

08022cc4 <__aeabi_ddiv>:

ARM_FUNC_START divdf3
ARM_FUNC_ALIAS aeabi_ddiv divdf3
	CFI_START_FUNCTION
	
	do_push	{r4, r5, r6, lr}
 8022cc4:	b570      	push	{r4, r5, r6, lr}
	.cfi_rel_offset r5, 4
	.cfi_rel_offset r6, 8
	.cfi_rel_offset lr, 12

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
 8022cc6:	f04f 0cff 	mov.w	ip, #255	@ 0xff
	orr	ip, ip, #0x700
 8022cca:	f44c 6ce0 	orr.w	ip, ip, #1792	@ 0x700
	ands	r4, ip, xh, lsr #20
 8022cce:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
	do_it	ne, tte
 8022cd2:	bf1d      	ittte	ne
	COND(and,s,ne)	r5, ip, yh, lsr #20
 8022cd4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
	teqne	r4, ip
 8022cd8:	ea94 0f0c 	teqne	r4, ip
	teqne	r5, ip
 8022cdc:	ea95 0f0c 	teqne	r5, ip
	bleq	LSYM(Ldv_s)
 8022ce0:	f000 f8a7 	bleq	8022e32 <__aeabi_ddiv+0x16e>

	@ Subtract divisor exponent from dividend''s.
	sub	r4, r4, r5
 8022ce4:	eba4 0405 	sub.w	r4, r4, r5

	@ Preserve final sign into lr.
	eor	lr, xh, yh
 8022ce8:	ea81 0e03 	eor.w	lr, r1, r3

	@ Convert mantissa to unsigned integer.
	@ Dividend -> r5-r6, divisor -> yh-yl.
	orrs	r5, yl, yh, lsl #12
 8022cec:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
	mov	xh, xh, lsl #12
 8022cf0:	ea4f 3101 	mov.w	r1, r1, lsl #12
	beq	LSYM(Ldv_1)
 8022cf4:	f000 8088 	beq.w	8022e08 <__aeabi_ddiv+0x144>
	mov	yh, yh, lsl #12
 8022cf8:	ea4f 3303 	mov.w	r3, r3, lsl #12
	mov	r5, #0x10000000
 8022cfc:	f04f 5580 	mov.w	r5, #268435456	@ 0x10000000
	orr	yh, r5, yh, lsr #4
 8022d00:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
	orr	yh, yh, yl, lsr #24
 8022d04:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
	mov	yl, yl, lsl #8
 8022d08:	ea4f 2202 	mov.w	r2, r2, lsl #8
	orr	r5, r5, xh, lsr #4
 8022d0c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
	orr	r5, r5, xl, lsr #24
 8022d10:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
	mov	r6, xl, lsl #8
 8022d14:	ea4f 2600 	mov.w	r6, r0, lsl #8

	@ Initialize xh with final sign bit.
	and	xh, lr, #0x80000000
 8022d18:	f00e 4100 	and.w	r1, lr, #2147483648	@ 0x80000000

	@ Ensure result will land to known bit position.
	@ Apply exponent bias accordingly.
	cmp	r5, yh
 8022d1c:	429d      	cmp	r5, r3
	do_it	eq
 8022d1e:	bf08      	it	eq
	cmpeq	r6, yl
 8022d20:	4296      	cmpeq	r6, r2
	adc	r4, r4, #(255 - 2)
 8022d22:	f144 04fd 	adc.w	r4, r4, #253	@ 0xfd
	add	r4, r4, #0x300
 8022d26:	f504 7440 	add.w	r4, r4, #768	@ 0x300
	bcs	1f
 8022d2a:	d202      	bcs.n	8022d32 <__aeabi_ddiv+0x6e>
	movs	yh, yh, lsr #1
 8022d2c:	085b      	lsrs	r3, r3, #1
	mov	yl, yl, rrx
 8022d2e:	ea4f 0232 	mov.w	r2, r2, rrx
1:
	@ Perform first subtraction to align result to a nibble.
	subs	r6, r6, yl
 8022d32:	1ab6      	subs	r6, r6, r2
	sbc	r5, r5, yh
 8022d34:	eb65 0503 	sbc.w	r5, r5, r3
	movs	yh, yh, lsr #1
 8022d38:	085b      	lsrs	r3, r3, #1
	mov	yl, yl, rrx
 8022d3a:	ea4f 0232 	mov.w	r2, r2, rrx
	mov	xl, #0x00100000
 8022d3e:	f44f 1080 	mov.w	r0, #1048576	@ 0x100000
	mov	ip, #0x00080000
 8022d42:	f44f 2c00 	mov.w	ip, #524288	@ 0x80000

	@ The actual division loop.
1:	subs	lr, r6, yl
 8022d46:	ebb6 0e02 	subs.w	lr, r6, r2
	sbcs	lr, r5, yh
 8022d4a:	eb75 0e03 	sbcs.w	lr, r5, r3
	do_it	cs, tt
 8022d4e:	bf22      	ittt	cs
	subcs	r6, r6, yl
 8022d50:	1ab6      	subcs	r6, r6, r2
	movcs	r5, lr
 8022d52:	4675      	movcs	r5, lr
	orrcs	xl, xl, ip
 8022d54:	ea40 000c 	orrcs.w	r0, r0, ip
	movs	yh, yh, lsr #1
 8022d58:	085b      	lsrs	r3, r3, #1
	mov	yl, yl, rrx
 8022d5a:	ea4f 0232 	mov.w	r2, r2, rrx
	subs	lr, r6, yl
 8022d5e:	ebb6 0e02 	subs.w	lr, r6, r2
	sbcs	lr, r5, yh
 8022d62:	eb75 0e03 	sbcs.w	lr, r5, r3
	do_it	cs, tt
 8022d66:	bf22      	ittt	cs
	subcs	r6, r6, yl
 8022d68:	1ab6      	subcs	r6, r6, r2
	movcs	r5, lr
 8022d6a:	4675      	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #1
 8022d6c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
	movs	yh, yh, lsr #1
 8022d70:	085b      	lsrs	r3, r3, #1
	mov	yl, yl, rrx
 8022d72:	ea4f 0232 	mov.w	r2, r2, rrx
	subs	lr, r6, yl
 8022d76:	ebb6 0e02 	subs.w	lr, r6, r2
	sbcs	lr, r5, yh
 8022d7a:	eb75 0e03 	sbcs.w	lr, r5, r3
	do_it	cs, tt
 8022d7e:	bf22      	ittt	cs
	subcs	r6, r6, yl
 8022d80:	1ab6      	subcs	r6, r6, r2
	movcs	r5, lr
 8022d82:	4675      	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #2
 8022d84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
	movs	yh, yh, lsr #1
 8022d88:	085b      	lsrs	r3, r3, #1
	mov	yl, yl, rrx
 8022d8a:	ea4f 0232 	mov.w	r2, r2, rrx
	subs	lr, r6, yl
 8022d8e:	ebb6 0e02 	subs.w	lr, r6, r2
	sbcs	lr, r5, yh
 8022d92:	eb75 0e03 	sbcs.w	lr, r5, r3
	do_it	cs, tt
 8022d96:	bf22      	ittt	cs
	subcs	r6, r6, yl
 8022d98:	1ab6      	subcs	r6, r6, r2
	movcs	r5, lr
 8022d9a:	4675      	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #3
 8022d9c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3

	orrs	lr, r5, r6
 8022da0:	ea55 0e06 	orrs.w	lr, r5, r6
	beq	2f
 8022da4:	d018      	beq.n	8022dd8 <__aeabi_ddiv+0x114>
	mov	r5, r5, lsl #4
 8022da6:	ea4f 1505 	mov.w	r5, r5, lsl #4
	orr	r5, r5, r6, lsr #28
 8022daa:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
	mov	r6, r6, lsl #4
 8022dae:	ea4f 1606 	mov.w	r6, r6, lsl #4
	mov	yh, yh, lsl #3
 8022db2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
	orr	yh, yh, yl, lsr #29
 8022db6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
	mov	yl, yl, lsl #3
 8022dba:	ea4f 02c2 	mov.w	r2, r2, lsl #3
	movs	ip, ip, lsr #4
 8022dbe:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
	bne	1b
 8022dc2:	d1c0      	bne.n	8022d46 <__aeabi_ddiv+0x82>

	@ We are done with a word of the result.
	@ Loop again for the low word if this pass was for the high word.
	tst	xh, #0x00100000
 8022dc4:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
	bne	3f
 8022dc8:	d10b      	bne.n	8022de2 <__aeabi_ddiv+0x11e>
	orr	xh, xh, xl
 8022dca:	ea41 0100 	orr.w	r1, r1, r0
	mov	xl, #0
 8022dce:	f04f 0000 	mov.w	r0, #0
	mov	ip, #0x80000000
 8022dd2:	f04f 4c00 	mov.w	ip, #2147483648	@ 0x80000000
	b	1b
 8022dd6:	e7b6      	b.n	8022d46 <__aeabi_ddiv+0x82>
2:
	@ Be sure result starts in the high word.
	tst	xh, #0x00100000
 8022dd8:	f411 1f80 	tst.w	r1, #1048576	@ 0x100000
	do_it	eq, t
 8022ddc:	bf04      	itt	eq
	orreq	xh, xh, xl
 8022dde:	4301      	orreq	r1, r0
	moveq	xl, #0
 8022de0:	2000      	moveq	r0, #0
3:
	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
 8022de2:	f1b4 0cfd 	subs.w	ip, r4, #253	@ 0xfd
	do_it	hi
 8022de6:	bf88      	it	hi
	cmphi	ip, #0x700
 8022de8:	f5bc 6fe0 	cmphi.w	ip, #1792	@ 0x700
	bhi	LSYM(Lml_u)
 8022dec:	f63f aeaf 	bhi.w	8022b4e <__aeabi_dmul+0xde>

	@ Round the result, merge final exponent.
	subs	ip, r5, yh
 8022df0:	ebb5 0c03 	subs.w	ip, r5, r3
	do_it	eq, t
 8022df4:	bf04      	itt	eq
	COND(sub,s,eq)	ip, r6, yl
 8022df6:	ebb6 0c02 	subseq.w	ip, r6, r2
	COND(mov,s,eq)	ip, xl, lsr #1
 8022dfa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
	adcs	xl, xl, #0
 8022dfe:	f150 0000 	adcs.w	r0, r0, #0
	adc	xh, xh, r4, lsl #20
 8022e02:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
 8022e06:	bd70      	pop	{r4, r5, r6, pc}

	@ Division by 0x1p*: shortcut a lot of code.
LSYM(Ldv_1):
	and	lr, lr, #0x80000000
 8022e08:	f00e 4e00 	and.w	lr, lr, #2147483648	@ 0x80000000
	orr	xh, lr, xh, lsr #12
 8022e0c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
	adds	r4, r4, ip, lsr #1
 8022e10:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
	do_it	gt, tt
 8022e14:	bfc2      	ittt	gt
	COND(rsb,s,gt)	r5, r4, ip
 8022e16:	ebd4 050c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
 8022e1a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
 8022e1e:	bd70      	popgt	{r4, r5, r6, pc}

	orr	xh, xh, #0x00100000
 8022e20:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
	mov	lr, #0
 8022e24:	f04f 0e00 	mov.w	lr, #0
	subs	r4, r4, #1
 8022e28:	3c01      	subs	r4, #1
	b	LSYM(Lml_u)
 8022e2a:	e690      	b.n	8022b4e <__aeabi_dmul+0xde>

	@ Result mightt need to be denormalized: put remainder bits
	@ in lr for rounding considerations.
LSYM(Ldv_u):
	orr	lr, r5, r6
 8022e2c:	ea45 0e06 	orr.w	lr, r5, r6
	b	LSYM(Lml_u)
 8022e30:	e68d      	b.n	8022b4e <__aeabi_dmul+0xde>

	@ One or both arguments is either INF, NAN or zero.
LSYM(Ldv_s):
	and	r5, ip, yh, lsr #20
 8022e32:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
	teq	r4, ip
 8022e36:	ea94 0f0c 	teq	r4, ip
	do_it	eq
 8022e3a:	bf08      	it	eq
	teqeq	r5, ip
 8022e3c:	ea95 0f0c 	teqeq	r5, ip
	beq	LSYM(Lml_n)		@ INF/NAN / INF/NAN -> NAN
 8022e40:	f43f af3b 	beq.w	8022cba <__aeabi_dmul+0x24a>
	teq	r4, ip
 8022e44:	ea94 0f0c 	teq	r4, ip
	bne	1f
 8022e48:	d10a      	bne.n	8022e60 <__aeabi_ddiv+0x19c>
	orrs	r4, xl, xh, lsl #12
 8022e4a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN / <anything> -> NAN
 8022e4e:	f47f af34 	bne.w	8022cba <__aeabi_dmul+0x24a>
	teq	r5, ip
 8022e52:	ea95 0f0c 	teq	r5, ip
	bne	LSYM(Lml_i)		@ INF / <anything> -> INF
 8022e56:	f47f af25 	bne.w	8022ca4 <__aeabi_dmul+0x234>
	mov	xl, yl
 8022e5a:	4610      	mov	r0, r2
	mov	xh, yh
 8022e5c:	4619      	mov	r1, r3
	b	LSYM(Lml_n)		@ INF / (INF or NAN) -> NAN
 8022e5e:	e72c      	b.n	8022cba <__aeabi_dmul+0x24a>
1:	teq	r5, ip
 8022e60:	ea95 0f0c 	teq	r5, ip
	bne	2f
 8022e64:	d106      	bne.n	8022e74 <__aeabi_ddiv+0x1b0>
	orrs	r5, yl, yh, lsl #12
 8022e66:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
	beq	LSYM(Lml_z)		@ <anything> / INF -> 0
 8022e6a:	f43f aefd 	beq.w	8022c68 <__aeabi_dmul+0x1f8>
	mov	xl, yl
 8022e6e:	4610      	mov	r0, r2
	mov	xh, yh
 8022e70:	4619      	mov	r1, r3
	b	LSYM(Lml_n)		@ <anything> / NAN -> NAN
 8022e72:	e722      	b.n	8022cba <__aeabi_dmul+0x24a>
2:	@ If both are nonzero, we need to normalize and resume above.
	orrs	r6, xl, xh, lsl #1
 8022e74:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
	do_it	ne
 8022e78:	bf18      	it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
 8022e7a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
 8022e7e:	f47f aec5 	bne.w	8022c0c <__aeabi_dmul+0x19c>
	@ One or both arguments are 0.
	orrs	r4, xl, xh, lsl #1
 8022e82:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
	bne	LSYM(Lml_i)		@ <non_zero> / 0 -> INF
 8022e86:	f47f af0d 	bne.w	8022ca4 <__aeabi_dmul+0x234>
	orrs	r5, yl, yh, lsl #1
 8022e8a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
 8022e8e:	f47f aeeb 	bne.w	8022c68 <__aeabi_dmul+0x1f8>
	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
 8022e92:	e712      	b.n	8022cba <__aeabi_dmul+0x24a>

08022e94 <__aeabi_d2iz>:
 8022e94:	ea4f 0241 	mov.w	r2, r1, lsl #1
ARM_FUNC_ALIAS aeabi_d2iz fixdfsi
	CFI_START_FUNCTION

	@ check exponent range.
	mov	r2, xh, lsl #1
	adds	r2, r2, #(1 << 21)
 8022e98:	f512 1200 	adds.w	r2, r2, #2097152	@ 0x200000
	bcs	2f			@ value is INF or NAN
 8022e9c:	d215      	bcs.n	8022eca <__aeabi_d2iz+0x36>
	bpl	1f			@ value is too small
 8022e9e:	d511      	bpl.n	8022ec4 <__aeabi_d2iz+0x30>
	mov	r3, #(0xfffffc00 + 31)
 8022ea0:	f46f 7378 	mvn.w	r3, #992	@ 0x3e0
	subs	r2, r3, r2, asr #21
 8022ea4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
	bls	3f			@ value is too large
 8022ea8:	d912      	bls.n	8022ed0 <__aeabi_d2iz+0x3c>

	@ scale value
	mov	r3, xh, lsl #11
 8022eaa:	ea4f 23c1 	mov.w	r3, r1, lsl #11
	orr	r3, r3, #0x80000000
 8022eae:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
	orr	r3, r3, xl, lsr #21
 8022eb2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
	tst	xh, #0x80000000		@ the sign bit
 8022eb6:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
	shift1	lsr, r0, r3, r2
 8022eba:	fa23 f002 	lsr.w	r0, r3, r2
	do_it	ne
 8022ebe:	bf18      	it	ne
	rsbne	r0, r0, #0
 8022ec0:	4240      	negne	r0, r0
	RET
 8022ec2:	4770      	bx	lr

1:	mov	r0, #0
 8022ec4:	f04f 0000 	mov.w	r0, #0
	RET
 8022ec8:	4770      	bx	lr

2:	orrs	xl, xl, xh, lsl #12
 8022eca:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
	bne	4f			@ x is NAN.
 8022ece:	d105      	bne.n	8022edc <__aeabi_d2iz+0x48>
3:	ands	r0, xh, #0x80000000	@ the sign bit
 8022ed0:	f011 4000 	ands.w	r0, r1, #2147483648	@ 0x80000000
	do_it	eq
 8022ed4:	bf08      	it	eq
	moveq	r0, #0x7fffffff		@ maximum signed positive si
 8022ed6:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
	RET
 8022eda:	4770      	bx	lr

4:	mov	r0, #0			@ How should we convert NAN?
 8022edc:	f04f 0000 	mov.w	r0, #0
	RET
 8022ee0:	4770      	bx	lr
 8022ee2:	bf00      	nop

08022ee4 <__aeabi_d2f>:
ARM_FUNC_START truncdfsf2
ARM_FUNC_ALIAS aeabi_d2f truncdfsf2
	CFI_START_FUNCTION

	@ check exponent range.
	mov	r2, xh, lsl #1
 8022ee4:	ea4f 0241 	mov.w	r2, r1, lsl #1
	subs	r3, r2, #((1023 - 127) << 21)
 8022ee8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
	do_it	cs, t
 8022eec:	bf24      	itt	cs
	COND(sub,s,cs)	ip, r3, #(1 << 21)
 8022eee:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
	COND(rsb,s,cs)	ip, ip, #(254 << 21)
 8022ef2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
	bls	2f			@ value is out of range
 8022ef6:	d90d      	bls.n	8022f14 <__aeabi_d2f+0x30>

1:	@ shift and round mantissa
	and	ip, xh, #0x80000000
 8022ef8:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
	mov	r2, xl, lsl #3
 8022efc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
	orr	xl, ip, xl, lsr #29
 8022f00:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
	cmp	r2, #0x80000000
 8022f04:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
	adc	r0, xl, r3, lsl #2
 8022f08:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
	do_it	eq
 8022f0c:	bf08      	it	eq
	biceq	r0, r0, #1
 8022f0e:	f020 0001 	biceq.w	r0, r0, #1
	RET
 8022f12:	4770      	bx	lr

2:	@ either overflow or underflow
	tst	xh, #0x40000000
 8022f14:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
	bne	3f			@ overflow
 8022f18:	d121      	bne.n	8022f5e <__aeabi_d2f+0x7a>

	@ check if denormalized value is possible
	adds	r2, r3, #(23 << 21)
 8022f1a:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
	do_it	lt, t
 8022f1e:	bfbc      	itt	lt
	andlt	r0, xh, #0x80000000	@ too small, return signed 0.
 8022f20:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
	RETc(lt)
 8022f24:	4770      	bxlt	lr

	@ denormalize value so we can resume with the code above afterwards.
	orr	xh, xh, #0x00100000
 8022f26:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
	mov	r2, r2, lsr #21
 8022f2a:	ea4f 5252 	mov.w	r2, r2, lsr #21
	rsb	r2, r2, #24
 8022f2e:	f1c2 0218 	rsb	r2, r2, #24
	rsb	ip, r2, #32
 8022f32:	f1c2 0c20 	rsb	ip, r2, #32
#if defined(__thumb2__)
	lsls	r3, xl, ip
 8022f36:	fa10 f30c 	lsls.w	r3, r0, ip
#else
	movs	r3, xl, lsl ip
#endif
	shift1	lsr, xl, xl, r2
 8022f3a:	fa20 f002 	lsr.w	r0, r0, r2
	do_it	ne
 8022f3e:	bf18      	it	ne
	orrne	xl, xl, #1		@ fold r3 for rounding considerations. 
 8022f40:	f040 0001 	orrne.w	r0, r0, #1
	mov	r3, xh, lsl #11
 8022f44:	ea4f 23c1 	mov.w	r3, r1, lsl #11
	mov	r3, r3, lsr #11
 8022f48:	ea4f 23d3 	mov.w	r3, r3, lsr #11
	shiftop orr xl xl r3 lsl ip ip
 8022f4c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8022f50:	ea40 000c 	orr.w	r0, r0, ip
	shift1	lsr, r3, r3, r2
 8022f54:	fa23 f302 	lsr.w	r3, r3, r2
	mov	r3, r3, lsl #1
 8022f58:	ea4f 0343 	mov.w	r3, r3, lsl #1
	b	1b
 8022f5c:	e7cc      	b.n	8022ef8 <__aeabi_d2f+0x14>

3:	@ chech for NAN
	mvns	r3, r2, asr #21
 8022f5e:	ea7f 5362 	mvns.w	r3, r2, asr #21
	bne	5f			@ simple overflow
 8022f62:	d107      	bne.n	8022f74 <__aeabi_d2f+0x90>
	orrs	r3, xl, xh, lsl #12
 8022f64:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
	do_it	ne, tt
 8022f68:	bf1e      	ittt	ne
	movne	r0, #0x7f000000
 8022f6a:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
	orrne	r0, r0, #0x00c00000
 8022f6e:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
	RETc(ne)			@ return NAN
 8022f72:	4770      	bxne	lr

5:	@ return INF with sign
	and	r0, xh, #0x80000000
 8022f74:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
	orr	r0, r0, #0x7f000000
 8022f78:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
	orr	r0, r0, #0x00800000
 8022f7c:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	RET
 8022f80:	4770      	bx	lr
 8022f82:	bf00      	nop

08022f84 <__aeabi_frsub>:
#ifdef L_arm_addsubsf3

ARM_FUNC_START aeabi_frsub
	CFI_START_FUNCTION

	eor	r0, r0, #0x80000000	@ flip sign bit of first arg
 8022f84:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
	b	1f
 8022f88:	e002      	b.n	8022f90 <__addsf3>
 8022f8a:	bf00      	nop

08022f8c <__aeabi_fsub>:

ARM_FUNC_START subsf3
ARM_FUNC_ALIAS aeabi_fsub subsf3

	eor	r1, r1, #0x80000000	@ flip sign bit of second arg
 8022f8c:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

08022f90 <__addsf3>:

ARM_FUNC_START addsf3
ARM_FUNC_ALIAS aeabi_fadd addsf3

1:	@ Look for zeroes, equal values, INF, or NAN.
	movs	r2, r0, lsl #1
 8022f90:	0042      	lsls	r2, r0, #1
	do_it	ne, ttt
 8022f92:	bf1f      	itttt	ne
	COND(mov,s,ne)	r3, r1, lsl #1
 8022f94:	ea5f 0341 	movsne.w	r3, r1, lsl #1
	teqne	r2, r3
 8022f98:	ea92 0f03 	teqne	r2, r3
	COND(mvn,s,ne)	ip, r2, asr #24
 8022f9c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
	COND(mvn,s,ne)	ip, r3, asr #24
 8022fa0:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
	beq	LSYM(Lad_s)
 8022fa4:	d06a      	beq.n	802307c <__addsf3+0xec>

	@ Compute exponent difference.  Make largest exponent in r2,
	@ corresponding arg in r0, and positive exponent difference in r3.
	mov	r2, r2, lsr #24
 8022fa6:	ea4f 6212 	mov.w	r2, r2, lsr #24
	rsbs	r3, r2, r3, lsr #24
 8022faa:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
	do_it	gt, ttt
 8022fae:	bfc1      	itttt	gt
	addgt	r2, r2, r3
 8022fb0:	18d2      	addgt	r2, r2, r3
	eorgt	r1, r0, r1
 8022fb2:	4041      	eorgt	r1, r0
	eorgt	r0, r1, r0
 8022fb4:	4048      	eorgt	r0, r1
	eorgt	r1, r0, r1
 8022fb6:	4041      	eorgt	r1, r0
	do_it	lt
 8022fb8:	bfb8      	it	lt
	rsblt	r3, r3, #0
 8022fba:	425b      	neglt	r3, r3

	@ If exponent difference is too large, return largest argument
	@ already in r0.  We need up to 25 bit to handle proper rounding
	@ of 0x1p25 - 1.1.
	cmp	r3, #25
 8022fbc:	2b19      	cmp	r3, #25
	do_it	hi
 8022fbe:	bf88      	it	hi
	RETc(hi)
 8022fc0:	4770      	bxhi	lr

	@ Convert mantissa to signed integer.
	tst	r0, #0x80000000
 8022fc2:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
	orr	r0, r0, #0x00800000
 8022fc6:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	bic	r0, r0, #0xff000000
 8022fca:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
	do_it	ne
 8022fce:	bf18      	it	ne
	rsbne	r0, r0, #0
 8022fd0:	4240      	negne	r0, r0
	tst	r1, #0x80000000
 8022fd2:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
	orr	r1, r1, #0x00800000
 8022fd6:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
	bic	r1, r1, #0xff000000
 8022fda:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
	do_it	ne
 8022fde:	bf18      	it	ne
	rsbne	r1, r1, #0
 8022fe0:	4249      	negne	r1, r1

	@ If exponent == difference, one or both args were denormalized.
	@ Since this is not common case, rescale them off line.
	teq	r2, r3
 8022fe2:	ea92 0f03 	teq	r2, r3
	beq	LSYM(Lad_d)
 8022fe6:	d03f      	beq.n	8023068 <__addsf3+0xd8>
LSYM(Lad_x):

	@ Compensate for the exponent overlapping the mantissa MSB added later
	sub	r2, r2, #1
 8022fe8:	f1a2 0201 	sub.w	r2, r2, #1

	@ Shift and add second arg to first arg in r0.
	@ Keep leftover bits into r1.
	shiftop adds r0 r0 r1 asr r3 ip
 8022fec:	fa41 fc03 	asr.w	ip, r1, r3
 8022ff0:	eb10 000c 	adds.w	r0, r0, ip
	rsb	r3, r3, #32
 8022ff4:	f1c3 0320 	rsb	r3, r3, #32
	shift1	lsl, r1, r1, r3
 8022ff8:	fa01 f103 	lsl.w	r1, r1, r3

	@ Keep absolute value in r0-r1, sign in r3 (the n bit was set above)
	and	r3, r0, #0x80000000
 8022ffc:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
	bpl	LSYM(Lad_p)
 8023000:	d502      	bpl.n	8023008 <__addsf3+0x78>
#if defined(__thumb2__)
	negs	r1, r1
 8023002:	4249      	negs	r1, r1
	sbc	r0, r0, r0, lsl #1
 8023004:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
	rsc	r0, r0, #0
#endif

	@ Determine how to normalize the result.
LSYM(Lad_p):
	cmp	r0, #0x00800000
 8023008:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
	bcc	LSYM(Lad_a)
 802300c:	d313      	bcc.n	8023036 <__addsf3+0xa6>
	cmp	r0, #0x01000000
 802300e:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
	bcc	LSYM(Lad_e)
 8023012:	d306      	bcc.n	8023022 <__addsf3+0x92>

	@ Result needs to be shifted right.
	movs	r0, r0, lsr #1
 8023014:	0840      	lsrs	r0, r0, #1
	mov	r1, r1, rrx
 8023016:	ea4f 0131 	mov.w	r1, r1, rrx
	add	r2, r2, #1
 802301a:	f102 0201 	add.w	r2, r2, #1

	@ Make sure we did not bust our exponent.
	cmp	r2, #254
 802301e:	2afe      	cmp	r2, #254	@ 0xfe
	bhs	LSYM(Lad_o)
 8023020:	d251      	bcs.n	80230c6 <__addsf3+0x136>
	@ Our result is now properly aligned into r0, remaining bits in r1.
	@ Pack final result together.
	@ Round with MSB of r1. If halfway between two numbers, round towards
	@ LSB of r0 = 0. 
LSYM(Lad_e):
	cmp	r1, #0x80000000
 8023022:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
	adc	r0, r0, r2, lsl #23
 8023026:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
	do_it	eq
 802302a:	bf08      	it	eq
	biceq	r0, r0, #1
 802302c:	f020 0001 	biceq.w	r0, r0, #1
	orr	r0, r0, r3
 8023030:	ea40 0003 	orr.w	r0, r0, r3
	RET
 8023034:	4770      	bx	lr

	@ Result must be shifted left and exponent adjusted.
LSYM(Lad_a):
	movs	r1, r1, lsl #1
 8023036:	0049      	lsls	r1, r1, #1
	adc	r0, r0, r0
 8023038:	eb40 0000 	adc.w	r0, r0, r0
	subs	r2, r2, #1
 802303c:	3a01      	subs	r2, #1
	do_it	hs
 802303e:	bf28      	it	cs
	cmphs	r0, #0x00800000
 8023040:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
	bhs	LSYM(Lad_e)
 8023044:	d2ed      	bcs.n	8023022 <__addsf3+0x92>
	movcc	r0, r0, lsl #1
	sbcs	r2, r2, #0

#else

	clz	ip, r0
 8023046:	fab0 fc80 	clz	ip, r0
	sub	ip, ip, #8
 802304a:	f1ac 0c08 	sub.w	ip, ip, #8
	subs	r2, r2, ip
 802304e:	ebb2 020c 	subs.w	r2, r2, ip
	shift1	lsl, r0, r0, ip
 8023052:	fa00 f00c 	lsl.w	r0, r0, ip

#endif

	@ Final result with sign
	@ If exponent negative, denormalize result.
	do_it	ge, et
 8023056:	bfaa      	itet	ge
	addge	r0, r0, r2, lsl #23
 8023058:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
	rsblt	r2, r2, #0
 802305c:	4252      	neglt	r2, r2
	orrge	r0, r0, r3
 802305e:	4318      	orrge	r0, r3
#if defined(__thumb2__)
	do_it	lt, t
 8023060:	bfbc      	itt	lt
	lsrlt	r0, r0, r2
 8023062:	40d0      	lsrlt	r0, r2
	orrlt	r0, r3, r0
 8023064:	4318      	orrlt	r0, r3
#else
	orrlt	r0, r3, r0, lsr r2
#endif
	RET
 8023066:	4770      	bx	lr

	@ Fixup and adjust bit position for denormalized arguments.
	@ Note that r2 must not remain equal to 0.
LSYM(Lad_d):
	teq	r2, #0
 8023068:	f092 0f00 	teq	r2, #0
	eor	r1, r1, #0x00800000
 802306c:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
	do_it	eq, te
 8023070:	bf06      	itte	eq
	eoreq	r0, r0, #0x00800000
 8023072:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
	addeq	r2, r2, #1
 8023076:	3201      	addeq	r2, #1
	subne	r3, r3, #1
 8023078:	3b01      	subne	r3, #1
	b	LSYM(Lad_x)
 802307a:	e7b5      	b.n	8022fe8 <__addsf3+0x58>

LSYM(Lad_s):
	mov	r3, r1, lsl #1
 802307c:	ea4f 0341 	mov.w	r3, r1, lsl #1

	mvns	ip, r2, asr #24
 8023080:	ea7f 6c22 	mvns.w	ip, r2, asr #24
	do_it	ne
 8023084:	bf18      	it	ne
	COND(mvn,s,ne)	ip, r3, asr #24
 8023086:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
	beq	LSYM(Lad_i)
 802308a:	d021      	beq.n	80230d0 <__addsf3+0x140>

	teq	r2, r3
 802308c:	ea92 0f03 	teq	r2, r3
	beq	1f
 8023090:	d004      	beq.n	802309c <__addsf3+0x10c>

	@ Result is x + 0.0 = x or 0.0 + y = y.
	teq	r2, #0
 8023092:	f092 0f00 	teq	r2, #0
	do_it	eq
 8023096:	bf08      	it	eq
	moveq	r0, r1
 8023098:	4608      	moveq	r0, r1
	RET
 802309a:	4770      	bx	lr

1:	teq	r0, r1
 802309c:	ea90 0f01 	teq	r0, r1

	@ Result is x - x = 0.
	do_it	ne, t
 80230a0:	bf1c      	itt	ne
	movne	r0, #0
 80230a2:	2000      	movne	r0, #0
	RETc(ne)
 80230a4:	4770      	bxne	lr

	@ Result is x + x = 2x.
	tst	r2, #0xff000000
 80230a6:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
	bne	2f
 80230aa:	d104      	bne.n	80230b6 <__addsf3+0x126>
	movs	r0, r0, lsl #1
 80230ac:	0040      	lsls	r0, r0, #1
	do_it	cs
 80230ae:	bf28      	it	cs
	orrcs	r0, r0, #0x80000000
 80230b0:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
	RET
 80230b4:	4770      	bx	lr
2:	adds	r2, r2, #(2 << 24)
 80230b6:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
	do_it	cc, t
 80230ba:	bf3c      	itt	cc
	addcc	r0, r0, #(1 << 23)
 80230bc:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
	RETc(cc)
 80230c0:	4770      	bxcc	lr
	and	r3, r0, #0x80000000
 80230c2:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000

	@ Overflow: return INF.
LSYM(Lad_o):
	orr	r0, r3, #0x7f000000
 80230c6:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
	orr	r0, r0, #0x00800000
 80230ca:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	RET
 80230ce:	4770      	bx	lr
	@   if r1 != INF/NAN: return r0 (which is INF/NAN)
	@   if r0 or r1 is NAN: return NAN
	@   if opposite sign: return NAN
	@   otherwise return r0 (which is INF or -INF)
LSYM(Lad_i):
	mvns	r2, r2, asr #24
 80230d0:	ea7f 6222 	mvns.w	r2, r2, asr #24
	do_it	ne, et
 80230d4:	bf16      	itet	ne
	movne	r0, r1
 80230d6:	4608      	movne	r0, r1
	COND(mvn,s,eq)	r3, r3, asr #24
 80230d8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
	movne	r1, r0
 80230dc:	4601      	movne	r1, r0
	movs	r2, r0, lsl #9
 80230de:	0242      	lsls	r2, r0, #9
	do_it	eq, te
 80230e0:	bf06      	itte	eq
	COND(mov,s,eq)	r3, r1, lsl #9
 80230e2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
	teqeq	r0, r1
 80230e6:	ea90 0f01 	teqeq	r0, r1
	orrne	r0, r0, #0x00400000	@ quiet NAN
 80230ea:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
	RET
 80230ee:	4770      	bx	lr

080230f0 <__aeabi_ui2f>:

ARM_FUNC_START floatunsisf
ARM_FUNC_ALIAS aeabi_ui2f floatunsisf
	CFI_START_FUNCTION
		
	mov	r3, #0
 80230f0:	f04f 0300 	mov.w	r3, #0
	b	1f
 80230f4:	e004      	b.n	8023100 <__aeabi_i2f+0x8>
 80230f6:	bf00      	nop

080230f8 <__aeabi_i2f>:

ARM_FUNC_START floatsisf
ARM_FUNC_ALIAS aeabi_i2f floatsisf
	
	ands	r3, r0, #0x80000000
 80230f8:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
	do_it	mi
 80230fc:	bf48      	it	mi
	rsbmi	r0, r0, #0
 80230fe:	4240      	negmi	r0, r0

1:	movs	ip, r0
 8023100:	ea5f 0c00 	movs.w	ip, r0
	do_it	eq
 8023104:	bf08      	it	eq
	RETc(eq)
 8023106:	4770      	bxeq	lr

	@ Add initial exponent to sign
	orr	r3, r3, #((127 + 23) << 23)
 8023108:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000

	.ifnc	ah, r0
	mov	ah, r0
 802310c:	4601      	mov	r1, r0
	.endif
	mov	al, #0
 802310e:	f04f 0000 	mov.w	r0, #0
	b	2f
 8023112:	e01c      	b.n	802314e <__aeabi_l2f+0x2a>

08023114 <__aeabi_ul2f>:

ARM_FUNC_START floatundisf
ARM_FUNC_ALIAS aeabi_ul2f floatundisf
	CFI_START_FUNCTION

	orrs	r2, r0, r1
 8023114:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
 8023118:	bf08      	it	eq
	RETc(eq)
 802311a:	4770      	bxeq	lr

	mov	r3, #0
 802311c:	f04f 0300 	mov.w	r3, #0
	b	1f
 8023120:	e00a      	b.n	8023138 <__aeabi_l2f+0x14>
 8023122:	bf00      	nop

08023124 <__aeabi_l2f>:

ARM_FUNC_START floatdisf
ARM_FUNC_ALIAS aeabi_l2f floatdisf

	orrs	r2, r0, r1
 8023124:	ea50 0201 	orrs.w	r2, r0, r1
	do_it	eq
 8023128:	bf08      	it	eq
	RETc(eq)
 802312a:	4770      	bxeq	lr

	ands	r3, ah, #0x80000000	@ sign bit in r3
 802312c:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
	bpl	1f
 8023130:	d502      	bpl.n	8023138 <__aeabi_l2f+0x14>
#if defined(__thumb2__)
	negs	al, al
 8023132:	4240      	negs	r0, r0
	sbc	ah, ah, ah, lsl #1
 8023134:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
#else
	rsbs	al, al, #0
	rsc	ah, ah, #0
#endif
1:
	movs	ip, ah
 8023138:	ea5f 0c01 	movs.w	ip, r1
	do_it	eq, tt
 802313c:	bf02      	ittt	eq
	moveq	ip, al
 802313e:	4684      	moveq	ip, r0
	moveq	ah, al
 8023140:	4601      	moveq	r1, r0
	moveq	al, #0
 8023142:	2000      	moveq	r0, #0

	@ Add initial exponent to sign
	orr	r3, r3, #((127 + 23 + 32) << 23)
 8023144:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
	do_it	eq
 8023148:	bf08      	it	eq
	subeq	r3, r3, #(32 << 23)
 802314a:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
2:	sub	r3, r3, #(1 << 23)
 802314e:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
	sublo	r2, r2, ip, lsr #1
	subs	r2, r2, ip, lsr #3

#else

	clz	r2, ip
 8023152:	fabc f28c 	clz	r2, ip
	subs	r2, r2, #8
 8023156:	3a08      	subs	r2, #8

#endif

	sub	r3, r3, r2, lsl #23
 8023158:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
	blt	3f
 802315c:	db10      	blt.n	8023180 <__aeabi_l2f+0x5c>

	shiftop add r3 r3 ah lsl r2 ip
 802315e:	fa01 fc02 	lsl.w	ip, r1, r2
 8023162:	4463      	add	r3, ip
	shift1	lsl, ip, al, r2
 8023164:	fa00 fc02 	lsl.w	ip, r0, r2
	rsb	r2, r2, #32
 8023168:	f1c2 0220 	rsb	r2, r2, #32
	cmp	ip, #0x80000000
 802316c:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
	shiftop adc r0 r3 al lsr r2 r2
 8023170:	fa20 f202 	lsr.w	r2, r0, r2
 8023174:	eb43 0002 	adc.w	r0, r3, r2
	do_it	eq
 8023178:	bf08      	it	eq
	biceq	r0, r0, #1
 802317a:	f020 0001 	biceq.w	r0, r0, #1
	RET
 802317e:	4770      	bx	lr

3:	add	r2, r2, #32
 8023180:	f102 0220 	add.w	r2, r2, #32
	shift1	lsl, ip, ah, r2
 8023184:	fa01 fc02 	lsl.w	ip, r1, r2
	rsb	r2, r2, #32
 8023188:	f1c2 0220 	rsb	r2, r2, #32
	orrs	al, al, ip, lsl #1
 802318c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
	shiftop adc r0 r3 ah lsr r2 r2
 8023190:	fa21 f202 	lsr.w	r2, r1, r2
 8023194:	eb43 0002 	adc.w	r0, r3, r2
	do_it	eq
 8023198:	bf08      	it	eq
	biceq	r0, r0, ip, lsr #31
 802319a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
	RET
 802319e:	4770      	bx	lr

080231a0 <__aeabi_fmul>:
 80231a0:	f04f 0cff 	mov.w	ip, #255	@ 0xff
ARM_FUNC_ALIAS aeabi_fmul mulsf3
	CFI_START_FUNCTION

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
	ands	r2, ip, r0, lsr #23
 80231a4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
	do_it	ne, tt
 80231a8:	bf1e      	ittt	ne
	COND(and,s,ne)	r3, ip, r1, lsr #23
 80231aa:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
	teqne	r2, ip
 80231ae:	ea92 0f0c 	teqne	r2, ip
	teqne	r3, ip
 80231b2:	ea93 0f0c 	teqne	r3, ip
	beq	LSYM(Lml_s)
 80231b6:	d06f      	beq.n	8023298 <__aeabi_fmul+0xf8>
LSYM(Lml_x):

	@ Add exponents together
	add	r2, r2, r3
 80231b8:	441a      	add	r2, r3

	@ Determine final sign.
	eor	ip, r0, r1
 80231ba:	ea80 0c01 	eor.w	ip, r0, r1

	@ Convert mantissa to unsigned integer.
	@ If power of two, branch to a separate path.
	@ Make up for final alignment.
	movs	r0, r0, lsl #9
 80231be:	0240      	lsls	r0, r0, #9
	do_it	ne
 80231c0:	bf18      	it	ne
	COND(mov,s,ne)	r1, r1, lsl #9
 80231c2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
	beq	LSYM(Lml_1)
 80231c6:	d01e      	beq.n	8023206 <__aeabi_fmul+0x66>
	mov	r3, #0x08000000
 80231c8:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
	orr	r0, r3, r0, lsr #5
 80231cc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
	orr	r1, r3, r1, lsr #5
 80231d0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5

	@ The actual multiplication.
	@ This code works on architecture versions >= 4
	umull	r3, r1, r0, r1
 80231d4:	fba0 3101 	umull	r3, r1, r0, r1

	@ Put final sign in r0.
	and	r0, ip, #0x80000000
 80231d8:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000

	@ Adjust result upon the MSB position.
	cmp	r1, #(1 << 23)
 80231dc:	f5b1 0f00 	cmp.w	r1, #8388608	@ 0x800000
	do_it	cc, tt
 80231e0:	bf3e      	ittt	cc
	movcc	r1, r1, lsl #1
 80231e2:	0049      	lslcc	r1, r1, #1
	orrcc	r1, r1, r3, lsr #31
 80231e4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
	movcc	r3, r3, lsl #1
 80231e8:	005b      	lslcc	r3, r3, #1

	@ Add sign to result.
	orr	r0, r0, r1
 80231ea:	ea40 0001 	orr.w	r0, r0, r1

	@ Apply exponent bias, check for under/overflow.
	sbc	r2, r2, #127
 80231ee:	f162 027f 	sbc.w	r2, r2, #127	@ 0x7f
	cmp	r2, #(254 - 1)
 80231f2:	2afd      	cmp	r2, #253	@ 0xfd
	bhi	LSYM(Lml_u)
 80231f4:	d81d      	bhi.n	8023232 <__aeabi_fmul+0x92>

	@ Round the result, merge final exponent.
	cmp	r3, #0x80000000
 80231f6:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
	adc	r0, r0, r2, lsl #23
 80231fa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
	do_it	eq
 80231fe:	bf08      	it	eq
	biceq	r0, r0, #1
 8023200:	f020 0001 	biceq.w	r0, r0, #1
	RET
 8023204:	4770      	bx	lr

	@ Multiplication by 0x1p*: let''s shortcut a lot of code.
LSYM(Lml_1):
	teq	r0, #0
 8023206:	f090 0f00 	teq	r0, #0
	and	ip, ip, #0x80000000
 802320a:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
	do_it	eq
 802320e:	bf08      	it	eq
	moveq	r1, r1, lsl #9
 8023210:	0249      	lsleq	r1, r1, #9
	orr	r0, ip, r0, lsr #9
 8023212:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
	orr	r0, r0, r1, lsr #9
 8023216:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
	subs	r2, r2, #127
 802321a:	3a7f      	subs	r2, #127	@ 0x7f
	do_it	gt, tt
 802321c:	bfc2      	ittt	gt
	COND(rsb,s,gt)	r3, r2, #255
 802321e:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
	orrgt	r0, r0, r2, lsl #23
 8023222:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
	RETc(gt)
 8023226:	4770      	bxgt	lr

	@ Under/overflow: fix things up for the code below.
	orr	r0, r0, #0x00800000
 8023228:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	mov	r3, #0
 802322c:	f04f 0300 	mov.w	r3, #0
	subs	r2, r2, #1
 8023230:	3a01      	subs	r2, #1

LSYM(Lml_u):
	@ Overflow?
	bgt	LSYM(Lml_o)
 8023232:	dc5d      	bgt.n	80232f0 <__aeabi_fmul+0x150>

	@ Check if denormalized result is possible, otherwise return signed 0.
	cmn	r2, #(24 + 1)
 8023234:	f112 0f19 	cmn.w	r2, #25
	do_it	le, t
 8023238:	bfdc      	itt	le
	bicle	r0, r0, #0x7fffffff
 802323a:	f000 4000 	andle.w	r0, r0, #2147483648	@ 0x80000000
	RETc(le)
 802323e:	4770      	bxle	lr

	@ Shift value right, round, etc.
	rsb	r2, r2, #0
 8023240:	f1c2 0200 	rsb	r2, r2, #0
	movs	r1, r0, lsl #1
 8023244:	0041      	lsls	r1, r0, #1
	shift1	lsr, r1, r1, r2
 8023246:	fa21 f102 	lsr.w	r1, r1, r2
	rsb	r2, r2, #32
 802324a:	f1c2 0220 	rsb	r2, r2, #32
	shift1	lsl, ip, r0, r2
 802324e:	fa00 fc02 	lsl.w	ip, r0, r2
	movs	r0, r1, rrx
 8023252:	ea5f 0031 	movs.w	r0, r1, rrx
	adc	r0, r0, #0
 8023256:	f140 0000 	adc.w	r0, r0, #0
	orrs	r3, r3, ip, lsl #1
 802325a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
	do_it	eq
 802325e:	bf08      	it	eq
	biceq	r0, r0, ip, lsr #31
 8023260:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
	RET
 8023264:	4770      	bx	lr

	@ One or both arguments are denormalized.
	@ Scale them leftwards and preserve sign bit.
LSYM(Lml_d):
	teq	r2, #0
 8023266:	f092 0f00 	teq	r2, #0
	and	ip, r0, #0x80000000
 802326a:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
1:	do_it	eq, tt
 802326e:	bf02      	ittt	eq
	moveq	r0, r0, lsl #1
 8023270:	0040      	lsleq	r0, r0, #1
	tsteq	r0, #0x00800000
 8023272:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
	subeq	r2, r2, #1
 8023276:	3a01      	subeq	r2, #1
	beq	1b
 8023278:	d0f9      	beq.n	802326e <__aeabi_fmul+0xce>
	orr	r0, r0, ip
 802327a:	ea40 000c 	orr.w	r0, r0, ip
	teq	r3, #0
 802327e:	f093 0f00 	teq	r3, #0
	and	ip, r1, #0x80000000
 8023282:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
2:	do_it	eq, tt
 8023286:	bf02      	ittt	eq
	moveq	r1, r1, lsl #1
 8023288:	0049      	lsleq	r1, r1, #1
	tsteq	r1, #0x00800000
 802328a:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
	subeq	r3, r3, #1
 802328e:	3b01      	subeq	r3, #1
	beq	2b
 8023290:	d0f9      	beq.n	8023286 <__aeabi_fmul+0xe6>
	orr	r1, r1, ip
 8023292:	ea41 010c 	orr.w	r1, r1, ip
	b	LSYM(Lml_x)
 8023296:	e78f      	b.n	80231b8 <__aeabi_fmul+0x18>

LSYM(Lml_s):
	@ Isolate the INF and NAN cases away
	and	r3, ip, r1, lsr #23
 8023298:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
	teq	r2, ip
 802329c:	ea92 0f0c 	teq	r2, ip
	do_it	ne
 80232a0:	bf18      	it	ne
	teqne	r3, ip
 80232a2:	ea93 0f0c 	teqne	r3, ip
	beq	1f
 80232a6:	d00a      	beq.n	80232be <__aeabi_fmul+0x11e>

	@ Here, one or more arguments are either denormalized or zero.
	bics	ip, r0, #0x80000000
 80232a8:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
	do_it	ne
 80232ac:	bf18      	it	ne
	COND(bic,s,ne)	ip, r1, #0x80000000
 80232ae:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
	bne	LSYM(Lml_d)
 80232b2:	d1d8      	bne.n	8023266 <__aeabi_fmul+0xc6>

	@ Result is 0, but determine sign anyway.
LSYM(Lml_z):
	eor	r0, r0, r1
 80232b4:	ea80 0001 	eor.w	r0, r0, r1
	bic	r0, r0, #0x7fffffff
 80232b8:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
	RET
 80232bc:	4770      	bx	lr

1:	@ One or both args are INF or NAN.
	teq	r0, #0x0
 80232be:	f090 0f00 	teq	r0, #0
	do_it	ne, ett
 80232c2:	bf17      	itett	ne
	teqne	r0, #0x80000000
 80232c4:	f090 4f00 	teqne	r0, #2147483648	@ 0x80000000
	moveq	r0, r1
 80232c8:	4608      	moveq	r0, r1
	teqne	r1, #0x0
 80232ca:	f091 0f00 	teqne	r1, #0
	teqne	r1, #0x80000000
 80232ce:	f091 4f00 	teqne	r1, #2147483648	@ 0x80000000
	beq	LSYM(Lml_n)		@ 0 * INF or INF * 0 -> NAN
 80232d2:	d014      	beq.n	80232fe <__aeabi_fmul+0x15e>
	teq	r2, ip
 80232d4:	ea92 0f0c 	teq	r2, ip
	bne	1f
 80232d8:	d101      	bne.n	80232de <__aeabi_fmul+0x13e>
	movs	r2, r0, lsl #9
 80232da:	0242      	lsls	r2, r0, #9
	bne	LSYM(Lml_n)		@ NAN * <anything> -> NAN
 80232dc:	d10f      	bne.n	80232fe <__aeabi_fmul+0x15e>
1:	teq	r3, ip
 80232de:	ea93 0f0c 	teq	r3, ip
	bne	LSYM(Lml_i)
 80232e2:	d103      	bne.n	80232ec <__aeabi_fmul+0x14c>
	movs	r3, r1, lsl #9
 80232e4:	024b      	lsls	r3, r1, #9
	do_it	ne
 80232e6:	bf18      	it	ne
	movne	r0, r1
 80232e8:	4608      	movne	r0, r1
	bne	LSYM(Lml_n)		@ <anything> * NAN -> NAN
 80232ea:	d108      	bne.n	80232fe <__aeabi_fmul+0x15e>

	@ Result is INF, but we need to determine its sign.
LSYM(Lml_i):
	eor	r0, r0, r1
 80232ec:	ea80 0001 	eor.w	r0, r0, r1

	@ Overflow: return INF (sign already in r0).
LSYM(Lml_o):
	and	r0, r0, #0x80000000
 80232f0:	f000 4000 	and.w	r0, r0, #2147483648	@ 0x80000000
	orr	r0, r0, #0x7f000000
 80232f4:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
	orr	r0, r0, #0x00800000
 80232f8:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	RET
 80232fc:	4770      	bx	lr

	@ Return a quiet NAN.
LSYM(Lml_n):
	orr	r0, r0, #0x7f000000
 80232fe:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
	orr	r0, r0, #0x00c00000
 8023302:	f440 0040 	orr.w	r0, r0, #12582912	@ 0xc00000
	RET
 8023306:	4770      	bx	lr

08023308 <__aeabi_fdiv>:
ARM_FUNC_START divsf3
ARM_FUNC_ALIAS aeabi_fdiv divsf3
	CFI_START_FUNCTION

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
 8023308:	f04f 0cff 	mov.w	ip, #255	@ 0xff
	ands	r2, ip, r0, lsr #23
 802330c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
	do_it	ne, tt
 8023310:	bf1e      	ittt	ne
	COND(and,s,ne)	r3, ip, r1, lsr #23
 8023312:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
	teqne	r2, ip
 8023316:	ea92 0f0c 	teqne	r2, ip
	teqne	r3, ip
 802331a:	ea93 0f0c 	teqne	r3, ip
	beq	LSYM(Ldv_s)
 802331e:	d069      	beq.n	80233f4 <__aeabi_fdiv+0xec>
LSYM(Ldv_x):

	@ Subtract divisor exponent from dividend''s
	sub	r2, r2, r3
 8023320:	eba2 0203 	sub.w	r2, r2, r3

	@ Preserve final sign into ip.
	eor	ip, r0, r1
 8023324:	ea80 0c01 	eor.w	ip, r0, r1

	@ Convert mantissa to unsigned integer.
	@ Dividend -> r3, divisor -> r1.
	movs	r1, r1, lsl #9
 8023328:	0249      	lsls	r1, r1, #9
	mov	r0, r0, lsl #9
 802332a:	ea4f 2040 	mov.w	r0, r0, lsl #9
	beq	LSYM(Ldv_1)
 802332e:	d037      	beq.n	80233a0 <__aeabi_fdiv+0x98>
	mov	r3, #0x10000000
 8023330:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
	orr	r1, r3, r1, lsr #4
 8023334:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
	orr	r3, r3, r0, lsr #4
 8023338:	ea43 1310 	orr.w	r3, r3, r0, lsr #4

	@ Initialize r0 (result) with final sign bit.
	and	r0, ip, #0x80000000
 802333c:	f00c 4000 	and.w	r0, ip, #2147483648	@ 0x80000000

	@ Ensure result will land to known bit position.
	@ Apply exponent bias accordingly.
	cmp	r3, r1
 8023340:	428b      	cmp	r3, r1
	do_it	cc
 8023342:	bf38      	it	cc
	movcc	r3, r3, lsl #1
 8023344:	005b      	lslcc	r3, r3, #1
	adc	r2, r2, #(127 - 2)
 8023346:	f142 027d 	adc.w	r2, r2, #125	@ 0x7d

	@ The actual division loop.
	mov	ip, #0x00800000
 802334a:	f44f 0c00 	mov.w	ip, #8388608	@ 0x800000
1:	cmp	r3, r1
 802334e:	428b      	cmp	r3, r1
	do_it	cs, t
 8023350:	bf24      	itt	cs
	subcs	r3, r3, r1
 8023352:	1a5b      	subcs	r3, r3, r1
	orrcs	r0, r0, ip
 8023354:	ea40 000c 	orrcs.w	r0, r0, ip
	cmp	r3, r1, lsr #1
 8023358:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
	do_it	cs, t
 802335c:	bf24      	itt	cs
	subcs	r3, r3, r1, lsr #1
 802335e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
	orrcs	r0, r0, ip, lsr #1
 8023362:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
	cmp	r3, r1, lsr #2
 8023366:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
	do_it	cs, t
 802336a:	bf24      	itt	cs
	subcs	r3, r3, r1, lsr #2
 802336c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
	orrcs	r0, r0, ip, lsr #2
 8023370:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
	cmp	r3, r1, lsr #3
 8023374:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
	do_it	cs, t
 8023378:	bf24      	itt	cs
	subcs	r3, r3, r1, lsr #3
 802337a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
	orrcs	r0, r0, ip, lsr #3
 802337e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
	movs	r3, r3, lsl #4
 8023382:	011b      	lsls	r3, r3, #4
	do_it	ne
 8023384:	bf18      	it	ne
	COND(mov,s,ne)	ip, ip, lsr #4
 8023386:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
	bne	1b
 802338a:	d1e0      	bne.n	802334e <__aeabi_fdiv+0x46>

	@ Check exponent for under/overflow.
	cmp	r2, #(254 - 1)
 802338c:	2afd      	cmp	r2, #253	@ 0xfd
	bhi	LSYM(Lml_u)
 802338e:	f63f af50 	bhi.w	8023232 <__aeabi_fmul+0x92>

	@ Round the result, merge final exponent.
	cmp	r3, r1
 8023392:	428b      	cmp	r3, r1
	adc	r0, r0, r2, lsl #23
 8023394:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
	do_it	eq
 8023398:	bf08      	it	eq
	biceq	r0, r0, #1
 802339a:	f020 0001 	biceq.w	r0, r0, #1
	RET
 802339e:	4770      	bx	lr

	@ Division by 0x1p*: let''s shortcut a lot of code.
LSYM(Ldv_1):
	and	ip, ip, #0x80000000
 80233a0:	f00c 4c00 	and.w	ip, ip, #2147483648	@ 0x80000000
	orr	r0, ip, r0, lsr #9
 80233a4:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
	adds	r2, r2, #127
 80233a8:	327f      	adds	r2, #127	@ 0x7f
	do_it	gt, tt
 80233aa:	bfc2      	ittt	gt
	COND(rsb,s,gt)	r3, r2, #255
 80233ac:	f1d2 03ff 	rsbsgt	r3, r2, #255	@ 0xff
	orrgt	r0, r0, r2, lsl #23
 80233b0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
	RETc(gt)
 80233b4:	4770      	bxgt	lr

	orr	r0, r0, #0x00800000
 80233b6:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
	mov	r3, #0
 80233ba:	f04f 0300 	mov.w	r3, #0
	subs	r2, r2, #1
 80233be:	3a01      	subs	r2, #1
	b	LSYM(Lml_u)
 80233c0:	e737      	b.n	8023232 <__aeabi_fmul+0x92>

	@ One or both arguments are denormalized.
	@ Scale them leftwards and preserve sign bit.
LSYM(Ldv_d):
	teq	r2, #0
 80233c2:	f092 0f00 	teq	r2, #0
	and	ip, r0, #0x80000000
 80233c6:	f000 4c00 	and.w	ip, r0, #2147483648	@ 0x80000000
1:	do_it	eq, tt
 80233ca:	bf02      	ittt	eq
	moveq	r0, r0, lsl #1
 80233cc:	0040      	lsleq	r0, r0, #1
	tsteq	r0, #0x00800000
 80233ce:	f410 0f00 	tsteq.w	r0, #8388608	@ 0x800000
	subeq	r2, r2, #1
 80233d2:	3a01      	subeq	r2, #1
	beq	1b
 80233d4:	d0f9      	beq.n	80233ca <__aeabi_fdiv+0xc2>
	orr	r0, r0, ip
 80233d6:	ea40 000c 	orr.w	r0, r0, ip
	teq	r3, #0
 80233da:	f093 0f00 	teq	r3, #0
	and	ip, r1, #0x80000000
 80233de:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
2:	do_it	eq, tt
 80233e2:	bf02      	ittt	eq
	moveq	r1, r1, lsl #1
 80233e4:	0049      	lsleq	r1, r1, #1
	tsteq	r1, #0x00800000
 80233e6:	f411 0f00 	tsteq.w	r1, #8388608	@ 0x800000
	subeq	r3, r3, #1
 80233ea:	3b01      	subeq	r3, #1
	beq	2b
 80233ec:	d0f9      	beq.n	80233e2 <__aeabi_fdiv+0xda>
	orr	r1, r1, ip
 80233ee:	ea41 010c 	orr.w	r1, r1, ip
	b	LSYM(Ldv_x)
 80233f2:	e795      	b.n	8023320 <__aeabi_fdiv+0x18>

	@ One or both arguments are either INF, NAN, zero or denormalized.
LSYM(Ldv_s):
	and	r3, ip, r1, lsr #23
 80233f4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
	teq	r2, ip
 80233f8:	ea92 0f0c 	teq	r2, ip
	bne	1f
 80233fc:	d108      	bne.n	8023410 <__aeabi_fdiv+0x108>
	movs	r2, r0, lsl #9
 80233fe:	0242      	lsls	r2, r0, #9
	bne	LSYM(Lml_n)		@ NAN / <anything> -> NAN
 8023400:	f47f af7d 	bne.w	80232fe <__aeabi_fmul+0x15e>
	teq	r3, ip
 8023404:	ea93 0f0c 	teq	r3, ip
	bne	LSYM(Lml_i)		@ INF / <anything> -> INF
 8023408:	f47f af70 	bne.w	80232ec <__aeabi_fmul+0x14c>
	mov	r0, r1
 802340c:	4608      	mov	r0, r1
	b	LSYM(Lml_n)		@ INF / (INF or NAN) -> NAN
 802340e:	e776      	b.n	80232fe <__aeabi_fmul+0x15e>
1:	teq	r3, ip
 8023410:	ea93 0f0c 	teq	r3, ip
	bne	2f
 8023414:	d104      	bne.n	8023420 <__aeabi_fdiv+0x118>
	movs	r3, r1, lsl #9
 8023416:	024b      	lsls	r3, r1, #9
	beq	LSYM(Lml_z)		@ <anything> / INF -> 0
 8023418:	f43f af4c 	beq.w	80232b4 <__aeabi_fmul+0x114>
	mov	r0, r1
 802341c:	4608      	mov	r0, r1
	b	LSYM(Lml_n)		@ <anything> / NAN -> NAN
 802341e:	e76e      	b.n	80232fe <__aeabi_fmul+0x15e>
2:	@ If both are nonzero, we need to normalize and resume above.
	bics	ip, r0, #0x80000000
 8023420:	f030 4c00 	bics.w	ip, r0, #2147483648	@ 0x80000000
	do_it	ne
 8023424:	bf18      	it	ne
	COND(bic,s,ne)	ip, r1, #0x80000000
 8023426:	f031 4c00 	bicsne.w	ip, r1, #2147483648	@ 0x80000000
	bne	LSYM(Ldv_d)
 802342a:	d1ca      	bne.n	80233c2 <__aeabi_fdiv+0xba>
	@ One or both arguments are zero.
	bics	r2, r0, #0x80000000
 802342c:	f030 4200 	bics.w	r2, r0, #2147483648	@ 0x80000000
	bne	LSYM(Lml_i)		@ <non_zero> / 0 -> INF
 8023430:	f47f af5c 	bne.w	80232ec <__aeabi_fmul+0x14c>
	bics	r3, r1, #0x80000000
 8023434:	f031 4300 	bics.w	r3, r1, #2147483648	@ 0x80000000
	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
 8023438:	f47f af3c 	bne.w	80232b4 <__aeabi_fmul+0x114>
	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
 802343c:	e75f      	b.n	80232fe <__aeabi_fmul+0x15e>
 802343e:	bf00      	nop

08023440 <__aeabi_f2iz>:
ARM_FUNC_START fixsfsi
ARM_FUNC_ALIAS aeabi_f2iz fixsfsi
	CFI_START_FUNCTION

	@ check exponent range.
	mov	r2, r0, lsl #1
 8023440:	ea4f 0240 	mov.w	r2, r0, lsl #1
	cmp	r2, #(127 << 24)
 8023444:	f1b2 4ffe 	cmp.w	r2, #2130706432	@ 0x7f000000
	bcc	1f			@ value is too small
 8023448:	d30f      	bcc.n	802346a <__aeabi_f2iz+0x2a>
	mov	r3, #(127 + 31)
 802344a:	f04f 039e 	mov.w	r3, #158	@ 0x9e
	subs	r2, r3, r2, lsr #24
 802344e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
	bls	2f			@ value is too large
 8023452:	d90d      	bls.n	8023470 <__aeabi_f2iz+0x30>

	@ scale value
	mov	r3, r0, lsl #8
 8023454:	ea4f 2300 	mov.w	r3, r0, lsl #8
	orr	r3, r3, #0x80000000
 8023458:	f043 4300 	orr.w	r3, r3, #2147483648	@ 0x80000000
	tst	r0, #0x80000000		@ the sign bit
 802345c:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
	shift1	lsr, r0, r3, r2
 8023460:	fa23 f002 	lsr.w	r0, r3, r2
	do_it	ne
 8023464:	bf18      	it	ne
	rsbne	r0, r0, #0
 8023466:	4240      	negne	r0, r0
	RET
 8023468:	4770      	bx	lr

1:	mov	r0, #0
 802346a:	f04f 0000 	mov.w	r0, #0
	RET
 802346e:	4770      	bx	lr

2:	cmp	r2, #(127 + 31 - 0xff)
 8023470:	f112 0f61 	cmn.w	r2, #97	@ 0x61
	bne	3f
 8023474:	d101      	bne.n	802347a <__aeabi_f2iz+0x3a>
	movs	r2, r0, lsl #9
 8023476:	0242      	lsls	r2, r0, #9
	bne	4f			@ r0 is NAN.
 8023478:	d105      	bne.n	8023486 <__aeabi_f2iz+0x46>
3:	ands	r0, r0, #0x80000000	@ the sign bit
 802347a:	f010 4000 	ands.w	r0, r0, #2147483648	@ 0x80000000
	do_it	eq
 802347e:	bf08      	it	eq
	moveq	r0, #0x7fffffff		@ the maximum signed positive si
 8023480:	f06f 4000 	mvneq.w	r0, #2147483648	@ 0x80000000
	RET
 8023484:	4770      	bx	lr

4:	mov	r0, #0			@ What should we convert NAN to?
 8023486:	f04f 0000 	mov.w	r0, #0
	RET
 802348a:	4770      	bx	lr

0802348c <strchr>:
 802348c:	b2c9      	uxtb	r1, r1

  s = (unsigned char *) aligned_addr;

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (*s && *s != c)
 802348e:	4603      	mov	r3, r0
 8023490:	4618      	mov	r0, r3
 8023492:	f813 2b01 	ldrb.w	r2, [r3], #1
 8023496:	b112      	cbz	r2, 802349e <strchr+0x12>
 8023498:	428a      	cmp	r2, r1
 802349a:	d1f9      	bne.n	8023490 <strchr+0x4>
 802349c:	4770      	bx	lr
    s++;
  if (*s == c)
    return (char *)s;
  return NULL;
 802349e:	2900      	cmp	r1, #0
 80234a0:	bf18      	it	ne
 80234a2:	2000      	movne	r0, #0
}
 80234a4:	4770      	bx	lr
	...

080234a8 <strcasecmp>:
#include <ctype.h>

int
strcasecmp (const char *s1,
	const char *s2)
{
 80234a8:	b530      	push	{r4, r5, lr}
  int d = 0;
  for ( ; ; )
    {
      const int c1 = tolower(*s1++);
 80234aa:	4d0b      	ldr	r5, [pc, #44]	@ (80234d8 <strcasecmp+0x30>)
{
 80234ac:	4604      	mov	r4, r0
      const int c1 = tolower(*s1++);
 80234ae:	f814 3b01 	ldrb.w	r3, [r4], #1
 80234b2:	5cea      	ldrb	r2, [r5, r3]
 80234b4:	f002 0203 	and.w	r2, r2, #3
 80234b8:	2a01      	cmp	r2, #1
      const int c2 = tolower(*s2++);
 80234ba:	f811 2b01 	ldrb.w	r2, [r1], #1
 80234be:	5ca8      	ldrb	r0, [r5, r2]
 80234c0:	f000 0003 	and.w	r0, r0, #3
      const int c1 = tolower(*s1++);
 80234c4:	bf08      	it	eq
 80234c6:	3320      	addeq	r3, #32
      const int c2 = tolower(*s2++);
 80234c8:	2801      	cmp	r0, #1
 80234ca:	bf08      	it	eq
 80234cc:	3220      	addeq	r2, #32
      if (((d = c1 - c2) != 0) || (c2 == '\0'))
 80234ce:	1a98      	subs	r0, r3, r2
 80234d0:	d101      	bne.n	80234d6 <strcasecmp+0x2e>
 80234d2:	2a00      	cmp	r2, #0
 80234d4:	d1eb      	bne.n	80234ae <strcasecmp+0x6>
        break;
    }
  return d;
}
 80234d6:	bd30      	pop	{r4, r5, pc}
 80234d8:	080292e5 	.word	0x080292e5

080234dc <strcpy>:
#endif

char* __attribute__((naked))
strcpy (char* dst, const char* src)
{
  asm (
 80234dc:	4603      	mov	r3, r0
 80234de:	f811 2b01 	ldrb.w	r2, [r1], #1
 80234e2:	f803 2b01 	strb.w	r2, [r3], #1
 80234e6:	2a00      	cmp	r2, #0
 80234e8:	d1f9      	bne.n	80234de <strcpy+0x2>
 80234ea:	4770      	bx	lr

080234ec <memcmp>:

int
memcmp (const void *m1,
	const void *m2,
	size_t n)
{
 80234ec:	b510      	push	{r4, lr}
 80234ee:	3901      	subs	r1, #1
 80234f0:	4402      	add	r2, r0
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  unsigned char *s1 = (unsigned char *) m1;
  unsigned char *s2 = (unsigned char *) m2;

  while (n--)
 80234f2:	4290      	cmp	r0, r2
 80234f4:	d101      	bne.n	80234fa <memcmp+0xe>
	  return *s1 - *s2;
	}
      s1++;
      s2++;
    }
  return 0;
 80234f6:	2000      	movs	r0, #0
 80234f8:	e005      	b.n	8023506 <memcmp+0x1a>
      if (*s1 != *s2)
 80234fa:	7803      	ldrb	r3, [r0, #0]
 80234fc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8023500:	42a3      	cmp	r3, r4
 8023502:	d001      	beq.n	8023508 <memcmp+0x1c>
	  return *s1 - *s2;
 8023504:	1b18      	subs	r0, r3, r4
      s2++;
    }

  return 0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8023506:	bd10      	pop	{r4, pc}
      s1++;
 8023508:	3001      	adds	r0, #1
      s2++;
 802350a:	e7f2      	b.n	80234f2 <memcmp+0x6>

0802350c <strlen>:

def_fn	strlen p2align=1
	.fnstart
	.cfi_startproc
	prologue
	mov     r3, r0
 802350c:	4603      	mov	r3, r0
1:	ldrb.w  r2, [r3], #1
 802350e:	f813 2b01 	ldrb.w	r2, [r3], #1
	cmp     r2, #0
 8023512:	2a00      	cmp	r2, #0
	bne	1b
 8023514:	d1fb      	bne.n	802350e <strlen+0x2>
	subs    r0, r3, r0
 8023516:	1a18      	subs	r0, r3, r0
	subs    r0, #1
 8023518:	3801      	subs	r0, #1
	epilogue
 802351a:	4770      	bx	lr

0802351c <strncmp>:
 802351c:	b510      	push	{r4, lr}
strncmp (const char *s1,
	const char *s2,
	size_t n)
{
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  if (n == 0)
 802351e:	b16a      	cbz	r2, 802353c <strncmp+0x20>
 8023520:	3901      	subs	r1, #1
 8023522:	1884      	adds	r4, r0, r2
    return 0;

  while (n-- != 0 && *s1 == *s2)
 8023524:	f810 2b01 	ldrb.w	r2, [r0], #1
 8023528:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 802352c:	429a      	cmp	r2, r3
 802352e:	d103      	bne.n	8023538 <strncmp+0x1c>
    {
      if (n == 0 || *s1 == '\0')
 8023530:	42a0      	cmp	r0, r4
 8023532:	d001      	beq.n	8023538 <strncmp+0x1c>
 8023534:	2a00      	cmp	r2, #0
 8023536:	d1f5      	bne.n	8023524 <strncmp+0x8>
	break;
      s1++;
      s2++;
    }

  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
 8023538:	1ad0      	subs	r0, r2, r3
      s1++;
      s2++;
    }
  return (*(unsigned char *) s1) - (*(unsigned char *) s2);
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 802353a:	bd10      	pop	{r4, pc}
    return 0;
 802353c:	4610      	mov	r0, r2
 802353e:	e7fc      	b.n	802353a <strncmp+0x1e>

08023540 <stpcpy>:
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }
#endif /* not PREFER_SIZE_OVER_SPEED */

  while ((*dst++ = *src++))
 8023540:	4603      	mov	r3, r0
 8023542:	f811 2b01 	ldrb.w	r2, [r1], #1
 8023546:	4618      	mov	r0, r3
 8023548:	f803 2b01 	strb.w	r2, [r3], #1
 802354c:	2a00      	cmp	r2, #0
 802354e:	d1f8      	bne.n	8023542 <stpcpy+0x2>
    ;
  return --dst;
}
 8023550:	4770      	bx	lr

08023552 <memset>:
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
 8023552:	4402      	add	r2, r0
  char *s = (char *) m;
 8023554:	4603      	mov	r3, r0
  while (n--)
 8023556:	4293      	cmp	r3, r2
 8023558:	d100      	bne.n	802355c <memset+0xa>
    *s++ = (char) c;

  return m;
}
 802355a:	4770      	bx	lr
    *s++ = (char) c;
 802355c:	f803 1b01 	strb.w	r1, [r3], #1
 8023560:	e7f9      	b.n	8023556 <memset+0x4>

08023562 <atoi>:

#ifndef _REENT_ONLY
int
atoi (const char *s)
{
  return (int) strtol (s, NULL, 10);
 8023562:	220a      	movs	r2, #10
 8023564:	2100      	movs	r1, #0
 8023566:	f7ef be23 	b.w	80131b0 <strtol>
	...

0802356c <__libc_init_array>:
#endif

/* Iterate over all the init routines.  */
void
__libc_init_array (void)
{
 802356c:	b570      	push	{r4, r5, r6, lr}
  size_t count;
  size_t i;

  count = __preinit_array_end - __preinit_array_start;
 802356e:	4d0d      	ldr	r5, [pc, #52]	@ (80235a4 <__libc_init_array+0x38>)
 8023570:	4c0d      	ldr	r4, [pc, #52]	@ (80235a8 <__libc_init_array+0x3c>)
 8023572:	1b64      	subs	r4, r4, r5
 8023574:	10a4      	asrs	r4, r4, #2
  for (i = 0; i < count; i++)
 8023576:	2600      	movs	r6, #0
 8023578:	42a6      	cmp	r6, r4
 802357a:	d109      	bne.n	8023590 <__libc_init_array+0x24>

#ifdef _HAVE_INIT_FINI
  _init ();
#endif

  count = __init_array_end - __init_array_start;
 802357c:	4d0b      	ldr	r5, [pc, #44]	@ (80235ac <__libc_init_array+0x40>)
 802357e:	4c0c      	ldr	r4, [pc, #48]	@ (80235b0 <__libc_init_array+0x44>)
  _init ();
 8023580:	f7f0 fe64 	bl	801424c <_init>
  count = __init_array_end - __init_array_start;
 8023584:	1b64      	subs	r4, r4, r5
 8023586:	10a4      	asrs	r4, r4, #2
  for (i = 0; i < count; i++)
 8023588:	2600      	movs	r6, #0
 802358a:	42a6      	cmp	r6, r4
 802358c:	d105      	bne.n	802359a <__libc_init_array+0x2e>
    __init_array_start[i] ();
}
 802358e:	bd70      	pop	{r4, r5, r6, pc}
    __preinit_array_start[i] ();
 8023590:	f855 3b04 	ldr.w	r3, [r5], #4
 8023594:	4798      	blx	r3
  for (i = 0; i < count; i++)
 8023596:	3601      	adds	r6, #1
 8023598:	e7ee      	b.n	8023578 <__libc_init_array+0xc>
    __init_array_start[i] ();
 802359a:	f855 3b04 	ldr.w	r3, [r5], #4
 802359e:	4798      	blx	r3
  for (i = 0; i < count; i++)
 80235a0:	3601      	adds	r6, #1
 80235a2:	e7f2      	b.n	802358a <__libc_init_array+0x1e>
 80235a4:	080293e8 	.word	0x080293e8
 80235a8:	080293e8 	.word	0x080293e8
 80235ac:	080293e8 	.word	0x080293e8
 80235b0:	080293e8 	.word	0x080293e8

080235b4 <__strtok_r>:
char *
__strtok_r (register char *s,
	register const char *delim,
	char **lasts,
	int skip_leading_delim)
{
 80235b4:	b5f0      	push	{r4, r5, r6, r7, lr}
	register char *spanp;
	register int c, sc;
	char *tok;


	if (s == NULL && (s = *lasts) == NULL)
 80235b6:	4604      	mov	r4, r0
 80235b8:	b908      	cbnz	r0, 80235be <__strtok_r+0xa>
 80235ba:	6814      	ldr	r4, [r2, #0]
 80235bc:	b144      	cbz	r4, 80235d0 <__strtok_r+0x1c>

	/*
	 * Skip (span) leading delimiters (s += strspn(s, delim), sort of).
	 */
cont:
	c = *s++;
 80235be:	4620      	mov	r0, r4
 80235c0:	f814 5b01 	ldrb.w	r5, [r4], #1
	for (spanp = (char *)delim; (sc = *spanp++) != 0;) {
 80235c4:	460f      	mov	r7, r1
 80235c6:	f817 6b01 	ldrb.w	r6, [r7], #1
 80235ca:	b91e      	cbnz	r6, 80235d4 <__strtok_r+0x20>
				return (s - 1);
			}
		}
	}

	if (c == 0) {		/* no non-delimiter characters */
 80235cc:	b965      	cbnz	r5, 80235e8 <__strtok_r+0x34>
		*lasts = NULL;
 80235ce:	6015      	str	r5, [r2, #0]
		return (NULL);
 80235d0:	2000      	movs	r0, #0
 80235d2:	e005      	b.n	80235e0 <__strtok_r+0x2c>
		if (c == sc) {
 80235d4:	42b5      	cmp	r5, r6
 80235d6:	d1f6      	bne.n	80235c6 <__strtok_r+0x12>
			if (skip_leading_delim) {
 80235d8:	2b00      	cmp	r3, #0
 80235da:	d1f0      	bne.n	80235be <__strtok_r+0xa>
				*lasts = s;
 80235dc:	6014      	str	r4, [r2, #0]
				s[-1] = 0;
 80235de:	7003      	strb	r3, [r0, #0]
				return (tok);
			}
		} while (sc != 0);
	}
	/* NOTREACHED */
}
 80235e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
					s = NULL;
 80235e2:	461c      	mov	r4, r3
 80235e4:	e00c      	b.n	8023600 <__strtok_r+0x4c>
		} while (sc != 0);
 80235e6:	b915      	cbnz	r5, 80235ee <__strtok_r+0x3a>
		c = *s++;
 80235e8:	f814 3b01 	ldrb.w	r3, [r4], #1
		spanp = (char *)delim;
 80235ec:	460e      	mov	r6, r1
			if ((sc = *spanp++) == c) {
 80235ee:	f816 5b01 	ldrb.w	r5, [r6], #1
 80235f2:	42ab      	cmp	r3, r5
 80235f4:	d1f7      	bne.n	80235e6 <__strtok_r+0x32>
				if (c == 0)
 80235f6:	2b00      	cmp	r3, #0
 80235f8:	d0f3      	beq.n	80235e2 <__strtok_r+0x2e>
					s[-1] = 0;
 80235fa:	2300      	movs	r3, #0
 80235fc:	f804 3c01 	strb.w	r3, [r4, #-1]
				*lasts = s;
 8023600:	6014      	str	r4, [r2, #0]
				return (tok);
 8023602:	e7ed      	b.n	80235e0 <__strtok_r+0x2c>

08023604 <strtok_r>:
char *
strtok_r (register char *__restrict s,
	register const char *__restrict delim,
	char **__restrict lasts)
{
	return __strtok_r (s, delim, lasts, 1);
 8023604:	2301      	movs	r3, #1
 8023606:	f7ff bfd5 	b.w	80235b4 <__strtok_r>

0802360a <strcmp>:
	.fnstart
	.cfi_sections .debug_frame
	.cfi_startproc
	prologue
1:
	ldrb	r2, [r0], #1
 802360a:	f810 2b01 	ldrb.w	r2, [r0], #1
	ldrb	r3, [r1], #1
 802360e:	f811 3b01 	ldrb.w	r3, [r1], #1
	cmp	r2, #1
 8023612:	2a01      	cmp	r2, #1
	it	cs
 8023614:	bf28      	it	cs
	cmpcs	r2, r3
 8023616:	429a      	cmpcs	r2, r3
	beq	1b
 8023618:	d0f7      	beq.n	802360a <strcmp>
2:
	subs	r0, r2, r3
 802361a:	1ad0      	subs	r0, r2, r3
	epilogue
 802361c:	4770      	bx	lr

0802361e <memcpy>:
 802361e:	440a      	add	r2, r1
  char *dst = (char *) dst0;
  char *src = (char *) src0;

  void *save = dst0;

  while (len0--)
 8023620:	4291      	cmp	r1, r2
 8023622:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
 8023626:	d100      	bne.n	802362a <memcpy+0xc>
 8023628:	4770      	bx	lr
{
 802362a:	b510      	push	{r4, lr}
    {
      *dst++ = *src++;
 802362c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8023630:	f803 4f01 	strb.w	r4, [r3, #1]!
  while (len0--)
 8023634:	4291      	cmp	r1, r2
 8023636:	d1f9      	bne.n	802362c <memcpy+0xe>
  while (len0--)
    *dst++ = *src++;

  return dst0;
#endif /* not PREFER_SIZE_OVER_SPEED */
}
 8023638:	bd10      	pop	{r4, pc}
